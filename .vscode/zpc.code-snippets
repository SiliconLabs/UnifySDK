{
  // Place your zpc workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
  // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
  // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
  // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
  // Placeholders with the same ids are connected.
  // Example:
  // "Print to console": {
  // 	"scope": "javascript,typescript",
  // 	"prefix": "log",
  // 	"body": [
  // 		"console.log('$1');",
  // 		"$2"
  // 	],
  // 	"description": "Log output to console"
  // }
  "ZPC CC Header": {
    "scope": "c,cpp",
    "prefix": "zpc",
    "body": [
      "/******************************************************************************",
      " * # License",
      " * <b>Copyright ${CURRENT_YEAR} Silicon Laboratories Inc. www.silabs.com</b>",
      " ******************************************************************************",
      " * The licensor of this software is Silicon Laboratories Inc. Your use of this",
      " * software is governed by the terms of Silicon Labs Master Software License",
      " * Agreement (MSLA) available at",
      " * www.silabs.com/about-us/legal/master-software-license-agreement. This",
      " * software is distributed to you in Source Code format and is governed by the",
      " * sections of the MSLA applicable to Source Code.",
      " *",
      " *****************************************************************************/",
      "",
      "/**",
      " * @defgroup ${TM_FILENAME_BASE}",
      " * @brief TODO: Write brief for ${TM_FILENAME_BASE}",
      " *",
      " * TODO: Write component description for ${TM_FILENAME_BASE}",
      " *",
      " * @{",
      " */",
      " ",
      "#ifndef ${TM_FILENAME/(.*)\\.(.*)/${1:/upcase}_${2:/upcase}/}",
      "#define ${TM_FILENAME/(.*)\\.(.*)/${1:/upcase}_${2:/upcase}/}",
      "",
      "#ifdef __cplusplus",
      "extern \"C\" {",
      "#endif",
      "",
      "#ifdef __cplusplus",
      "}",
      "#endif",
      "",
      "#endif  //${TM_FILENAME/(.*)\\.(.*)/${1:/upcase}_${2:/upcase}/}",
      "/** @} end ${TM_FILENAME_BASE} */",
      ""
    ],
    "description": "ZPC CC Header"
  },
  "ZPC CC Source": {
    "prefix": "zpc",
    "scope": "c,cpp",
    "body": [
      "/******************************************************************************",
      " * # License",
      " * <b>Copyright ${CURRENT_YEAR} Silicon Laboratories Inc. www.silabs.com</b>",
      " ******************************************************************************",
      " * The licensor of this software is Silicon Laboratories Inc. Your use of this",
      " * software is governed by the terms of Silicon Labs Master Software License",
      " * Agreement (MSLA) available at",
      " * www.silabs.com/about-us/legal/master-software-license-agreement. This",
      " * software is distributed to you in Source Code format and is governed by the",
      " * sections of the MSLA applicable to Source Code.",
      " *",
      " *****************************************************************************/",
      "// Includes from this component",
      "#include \"zwave_command_class_$1.h\"",
      "#include \"zwave_command_classes_utils.h\"",
      "",
      "// Generic includes",
      "#include <stdlib.h>",
      "#include <assert.h>",
      "",
      "// Includes from other ZPC Components",
      "#include \"zwave_command_class_indices.h\"",
      "#include \"zwave_command_handler.h\"",
      "#include \"zpc_attribute_store_network_helper.h\"",
      "#include \"attribute_store_defined_attribute_types.h\"",
      "#include \"ZW_classcmd.h\"",
      "#include \"zpc_attribute_resolver.h\"",
      "",
      "// Includes from other Unify Components",
      "#include \"dotdot_mqtt.h\"",
      "#include \"dotdot_mqtt_generated_commands.h\"",
      "#include \"attribute_store_helper.h\"",
      "#include \"attribute_resolver.h\"",
      "#include \"attribute_timeouts.h\"",
      "#include \"sl_log.h\"",
      "",
      "// Cpp include",
      "#include \"attribute.hpp\"",
      "#include \"zwave_frame_generator.hpp\"",
      "#include \"zwave_frame_parser.hpp\"",
      "",
      "// Attribute macro, shortening those long defines for attribute types:",
      "#define ATTRIBUTE(type) ATTRIBUTE_COMMAND_CLASS_${1/(.*)/${1:/upcase}/}_##type",
      "",
      "// Log tag",
      "constexpr char LOG_TAG[] = \"zwave_command_class_$1\";",
      "",
      "",
      "// Cpp helpers",
      "namespace",
      "{",
      "const zwave_frame_generator frame_generator(COMMAND_CLASS_${1/(.*)/${1:/upcase}/}); //NOSONAR - false positive since it is warped in a namespace",
      "}",
      "",
      "///////////////////////////////////////////////////////////////////////////////",
      "// Helper functions",
      "///////////////////////////////////////////////////////////////////////////////",
      "zwave_cc_version_t get_current_$1_version(attribute_store_node_t node)",
      "{",
      "  zwave_cc_version_t version",
      "    = zwave_command_class_get_version_from_node(node, COMMAND_CLASS_${1/(.*)/${1:/upcase}/});",
      "",
      "  if (version == 0) {",
      "    sl_log_error(LOG_TAG, \"${1/(.*)/${1:/capitalize}/} Command Class Version not found\");",
      "  }",
      "",
      "  return version;",
      "}",
      "///////////////////////////////////////////////////////////////////////////////",
      "// Resolution functions",
      "///////////////////////////////////////////////////////////////////////////////",
      "//static sl_status_t zwave_command_class_$1_get(",
      "//  attribute_store_node_t node, uint8_t *frame, uint16_t *frame_length)",
      "//{",
      "//   return frame_generator.generate_no_args_frame(${1/(.*)/${1:/upcase}/}_GET,",
      "//                                                 frame,",
      "//                                                 frame_length);",
      "//}",
      "",
      "// static sl_status_t zwave_command_class_$1_set(",
      "//  attribute_store_node_t node, uint8_t *frame, uint16_t *frame_length)",
      "// {",
      "//  try {",
      "//    attribute_store::attribute value_node(node);",
      "//    auto current_version = get_current_$1_version(node);",
      "//",
      "//    // Compute expected size for set frame",
      "//    const uint8_t expected_frame_size = 12;",
      "//",
      "//    // Creating the frame",
      "//     frame_generator.initialize_frame(${1/(.*)/${1:/upcase}/}_SET,",
      "//                                      frame,",
      "//                                      expected_frame_size);",
      "//     frame_generator.add_value(value_node, DESIRED_OR_REPORTED_ATTRIBUTE);",
      "//     frame_generator.validate_frame(frame_length);",
      "//  } catch (const std::exception &e) {",
      "//    sl_log_error(LOG_TAG,",
      "//                 \"Error while generating ${1/(.*)/${1:/capitalize}/} Set frame : %s\",",
      "//                 e.what());",
      "//    return SL_STATUS_FAIL;",
      "//  }",
      "//",
      "//  return SL_STATUS_OK;",
      "//}",
      "",
      "///////////////////////////////////////////////////////////////////////////////",
      "// Frame parsing functions",
      "///////////////////////////////////////////////////////////////////////////////",
      "//static sl_status_t zwave_command_class_$1_handle_report(",
      "//  const zwave_controller_connection_info_t *connection_info,",
      "//  const uint8_t *frame_data,",
      "//  uint16_t frame_length)",
      "//{",
      "//  // Setup",
      "//  attribute_store::attribute endpoint_node(",
      "//    zwave_command_class_get_endpoint_node(connection_info));",
      "//  auto current_version = get_current_$1_version(endpoint_node);",
      "//",
      "//  sl_log_debug(LOG_TAG, \"${1/(.*)/${1:/capitalize}/} Report frame received\");",
      "//",
      "//  // Compute expected size for report frame",
      "//  const uint8_t expected_size = 12;",
      "",
      "//  // Parse the frame",
      "//  try {",
      "//   zwave_frame_parser parser(frame_data, frame_length);",
      "",
      "//   if (!parser.is_frame_size_valid(expected_size)) {",
      "//     sl_log_error(LOG_TAG,",
      "//                  \"Invalid frame size for ${1/(.*)/${1:/capitalize}/} Report frame\");",
      "//     return SL_STATUS_FAIL;",
      "//   }",
      "",
      "//  } catch (const std::exception &e) {",
      "//   sl_log_error(LOG_TAG,",
      "//                \"Error while parsing ${1/(.*)/${1:/capitalize}/} Report frame : %s\",",
      "//                e.what());",
      "//   return SL_STATUS_FAIL;",
      "//  }",
      "//  return SL_STATUS_OK;",
      "//}",
      "",
      "///////////////////////////////////////////////////////////////////////////////",
      "// Incoming commands handler",
      "///////////////////////////////////////////////////////////////////////////////",
      "sl_status_t zwave_command_class_$1_control_handler(",
      "  const zwave_controller_connection_info_t *connection_info,",
      "  const uint8_t *frame_data,",
      "  uint16_t frame_length)",
      "{",
      "  // Frame too short, it should have not come here.",
      "  if (frame_length <= COMMAND_INDEX) {",
      "    return SL_STATUS_NOT_SUPPORTED;",
      "  }",
      "",
      "  switch (frame_data[COMMAND_INDEX]) {",
      "    // case ${1/(.*)/${1:/upcase}/}_REPORT:",
      "    //   return zwave_command_class_$1_handle_report(connection_info,",
      "    //                                                    frame_data,",
      "    //                                                    frame_length);",
      "    default:",
      "      return SL_STATUS_NOT_SUPPORTED;",
      "  }",
      "}",
      "",
      "///////////////////////////////////////////////////////////////////////////////",
      "// Attribute Store callback functions",
      "///////////////////////////////////////////////////////////////////////////////",
      "static void zwave_command_class_$1_on_version_attribute_update(",
      "  attribute_store_node_t updated_node, attribute_store_change_t change)",
      "{",
      "  if (change == ATTRIBUTE_DELETED) {",
      "    return;",
      "  }",
      "",
      "  // Confirm that we have a version attribute update",
      "  assert(ATTRIBUTE(VERSION) == attribute_store_get_node_type(updated_node));",
      "",
      "  attribute_store::attribute version_node(updated_node);",
      "  // Do not create the attributes until we are sure of the version",
      "  zwave_cc_version_t supporting_node_version = 0;",
      "",
      "  // Wait for the version",
      "  if (!version_node.reported_exists()) {",
      "    return;",
      "  }",
      "  supporting_node_version = version_node.reported<uint8_t>();",
      "",
      "  // Now we know we have a $1 supporting endpoint.",
      "  // attribute_store::attribute endpoint_node",
      "  //  = version_node.first_parent(ATTRIBUTE_ENDPOINT_ID);",
      "",
      "  // Create the $1 attributes",
      "  //std::vector<attribute_store_node_t> $1_attributes;",
      "  //$1_attributes.push_back(ATTRIBUTE(LEVEL));",
      "",
      "  if (supporting_node_version >= 2) {",
      "",
      "  }",
      "",
      "//   for(auto attribute : $1_attributes) {",
      "//     endpoint_node.emplace_node(attribute);",
      "//   }",
      "}",
      "",
      "///////////////////////////////////////////////////////////////////////////////",
      "// Public interface functions",
      "///////////////////////////////////////////////////////////////////////////////",
      "sl_status_t zwave_command_class_$1_init()",
      "{",
      "  // Attribute store callbacks",
      "  attribute_store_register_callback_by_type(",
      "    zwave_command_class_$1_on_version_attribute_update,",
      "    ATTRIBUTE(VERSION));",
      "",
      "  // Attribute resolver rules",
      "  // attribute_resolver_register_rule(ATTRIBUTE(VALUE),",
      "  //                                  zwave_command_class_$1_set,",
      "  //                                  zwave_command_class_$1_get);",
      "",
      "  // The support side of things: Register our handler to the Z-Wave CC framework:",
      "  zwave_command_handler_t handler = {};",
      "  handler.support_handler         = NULL;",
      "  handler.control_handler = &zwave_command_class_$1_control_handler;",
      "  // Not supported, so this does not really matter",
      "  handler.minimal_scheme             = ZWAVE_CONTROLLER_ENCAPSULATION_NETWORK_SCHEME;",
      "  handler.manual_security_validation = false;",
      "  handler.command_class              = COMMAND_CLASS_${1/(.*)/${1:/upcase}/};",
      "  handler.version                    = ${1/(.*)/${1:/upcase}/}_VERSION_V3;",
      "  handler.command_class_name         = \"${1/(.*)/${1:/capitalize}/}\";",
      "  handler.comments                   = \"\";",
      "",
      "  zwave_command_handler_register_handler(handler);",
      "",
      "  return SL_STATUS_OK;",
      "}$0",
      ""
    ],
    "description": "ZPC CC Source"
  },
  "CC Report Frame Parsing": {
    "prefix": "report",
    "body": [
      "sl_status_t",
      "  zwave_command_class_${1:command_class}_${2:report_name}_handle_report(",
      "    const zwave_controller_connection_info_t *connection_info,",
      "    const uint8_t *frame_data,",
      "    uint16_t frame_length)",
      "{",
      "  sl_log_debug(LOG_TAG, \"${2/([^_]+)(_*)/${1:/capitalize}${2:+ }/g} Report\");",
      "  ",
      "  attribute_store::attribute endpoint_node(",
      "    zwave_command_class_get_endpoint_node(connection_info));",
      "",
      "  const uint8_t expected_size = $3;",
      "",
      "  try {",
      "    zwave_frame_parser parser(frame_data, frame_length);",
      "",
      "    if (!parser.is_frame_size_valid(expected_size)) {",
      "      sl_log_error(LOG_TAG,",
      "                   \"Invalid frame size for ${2/([^_]+)(_*)/${1:/capitalize}${2:+ }/g} Report frame\");",
      "      return SL_STATUS_FAIL;",
      "    }",
      "",
      "    } catch (const std::exception &e) {",
      "    sl_log_error(LOG_TAG,",
      "                 \"Error while parsing ${2/([^_]+)(_*)/${1:/capitalize}${2:+ }/g} Report frame : %s\",",
      "                 e.what());",
      "    return SL_STATUS_FAIL;",
      "  }",
      " return SL_STATUS_OK;",
      "}$0"
    ],
    "description": "Report Frame Parsing"
  },
  "CC Get Frame No Args": {
    "prefix": "get_no_args",
    "body": [
      "static sl_status_t zwave_command_class_${1:command_class}_${2:report_name}(",
      "  [[maybe_unused]] attribute_store_node_t node,",
      "  uint8_t *frame,",
      "  uint16_t *frame_length)",
      "{",
      "  return frame_generator.generate_no_args_frame(${2/(.*)/${1:/upcase}/},",
      "                                                frame,",
      "                                                frame_length);",
      "}"
    ],
    "description": "CC Get Frame No Args"
  },
  "CC Get/Set": {
    "prefix": "get_set",
    "body": [
      "static sl_status_t zwave_command_class_${1:command_class}_${2:set_get_name}(",
      " attribute_store_node_t node, uint8_t *frame, uint16_t *frame_length)",
      "{",
      " try {",
      "   attribute_store::attribute ${3:node_name}_node(node);",
      "",
      "   // Compute expected size for set frame",
      "   const uint8_t expected_frame_size = ${4:frame_size};",
      "",
      "   // Creating the frame",
      "    frame_generator.initialize_frame(${2/(.*)/${1:/upcase}/},",
      "                                     frame,",
      "                                     expected_frame_size);",
      "    frame_generator.add_value(${3:node_name}_node, DESIRED_OR_REPORTED_ATTRIBUTE);",
      "    frame_generator.validate_frame(frame_length);",
      " } catch (const std::exception &e) {",
      "   sl_log_error(LOG_TAG,",
      "                \"Error while generating ${2/([^_]+)(_*)/${1:/capitalize}${2:+ }/g} frame : %s\",",
      "                e.what());",
      "   return SL_STATUS_FAIL;",
      " }",
      "",
      " return SL_STATUS_OK;",
      "}"
    ],
    "description": "CC Get/Set"
  },
  "Contiki Process": {
    "scope": "c,cpp",
    "prefix": "zpc",
    "body": [
      "PROCESS(${1:${TM_FILENAME_BASE}_process}, \"$1\");",
      "",
      "PROCESS_THREAD($1, ev, data)",
      "{",
      "",
      "  PROCESS_BEGIN();",
      " while (1) {",
      "   if (ev == PROCESS_EVENT_INIT) {",
      "    } else if (ev == PROCESS_EVENT_EXIT) {",
      "    }",
      "    PROCESS_WAIT_EVENT();",
      "  }",
      "  PROCESS_END()",
      "}"
    ],
    "description": "Add Contiki process"
  },
  "Unity Test": {
    "prefix": "zpc",
    "scope": "c,cpp",
    "body": [
      "/******************************************************************************",
      " * # License",
      " * <b>Copyright ${CURRENT_YEAR} Silicon Laboratories Inc. www.silabs.com</b>",
      " ******************************************************************************",
      " * The licensor of this software is Silicon Laboratories Inc. Your use of this",
      " * software is governed by the terms of Silicon Labs Master Software License",
      " * Agreement (MSLA) available at",
      " * www.silabs.com/about-us/legal/master-software-license-agreement. This",
      " * software is distributed to you in Source Code format and is governed by the",
      " * sections of the MSLA applicable to Source Code.",
      " *",
      " *****************************************************************************/",
      "#include \"unity.h\"",
      "/// Setup the test suite (called once before all test_xxx functions are called)",
      "void suiteSetUp() {}",
      "",
      "/// Teardown the test suite (called once after all test_xxx functions are called)",
      "int suiteTearDown(int num_failures)",
      "{",
      "return num_failures;",
      "}",
      "",
      "/// Called before each and every test",
      "void setUp() {}",
      "",
      "void test_${TM_FILENAME_BASE}(){}"
    ],
    "description": "Unity Test"
  },
  "ZPC CC Test": {
    "prefix": "zpc",
    "scope": "c,cpp",
    "body": [
      "/******************************************************************************",
      " * # License",
      " * <b>Copyright ${CURRENT_YEAR} Silicon Laboratories Inc. www.silabs.com</b>",
      " ******************************************************************************",
      " * The licensor of this software is Silicon Laboratories Inc. Your use of this",
      " * software is governed by the terms of Silicon Labs Master Software License",
      " * Agreement (MSLA) available at",
      " * www.silabs.com/about-us/legal/master-software-license-agreement. This",
      " * software is distributed to you in Source Code format and is governed by the",
      " * sections of the MSLA applicable to Source Code.",
      " *",
      " *****************************************************************************/",
      "// Base class",
      "#include \"zwave_command_class_$1.h\"",
      "#include \"zwave_command_classes_utils.h\"",
      "#include \"unity.h\"",
      "",
      "// Generic includes",
      "#include <string.h>",
      "",
      "// Unify",
      "#include \"datastore.h\"",
      "#include \"attribute_store.h\"",
      "#include \"attribute_store_fixt.h\"",
      "// Interface includes",
      "#include \"ZW_classcmd.h\"",
      "",
      "// ZPC includes",
      "#include \"attribute_store_defined_attribute_types.h\"",
      "#include \"zpc_attribute_store_type_registration.h\"",
      "",
      "// Test helpers",
      "#include \"zwave_command_class_test_helper.hpp\"",
      "",
      "",
      "// Attribute macro, shortening those long defines for attribute types:",
      "#define ATTRIBUTE(type) ATTRIBUTE_COMMAND_CLASS_${1/(.*)/${1:/upcase}/}_##type",
      "",
      "",
      "using namespace zwave_command_class_test_helper;",
      "",
      "extern \"C\" {",
      "",
      "/// Setup the test suite (called once before all test_xxx functions are called)",
      "void suiteSetUp()",
      "{",
      "  datastore_init(\":memory:\");",
      "  attribute_store_init();",
      "  zpc_attribute_store_register_known_attribute_types();",
      "}",
      "",
      "/// Teardown the test suite (called once after all test_xxx functions are called)",
      "int suiteTearDown(int num_failures)",
      "{",
      "  attribute_store_teardown();",
      "  datastore_teardown();",
      "  return num_failures;",
      "}",
      "",
      "// Tested command class handler",
      "const zwave_struct_handler_args command_class_handler",
      "  = {.command_class_id  = COMMAND_CLASS_${1/(.*)/${1:/upcase}/},",
      "     .supported_version = ${1/(.*)/${1:/upcase}/}_VERSION};",
      "// Get Set function map",
      "const resolver_function_map attribute_bindings = {",
      "  //{ATTRIBUTE(VALUE), {SWITCH_BINARY_GET, SWITCH_BINARY_SET}},",
      "};",
      "",
      "/// Called before each and every test",
      "void setUp()",
      "{",
      "  zwave_setUp(command_class_handler,",
      "              &zwave_command_class_$1_init,",
      "              attribute_bindings);",
      "}",
      "",
      "} // extern \"C\"$0"
    ],
    "description": "ZPC Reference for CC Test"
  },
  "Rust file": {
    "prefix": "zpc",
    "scope": "rust",
    "body": [
      "///////////////////////////////////////////////////////////////////////////////",
      "// # License",
      "// <b>Copyright ${CURRENT_YEAR}  Silicon Laboratories Inc. www.silabs.com</b>",
      "///////////////////////////////////////////////////////////////////////////////",
      "// The licensor of this software is Silicon Laboratories Inc. Your use of this",
      "// software is governed by the terms of Silicon Labs Master Software License",
      "// Agreement (MSLA) available at",
      "// www.silabs.com/about-us/legal/master-software-license-agreement. This",
      "// software is distributed to you in Source Code format and is governed by the",
      "// sections of the MSLA applicable to Source Code.",
      "//",
      "///////////////////////////////////////////////////////////////////////////////",
    ],
    "description": "UIC rust source file"
  },
  "Python file": {
    "prefix": "zpc",
    "scope": "python",
    "body": [
      "###############################################################################",
      "## License",
      "## <b>Copyright ${CURRENT_YEAR}  Silicon Laboratories Inc. www.silabs.com</b>",
      "###############################################################################",
      "## The licensor of this software is Silicon Laboratories Inc. Your use of this",
      "## software is governed by the terms of Silicon Labs Master Software License",
      "## Agreement (MSLA) available at",
      "## www.silabs.com/about-us/legal/master-software-license-agreement. This",
      "## software is distributed to you in Source Code format and is governed by the",
      "## sections of the MSLA applicable to Source Code.",
      "##",
      "###############################################################################",
    ],
    "description": "UIC python source file"
  }
}