<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Unify Specification: Dotdot ZCL in Unify Framework for Application Level Control</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Unify Specification
   &#160;<span id="projectnumber">ver1_0_RC11_20211006-19-g32c28c7</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Dotdot ZCL in Unify Framework for Application Level Control </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md40"></a>
Introduction</h1>
<p>This chapter provides application examples about the usage of the DotDot Zigbee cluster library specification <a class="el" href="md_doc_references.html">ZCL2018</a> in the Unify framework considering that the node capabilities have been discovered (i.e., the supported clusters, commands and attributes). The Unify framework uses MQTT transport protocol as an internal message transportation between Clients (IoT Service API, Protocol Controller, and so on), and unified controller application language that enables seamless communications across a Unify network.</p>
<p>In the Unify framework, every Protocol Controller must discover the capability of the PAN nodes in its network and advertise the capabilities of each node (supported commands and attributes) to interested parties (i.e., IoT Service for a cloud service like AWS-IOT) using MQTT protocol. This procedure known as <a class="el" href="md_doc__chapter06-service-discovery.html">service discovery</a>. After the PAN nodes capabilities have been discovered, the IoT service MQTT clients can control and observe the behavior of the nodes using the unified controller application language. The unified application language is based on a publish/subscribe messaging transport protocol and the dotdot/ZigBee Cluster library (ZCL) specification.</p>
<h1><a class="anchor" id="autotoc_md41"></a>
MQTT Topics</h1>
<p>The MQTT topics are divided into sub-spaces for each device to allow a Protocol Controller to advertise state and capabilities of a given device and IoT Services to read the state and control a given device.</p>
<p>There are three main spaces in a cluster MQTT topic, as follows:</p>
<ul>
<li><code>ucl/by-unid/+/+/&lt;ClusterName&gt;/Attributes/#</code> : This represents the cluster attributes state.</li>
<li><code>ucl/by-unid/+/+/&lt;ClusterName&gt;/SupportedCommands</code>: This represents the list of commands that the node can receive for this cluster.</li>
<li><code>ucl/by-unid/+/+/&lt;ClusterName&gt;/Commands/+</code> : This is the topic where IoT Services issue commands.</li>
<li><code>ucl/by-unid/+/+/&lt;ClusterName&gt;/SupportedGeneratedCommands</code>: This represents the list of commands that the node can generate for this cluster.</li>
<li><code>ucl/by-unid/+/+/&lt;ClusterName&gt;/GeneratedCommands/+</code> : This is the topic where IoT Services receives commands from PAN nodes.</li>
</ul>
<p>The <code>/+/+</code> wildcards can be replaced with a specific UNID and endpoint to control/monitor only a single endpoint.</p>
<p>An overview of these topics is shown in the table below.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">MQTT Topic </th><th class="markdownTableHeadNone">Protocol<br  />
Controllers </th><th class="markdownTableHeadNone">IoT<br  />
Services </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>ucl/by-unid/&lt;UNID&gt;/ep&lt;EndPointID&gt;/&lt;ClusterName&gt;/Attributes/&lt;AttributeName&gt;/Reported</code> </td><td class="markdownTableBodyNone">Publish<br  />
(retained) </td><td class="markdownTableBodyNone">Subscribe </td><td class="markdownTableBodyNone">Advertises the reported value of an attribute for the Cluster.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>ucl/by-unid/&lt;UNID&gt;/ep&lt;EndPointID&gt;/&lt;ClusterName&gt;/Attributes/&lt;AttributeName&gt;/Desired</code> </td><td class="markdownTableBodyNone">Publish<br  />
(retained) </td><td class="markdownTableBodyNone">Subscribe </td><td class="markdownTableBodyNone">Advertises the desired value of an attribute for the Cluster.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>ucl/by-unid/&lt;UNID&gt;/ep&lt;EndPointID&gt;/&lt;ClusterName&gt;/Attributes/#</code> </td><td class="markdownTableBodyNone">Publish<br  />
(retained) </td><td class="markdownTableBodyNone">Subscribe </td><td class="markdownTableBodyNone">Advertises the reported/desired value of a non-standard attribute for the Cluster. Non-standard attributes are defined in this specification. The last level of this topic space will always be /Reported or /Desired.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>ucl/by-unid/&lt;UNID&gt;/ep&lt;EndPointID&gt;/&lt;ClusterName&gt;/SupportedCommands</code> </td><td class="markdownTableBodyNone">Publish<br  />
(retained) </td><td class="markdownTableBodyNone">Subscribe </td><td class="markdownTableBodyNone">Advertises an array of commands that can be published under the Commands/# namespace by IoT Services to control the device.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>ucl/by-unid/&lt;UNID&gt;/ep&lt;EndPointID&gt;/&lt;ClusterName&gt;/Commands/&lt;CommandName&gt;</code> </td><td class="markdownTableBodyNone">Subscribe </td><td class="markdownTableBodyNone">Publish<br  />
(unretained) </td><td class="markdownTableBodyNone">Instruct a Protocol Controller to send a command to the UNID/endpoint server cluster.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>ucl/by-unid/&lt;UNID&gt;/ep&lt;EndPointID&gt;/&lt;ClusterName&gt;/SupportedGeneratedCommands</code> </td><td class="markdownTableBodyNone">Publish<br  />
(retained) </td><td class="markdownTableBodyNone">Subscribe </td><td class="markdownTableBodyNone">Advertises an array of commands that can be generated under the GeneratedCommands/# namespace by Protocol Controller as commands sent from the device.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>ucl/by-unid/&lt;UNID&gt;/ep&lt;EndPointID&gt;/&lt;ClusterName&gt;/GeneratedCommands/&lt;CommandName&gt;</code> </td><td class="markdownTableBodyNone">Publish<br  />
(unretained) </td><td class="markdownTableBodyNone">Subscribe </td><td class="markdownTableBodyNone">Receive commands sent from the UNID/endpoint cluster to Unify.  </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md42"></a>
Reported and Desired</h2>
<p>The state of a cluster for a device/endpoint is represented by a list of attributes, additional (non-standard) attributes, and a list of supported commands.</p>
<p>A PAN node may perform state transitions or delays may occur between an IoT Service issuing an MQTT command and the device itself confirming that its state matches what the IoT Service wished to accomplish. For that purpose, each attribute in a Cluster has two values, a <em>desired</em> and a <em>reported</em> value. The <em>desired value</em> indicates what the Protocol Controller attempts to get device/endpoint to reach. The <em>reported value</em> indicates the state confirmed by the device/endpoint itself.</p>
<p>More information about the 'desired' and 'reported' state description can be found in the <a href="https://docs.aws.amazon.com/iot/latest/developerguide/device-shadow-document-syntax.html#device-shadow-example-request-json">Amazon AWS Specification</a>.</p>
<h2><a class="anchor" id="autotoc_md43"></a>
Cluster MQTT Topics</h2>
<p>IoT Services (Cloud Service connectors, Middleware Translator, and Rules Engines) should subscribe to the following topic filter to get any application message corresponding to the state of given cluster from any PAN node in the Unify network:</p>
<div class="fragment"><div class="line">ucl/by-unid/+/+/&lt;ClusterName&gt;/#</div>
</div><!-- fragment --><p>The Protocol Controllers MUST then publish to the following topics to advertise the supported attributes of a PAN Node and also when the attributes state is updated:</p>
<div class="fragment"><div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndPointID&gt;/&lt;ClusterName&gt;/Attributes/&lt;AttributeName&gt;/Reported { &quot;value&quot;: 23 }</div>
</div><!-- fragment --><p>For each attribute, the value property is required. This represents the value of the attribute and it can be any of the following JSON types:</p>
<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>null</li>
<li>an object, containing boolean types (only for bitmasks)</li>
</ul>
<p>For example, a Protocol Controller advertising the state of a device/endpoint being a OnOff and Level cluster server will publish the following:</p>
<div class="fragment"><div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/OnOff/Attributes/OnOff/Desired { &quot;value&quot;: true}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/OnOff/Attributes/OnOff/Reported { &quot;value&quot;: true}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Level/Attributes/CurrentLevel/Desired { &quot;value&quot;: 50}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Level/Attributes/CurrentLevel/Reported { &quot;value&quot;: 100}</div>
</div><!-- fragment --><p>Furthermore, in the example above, the PAN node is dimming its level from 100% to 50%. When it reaches 50% and the Protocol Controller has received a confirmation, the reported state of the CurrentLevel attribute will be updated to match the desired value.</p>
<p>Strings MUST be used by Protocol Controllers when a descriptive name is given to the possible values for a given attribute by the DotDot XML files. For example, the <em>LockState</em> attribute of a door lock MUST be published as follows:</p>
<div class="fragment"><div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Lock/Attributes/LockState/Desired { &quot;value&quot;: &quot;Locked&quot;}</div>
</div><!-- fragment --><p>If the individual values do not have a description string name, their value MUST be presented using either a JSON number or boolean. See the ZCL Cluster Library <a class="el" href="md_doc_references.html">ZCL2018</a>.</p>
<p>Finally, only JSON objects are allowed for bitmaps/bitmasks when names are defined in the ZCL Cluster Library <a class="el" href="md_doc_references.html">ZCL2018</a>. Numbers MUST NOT be used in this case. For example, the ColorCapabilities attribute of the ColorControl cluster MUST be represented as follows:</p>
<div class="fragment"><div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/ColorControl/Attributes/ColorCapabilities/Reported</div>
</div><!-- fragment --><div class="fragment"><div class="line">{</div>
<div class="line">  &quot;value&quot;: {</div>
<div class="line">    &quot;HueSaturationSupported&quot;: true,</div>
<div class="line">    &quot;EnhancedHueSupported&quot;: true,</div>
<div class="line">    &quot;ColorLoopSupported&quot;: true,</div>
<div class="line">    &quot;XYSupported&quot;: true,</div>
<div class="line">    &quot;ColorTemperatureSupported&quot;: true</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md44"></a>
Mandatory Cluster Attributes</h3>
<p>PAN Nodes may support more than the minimum mandatory set of attributes for a given cluster. When a node is interviewed and its capabilities are discovered, a Protocol Controller MUST, at a minimum, publish all attributes for a cluster that are specified as <em>mandatory</em> in the ZigBee Cluster library.</p>
<p>For example, for a PAN Node supporting the OnOff cluster, it will be guaranteed that the <em>OnOff</em> attribute will be published, however, the <em>GlobalSceneControl</em> will be published only if supported by the PAN node.</p>
<div class="fragment"><div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/OnOff/Attributes/OnOff/Desired { &quot;value&quot;: true}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/OnOff/Attributes/OnOff/Reported { &quot;value&quot;: true}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/OnOff/Attributes/GlobalSceneControl/Desired { &quot;value&quot;: true}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/OnOff/Attributes/GlobalSceneControl/Reported { &quot;value&quot;: true}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md45"></a>
Missing Mandatory Cluster Attributes</h3>
<p>Because of multiple PHYs and the application level variety between them, a node might be shown as a ZCL cluster server, despite missing a mandatory attribute.</p>
<p>For example, in Z-Wave, it is possible to have Thermostats without a local temperature reading. These thermostats can nonetheless be controlled by MQTT clients and the lack of a temperature reading should not prevent the exposition of such a device to the IoT Services.</p>
<p>In this case, the value of the attribute MUST be set to a null JSON type. For instance, a thermostat without local temperature MAY be published as follows:</p>
<div class="fragment"><div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Thermostat/Attributes/LocalTemperature/Desired { &quot;value&quot;: null}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Thermostat/Attributes/LocalTemperature/Reported { &quot;value&quot;: null}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Thermostat/Attributes/OccupiedCoolingSetpoint/Desired { &quot;value&quot;: 2600}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Thermostat/Attributes/OccupiedCoolingSetpoint/Reported { &quot;value&quot;: 2600}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Thermostat/Attributes/OccupiedHeatingSetpoint/Desired { &quot;value&quot;: 2100}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Thermostat/Attributes/OccupiedHeatingSetpoint/Reported { &quot;value&quot;: 2100}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Thermostat/Attributes/SystemMode/Desired { &quot;value&quot;: &quot;Auto&quot;}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Thermostat/Attributes/SystemMode/Reported { &quot;value&quot;: &quot;Auto&quot;}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Thermostat/Attributes/ThermostatProgrammingOperationMode/Desired { &quot;value&quot;: 0}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Thermostat/Attributes/ThermostatProgrammingOperationMode/Reported { &quot;value&quot;: 0}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Thermostat/Attributes/ControlSequenceOfOperation/Desired { &quot;value&quot;: 4}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Thermostat/Attributes/ControlSequenceOfOperation/Reported { &quot;value&quot;: 4}</div>
</div><!-- fragment --><p>In any case, a Protocol Controller SHOULD publish the <em>LocalTemperature</em> attribute state when publishing a node as a Thermostat Cluster server because it is a mandatory attribute.</p>
<p>When a reported state is updated from the PAN node, the Protocol Controllers MUST update both the reported and desired values of the corresponding attributes. In this case, Protocol Controllers SHOULD publish the desired part of the updated state first.</p>
<h3><a class="anchor" id="autotoc_md46"></a>
Cluster Revisions</h3>
<p>A special attribute under every cluster called ClusterRevision is used to advertise the ZCL revision of the cluster that the node and/or Protocol Controller are using.</p>
<p>ProtocolControllers MUST publish this information for all clusters of all nodes they advertise.</p>
<p>See the the ZCL Cluster Library <a class="el" href="md_doc_references.html">ZCL2018</a> for Cluster revision details.</p>
<p>The JSON value type for the ClusterRevision attribute MUST be an integer. Both Desired and Reported values MUST be published by Protocol Controllers. The ClusterRevision is a read-only attribute.</p>
<p>For example, publishing the cluster revision of an OnOff node:</p>
<div class="fragment"><div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/OnOff/Attributes/OnOff/Desired {&quot;value&quot;: true}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/OnOff/Attributes/OnOff/Reported {&quot;value&quot;: true}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/OnOff/Attributes/ClusterRevision/Desired {&quot;value&quot;: 2}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/OnOff/Attributes/ClusterRevision/Reported {&quot;value&quot;: 2}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md47"></a>
Additional Attributes</h3>
<p>Additional attributes under a cluster state can be used to advertise state information that is not standardized as Cluster attributes.</p>
<p>The format of this additional state information is UCL-specific and defined in this specification. It follows as closely as possible the data models described in the ZCL Cluster Library <a class="el" href="md_doc_references.html">ZCL2018</a>.</p>
<p>The additional state information can be affected by the use of commands and it MUST also follow a desired/reported state. Most clusters do not have any additional attributes defined.</p>
<p>Additional attributes MUST be published under the same <code>Attributes/</code> MQTT topic hierarchy as the standard cluster attributes, however, the MQTT topic hierarchy MAY contain additional levels before the final Desired or Reported level.</p>
<p>For example, the Scene Cluster definition uses a Scene Table, which is advertised to the IoT Services using a UCL-specific definition. Non-standard attributes MUST be represented using object JSON types. This specification will provide a JSON schema for all non-standard attributes.</p>
<p><b>Topic:</b> <code>ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Scenes/Attributes/SceneTable/1/Desired</code></p>
<p><b>Payload:</b></p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;GroupID&quot;: 12,</div>
<div class="line">  &quot;SceneID&quot;: 1,</div>
<div class="line">  &quot;SceneName&quot;: &quot;Cozy Scene&quot;,</div>
<div class="line">  &quot;TransitionTime&quot;: 10,</div>
<div class="line">  &quot;TransitionTime100ms&quot;: 0,</div>
<div class="line">  &quot;SceneTableExtensions&quot;: {</div>
<div class="line">    &quot;OnOff&quot;: {</div>
<div class="line">      &quot;OnOff&quot;: true</div>
<div class="line">    },</div>
<div class="line">    &quot;Level&quot;: {</div>
<div class="line">      &quot;CurrentLevel&quot;: 25</div>
<div class="line">    },</div>
<div class="line">    &quot;ColorControl&quot;: {</div>
<div class="line">      &quot;CurrentX&quot;: 25,</div>
<div class="line">      &quot;CurrentY&quot;: 3455</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md48"></a>
Commands Supported by PAN Node</h3>
<p>IoT Services MUST be able to read the commands that are supported for a cluster server under a UNID/Endpoint to control them.</p>
<p>The list of supported Commands for each PAN node MUST be advertised by the Protocol Controllers in the <em>SupportedCommands</em> topic under the Cluster level.</p>
<p>The list of supported Commands MUST be advertised using a JSON array containing strings. For example, the list of supported commands for the OnOff cluster could look like this:</p>
<p><b>Topic:</b> <code>ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/OnOff/SupportedCommands</code></p>
<p><b>Payload:</b></p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;value&quot;: [&quot;On&quot;,&quot;Off&quot;,&quot;Toggle&quot;,&quot;ForceReadAttributes&quot;,&quot;WriteAttributes&quot;]</div>
<div class="line">}</div>
</div><!-- fragment --><p>It is OPTIONAL for a Protocol Controller to publish the availability of the <em>WriteAttributes</em> and <em>ForceReadAttributes</em> commands. These commands MUST be supported for all clusters advertised by a Protocol Controller.</p>
<p>Note: A ProtocolController MAY publish an empty array for the SupportedCommands of a cluster. In this case, IoT Services can only use the WriteAttributes commands if the cluster contains writable attributes.</p>
<p>Note 2: IoT Services MUST NOT wait for a feedback after sending a ForceReadAttributes command. This command is used to <em>force</em> an update on the usual feedback channels - i.e., the <em>reported</em> MQTT topic.</p>
<p>Protocol Controllers SHOULD explicitly advertise the availability of the <em>WriteAttributes</em> Command in the SupportedCommands topic when there is at least one writable attribute supported by the PAN node (i.e., marked as <code>writable=true</code> in the ZCL cluster definition).</p>
<p>Protocol Controllers SHOULD NOT advertise the availability of the <em>WriteAttributes</em> Command in the SupportedCommands topic when there is no writable attribute supported by the PAN node for the cluster. IoT Services MAY use this command but it will have no effect.</p>
<p>Protocol Controllers SHOULD explicitly advertise the availability of the <em>ForceReadAttributes</em> Command in the SupportedCommands topic when there is at least one readable attribute that is of a type not of an integer or floating point type (i.e., an attribute of type "String" or other complex data types).</p>
<p>Protocol Controller SHOULD advertise the <em>ForceReadAttributes</em> Command for all endpoints with readable mandatory attributes, as supported in the ZCL cluster definition.</p>
<h3><a class="anchor" id="autotoc_md49"></a>
Sending Supported Commands to PAN Node</h3>
<p>When a PAN node is included to the network, a Protocol Controller servicing the node MUST subscribe to the following topic filter to receive incoming Commands:</p>
<blockquote class="doxtable">
<p><code>ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/&lt;ClusterName&gt;/Commands/+</code> </p>
</blockquote>
<p>It is OPTIONAL for a Protocol Controller to subscribe to the command topic filter only if the PAN node supports no commands and all attributes are read-only attributes (i.e., the WriteAttributes command will have no effect).</p>
<p>When the IoT Services (AWS IoT connectors, Web-based UIs, Rules Engines, Data Loggers, and so on.) want a PAN node to execute a given command, the Clients can publish a command payload using the respective command topic:</p>
<p><b>Topic:</b> <code>ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/&lt;ClusterName&gt;/Commands/&lt;CommandName&gt;</code></p>
<p><b>Payload:</b></p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;FieldName1&quot;: &quot;value&quot;,</div>
<div class="line">  &quot;FieldName2&quot;: &quot;value&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md50"></a>
Commands Generated by PAN Node</h3>
<p>IoT Services SHOULD be able to read the commands that are generated by a cluster under a UNID/Endpoint to listen to unsolicited events and responses.</p>
<p>The list of generated commands for each PAN node SHOULD be advertised by the Protocol Controllers in the <em>SupportedGeneratedCommands</em> topic under the Cluster level.</p>
<p>The list of generated commands SHOULD be advertised using a JSON array containing strings. For example, the list of generated commands for the OnOff client cluster could look like this:</p>
<p><b>Topic:</b> <code>ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/OnOff/SupportedGeneratedCommands</code></p>
<p><b>Payload:</b></p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;value&quot;: [&quot;On&quot;,&quot;Off&quot;,&quot;Toggle&quot;]</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note: No publications to this topic is equivalent to the Protocol Controller publishing an empty array of strings to indicate no commands can be generated by this PAN node.</p>
<h3><a class="anchor" id="autotoc_md51"></a>
Receiving Generated Commands from PAN Node</h3>
<p>When a PAN node is included to the network, an IoT Service monitoring the node SHOULD subscribe to the following topic filter to receive incoming commands from the PAN node:</p>
<blockquote class="doxtable">
<p><code>ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/&lt;ClusterName&gt;/GeneratedCommands/+</code> </p>
</blockquote>
<p>It is OPTIONAL for a Protocol Controller to publish to the command topic since not all PAN nodes can generate commands. IoT Services SHOULD NOT expect to see publications for all PAN nodes on this topic filter.</p>
<p>When the IoT Services (AWS IoT connectors, Web-based UIs, Rules Engines, Data Loggers, and so on.) want to receive commands from a PAN node, the Clients can subscribe to the topic and parse the command payload:</p>
<p><b>Topic:</b> <code>ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/&lt;ClusterName&gt;/GeneratedCommands/&lt;CommandName&gt;</code></p>
<p><b>Payload:</b></p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;FieldName1&quot;: &quot;value&quot;,</div>
<div class="line">  &quot;FieldName2&quot;: &quot;value&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md52"></a>
Command Payloads</h3>
<p>If the command does not have any mandatory fields, an empty JSON object (i.e., {}) MUST be sent as a payload.</p>
<p>If the command has mandatory fields, the payload MUST contain all of them. For example, in the 'Level' cluster, the 'MoveToLevel' command consists of two mandatory fields (i.e., 'Level' and 'Transition Time' ). In this case, the payload MUST be: <code>{"Level": 100, "TransitionTime": 0}</code>.</p>
<p>Each property representing a field MUST be of the following JSON types:</p>
<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>null</li>
<li>an object, containing boolean types (only for bitmasks)</li>
</ul>
<p>Strings MUST be used in command payloads when a descriptive name is given to the possible values for a given attribute by the DotDot XML files.</p>
<p>If the individual values do not have a description string name, their value MUST be presented using either a JSON number or boolean. See the ZCL Cluster Library <a class="el" href="md_doc_references.html">ZCL2018</a>.</p>
<p>Finally, only JSON objects are allowed for bitmaps/bitmasks when names are defined in the ZCL Cluster Library <a class="el" href="md_doc_references.html">ZCL2018</a>. Numbers MUST NOT be used in this case. For example, the UpdateFlags field of the ColorLoopSet command in the ColorControl cluster MUST be represented as follows:</p>
<div class="fragment"><div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/ColorControl/Commands/ColorLoopSet</div>
</div><!-- fragment --><div class="fragment"><div class="line">{</div>
<div class="line">  &quot;UpdateFlags&quot; : {</div>
<div class="line">    &quot;UpdateAction&quot;: true,</div>
<div class="line">    &quot;UpdateDirection&quot;: true,</div>
<div class="line">    &quot;UpdateTime&quot;: true,</div>
<div class="line">    &quot;UpdateStartHue&quot;: false</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md53"></a>
WriteAttributes Generic Command</h3>
<p>A Protocol Controller MUST always publish the desired/reported state of all mandatory attributes in a cluster, using the Cluster state topic space. An attribute state can be changed in three ways:</p>
<ul>
<li>Locally on the PAN node</li>
<li>Using a specific command as described above</li>
<li>Using a generic command called 'WriteAttributes'</li>
</ul>
<p>For example, an IoT Service MAY issue the following payload to modify the desired values of writable attributes directly:</p>
<p><b>Topic:</b> <code>ucl/by-unid/&lt;UNID&gt;/ep&lt;EndPointID&gt;/&lt;ClusterName&gt;/Commands/WriteAttributes</code></p>
<p><b>Payload:</b></p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;AttributeName1&quot;: &quot;value&quot;,</div>
<div class="line">  &quot;AttributeName2&quot;: &quot;value&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that all PAN nodes, which support writable attributes MUST be writable directly using the <em>WriteAttributes</em> Command. Read-only attributes received in this Command will be ignored. See <a class="el" href="md_doc_references.html">ZCL2018</a> for details about writable/read-only attributes.</p>
<p>To ensure an end-to-end quality of service, a Protocol Controller MUST always publish the attributes desired/reported state when it detects a state update. IoT Services can therefore see the effect of their published commands by subscribing to the cluster <em>Attributes</em> space.</p>
<p>Non-standard attribute cannot be updated or modified using the <em>WriteAttributes</em> command.</p>
<h2><a class="anchor" id="autotoc_md54"></a>
ForceReadAttributes Generic Command</h2>
<p>The <em>ForceReadAttributes</em> command is used to force an update of specified attributes that may not be properly reported using standard reporting mechanisms. On reception of this command, the Protocol Controller SHOULD request the latest available data from the network for each attribute specified in the command. The data SHOULD be published on the <em>reported</em> MQTT topic for each attribute.</p>
<p>ForceReadAttributes should be used sparingly because it can generate significant radio traffic. The default behavior of the protocol controllers already guarantee a good trade off between timely updates and radio traffic without the use of ForceReadAttributes.</p>
<p>If the newly read value of an attribute matches its previously reported value, a new MQTT message MAY not be published.</p>
<p>If the payload of the received MQTT command is empty, the Protocol Controller SHOULD request new data for all supported attributes of that cluster.</p>
<p>The <em>ForceReadAttributes</em> command is intended only for attributes with values that cannot be adequately handled by standard reporting mechanisms. For example, the 'String' or 'Array' types on Zigbee clusters, which would NOT notify the Protocol Controller when their values change. For a complete list of expected types, see <a class="el" href="md_doc_references.html">ZCL2018</a>.</p>
<p>For standard attribute types, a Protocol Controller SHOULD rely on the <em>reported</em> MQTT topic alone.</p>
<p>For example, an IoT Service MAY issue the following payload to directly read several attributes of a given cluster</p>
<p><b>Topic:</b> <code>ucl/by-unid/&lt;UNID&gt;/ep&lt;EndPointID&gt;/&lt;ClusterName&gt;/Commands/ForceReadAttributes</code></p>
<p><b>Payload:</b></p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;value&quot; :</div>
<div class="line">    [</div>
<div class="line">      &quot;AttributeName1&quot;,</div>
<div class="line">      &quot;AttributeName2&quot;,</div>
<div class="line">      &quot;AttributeName6&quot;</div>
<div class="line">    ]</div>
<div class="line">}</div>
</div><!-- fragment --><p>In response, the Protocol Controller should update the 'reported' MQTT topics for 'AttributeName1' and 'AttributeName2', as discussed in the [MQTT Topics](Reported and desired).</p>
<p>Another example, an IoT Service MAY issue the following payload to directly read ALL the attributes of a given cluster</p>
<p><b>Topic:</b> <code>ucl/by-unid/&lt;UNID&gt;/ep&lt;EndPointID&gt;/&lt;ClusterName&gt;/Commands/ForceReadAttributes</code></p>
<p><b>Payload:</b></p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;value&quot; : []</div>
<div class="line">}</div>
</div><!-- fragment --><p>In response, the Protocol Controller should update ALL available attributes for <em>ClusterName</em>, as specified in <a class="el" href="md_doc_references.html">ZCL2018</a>.</p>
<p><em>ForceReadAttribute</em> support for non-standard ZCL cluster attributes is optional.</p>
<p><em>ForceReadAttribute</em> is EXPLICITLY not supported for groups or multicast due to network performance considerations.</p>
<h1><a class="anchor" id="autotoc_md55"></a>
Clusters for Lights, Switches, DoorLock, Thermostat, and Occupancy Sensor Applications</h1>
<p>The following subsections provide specific cluster examples using the Cluster state and Commands topics, such as Dimmer lighting, Switch, Door Lock, Thermostat, and Occupancy Sensor applications. The detailed description of each cluster can be found in <a class="el" href="md_doc_references.html">ZCL2018</a>.</p>
<p>Each cluster has a list of mandatory attributes and commands. All mandatory attributes in a given cluster MUST be advertised by a Protocol Controller for all devices/endpoints. All mandatory Commands SHOULD be advertised in the SupportedCommand topic, when possible.</p>
<h2><a class="anchor" id="autotoc_md56"></a>
Groups Cluster (0x0004)</h2>
<p>This cluster is used to define group memberships for PAN nodes.</p>
<p>This cluster requires additional attributes, because the <em>Group list</em> is not captured by its defined attributes. See <a class="el" href="md_doc_references.html">ZCL2018</a> for the <em>Groups</em> cluster definition.</p>
<p>Each group is identified using a 16 bits unsigned integer value. Below is an example of a PAN node Group Cluster server:</p>
<div class="fragment"><div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Groups/Attributes/ClusterRevision/Desired {&quot;value&quot;: 2}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Groups/Attributes/ClusterRevision/Reported {&quot;value&quot;: 2}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Groups/Attributes/NameSupport/Desired {&quot;value&quot;: {&quot;Supported&quot;:true}}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Groups/Attributes/NameSupport/Reported {&quot;value&quot;: {&quot;Supported&quot;:true}}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Groups/Attributes/GroupList/Desired {&quot;value&quot;: [1, 2] }</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Groups/Attributes/GroupList/Reported {&quot;value&quot;: [1] }</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Groups/Attributes/1/Name/Desired {&quot;value&quot;: &quot;Kitchen nodes&quot;}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Groups/Attributes/1/Name/Reported {&quot;value&quot;: &quot;Kitchen nodes&quot;}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Groups/Attributes/2/Name/Desired {&quot;value&quot;: &quot;Light bulbs&quot;}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Groups/SupportedCommands {&quot;value&quot;: [&quot;AddGroup&quot;, &quot;ViewGroup&quot;, &quot;GetGroupMembership&quot;, &quot;RemoveGroup&quot;, &quot;RemoveAllGroups&quot;, &quot;AddGroupIfIdentifying&quot;] }</div>
</div><!-- fragment --><p>The only mandatory attribute in the group cluster is the NameSupport attribute. If a PAN node supports name for groups, it will advertise the assigned names for each of its groups under the following topics:</p>
<p><b>Topic:</b> <code>ucl/by-unid/&lt;UNID&gt;/ep&lt;id&gt;/Groups/Attributes/&lt;GroupID&gt;/Name/Reported</code></p>
<p><b>Topic:</b> <code>ucl/by-unid/&lt;UNID&gt;/ep&lt;id&gt;/Groups/Attributes/&lt;GroupID&gt;/Name/Desired</code></p>
<p>The names assigned to each group will be a value containing a string as if the name was a regular string attribute.</p>
<p><b>JSON Schema:</b></p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,</div>
<div class="line">  &quot;title&quot;: &quot;Group name objects&quot;,</div>
<div class="line">  &quot;description&quot;: &quot;Names assigned to individual groups. (Group cluster)&quot;,</div>
<div class="line">  &quot;type&quot;: &quot;object&quot;,</div>
<div class="line">  &quot;properties&quot;: {</div>
<div class="line">    &quot;value&quot;: {</div>
<div class="line">      &quot;type&quot;: &quot;string&quot;</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line">  &quot;required&quot;: [</div>
<div class="line">    &quot;value&quot;</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --><p>The list of groups that a node is part of will be advertised under the GroupList topic. Note that GroupID 0 is not a valid group and MUST NOT be used.</p>
<p><b>Topic:</b> <code>ucl/by-unid/&lt;UNID&gt;/ep&lt;id&gt;/Groups/Attributes/GroupList/Desired</code></p>
<p><b>JSON Schema:</b></p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,</div>
<div class="line">  &quot;title&quot;: &quot;GroupList Object&quot;,</div>
<div class="line">  &quot;description&quot;: &quot;List of Groups that a PAN Node belongs to. (Group cluster)&quot;,</div>
<div class="line">  &quot;type&quot;: &quot;object&quot;,</div>
<div class="line">  &quot;properties&quot;: {</div>
<div class="line">    &quot;value&quot;: {</div>
<div class="line">       &quot;type&quot;: &quot;array&quot;,</div>
<div class="line">        &quot;items&quot;: {</div>
<div class="line">          &quot;type&quot;: &quot;integer&quot;,</div>
<div class="line">          &quot;minimum&quot;: 1,</div>
<div class="line">          &quot;maximum&quot;: 65535</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line">  &quot;required&quot;: [</div>
<div class="line">    &quot;value&quot;</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md57"></a>
Scenes Cluster (0x0005)</h2>
<p>This cluster is used to define scene and configuration of each device/endpoint. In the Unify context, it can be used both for scene controlling devices (e.g., wall controller button) and for activating scenes for other nodes (e.g., light dimmer).</p>
<p>This cluster requires additional attributes because the <em>Scene Table</em> is not captured by its defined attributes. See <a class="el" href="md_doc_references.html">ZCL2018</a> for the <em>Scene Table</em> definition.</p>
<p>Below is an example of a PAN node Scene Cluster server:</p>
<div class="fragment"><div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Scenes/Attributes/ClusterRevision/Desired {&quot;value&quot;: 2}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Scenes/Attributes/ClusterRevision/Reported {&quot;value&quot;: 2}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Scenes/Attributes/SceneCount/Desired {&quot;value&quot;: 5}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Scenes/Attributes/SceneCount/Reported {&quot;value&quot;: 5}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Scenes/Attributes/CurrentScene/Desired {&quot;value&quot;: 2}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Scenes/Attributes/CurrentScene/Reported {&quot;value&quot;: 2}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Scenes/Attributes/CurrentGroup/Desired {&quot;value&quot;: 1}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Scenes/Attributes/CurrentGroup/Reported {&quot;value&quot;: 1}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Scenes/Attributes/SceneValid/Desired {&quot;value&quot;: true}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Scenes/Attributes/SceneValid/Reported {&quot;value&quot;: true}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Scenes/Attributes/NameSupport/Desired {&quot;value&quot;: true}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Scenes/Attributes/NameSupport/Reported {&quot;value&quot;: true}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Scenes/SupportedCommands {&quot;value&quot; :[&quot;AddScene&quot;, &quot;ViewScene&quot;, &quot;RemoveScene&quot;, &quot;RemoveAllScenes&quot;, &quot;StoreScene&quot;, &quot;RecallScene&quot;, &quot;GetSceneMembership&quot;, &quot;WriteAttributes&quot;] }</div>
</div><!-- fragment --><p>Note that in the example above, the <em>ViewScene</em> and <em>GetSceneMembership</em> commands are available, but will have no effect, because their purpose is to retrieve data. Retrieving data is done automatically by the protocol controllers. In this case, a Protocol Controller SHOULD remove these commands from the <em>SupportedCommands</em> list.</p>
<p>Note that in the example above, the <em>WriteAttributes</em> commands is available, but will also have no effect because all standard attributes are read-only in this cluster. In this case, a Protocol Controller SHOULD remove these commands from the <em>SupportedCommands</em> list.</p>
<p>The Scene Table data is represented using this topic hierarchy:</p>
<p><b>Topic:</b> <code>ucl/by-unid/&lt;UNID&gt;/ep&lt;id&gt;/Scenes/Attributes/SceneTable/&lt;SceneNumber&gt;/Reported</code></p>
<p><b>Topic:</b> <code>ucl/by-unid/&lt;UNID&gt;/ep&lt;id&gt;/Scenes/Attributes/SceneTable/&lt;SceneNumber&gt;/Desired</code></p>
<p>The payload of the JSON data published for a scene entry are defined in in the following JSON schema:</p>
<p><b>JSON Schema:</b></p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,</div>
<div class="line">  &quot;title&quot;: &quot;Scene Object&quot;,</div>
<div class="line">  &quot;description&quot;: &quot;Scene object for the Scenes Table in the Scene Cluster&quot;,</div>
<div class="line"> </div>
<div class="line">  &quot;type&quot;: &quot;object&quot;,</div>
<div class="line">  &quot;properties&quot;: {</div>
<div class="line">    &quot;GroupID&quot; : {</div>
<div class="line">      &quot;type&quot;: &quot;number&quot;,</div>
<div class="line">      &quot;minimum&quot;: 0,</div>
<div class="line">      &quot;maximum&quot;: 65535</div>
<div class="line">    },</div>
<div class="line">    &quot;SceneID&quot; : {&quot;type&quot;: &quot;number&quot;},</div>
<div class="line">    &quot;SceneName&quot; : {&quot;type&quot;: &quot;string&quot;},</div>
<div class="line">    &quot;TransitionTime&quot; : {&quot;type&quot;: &quot;number&quot;},</div>
<div class="line">    &quot;TransitionTime100ms&quot; : {&quot;type&quot;: &quot;number&quot;},</div>
<div class="line">    &quot;SceneTableExtensions&quot;: {</div>
<div class="line">      &quot;type&quot;: &quot;object&quot;,</div>
<div class="line">      &quot;patternProperties&quot;: {</div>
<div class="line">        &quot;&quot;: { &quot;type&quot;: &quot;object&quot; }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line"> </div>
<div class="line">  &quot;required&quot;: [&quot;GroupID&quot;, &quot;SceneID&quot;, &quot;SceneName&quot;, &quot;TransitionTime&quot;, &quot;TransitionTime100ms&quot;, &quot;SceneTableExtensions&quot;]</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p>An example of a scene object is shown below.</p>
<p><b>Payload:</b></p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;GroupID&quot;: 12,</div>
<div class="line">  &quot;SceneID&quot;: 1,</div>
<div class="line">  &quot;SceneName&quot;: &quot;Cozy Scene&quot;,</div>
<div class="line">  &quot;TransitionTime&quot;: 10,</div>
<div class="line">  &quot;TransitionTime100ms&quot;: 0,</div>
<div class="line">  &quot;SceneTableExtensions&quot;: {</div>
<div class="line">    &quot;OnOff&quot;: {</div>
<div class="line">      &quot;OnOff&quot;: true</div>
<div class="line">    },</div>
<div class="line">    &quot;Level&quot;: {</div>
<div class="line">      &quot;CurrentLevel&quot;: 25</div>
<div class="line">    },</div>
<div class="line">    &quot;ColorControl&quot;: {</div>
<div class="line">      &quot;CurrentX&quot;: 25,</div>
<div class="line">      &quot;CurrentY&quot;: 3455</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md58"></a>
(Z-Wave) Scenes Actuators</h3>
<p>Scenes actuators do not support any of the ZCL required "SupportedCommands", and instead use the Scene Cluster attributes to indicate which scene they wish to activate. Such devices are both Scene Cluster servers and clients.</p>
<p>An MQTT client can therefore decide to activate scenes in a number of devices/endpoints based on the spontaneous changes made by these scenes actuator devices/endpoints.</p>
<p>For example, a wall switch with four buttons and three possible gestures for each button may be presented as a scene device, supporting twelve read-only scenes that would transition automatically (i.e., <em>CurrentScene</em> attribute will be updated in a read-only fashion). At each activation, the wall switch will aditionally generate a Recall Scene command that will be forwarded to the IoT Services. The Scene table will stay empty and will not be writable by IoT Services.</p>
<p>In this case, the wall switch Scenes numbers will not "match" the configured scenes in other devices. IoT Services SHOULD interpret the Scene ID as a unique combination with the UNID/ep to decide what to do.</p>
<p>IoT Services SHOULD pay attention to the security level (see the "Security" in the State topic) of a UNID before modifying the state (or sending commands) of other PAN nodes based on Generated Commands from a PAN node.</p>
<p>Note that the GroupID can be set to 0 if it is not used.</p>
<div class="fragment"><div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Scenes/Attributes/ClusterRevision/Desired {&quot;value&quot;: 2}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Scenes/Attributes/ClusterRevision/Reported {&quot;value&quot;: 2}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Scenes/Attributes/SceneCount/Desired {&quot;value&quot;: 12}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Scenes/Attributes/SceneCount/Reported {&quot;value&quot;: 12}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Scenes/Attributes/CurrentScene/Desired {&quot;value&quot;: 2}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Scenes/Attributes/CurrentScene/Reported {&quot;value&quot;: 2}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Scenes/Attributes/CurrentGroup/Desired {&quot;value&quot;: 0}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Scenes/Attributes/CurrentGroup/Reported {&quot;value&quot;: 0}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Scenes/Attributes/SceneValid/Desired {&quot;value&quot;: true}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Scenes/Attributes/SceneValid/Reported {&quot;value&quot;: true}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Scenes/Attributes/NameSupport/Desired {&quot;value&quot;: false}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Scenes/Attributes/NameSupport/Reported {&quot;value&quot;: false}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Scenes/SupportedCommands {&quot;value&quot;:[ ] }</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Scenes/SupportedGeneratedCommands {&quot;value&quot;:[&quot;RecallScene&quot;] }</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md59"></a>
Scenes Supporting Nodes</h3>
<p>Protocol Controller MUST advertise the Scene Table attribute for PAN nodes that can be configured to react and change state based on scenes.</p>
<p>All PAN nodes/endpoints supporting attributes marked as <em>sceneRequired="true"</em> in the <a href="https://zigbeealliance.org/solution/dotdot/">dotdot definitions</a> SHOULD be presented as a Scene cluster server by Protocol Controllers.</p>
<p>The Scene Extension table is described in the <a class="el" href="md_doc_references.html">ZCL2018</a>.</p>
<p>Each scene configuration can be done using the supported commands. The "SceneTableExtensions" JSON object may contain all attributes of other clusters marked as <em>sceneRequired="true"</em> in the <a href="https://zigbeealliance.org/solution/dotdot/">dotdot definitions</a>.</p>
<p>For example, a properly formed <em>AddScene</em> command could be as follows:</p>
<p><b>Topic:</b> <code>ucl/by-unid/&lt;UNID&gt;/ep&lt;id&gt;/Cluster/Scenes/AddScene</code></p>
<p><b>Payload:</b></p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;GroupID&quot;: 0,</div>
<div class="line">  &quot;SceneID&quot;: 1,</div>
<div class="line">  &quot;TransitionTime&quot;: 1,</div>
<div class="line">  &quot;SceneName&quot;: &quot;New Scene&quot;,</div>
<div class="line">  &quot;ExtensionFieldSets&quot;: {</div>
<div class="line">    &quot;OnOff&quot;: {</div>
<div class="line">      &quot;OnOff&quot;: true</div>
<div class="line">    },</div>
<div class="line">    &quot;Level&quot;: {</div>
<div class="line">      &quot;CurrentLevel&quot;: 100</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>In this case, the "ExtensionFieldSets" data will be parsed and copied into the "SceneTableExtensions" object of the Scene Table.</p>
<p>Only Cluster Attributes marked as <code>sceneRequired="true"</code> MUST be used by MQTT Client in the <code>ExtensionFieldSets</code> JSON object. Protocol Controllers MUST accept any CLuster/attribute combination in the <code>ExtensionFieldSets</code> JSON object as long as they are marked as <code>sceneRequired="true"</code>.</p>
<h2><a class="anchor" id="autotoc_md60"></a>
On/Off Cluster (0x0006)</h2>
<p>Mandatory Attributes:</p>
<ul>
<li>OnOff(0x0000); expected state values Off(0x00) and On(0x01).</li>
</ul>
<p>Mandatory Commands:</p>
<ul>
<li>Off (0x00): when a device receive this command, the device should enter to "Off" state.</li>
<li>On (0x01): when a device receive this command, the device should enter to "On" state.</li>
<li>Toggle (0x02): when a device receive this command, the device should enter to "On" state if it was on " Off" state and vice versa.</li>
</ul>
<h2><a class="anchor" id="autotoc_md61"></a>
Level Cluster(0x0008)</h2>
<p>The level cluster controls the light brightness level, the door closure level, or the heater power output.</p>
<p>Mandatory attributes:</p>
<ul>
<li>CurrentLevel 0x0000 (accepted value range: MinLevel ... MaxLevel) represents the current level of the device (the meaning of 'level' is device dependent). Current Level is read only and cannot be updated using the WriteAttributes command.</li>
</ul>
<p>Some Optional attributes that define the minimum and maximum level supported by the device:</p>
<ul>
<li>MinLevel (0x0002): the minimum level the device supports.</li>
<li>MaxLevel (0x0003): the maximum level the device supports.</li>
<li>onLevel (0x0010): determines the value that the CurrentLevel attribute is set to when the OnOff attribute is set to "On", as a result of processing an On/Off cluster command. If the OnLevel attribute is not implemented or is set to 0xff, the CurrentLevel value is not modified when the OnOff attribute of the OnOff Cluster is modified.</li>
</ul>
<p>Mandatory Commands:</p>
<ul>
<li>MoveToLevel (0x00): should contain a Level and TransitionTime [in tenths of seconds] in the command JSON payload.</li>
<li>Move (0x01): should contain a MoveMode (Up or Down) and the Rate (define the rate of the movement in units per second) in the command JSON payload.</li>
<li>Step (0x02): should contain StepMode (Up or Down), StepSize, and TransitionTime in the command JSON payload.</li>
<li>Stop (0x03): command that stops the level changes that was triggered by the MoveToLevel, Move and Step commands.</li>
</ul>
<p>Commands that will affect the On/Off Attribute of the device if On/Off Cluster also supported:</p>
<ul>
<li>MoveToLevelWithOnOff (0x04)</li>
<li>MovewithOnOff (0x05)</li>
<li>StepWithOnOff (0x06)</li>
</ul>
<p>Note that the the behavior of these commands is similar to the above mandatory commands. The main difference is the MoveToLevelWithOnOff, MovewithOnOff, and StepWithOnOff commands impact the On/Off Attribute of the device if On/Off Cluster is also supported. If the targeted level value is higher than the minimum level, the On/Off attribute should be set to "On" (light bulb). If the target level is set to the minimum level allowed by the device, the OnOff attribute should be set to "Off" (grey lightbulb).</p>
<h2><a class="anchor" id="autotoc_md62"></a>
Door Lock Cluster (0x0101)</h2>
<p>This cluster is used as a generic interface to secure a door. The ZCL Door Lock cluster contains a lot of optional attributes, such as logging events, alarms, security setting, and so on and commands, such as setting user PIN, getting log events, setting schedules, and so on. However, this section lists only the mandatory attributes and commands used for basic door operations.</p>
<p>Mandatory Attributes:</p>
<ul>
<li>LockState (0x0000): NotFullyLocked (0x00), Locked (0x01), Unlocked (0x02) and Undefined (0xFF) are the possible attribute values that describe the state of the door.</li>
<li>LockType(0x0001): defines the door lock types such as Deadbolt (0x00), Magnetic (0x01), Other (0x02), Latch Bolt (0x05) and etc.</li>
<li>ActuatorEnabled (0x002): defines if the actuator is Enables (true) or Disable (false).</li>
</ul>
<p>Mandatory Request Commands (client to a device):</p>
<ul>
<li>LockDoor (0x00): a command used to lock a door with PINOrRFIDCode code.</li>
<li>UnlockDoor( 0x01): a command used to unlock the door with PINOrRFIDCode Code.</li>
</ul>
<p>Note if the PIN or RFID is not defined on the device, the PINOrRFIDCode field value can be empty string (i.e., " ").</p>
<h2><a class="anchor" id="autotoc_md63"></a>
Thermostat Cluster (0x0201)</h2>
<p>This cluster defines the interface to thermostats. The ZCL Thermostat cluster contains a lot of optional attributes, such as Outdoor Temperature, Occupancy, PID configuration, and so on, and a few optional commands used primarily for scheduling. However, this section only covers the (only) mandatory attribute, LocalTemperature, as well as the (only) mandatory command, Setpoint Raise/Lower.</p>
<blockquote class="doxtable">
<p>Note that for the ZCL Thermostat Cluster, all temperatures are in <b>Celcius (C)</b> and any necessary conversion to/from, for example, Fahrenheit F must be done by the Unify components (Protocol Controllers and GUI). </p>
</blockquote>
<h3><a class="anchor" id="autotoc_md64"></a>
Fingerprinting of Z-Wave Nodes</h3>
<p>For example, to map a Z-Wave node's functionalities to the Thermostat Cluster, a protocol Controller may expect the following conditions to be met before it exposes a Node as a Thermostat Cluster server:</p>
<ul>
<li>Node supports the Multilevel Sensor Command Class, version 1 or newer<ul>
<li>Node supports the Multilevel sensor type 0x01 (Air Temperature)</li>
</ul>
</li>
<li>Node supports the Thermostat Setpoint Command Class, version 1 or newer</li>
<li>Node supports the Thermostat Mode Command Class, version 1 or newer<ul>
<li>Node supports at least one of the following modes: 0x01 (HEAT), 0x02 (COOL), 0x03 (AUTO).</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md65"></a>
Mandatory Attributes</h3>
<p>The following attributes are mandatory for the ZigBee thermostat cluster.</p>
<ul>
<li>LocalTemperature (0x0000): The temperature in <b>Celsius (C)</b> multiplied by 100 measured by the Thermostat. This gives a resolution of 0.01C. This is mapped from the Multilevel Sensor Report for the "Air temperature" sensor type.</li>
<li>OccupiedCoolingSetpoint (0x0011) indicates the configured temperature setpoint for the thermostat when it operates in Cooling mode. This value is writable directly, which is supported only if the node supports 0x02 (COOL) or 0x03 (AUTO) modes.</li>
<li>OccupiedHeatingSetpoint (0x0012) indicates the configured temperature setpoint for the thermostat when it operates in Heating mode. This value is writable directly, which is supported only if the node supports 0x01 (HEAT) or 0x03 (AUTO) modes.</li>
<li>SystemMode (0x001C) indicates the current operating mode in the system. Note that all modes are not supported. Only 0 (Off) is supported by default. Other modes are supported only if the respective Z-Wave mode is supported (Auto, Cool and Heat).</li>
<li>ControlSequenceOfOperation (0x001B): This indicates the supported SystemModes and restricts which ones can be used. This attribute should be writable, but not all values are mandatory to support. To start with, this attirbute will be mapped based on the supported modes in the Z-Wave Thermostat Mode. Only values 0x00, 0x02 or 0x04 will be used and the "With reheat" option will not be used. Since only 1 value is supported, it will appear as if this attribute is read-only.</li>
</ul>
<p>Read only attributes:</p>
<ul>
<li>ThermostatProgrammingOperationMode (0x0025): This attribute is read only, showing the thermostats' capabilities. Z-Wave Thermostats will have SimpleOrSetpoint support to start with. When the Schedule Command Class is supported, the Schedule bit will be updated to 1.</li>
</ul>
<p>Typically, the state topic for the Thermostat cluster will look like this:</p>
<div class="fragment"><div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Thermostat/Attributes/ClusterRevision/Desired {&quot;value&quot;: 2}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Thermostat/Attributes/ClusterRevision/Reported {&quot;value&quot;: 2}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Thermostat/Attributes/LocalTemperature/Desired {&quot;value&quot;: 2300}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Thermostat/Attributes/LocalTemperature/Reported {&quot;value&quot;: 2300}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Thermostat/Attributes/OccupiedCoolingSetpoint/Desired {&quot;value&quot;: 2600}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Thermostat/Attributes/OccupiedCoolingSetpoint/Reported {&quot;value&quot;: 2600}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Thermostat/Attributes/OccupiedHeatingSetpoint/Desired {&quot;value&quot;: 2100}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Thermostat/Attributes/OccupiedHeatingSetpoint/Reported {&quot;value&quot;: 2100}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Thermostat/Attributes/SystemMode/Desired {&quot;value&quot;: &quot;Auto&quot;}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Thermostat/Attributes/SystemMode/Reported {&quot;value&quot;: &quot;Auto&quot;}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Thermostat/Attributes/ThermostatProgrammingOperationMode/Desired {&quot;value&quot;: 0}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Thermostat/Attributes/ThermostatProgrammingOperationMode/Reported {&quot;value&quot;: 0}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Thermostat/Attributes/ControlSequenceOfOperation/Desired {&quot;value&quot;: 4}</div>
<div class="line">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Thermostat/Attributes/ControlSequenceOfOperation/Reported {&quot;value&quot;: 4}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md66"></a>
Mandatory Commands</h3>
<p>Only one command is mandatory command (alongside WriteAttributes), which allows changing the operating mode and applying an offset to the currently-configured setpoints.</p>
<ul>
<li>SetpointRaiseOrLower Command (0x00).</li>
</ul>
<p>This command is used to change the Mode and adjust the setpoint(s). For example, to change to heat mode and increase by 1 degree:</p>
<p><b>Topic:</b> <code>ucl/by-unid/&lt;UNID&gt;/ep&lt;id&gt;/Thermostat/Commands/SetpointRaiseOrLower</code></p>
<p><b>Payload:</b></p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;Mode&quot;: &quot;Heat&quot;,</div>
<div class="line">  &quot;Amount&quot;: 100</div>
<div class="line">}</div>
</div><!-- fragment --><p>The mode field can take the following values: "Heat", "Cool" or "Auto".</p>
<p>The Amount field in the SetpointRaiseOrLower will trigger a change in the setpoint. This value is signed. OccupiedCoolingSetpoint and OccupiedHeatingSetpoint are the two possible setpoints.</p>
<p>If the Mode field is set to Heat or Auto, the OccupiedHeatingSetpoint (if supported) will be adjusted by the amount indicated in the Amount field.</p>
<p>If the Mode field is set to Cool or Auto, the OccupiedCoolingSetpoint (if supported) will be adjusted by the amount indicated in the Amount field.</p>
<ul>
<li>WriteAttributes Command.</li>
</ul>
<p>This command can be used to directly modify the writable attributes.</p>
<p><b>Topic:</b> <code>ucl/by-unid/&lt;UNID&gt;/ep&lt;id&gt;/Thermostat/Commands/WriteAttributes</code></p>
<p><b>Payload:</b></p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;SystemMode&quot;: &quot;Auto&quot;,</div>
<div class="line">  &quot;OccupiedCoolingSetpoint&quot;: 3200,</div>
<div class="line">  &quot;OccupiedHeatingSetpoint&quot;: 2200</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that it is not possible to detect which SystemModes are supported or if the setpoints will be accepted. For example, in most cases the <code>ControlSequenceOfOperation</code> will have only 1 valid value. In this case, the cluster state topic will reflect back that no change was applied.</p>
<h2><a class="anchor" id="autotoc_md67"></a>
Occupancy Sensing Cluster (0x0406)</h2>
<p>The cluster defines an interface to occupancy sensing functionality including configuration and getting the occupancy status. Here, only the mandatory attributes that can enable the basic functionality of occupancy sensing are described.</p>
<p>Mandatory Attributes:</p>
<ul>
<li>Occupancy (0x0000): is a bitmap and Bit 0 defines the sensed occupancy (Occupied = 1 and Unoccupied = 0)</li>
<li>OccupancySensorType (0x0001): defines the occupancy sensor, and the values can be PIR (0x00), Ultrasonic(0x01), PIR and ultrasonic(0x02) and Physical contact(0x03).</li>
</ul>
<p>There are no supported command for Occupancy Sensing cluster. The <em>WriteAttributes</em> command will have no effect.</p>
<h1><a class="anchor" id="autotoc_md68"></a>
Examples of Application Level Control Using Unify Framework</h1>
<h2><a class="anchor" id="autotoc_md69"></a>
Turning On the On/Off Light Device using Unify Framework</h2>
<p>The following diagram shows an example of On/Off Cluster control using the Unify framework.</p>
<div class="plantumlgraph">
<img src="inline_umlgraph_1.png" />
</div>
<h2><a class="anchor" id="autotoc_md70"></a>
Changing the Brightness Level of the Light Using Unify Framework</h2>
<p>The following diagram shows an example of a device with both On/Off and Level Clusters server.</p>
<div class="plantumlgraph">
<img src="inline_umlgraph_2.png" />
</div>
<h2><a class="anchor" id="autotoc_md71"></a>
DoorLock Operation Using Unify Framework</h2>
<p>The following diagram shows an example of a Door Lock controlled using the Unify Framework.</p>
<div class="plantumlgraph">
<img src="inline_umlgraph_3.png" />
</div>
<h2><a class="anchor" id="autotoc_md72"></a>
DoorLockController Operation Using Unify Framework</h2>
<p>The following diagram shows an example of a Door Lock Controller being used in the Unify Framework.</p>
<div class="plantumlgraph">
<img src="inline_umlgraph_4.png" />
</div>
<h2><a class="anchor" id="autotoc_md73"></a>
PIR Sensor Notification Application Using Unify Framework</h2>
<p>The following diagram shows an example of PIR Sensor device represented as an OccupancySensing Cluster server with the Unify framework.</p>
<div class="plantumlgraph">
<img src="inline_umlgraph_5.png" />
</div>
<h2><a class="anchor" id="autotoc_md74"></a>
Using the WriteAttributes Generic Topics</h2>
<p>Scenario: A device supports the <code>ManufacturerName</code> and <code>LocationDescription</code> attributes in the Basic Cluster. An MQTT Client wants to update the location of the device using the <em>WriteAttributes</em> Command.</p>
<p>Note that the <code>ManufacturerName</code> is a read only attribute and the <code>LocationDescription</code> is a writable attribute.</p>
<div class="plantumlgraph">
<img src="inline_umlgraph_6.png" />
</div>
<h2><a class="anchor" id="autotoc_md75"></a>
On/Off and Scene-Capable PAN Node</h2>
<p>The following diagram shows an example of On/Off and Scene Cluster control using the Unify framework.</p>
<div class="plantumlgraph">
<img src="inline_umlgraph_7.png" />
</div>
<h2><a class="anchor" id="autotoc_md76"></a>
Scene PAN Node without Actuator Capabilities</h2>
<p>The following diagram shows an example of a node using scenes without supporting any of the actuator functionalities.</p>
<div class="plantumlgraph">
<img src="inline_umlgraph_8.png" />
</div>
<h2><a class="anchor" id="autotoc_md77"></a>
Manipulating PAN Node Group Membership</h2>
<p>The following diagram shows an example of adding/removing groups for a PAN node</p>
<div class="plantumlgraph">
<img src="inline_umlgraph_9.png" />
</div>
 </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
