<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Unify Specification: Unify Architecture Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Unify Specification
   &#160;<span id="projectnumber">ver1_0_RC11_20211006-12-g5cdaf55</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Unify Architecture Overview </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md1"></a>
Terminology And Abbreviations</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Term </th><th class="markdownTableHeadNone">Abbreviation </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Unify SDK </td><td class="markdownTableBodyNone">Unify </td><td class="markdownTableBodyNone">The system whose design is described here. Formerly known as Unified IoT Controller (UIC).  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Software Development Kit </td><td class="markdownTableBodyNone">SDK </td><td class="markdownTableBodyNone">A software package used as a building block for other software. Unify is itself an SDK.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Unified Node ID </td><td class="markdownTableBodyNone">UNID </td><td class="markdownTableBodyNone">A unified addressing system with a separate sub-namespace for each PHY supported by the Unify SDK. It is arbitrarily chosen to resemble an IPv6 address in the current design.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Unify Controller Language </td><td class="markdownTableBodyNone">UCL </td><td class="markdownTableBodyNone">The unified command language used as an internal abstraction layer in the Unify SDK.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Cluster </td><td class="markdownTableBodyNone">CL </td><td class="markdownTableBodyNone">A grouping of related commands/attributes supported by an end-node. Examples include Door Lock, Multilevel Switch, Movement Sensor, and so on. For example, Bluetooth Profiles and Z-Wave Command Classes can be translated into CCs. CCs are encoded as MQTT topic strings, e.g., "door_lock", "movement_sensor", and so on.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Command </td><td class="markdownTableBodyNone">CMD </td><td class="markdownTableBodyNone">An attribute or command that can either be sent to the endnode or received from it. Grouped into Clusters. Zigbee Commands and Attributes, Z-Wave Commands, and Bluetooth Profiles can all be translated or broken down into CMDs. CMDs are encoded as MQTT topic strings, e.g., "doorlock_operation_set" and "doorlock_operation_get" and "doorlock_operation_report".  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Endpoint </td><td class="markdownTableBodyNone">EndPointID </td><td class="markdownTableBodyNone">Endpoints are sub-addresses in unsigned integers of a UNID. Devices without PAN-side support for endpoints use ep0.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">MQTT Broker </td><td class="markdownTableBodyNone">- </td><td class="markdownTableBodyNone">The "server" side of MQTT, which distributes published messages to a topic to all subscribers in the topic.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Personal Area Network </td><td class="markdownTableBodyNone">PAN </td><td class="markdownTableBodyNone">The network of end nodes behind a PHY Radio controlled by Unify.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">IoT Service </td><td class="markdownTableBodyNone">- </td><td class="markdownTableBodyNone">An MQTT client that translates the UCL language into the API of a cloud service or locally running high-level service (e.g., Web UI). This is a translator to a cloud service, not the actual cloud service. An AWS-IoT IoT Service runs on Unify hardware and connects to AWS IoT cloud, for example.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Protocol Controller </td><td class="markdownTableBodyNone">- </td><td class="markdownTableBodyNone">An MQTT client that controls a PHY Radio and translates commands between the UCL and the native language of that PHY. Also known as a PHY Translator.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Gateway </td><td class="markdownTableBodyNone">GW </td><td class="markdownTableBodyNone">An IP host connecting two different domains. A Unify Gateway consists of the Unify components and SDK installed on an IP host providing OS functionality and hardware support.  </td></tr>
</table>
<p><em>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="https://tools.ietf.org/html/rfc2119">RFC2119</a>.</em></p>
<h1><a class="anchor" id="autotoc_md2"></a>
Introduction</h1>
<p>The Unify SDK delivers a unified high-level API, such as cloud control, local HomeAssistant middle-wares, and so on to control, observe and manage end nodes in all PHYs supported by Silicon Labs. It also facilitates code reuse and allows easily adding new high-level APIs without the need to modify the PHY drivers. After a new high-level API module has been created, it should be possible to control all the supported PHYs without any changes to the PHY drivers. Likewise, after a new PHY driver has been created, it should immediately be possible to control that PHY from all the existing high-level APIs without modifying the high-level API module.</p>
<p>In other words, the Unify SDK decouples API modules from the PHY drivers.</p>
<p>The Unify SDK is a software component that runs inside a gateway product. It needs a hardware platform and an operating system to be a complete product.</p>
<div class="image">
<img src="sl_gw_asset.png" alt="" width="800px"/>
</div>
 <p>From a business perspective, Unify makes it possible to maintain a single IoT Service that can interface with multiple wireless PHY radios. The functionality includes SmartStart, best-in-class security, firmware updates, and so on. Unify makes it easier to develop gateway products by driving down the marginal effort needed in launching the next customer gateway and enables rapid development cycles.</p>
<p>The remainder of this document refers to PHY drivers as Protocol Controllers because they not only drive the modem but also translate the Application Layer commands from one PHY technology to another. Similarly, the high-level API modules are called IoT Services, which are named after the expected use case, but they can also connect to locally running services.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
System Components</h1>
<p>The Unify SDK is a software component of a full plastic-enclosed GW box. You can think of it as a "device driver" for the IoT, seen from the Host MCU in the GW box. The Unify component uses MQTT as an internal message-bus for inter-process communication among MQTT clients that are each an independent process/thread. In a Linux or other full OS implementation, real processes should be used. The primary hardware platform of the Unify design is a Cortex A-class device or an equivalent.</p>
<p>The MQTT clients are one of these types:</p>
<ul>
<li>IoT Services (or IoT services): These modules expose the externally-visible APIs in Unify. IoT Services translate back and forth between external APIs and the intermediate UCL. The external API is typically consumed by a cloud-service or a local middleware/app. It is slightly confusing that an IoT Service can also provide APIs to a locally-running service. It is named after the expected use case, which is a cloud-based remote control. Examples of IoT Services include:<ul>
<li>AWS IoT</li>
<li>HomeAssistant</li>
<li>Azure IoT</li>
<li>Rules Engines (even if running locally)</li>
<li>Web UI for local control</li>
</ul>
</li>
<li>Protocol Controllers: These MQTT clients own a physical radio operated through Unify. They also translate from UCL to the native language of the radio. Examples include the following:<ul>
<li>Zigbee Protocol Controller owning an NCP</li>
<li>Z-Wave Protocol Controller owning a SerialAPI</li>
<li>BLE Protocol Controller</li>
<li>BLE-Mesh Protocol Controller</li>
<li>Silicon Labs Connect Stack Protocol Controller</li>
</ul>
</li>
<li>A singleton Resource Directory MQTT client, responsible for aggregating node information and providing the ucl/&lt;#&gt;/discover topic for discovering nodes, where &lt;#&gt; can be one of (by-unid, by-location, by-roletype, by-devicetype, by-group).</li>
</ul>
<h1><a class="anchor" id="autotoc_md4"></a>
System Diagram</h1>
<p>This diagram shows the overall architecture and some of the technologies that Unify connects.</p>
<div class="image">
<img src="slide8_block_diagram.png" alt="" width="800px"/>
</div>
 <p>Because a central MQTT broker and standardized MQTT topics and JSON payload (the UCL) are used, the architecture is more like a star topology, as shown below:</p>
<div class="image">
<img src="uic-system-diagram.png" alt="" width="800px"/>
</div>
 <p>The figure above shows the overall Unify architecture with MQTT as an integral part. IoT Services (blue boxes) for AWS IoT, Azure, HomeAssistant and so on are shown. Protocol Controllers (green boxes) for all Silicon Labs PHYs are possible, with a random selection of Z-Wave, Zigbee, and Bluetooth shown. All IoT Services and Protocol Controllers are connected by a common Unify abstraction layer consisting of an MQTT broker transporting the Unify Controller Language. Clients can roughly be grouped into IoT Services, local middlewares, Protocol Controllers, and a Singleton Resource Directory.</p>
<p>The Resource Directory is also an MQTT client.</p>
<p>The MQTT server should run as a separate Linux process.</p>
<p>The Resource Directory facilitates device discovery and communicates with each Protocol Controller through specific MQTT topics. The Protocol Controller MUST automatically notify the Resource Directory of nodes that join or leave the network, as well as multicast groups that are added/removed/modified.</p>
<p>The ACL Engine validates all publish and subscribe requests before being processed by the Broker. The permissions of each MQTT Client is established by looking up a permission token in an Access Control List (ACL). The key to the ACL is a security token contained in the TLS certificate presented by the MQTT client. Local clients SHOULD only be allowed to connect TLS, but they may use raw TCP if absolutely necessary (note that this will prevent the ACL Engine from identifying the client). Remote clients MUST only connect with TLS. If non-TLS connections are accepted against this RECOMMENDATION, another simple (and non-secure) permission token exchange must be added.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Design Variants</h2>
<p>Unify gateways comes in a few variants that differ in the number of PHYs controlled:</p>
<ul>
<li>A multi-homed Unify gateway has several Protocol Controllers installed. This is a more complicated product to develop and market.</li>
<li>A single-homed Unify gateway has a single Protocol Controller and relies on MQTT bridging and/or Cloud Services to connect to other PHYs. To unify two PHYs, you need two physical Unify-based gateways, which must be connected to the same IP network or cloud service. The two single-Protocol Controller Unify GWs communicate via MQTT bridging and UCL or via a Cloud Service they are both connected to. The single-homed Unify GW is a simpler product to develop, allows the developer to focus solely on the PHY they are most comfortable with, and still end up with a complete, functional, gateway product. The process of interconnecting multiple independent single-Protocol Controller Unify GWs can be thought of as the "LEGO-block design principle for Unify".</li>
</ul>
<p>Another variant of the design uses MQTT bridging to allow multiple Unify gateways to cooperatively control and manage the same PAN. The bridging may happen either locally or in the cloud.</p>
<div class="image">
<img src="slide20_lego_block_ug_design.png" alt="" width="800px"/>
</div>
 <p>This figure shows an example of 3 single-Protocol Controller Unify-based gateways, that when connected to the same IP backbone can unify Zigbee, Z-Wave and the AWS IoT cloud service. Each gateway is represented by a green, blue or yellow rectangle, showing which connectors it has attached.</p>
<h1><a class="anchor" id="autotoc_md6"></a>
Packet Format</h1>
<p>When Unify MQTT clients attach to the locally-running MQTT broker, they publish and receive messages in the following format (i.e., a tcpdump attached to the sockets going to and from the MQTT Broker, would see the packets in the following two figures).</p>
<div class="image">
<img src="UniversalGWPacketFormatv2.0.png" alt="" width="800px"/>
<div class="caption">
PUBlish messages style</div></div>
 <div class="image">
<img src="UniversalGWPacketFormatSUBSCRIBE.png" alt="" width="800px"/>
<div class="caption">
SUBscribe messages style</div></div>
 <p>If the MQTT broker is running remotely, the MQTT MUST be using strong transport encryption to provide adequate security (e.g., MQTT over TLS or WebSocket).</p>
<h1><a class="anchor" id="autotoc_md7"></a>
Unify Controller Language Definition</h1>
<p>The Unify Controller Language (UCL) is developed to allow the easiest possible translation to and from as many PHYs and cloud services as possible. The UCL serves as an abstraction layer between the PHY-specific data models and the models used in various cloud services for controlling IoT devices. The UCL data model MUST be the Zigbee Cluster Library/dotdot (dotdot is ZCL transported over CoAP, whereas UCL will be transported over MQTT). ZCL has been chosen to align Unify with the high-profile <a href="https://https://buildwithmatter.com/">Matter project</a>.</p>
<p>In addition to the existing Zigbee Clusters, UCL is extended with the necessary commands to support all features of the supported PHYs.</p>
<h1><a class="anchor" id="autotoc_md8"></a>
UNID: Unified Node IDs</h1>
<p>The UNIDs are unique text strings in the MQTT topic hierarchy, which MUST follow the MQTT naming limitations.</p>
<p>The Protocol Controllers generate UNID for all nodes in the PAN (or PANs) it controls. The UNID MUST consist of a prefix part and a PAN part, separated by a minus string character "-".</p>
<p>The PAN part MUST be generated by the Protocol Controller and MUST be unique among PAN parts generated by that PC. The Protocol Controller MUST prefix all UNIDs with the same prefix. This prefix must be configurable at startup. The system integrator MUST ensure that no two Protocol Controllers have the same prefix configured. The prefix ensures that separate Protocol Controllers never generate the same UNID and hence keeps them unique.</p>
<p>The following table shows examples of generated UNIDs:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Protocol Controller PHY </th><th class="markdownTableHeadNone">Prefix </th><th class="markdownTableHeadNone">Example UNID  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Z-Wave </td><td class="markdownTableBodyNone">"zw" </td><td class="markdownTableBodyNone">"zw-DEADBEEF-0001" for NodeID 01 in HomeID 0xDEADBEEF. NodeID is mutable on network reset.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Zigbee </td><td class="markdownTableBodyNone">"zb" </td><td class="markdownTableBodyNone">"zb-DEADBEEFC0FFEE12" for node with EUI-64 DEADBEEFC0FFEE12.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">BLE </td><td class="markdownTableBodyNone">"ble-sr" </td><td class="markdownTableBodyNone">Static random addresses. "ble-sr-112233445566" for a BLE device with random identifier 11:22:33:44:55:66.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">BLE </td><td class="markdownTableBodyNone">"ble-pd" </td><td class="markdownTableBodyNone">Public device addresses. "ble-sr-112233445566" for a BLE device with public address 11:22:33:44:55:66.  </td></tr>
</table>
<p>For example, Z-Wave UNIDs could be prefixed "zw", zigbee with "zb", and so on. The prefix should be short (max 8-10 characters) to keep MQTT topics short.</p>
<p>The UNID PAN parts can be derived from a unique identifier, such as the EUI-64 of a Bluetooth LE or Zigbee device. For devices without a permanent unique identifier, something like the currently assigned address on the PAN can be used, for example a combination of HomeID and NodeID in Z-Wave.</p>
<p>Mutable UNID PAN parts may be used instead of permanent identifiers if they allow simpler diagnostics and troubleshooting of the system. This may be the case when choosing Z-Wave HomeID/NodeIDs instead of S2 DSKs. The disadvantage is that nodes will change their UNID when the network is reset or leaving and re-joining.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
MQTT Topic Hierarchical Namespace</h1>
<p>MQTT topics are hierarchical namespaces that any MQTT client can publish and subscribe to. Subscriptions can use wildcards where # match multiple hierarchy levels and + matches one. As a result, subscribing to ucl/by-unid/# gets all ACs for all PAN nodes. On the other hand, subscribing to ucl/by-unid/+/door_lock receives only data related to Door Lock functionality on any and all Door Locks in the network.</p>
<p>The topic tree looks like the following:</p>
<div class="fragment"><div class="line">ucl/</div>
<div class="line">  by-unid/</div>
<div class="line">    &lt;UNID&gt;                            UNID can be e.g. &quot;xy-123456-05&quot; or  &quot;bld42-&lt;EUI-64&gt;&quot;.</div>
<div class="line">      ep&lt;EndPointID&gt;                  The endpoint to control/monitor. ep0 is used for devices</div>
<div class="line">                                      without PAN-side endpoints.</div>
<div class="line">        &lt;ClusterName&gt;                 Everything relating to a specific Cluster, e.g. &quot;ColorControl&quot;.</div>
<div class="line">          Attributes                  Attribute namespace, where all attributes will be advertised.</div>
<div class="line">            &lt;AttributeName&gt;           Attribute name, e.g &quot;ColorCapabilities&quot;.</div>
<div class="line">              Reported                Reported state for a given attribute.</div>
<div class="line">              Desired                 Desired state for a given attribute.</div>
<div class="line">            &lt;AdditionalAttributes&gt;    Non Standard ZCL attribute are advertised here.</div>
<div class="line">                                      ZCL Tables may use more than 1 level. E.g. &quot;SceneTable&quot;.</div>
<div class="line">              ../Reported             Reported state for a given attribute. &quot;..&quot; represents several levels. E.g. &quot;SceneTable/1&quot;</div>
<div class="line">              ../Desired              Desired state for a given attribute.</div>
<div class="line">          SupportedCommands           Array of supported commands accepted by the cluster.</div>
<div class="line">          SupportedGeneratedCommands  Array of generated commands sent from the cluster.</div>
<div class="line">          Commands                    Namespace for triggering commands used to control a device.</div>
<div class="line">            &lt;CommandName&gt;             Particular command under a cluster. Example: &quot;MoveToLevel&quot;.</div>
<div class="line">          GeneratedCommands           Namespace for receiving generated commands from a client-type device.</div>
<div class="line">            &lt;CommandName&gt;             Particular command under a cluster. Example: &quot;MoveToLevel&quot;.</div>
<div class="line">      ProtocolController</div>
<div class="line">        NetworkManagement             Network Management related topics, see &quot;Network Management Commands&quot; page.</div>
<div class="line">          Write                       Publish here to initiate Network Management operations</div>
<div class="line">        RFTelemetry                   Telemetry about RF transmissions</div>
<div class="line">                                      are published under this topic. The sub</div>
<div class="line">                                      topics under this &quot;cluster&quot; are identical</div>
<div class="line">                                      to regular application clusters (Attributes/,</div>
<div class="line">                                      SupportedCommands, Commands/, etc.)</div>
<div class="line">      State                           Network state, security and command delay of the node (for all endpoints).</div>
<div class="line">        SupportedCommands             List of (Network management) supported</div>
<div class="line">                                      commands attached to a node state, that</div>
<div class="line">                                      will affect this node only.</div>
<div class="line">        Command                       Namespace for triggering commands used to</div>
<div class="line">                                      manage a device.</div>
<div class="line">          &lt;CommandName&gt;               Particular command for node management. Example: &quot;Interview&quot;, &quot;Remove&quot;.</div>
<div class="line">                                      node state, that will affect this node only.</div>
<div class="line">      NameAndLocation                 Topic for setting node name and location. Discover via ucl/by-location/ .</div>
<div class="line"> </div>
<div class="line">by-location                           Subscribe to ucl/by-location/+ to receive all locations.</div>
<div class="line">  &lt;LOCATION&gt;                          Payload is the pretty-printed name of location. E.g.</div>
<div class="line">                                      {&quot;location-name-utf8&quot; : &quot;walk-in closet&quot;} for topic ucl/by-location/</div>
<div class="line">                                      walk-in_closet .</div>
<div class="line">    &lt;UNID&gt;                            Each node in &lt;LOCATION&gt; publishes a retained message here using its</div>
<div class="line">                                      UNID as topic here.</div>
<div class="line">                                      Subscribe to ucl/by-location/&lt;LOCATION&gt;/+ to receive a message from</div>
<div class="line">                                      each UNID in &lt;LOCATION&gt;.</div>
<div class="line"> </div>
<div class="line">by-type/</div>
<div class="line">  by-devicetype/</div>
<div class="line">    &lt;DEVICETYPE&gt;                      e.g. &quot;door_lock&quot;, &quot;light&quot; or &quot;sensor&quot;.</div>
<div class="line">      &lt;UNID&gt;                          Each node of &lt;DEVICETYPE&gt; publishes a retained message here using</div>
<div class="line">                                      its own UNID as sub-topic.</div>
<div class="line">                                      Subscribe to ucl/by-devicetype/&lt;DEVICETYPE&gt;/+ to receive a message from</div>
<div class="line">                                      each UNID in of that type.</div>
<div class="line"> </div>
<div class="line">by-homeassistant-type/</div>
<div class="line">  &lt;HOMEASSISTANT_TYPE&gt;                e.g. &quot;binary_sensor&quot; or &quot;camera&quot;</div>
<div class="line">    &lt;UNID&gt;                            Subscribe to ucl/by-type/by-homeassistant-type/+ to receive a message</div>
<div class="line">                                      for each HomeAssistant type in the network</div>
<div class="line">                                      Subscribe to ucl/by-type/by-homeassistant-type/&lt;HOMEASSISTANT_TYPE&gt;/+ to</div>
<div class="line">                                      receive messages from each UNID of that type</div>
<div class="line">by-group/                             For multicast groups</div>
<div class="line">  &lt;GroupID&gt;                           A unique, numeric group ID</div>
<div class="line">                                      e.g. 1, 2, ... 65535.</div>
<div class="line">    GroupName                         Name assigned to the group.</div>
<div class="line">    NodeList</div>
<div class="line">      &lt;UNID&gt;                          Used to advertise the membership of a UNID</div>
<div class="line">                                      and a list of its endpoints for a group</div>
<div class="line">    &lt;ClusterName&gt;</div>
<div class="line">      Commands/</div>
<div class="line">        &lt;CommandName&gt;                 Publish here to multicast &lt;CommandName&gt; to</div>
<div class="line">                                      all UNIDs/endpoints that are part of the</div>
<div class="line">                                      group.</div>
<div class="line">        WriteAttributes               Publish here to multicast attribute write</div>
<div class="line">                                      to all UNIDs/endpoints that are part of</div>
<div class="line">                                      the group.</div>
<div class="line">      SupportedCommands               List of commands supported by all UNIDs/</div>
<div class="line">                                      endpoints that are part of the group.</div>
<div class="line"> </div>
<div class="line">  SmartStart                          Topics for managing SmartStart node provisioning</div>
<div class="line">    List                              The full list of SmartStart entries is published here</div>
<div class="line">    Update                            Publish here to add/update an entry to the list</div>
<div class="line">    Remove                            Publish here to remove an entry from the list</div>
<div class="line">  _well_known                         Versioning and list of supported ucl/ sub-topics</div>
</div><!-- fragment --><p>The &lt;DEVICETYPE&gt; MUST adequately describe the Device Types (i.e., the practical functions) of all the device types found in all PANs supported by Silicon Labs. The <a href="https://zigbeealliance.org/solution/dotdot/">dotdot Device Library specification</a> has a good list of device types.</p>
<p>The &lt;HOMEASSISTANT_TYPE&gt; MUST be a strict superset of the <a href="https://www.home-assistant.io/docs/mqtt/discovery/">MQTT discovery types defined in the HomeAssistant open-source project</a>.</p>
<p>The subscribers to the ucl/_well_known topic/+ MUST receive a <a href="https://www.w3schools.com/js/js_json_datatypes.asp">JSON-encoded</a> payload in a <a href="https://www.hivemq.com/blog/mqtt-essentials-part-8-retained-messages/">Retained Message</a> with at least the following contents:</p>
<p><b>The JSON-encoded well-known payload:</b></p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;schema_version&quot; : 1,</div>
<div class="line">  &quot;wellknown_topics&quot; :</div>
<div class="line">   [</div>
<div class="line">     {&quot;name&quot; : &quot;ucl/by-unid&quot;, &quot;description&quot; : &quot;All nodes grouped by UNID&quot;},</div>
<div class="line">     {&quot;name&quot; : &quot;ucl/by-location&quot;, &quot;description&quot; : &quot;All nodes grouped by location&quot;},</div>
<div class="line">     {&quot;name&quot; : &quot;ucl/SmartStart&quot;, &quot;description&quot; : &quot;SmartStart management&quot;},</div>
<div class="line">     ...</div>
<div class="line">     {&quot;name&quot; : &quot;ucl/by-group/&quot;, &quot;description&quot; : &quot;Multicast transmission and group management&quot;}</div>
<div class="line">   ]</div>
<div class="line">}</div>
</div><!-- fragment --><p>Each protocol controller MUST publish the well known topics they provide under ucl/_well_known/&lt;UNID&gt;</p>
<h1><a class="anchor" id="autotoc_md10"></a>
Payload Encoding</h1>
<p>Everything after the Cluster, Command, Attribute and Table field in a given dotdot ZCL command must be encoded in the payload of the MQTT message. The UCL header must also be JSON-encoded in the format given in the example below.</p>
<p>Field names are taken from the Zigbee Cluster Library. Camel-case is used to encode spaces, forward slashes are omitted (On/Off â†’ OnOff).</p>
<h1><a class="anchor" id="autotoc_md11"></a>
Payload Versioning</h1>
<p>Future extensions of the ZCL or Unify framework MAY add new information in the existing fields of a JSON payload.</p>
<p>IoT services and Protocol Controllers MUST be resistant to unknown/new keys or key values when parsing JSON objects.</p>
<p>As an example, the following payload:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;value&quot; : 1</div>
<div class="line">}</div>
</div><!-- fragment --><p>May be extended in a future version to something alike:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;value&quot; : 1,</div>
<div class="line">  &quot;value_options&quot;: [1,2,3]</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md12"></a>
Protocol Controller and IoT Service MQTT Clients</h1>
<p>The MQTT clients connecting to the MQTT broker of a Unify gateway can very broadly be divided into two categories: Protocol Controllers and IoT Services. These were also called PHY Translator/Connectors and Cloud Connectors/Translators previously.</p>
<p>A Protocol Controller is an MQTT client that runs in its own OS process. It can be written in any language and run on any platform that provides an MQTT client.</p>
<p>A Protocol Controller MUST implement these interfaces</p>
<ul>
<li>Unify Interface. The interface between the MQTT Broker and each Protocol Controller. This is an MQTT pub/sub connection, with topics and payloads specified by the UCL.</li>
<li>PAN interface: NCP, SerialAPI or similar PHY-specific interface.</li>
</ul>
<p>An IoT Service MUST implement this interface:</p>
<ul>
<li>Unify Interface. The interface between the MQTT Broker and each Protocol Controller. This is an MQTT pub/sub connection with topics and payloads specified by the UCL.</li>
</ul>
<p>An IoT Service MAY implement this interface:</p>
<ul>
<li>Cloud Interface: Interface from Cloud Service to IoT Service module in the Unify gateway. The first example is an AWS-IoT IoT Service module. Rules Engines can also be seen as special instances of IoT Services. The Cloud Interface is defined by the cloud service and implemented by the IoT Service.</li>
</ul>
<h2><a class="anchor" id="autotoc_md13"></a>
Protocol Controller API</h2>
<p>Each Protocol Controller connects to the MQTT server. The Protocol Controller subscribes for example to an MQTT topic:</p>
<blockquote class="doxtable">
<p><code>ucl/by-unid/#</code> </p>
</blockquote>
<p>When packets are received, the Protocol Controller must drop all messages where the UNID prefix does not match the manually-configured prefix of the Protocol Controller. For example, the Zigbee Protocol Controller may be manually configured to handle all UNIDs starting with, for example, <code>zb-example-pc-*</code> prefix, and the BLE Protocol Controller might be configured for <code>ble001-*</code>. They will each drop everything with UNID not matching that prefix.</p>
<p>A Protocol Controller MUST publish a message to the topic <code>ucl/by-unid/&lt;UNID&gt;/State</code> to notify the IoT Services of the new node.</p>
<p>It MUST also process and translate all commands from a topic <code>ucl/by-unid/&lt;UNID&gt;/+/+</code> to the PAN (i.e., the PHY Radio it owns), if the <code>&lt;UNID&gt;</code> matches the prefix assigned to the Protocol Controller. The Cluster and Command is derived by the Protocol Controller from the wildcard part of the received topic and translated to PAN-specific commands as the Protocol Controller sees fit. The UCL header in the MQTT payload must also be examined as part of the translation to the native language. The translation of one UCL command MAY result in a sequence of PHY native commands. For example, one UCL command may be translated to a sequence of Z-Wave commands and then transmitted through the NCP.</p>
<p>When commands are received from the PAN, a Protocol Controller must translate and publish to the MQTT topic <code>ucl/by-unid/&lt;source_UNID&gt;/ep&lt;ID&gt;/&lt;ClusterName&gt;/Attributes/&lt;AttributeName&gt;/Reported</code> with a UCL header and translated CMD payload in the MQTT payload field. The Protocol Controller must fill out the UCL header fields in addition to concatenating with the translated payload.</p>
<p>When commands are received from the PAN, a Protocol Controller may additionally publish on the MQTT topic: <code>ucl/by-unid/&lt;source_UNID&gt;/ep&lt;ID&gt;/&lt;ClusterName&gt;/GeneratedCommands/&lt;CommandName&gt;</code></p>
<p>See <a class="el" href="md_doc__chapter02-_z_c_l-in-uic.html">the usage of the Dotdot ZCL in Unify Framework for Application Level Control</a> for details.</p>
<p><b>Protocol Controller responsibilities</b></p>
<ol type="1">
<li>Protocol Controller starts up and queries the current state of all PAN Nodes.</li>
<li>Configure all PAN nodes to send updates to the NCP controller by the Protocol Controller.</li>
<li>Whenever node state changes, publish to ucl/by-unid/&lt;UNID&gt;/ep&lt;EndPointID&gt;/&lt;Cluster&gt; for all UNIDs/EndPointIDs in PAN and for all Clusters supported. This allows IoT Services to discover nodes and read out the state by subscribing to ucl/by-unid/+/+/&lt;Cluster&gt;</li>
<li>Subscribe to ucl/by-unid/# and siphon off only the UNIDs assigned to this Protocol Controller.</li>
<li>Translate Clusters, Commands/WriteAttributes and Commands/ForceReadAttributes published to the node from UCL to the native Application Layer language of the PAN. Finally, transmit the translated sequence of frames to the radio.</li>
<li><p class="startli">Handle multicast:</p>
<p class="startli">a. Subscribe to ucl/by-group/+/+/+ . The first wildcard is the group name being multicasted to. The Protocol Controller monitors the group name, and when appropriate multicasts to nodes in the PAN it controls. If the PAN does not support multicast or</p>
<p class="startli">b. Subscribe to ucl/by-unid/+/+/Groups/+/+ . Group management is done via the groups cluster, so the Protocol Controller monitors all group management for nodes it controls. It maintains a list mapping groups to nodes it controls.</p>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md14"></a>
IoT Service API</h2>
<p>When creating IoT Service modules, the main goal is to keep this interface simple and easy to implement correctly, securely, and robustly.</p>
<p>A cloud controller must implement an MQTT Client and TLS transport for the MQTT connection. Unify abstracts away the differences between end-nodes on different PHYs. The IoT Service can use a single unified API for all PHY types. This is a primary goal of Unify.</p>
<p><b>Note</b>: PHY-specific APIs MAY be added on demand, but a single API covering all PHYs is strongly preferred. Of course, exceptions will arise over the coming years as PHY technologies develop at break-neck pace and Unify may as well be pragmatic about it. The UCL API is expected to develop with the PHY technologies.</p>
<p>An IoT Service MUST implement at least the following API sections.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
IoT Service API for Discovering, Controlling, and Requesting Reports</h2>
<p>An IoT Service that wants to control a command in a cluster on a device with a given UNID MUST publish on the topic:</p>
<blockquote class="doxtable">
<p>ucl/by-unid/&lt;UNID&gt;/ep&lt;EndPointID&gt;/&lt;ClusterName&gt;/Commands/&lt;CommandName&gt; </p>
</blockquote>
<p>It should also subscribe to the following topic filter to be notified of any state update.</p>
<blockquote class="doxtable">
<p>ucl/by-unid/&lt;UNID&gt;/ep&lt;EndPointID&gt;/&lt;ClusterName&gt;/Attributes/# </p>
</blockquote>
<p>AWS IoT Service (or any other IoT Service) can do the following:</p>
<ul>
<li>Subscribe to ucl/by-unid/# to get all messages from the Protocol Controllers</li>
<li>Discover devices in one of these ways:<ul>
<li>Discover all devices by subscribing to topic ucl/by-unid/+/+/State The client will receive a retained discovery message about on all available nodes and their endpoints</li>
<li>In a specific location by subscribing to topic ucl/by-location/living_room/+</li>
<li>Discover which device types are available by subscribing to 'ucl/by-type/by-devicetype/#', which will yield a number of retained messages containing the UNID/endpoint of each node.</li>
</ul>
</li>
<li>Discover locations by<ul>
<li>First discovering locations by subscribing to ucl/by-location/#. The client will now receive a retained message from each location with the MQTT-compatible name in the topic and the pretty-printed display name of the location in the JSON payload. This message has been sent by the Resource Directory, based on individual location announcements from nodes.</li>
<li>Discovering nodes in the location by subscribing to a topic filter such as ucl/by-location/&lt;LocationName&gt;/+. The publications will be retained messages advertising each node in that location. The MQTT payload will simply be the UNID repeated from the topic string, e.g., { "unid":"32049350" }. The node can then be probed and actuated in the ucl/by-unid/&lt;UNID&gt; namespace.</li>
</ul>
</li>
</ul>
<p>A subscribed IoT Service receives the following MQTT payload: UCL hdr | CMD payload (see the Packet Format figure).</p>
<p>AWS IoT issue commands by publishing to ucl/by-unid/&lt;UNID&gt;/ep&lt;EndPointID&gt;/&lt;ClusterName&gt;/Commands/&lt;CommandName&gt; for a fire-and-forget transmission. On the PAN side, all reliability and acknowledgment mechanisms will be used, but there will be no acknowledgment on the MQTT client side. An IoT Service should subscribe to ucl/by-unid/&lt;UNID&gt;/ep&lt;EndPointID&gt;/&lt;ClusterName&gt;/Attributes/# to be notified of attribute state changes. The attribute changes reported will report if and when the command has been carried out.</p>
<p>IoT Services must translate the entire UCL message including payload into whatever format the Cloud Provider uses.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Implementation Recommendations for IoT Services</h2>
<p>IoT Service Reference Designs should preferably not be written in C to avoid whole classes of common security and stability bugs, such as buffer overflows and use-after-free pointer errors. Instead, a high level language with focus on security MUST be used. Rust is a very good candidate with broad HW platform support and focus on secure programs.</p>
<h1><a class="anchor" id="autotoc_md17"></a>
The Resource Directory MQTT Client</h1>
<p>A singleton Resource Directory MQTT client, responsible for aggregating node information and providing the ucl/+/discover interface for discovering nodes, where '+' can be one of (by-unid, by-location, by-type, by-clustercommand). The Resource Discovery works in the following way:</p>
<ul>
<li>It is the only MQTT client guaranteed to connect immediately after the Unify broker starts up.</li>
<li>It MUST add the NameLocation cluster to all nodes added to the Unify GW and handle all aspects of updating and discovering the name and location. The Protocol Controllers are not required to do anything regarding Name and Location.<ul>
<li>RD subscribes to ucl/by-unid/&lt;UNID&gt;/ep&lt;EndPointID&gt;/NameAndLocation and stores all writes to the Name and Location attributes. This is done for each UNID and EndPointID in the network.</li>
<li>RD publishes to ucl/by-location/&lt;LOCATION&gt;/&lt;UID&gt; with payload {"unid":"987654321"} so other clients can discover the nodes by their location. All endpoints are assumed to be in the same location.</li>
<li>RD publishes to ucl/by-location/&lt;LOCATION&gt; with a payload of {"location-name-utf8" : "Children's Room"}. This allows location discovery by other clients. &lt;LOCATION&gt; is a valid MQTT topic name derived from the full UTF-8 location name.</li>
</ul>
</li>
<li>It MUST manage the global SmartStart provisioning list, which is common to all Protocol Controllers.</li>
</ul>
<h1><a class="anchor" id="autotoc_md18"></a>
ACL Engine</h1>
<p>The ACL Engine acts as a filter between the MQTT broker and the various MQTT clients. It ensures that IoT Service and Protocol Controllers can only issue the commands they are trusted for. Without the ACL Engine, any PAN Protocol Controller could send any and all commands to all other PAN nodes managed by other Protocol Controllers. It may not be appropriate for the BLE Protocol Controller to issue unlock commands directly to the Z-Wave DoorLocks, for example. Similarly, just because an Azure IoT Service is allowed to receive sensor data from the ZigBee PAN, it should not be allowed to unlock BT Mesh doorlocks. Without an ACL engine, the pub/sub nature of the MQTT broker would allow any MQTT client to publish and subscribe to any topic and hence control and monitor anything connected to Unify.</p>
<p>Technically, the ACL Engine MUST identify each MQTT client by the TLS certificate it presents when connecting to the Broker. The ACL Engine MUST then look up the accessible topics for this client, either in an ACL stored in the ACL engine, or stored securely in the certificate itself (and signed by a trusted root). The exact mechanism to populate the internal ACL is TBD, but must be at least as strong as the TLS certificate validation and anchored in a strong-trust root certificate.</p>
<h1><a class="anchor" id="autotoc_md19"></a>
Security Considerations</h1>
<h2><a class="anchor" id="autotoc_md20"></a>
Mandatory TLS Transport on Remote Access</h2>
<p>TCP (non-TLS) MQTT transport for local connection SHOULD NOT be allowed. Raw TCP transport (non-TLS) MUST be rejected for remote connections including all non-monolithic variants with a remote MQTT broker.</p>
<p>MUST transport MQTT over TLS or WebSockets for Bridged Broker.</p>
<p>The type of TLS negotiated <a href="https://www.w3.org/TR/wsc-ui/#typesoftls">MUST be strong</a> and the Trust Anchors used to validate certificates must be carefully selected. The trust anchors used in the PKI for public web browsers MUST NOT be used for Unify gateways. Instead, a trust anchor should be created and installed for a particular GW product. Unify should provide an example and make it easy for Unify integrators and manufacturing partners to generate and replace the trust anchor with their own.</p>
<h2><a class="anchor" id="autotoc_md21"></a>
Unify Process Isolation</h2>
<p>The Unify processes (Protocol Controllers, Resource Directory, IoT Services) MUST be hardened against malformed input thorough input validation, for example, should avoid common bug classes, such as array out-of-bounds addressing and pointer errors by design. It is RECOMMENDED to use memory safe languages (not C/C++). The processes SHOULD adopt the <a href="https://en.wikipedia.org/wiki/Principle_of_least_privilege">principle of least privileges</a>, and not require root privileges to run. If a root is required, the processes SHOULD drop the privileges after initialization. A similar hardening SHOULD be applied to the MQTT Broker, although this will probably be a third-party implementation, at least in the first several phases of the Unify project.</p>
<p>The Protocol Controller and Resource Directory processes handle sensitive crypto key material (at least the certificates and private keys for establishing TLS session with MQTT broker, potentially also PAN network keys). PAN encryption keys SHOULD (MUST in later phase) be stored in the PHY radio chip whenever possible to protect from adversarial processes on the Unify GW itself. Therefore, it must be protected against hostile processes reading the memory of the Unify software. Similarly, the Unify software must have exclusive access to the radios, so hostile processes cannot inject commands into the PAN. This must be achieved through OS access control mechanisms.</p>
<h2><a class="anchor" id="autotoc_md22"></a>
Mapping PAN Device Security to the Unified Controller Language</h2>
<p>Protocol Controllers MUST fill out the UCL Header field "PAN Security" to indicate the security level of the received PAN frame that triggered the UCL publish message. The field will be used by the ACL to make sure non-secure commands can't control secure devices. This field MUST NOT control the outgoing security level transmitted on a PAN, that is to be determined by the Protocol Controller.</p>
<h1><a class="anchor" id="autotoc_md23"></a>
Broker Discovery</h1>
<p>To interact with the Unify GW and the PAN nodes behind it, the IP address of the broker must be discovered. The mechanism of discovery is not yet defined, but the most likely candidate is <a href="https://en.wikipedia.org/wiki/Multicast_DNS">Multicast DNS (mDNS)</a>. Once connected, Resource Discovery MUST be used to discover the nodes and capabilities of the PAN nodes.</p>
<h1><a class="anchor" id="autotoc_md24"></a>
Sleepy Devices</h1>
<p>Protocol Controller must manage sleepy devices in the optimal way for each PHY. MQTT retained messages SHOULD be used to cache the latest status from a sleepy device.</p>
<h2><a class="anchor" id="autotoc_md25"></a>
Z-Wave Battery Device</h2>
<p>A Z-Wave Protocol Controller must handle messages to Sleepy Devices, which are known as Battery Devices or devices implementing the Wake Up Command Class, in the following way:</p>
<p>Whenever a Battery Device is included in the PAN, the Protocol Controller MUST set itself as the Lifeline of that node (if allowed) (i.e., make the node report all status commands to the Protocol Controller). The Battery Node will send Wake Up Notification Commands to the Protocol Controller whenever it is available for two-way communication. Usually the frequency is selected to achieve a certain battery life.</p>
<p>After a message for a particular battery device has been published, and again when the message has been delivered and acknowledged on the application layer, the Protocol Controller must publish attribute state updates to their respective topics (<code>ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointIdD&gt;/&lt;ClusterName&gt;/Attributes/Reported</code>).</p>
<p>The state must be described both by a <a href="https://d1.awsstatic.com/whitepapers/Designing_MQTT_Topics_for_AWS_IoT_Core.pdf">"desired" and "reported" state</a>.</p>
<p>The desired state must be updated when the message has been received by the Protocol Controller. When the message has been application layer acknowledged by the PAN Node ("the garage door is now fully lowered and closed"), another update must be published, this time changing the "reported" state. of the Cluster attrbutes. The Supervision Command Class can be used to obtain application level confirmations in Z-Wave.</p>
<h2><a class="anchor" id="autotoc_md26"></a>
Zigbee Sleepy Device</h2>
<p><b>TBD:</b><b> Describe how to handle Zigbee Sleepy Devices</b></p>
<h2><a class="anchor" id="autotoc_md27"></a>
BT Mesh Low Power Devices</h2>
<p><b>TBD: Describe how to handle BT Mesh/BLE low-power devices</b></p>
<h1><a class="anchor" id="autotoc_md28"></a>
Mailbox</h1>
<p>Protocol Controllers will let IoT Service issue commands to sleepy devices whenever they want to. Protocol Controllers are responsible for reflecting the desired state change for the attributes that are affected by the command.</p>
<p>The Protocol Controllers must subsequently issue all pending commands to the sleepy devices whenever communication becomes possible again.</p>
<p>IoT Services may expect to wait a delay in seconds (<code>MaximumCommandDelay</code>) advertised in the state topic <code>ucl/by-unid/&lt;UNID&gt;State</code> for each node before commands are delivered to the end node.</p>
<p>Refer to the <a class="el" href="md_doc__chapter06-service-discovery.html">Service Discovery chapter</a> for details about the the node state topic.</p>
<h1><a class="anchor" id="autotoc_md29"></a>
Reportables/Unsolicited Messages from the PAN</h1>
<p>A IoT Service that wants to receive Reportables (a.k.a. unsolicited messages) from a PAN node MUST have a well-defined way to subscribe to all events from a PAN node. An IoT Service must also be able to subscribe to all event notifications from a particular cluster by subscribing to the topic ucl/by-unid/&lt;UNID&gt;/#. The IoT Service will then receive all reportables from the &lt;UNID&gt; device along with all commands sent to it.</p>
<p><b>NOTE:</b> IOT Services should evaluate the PAN node security level before trusting reportables/unsolicited messages received from the PAN. For</p>
<p>To receive event notifications from multiple devices, MQTT topic wildcards can be used.</p>
<h1><a class="anchor" id="autotoc_md30"></a>
True Status and Almost True Status for Sleepy Devices</h1>
<p><a href="https://community.smartthings.com/t/z-wave-switches-with-instant-update-2016/59328/7">True Status is a feature that allows end nodes to immediately report changes in their status</a>, especially when it is locally initiated. It has been covered by <a href="https://community.smartthings.com/t/z-wave-switches-with-instant-update-2016/59328">patents for years</a>, but at least <a href="https://patents.google.com/patent/US5905442A/en">one patent</a> expired in 2016. This feature MUST be leveraged and exposed to the IoT Service in the Unify design, if the PAN nodes support it.</p>
<p>Status updates must be advertised to IoT Service as described in the <a href="## Reportables/Unsolicited messages from the PAN">Reportables/Unsolicited messages from the PAN section</a>.</p>
<h1><a class="anchor" id="autotoc_md31"></a>
Rules Engines</h1>
<p>Rules engines allow certain actions to be published when certain other events are received. Rules Engines should be distributed, in the sense that multiple IoT Services should be able to set up rules without conflicting with each other. For this, a single Rules Engine Module should be provided that manages a namespace likg ucl/rules_engine/ and providing an API for setting, getting and modifying if-then-else style rules. TBD: Should there be access controls in place to prevent IoT Services from modifying each other's rules? More advanced rules engines can be implemented by IoT Services using the raw publish/subscribe semantics. The Rules Engine SHOULD be implemented as a separate MQTT client to keep the Broker simple.</p>
<h1><a class="anchor" id="autotoc_md32"></a>
Data Logging</h1>
<p>A data logger is an MQTT client that subscribes to ucl/by-unid/+/+/&lt;CLUSTER-TO-LOG&gt;/# and logs the received messages somewhere. Multiple subscriptions and logging streams are possible.</p>
<h1><a class="anchor" id="autotoc_md33"></a>
Command-Line Interface</h1>
<p>It must be possible to control PAN devices and IoT Services from a Command-line interface. The CLI must allow SQA to test Protocol Controllers or IoT Services in isolation by injecting test stimulus to the broker. The CLI MUST also allow Gateway manufacturers to initiate RF performance tests.</p>
<h1><a class="anchor" id="autotoc_md34"></a>
Data Caching or Status Database</h1>
<p>A cache of recent status messages from the PAN SHOULD be maintained in the GW to reduce the load on the PAN network when facing repeated queries from the IoT Service. This Data Layer can be thought of as a continually updating database of the total PAN state. Ideally, IoT Services should query this self-refreshing Status Database, and never issue requests directly to the PAN. The subscriptions may need a mechanism to signal the desired freshness of the response, so the Data Caching component can decide to update the status before responding. Data caching should probably be handled in each Protocol Controller. The mechanism of distribution (Retained Messages in the MQTT broker) or a real database will be decided later. A replication mechanism between these data bases will allow multiple Unified Gateways to control the same PAN without multiplying the amount of probing traffic needed to keep their individual status data bases up to date.</p>
<h1><a class="anchor" id="autotoc_md35"></a>
Latency Considerations</h1>
<p>Unify must provide a perceived "latency-free" end-user experience. Lights and other devices should appear to respond immediately regardless of the type of Unify configuration (local MQTT broker, slim MQTT broker in cloud, full security with TLS for all broker connections, and so on). In practice, this requires a latency below 250 ms, which should be achievable given the following latency budget (all times are round-trips):</p>
<ul>
<li>Local Wi-Fi: 20-50 ms</li>
<li>Local TLS processing 2 ms</li>
<li>cloud connectivity including TLS: 20 ms</li>
<li>cloud response time 20 ms</li>
<li>PHY latency: 100 ms</li>
<li>TOTAL: &lt; 200 ms Care must be taken in the Protocol Controller to avoid extra processing delays when translating and communicating with the PHY Radio.</li>
</ul>
<h1><a class="anchor" id="autotoc_md36"></a>
Examples and Use Cases</h1>
<h2><a class="anchor" id="autotoc_md37"></a>
Turning On a Zigbee Light Bulb from AWS IoT</h2>
<p>Assume the Zigbee Protocol Controller has the prefix "zb" and the bulb has EUI-64 0x9876543210abcdef. The Protocol Controller has assigned the UNID "zb-9876543210abcdef" to the bulb.</p>
<ol type="1">
<li>Unify GW starts up.</li>
<li>Zigbee Protocol Controller initializes, connects to the NCP, and discovers the Zigbee PAN devices. It also probes which clusters the light bulb supports. For simplicity, assume that only the Level and basic clusters are supported. The Level cluster is trivially translated to UCL as Level cluster (same data model in UCL and Zigbee makes this easy). The Protocol Controller publishes the following Retained Message to allow service discovery: ucl/by-unid/zb-9876543210abcdef/ep0/LevelCluster payload = { "state" : { "reported" : {"OnOff":"0x00", "SupportedCommands":["Move to Level", "Move", "Step", "Stop", "Move to Level (with On/Off)", ...], "desired" : {...}}}}.</li>
<li>The Zigbee Protocol Controller subscribes to the following topics so it can execute commands in the cluster:<ul>
<li>ucl/by-unid/zb-9876543210abcdef/ep0/OnOffCluster/WriteAttributes</li>
<li>ucl/by-unid/zb-9876543210abcdef/ep0/OnOffCluster/ForceReadAttributes</li>
<li>and one for each command in the Cluster: .../Move, .../MoveToLevel(withOnOff) etc.</li>
</ul>
</li>
<li>The AWS-IoT IoT Service wants to display all devices that can be dimmed and turn on the first one. It connects to the Unify Broker and subscribes to ucl/by-unid/+/+/LevelCluster and receives the message described above. It now knows that UNID zb-9876543210abcdef Supports the Level cluster and can be dimmed.</li>
<li>To learn the type IoT device, the AWS-IoT IoT Service subscribes to ucl/by-type/dimmable_light/+ and receives a message back on the topic ucl/by-type/dimmable_light/zb-9876543210abcdef and knows that this is indeed a light.</li>
<li>The home owner's Alexa Smartphone App now displays the light bulb complete with a colorful bulb icon. The home owner clicks the "ON" button.</li>
<li>In a matter of milliseconds, the AWS-IoT IoT Service receives a command from the cloud to turn on the bulb. The IoT Service quickly translates this into UCL and publishes to the topic ucl/by-unid/LevelCluster/MoveToLevelOnOff with a payload = {"state" : {"Level":"100", "TransitionTime" : "0.5"}}</li>
<li>The Zigbee Protocol Controller receives this message, matches the prefix and translates the UCL message to a sequence of Zigbee Cluster Library Commands (maybe just one command) and sends those out over the NCP.</li>
<li>The bulb turns on.</li>
</ol>
<h2><a class="anchor" id="autotoc_md38"></a>
Updating the Firmware of a PIR Sensor from the Cloud</h2>
<p><b>Use case 1: Cloud service wants a fleet overview: A list of devices and their Firmware Versions.</b></p>
<p>See <a class="el" href="md_doc__chapter05-common-ota.html">Common OTA FW Update Service</a></p>
<p><b>Use case 2: A cloud user wants to firmware update a Unify-managed device</b></p>
<p>See <a class="el" href="md_doc__chapter05-common-ota.html">Common OTA FW Update Service</a></p>
<h2><a class="anchor" id="autotoc_md39"></a>
Multicasting to Two Light Bulbs</h2>
<p><b> Use case: A IoT Service wants to turn on two light bulbs simultaneously.</b></p>
<p>Assume that the UNIDs (UNID1 and UNID2) have already been discovered.</p>
<ol type="1">
<li>Unify GW starts up and Protocol Controller initializes.</li>
<li>Protocol Controller subscribes to ucl/by-unid/+/+/Groups/Attributes/# and ucl/by-unid/+/+/Groups/SupportedCommands.</li>
<li>IoT Service uses the Groups cluster on UNID1/ep0 and UNID2/ep0 to add both UNIDs to the same group 1.</li>
<li>Protocol Controller receives the Groups commands via the subscription and adds UNID1/ep0 and UNID2/ep0 in group 1.</li>
<li>IoT Services reads the common capabilities of the group at ucl/by-group/1/+/SupportedCommands.</li>
<li>IoT Service publishes a command for the group. For example, {"Level:100", "TransitionTime":"0.05"} to topic ucl/by-group/1/Level/Commands/MoveToLevelWithOnOff.</li>
<li>Protocol Controller receives the message and issues a multicast message to those nodes. If managed by two different Protocol Controllers, a singlecast on each PHY will happen instead.</li>
</ol>
<h2><a class="anchor" id="autotoc_md40"></a>
Contractor Writing an IoT Service</h2>
<p><b>Type 1: Cloud provider uses MQTT</b></p>
<p>Assume that a contractor is commissioned to build an IoT service. The IoT service connects UCL to a cloud solution of some sort. The contractor picks a MQTT client in a preferred language (in this use case Python), subscribes to relevant channels on the Unify broker, and publishes translated-to-cloud-solution commands to the cloud solution and vice-verse.</p>
<p>Translation should be a lot simpler than the Protocol Controllers due to structural similarities btw. UCL and prevalent IoT cloud solution architectures. For example, both AWS IoT and Azure IoT uses MQTT transport and fits in this category (AWS IoT is agnostic to the payload/data model, but UCL must be translated to the data model of the cloud service being targeted, so some translation is still needed).</p>
<p><b>Type 2: Cloud provider does not use MQTT:</b></p>
<p>Add MQTT client, subscribe to stuff on the GW broker, translate and transmit to cloud provider in whatever transport and format they use. This requires more work than type 1, obviously, but is still significantly easier than pre-Unify solutions.</p>
<h2><a class="anchor" id="autotoc_md41"></a>
Contractor Writing a Protocol Controller</h2>
<p>Contractor chooses an MQTT client in a preferred language and starts implementing the APIs detailed above in the Protocol Controller API section. Preferably, the contractor has in-depth knowledge of the PHY in question.</p>
<h2><a class="anchor" id="autotoc_md42"></a>
IoT Service Discovering All Devices Supporting Cluster "DoorLock"</h2>
<ol type="1">
<li>IoT Service subscribes to topic ucl/by-unid/+/+/DoorLock.</li>
<li>IoT Service receives a <a href="https://www.hivemq.com/blog/mqtt-essentials-part-8-retained-messages/">Retained Message</a> from each endpoint supporting the DoorLock command class. These messages were published by the Protocol Controllers. </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
