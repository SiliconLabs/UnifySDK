<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Z-Wave Protocol Controller Refrence: Attribute Resolver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Z-Wave Protocol Controller Refrence<span id="projectnumber">&#160;1.7.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__attribute__resolver.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Attribute Resolver<div class="ingroups"><a class="el" href="group__unify__components.html">Unify Components</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>The role of the attribute resolver is to locate and resolve missing information in the attribute store.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:attribute__resolver__rule_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="attribute__resolver__rule_8h.html">attribute_resolver_rule.h</a></td></tr>
<tr class="memdesc:attribute__resolver__rule_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">This module defines necessary API for using resolver. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:attribute__resolver__rule__internal_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="attribute__resolver__rule__internal_8h.html">attribute_resolver_rule_internal.h</a></td></tr>
<tr class="memdesc:attribute__resolver__rule__internal_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">This module offers API for registering and executing rules. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structattribute__resolver__config__t.html">attribute_resolver_config_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gae480dcd4682b4ad7442fdd1db297083e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__attribute__resolver.html#gae480dcd4682b4ad7442fdd1db297083e">MAX_FRAME_LEN</a>&#160;&#160;&#160;255</td></tr>
<tr class="separator:gae480dcd4682b4ad7442fdd1db297083e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gab969c331fd29e45a9e9f2b82635c6bff"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__attribute__resolver.html#gab969c331fd29e45a9e9f2b82635c6bff">attribute_resolver_callback_t</a>) (<a class="el" href="group__attribute__store__api.html#ga66c4c40720e5271c527c718924261fc6">attribute_store_node_t</a> node)</td></tr>
<tr class="memdesc:gab969c331fd29e45a9e9f2b82635c6bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback type for notifying about resolver events.  <a href="group__attribute__resolver.html#gab969c331fd29e45a9e9f2b82635c6bff">More...</a><br /></td></tr>
<tr class="separator:gab969c331fd29e45a9e9f2b82635c6bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1142d2eecafcaca3744a6a4d66d39fcc"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__unify__sl__status__codes.html#ga7e293ad81575c986a476d3065d7ae49f">sl_status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__attribute__resolver.html#ga1142d2eecafcaca3744a6a4d66d39fcc">attribute_resolver_function_t</a>) (<a class="el" href="group__attribute__store__api.html#ga66c4c40720e5271c527c718924261fc6">attribute_store_node_t</a> node, uint8_t *frame, uint16_t *frame_len)</td></tr>
<tr class="memdesc:ga1142d2eecafcaca3744a6a4d66d39fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generator function for building PAN frames.  <a href="group__attribute__resolver.html#ga1142d2eecafcaca3744a6a4d66d39fcc">More...</a><br /></td></tr>
<tr class="separator:ga1142d2eecafcaca3744a6a4d66d39fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9b0ec14c67049440c068de76d41639f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__unify__sl__status__codes.html#ga7e293ad81575c986a476d3065d7ae49f">sl_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__attribute__resolver.html#ga9b0ec14c67049440c068de76d41639f5">attribute_resolver_init</a> (<a class="el" href="structattribute__resolver__config__t.html">attribute_resolver_config_t</a> resolver_config)</td></tr>
<tr class="memdesc:ga9b0ec14c67049440c068de76d41639f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the attribute resolver. This function will clear the rulebook and reset the resolver state.  <a href="group__attribute__resolver.html#ga9b0ec14c67049440c068de76d41639f5">More...</a><br /></td></tr>
<tr class="separator:ga9b0ec14c67049440c068de76d41639f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad926dec80fd09bd159b1f2fa0cdf38a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__attribute__resolver.html#gaad926dec80fd09bd159b1f2fa0cdf38a">attribute_resolver_teardown</a> ()</td></tr>
<tr class="memdesc:gaad926dec80fd09bd159b1f2fa0cdf38a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Teardown the attribute resolver.  <a href="group__attribute__resolver.html#gaad926dec80fd09bd159b1f2fa0cdf38a">More...</a><br /></td></tr>
<tr class="separator:gaad926dec80fd09bd159b1f2fa0cdf38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf861538dd5cb124bd6d0a83526e327c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__unify__sl__status__codes.html#ga7e293ad81575c986a476d3065d7ae49f">sl_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__attribute__resolver.html#gadf861538dd5cb124bd6d0a83526e327c">attribute_resolver_register_rule</a> (<a class="el" href="attribute__store_8h.html#ab7b43e61cc3128952b765dc99020b160">attribute_store_type_t</a> node_type, <a class="el" href="group__attribute__resolver.html#ga1142d2eecafcaca3744a6a4d66d39fcc">attribute_resolver_function_t</a> set_func, <a class="el" href="group__attribute__resolver.html#ga1142d2eecafcaca3744a6a4d66d39fcc">attribute_resolver_function_t</a> get_func)</td></tr>
<tr class="memdesc:gadf861538dd5cb124bd6d0a83526e327c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an attribute rule.  <a href="group__attribute__resolver.html#gadf861538dd5cb124bd6d0a83526e327c">More...</a><br /></td></tr>
<tr class="separator:gadf861538dd5cb124bd6d0a83526e327c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36150b164bf3a1a4bdd7b5c762999473"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__unify__sl__status__codes.html#ga7e293ad81575c986a476d3065d7ae49f">sl_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__attribute__resolver.html#ga36150b164bf3a1a4bdd7b5c762999473">attribute_resolver_set_attribute_depth</a> (<a class="el" href="attribute__store_8h.html#ab7b43e61cc3128952b765dc99020b160">attribute_store_type_t</a> node_type, int depth)</td></tr>
<tr class="memdesc:ga36150b164bf3a1a4bdd7b5c762999473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the relative depth of an attribute in the attribute tree.  <a href="group__attribute__resolver.html#ga36150b164bf3a1a4bdd7b5c762999473">More...</a><br /></td></tr>
<tr class="separator:ga36150b164bf3a1a4bdd7b5c762999473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2be726f603b349975aab0498d1457202"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__attribute__resolver.html#ga2be726f603b349975aab0498d1457202">attribute_resolver_pause_node_resolution</a> (<a class="el" href="group__attribute__store__api.html#ga66c4c40720e5271c527c718924261fc6">attribute_store_node_t</a> node)</td></tr>
<tr class="memdesc:ga2be726f603b349975aab0498d1457202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause the resolution on a given node.  <a href="group__attribute__resolver.html#ga2be726f603b349975aab0498d1457202">More...</a><br /></td></tr>
<tr class="separator:ga2be726f603b349975aab0498d1457202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b1564df64159c70b31bfe10e9e5b8a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__attribute__resolver.html#ga3b1564df64159c70b31bfe10e9e5b8a6">attribute_resolver_resume_node_resolution</a> (<a class="el" href="group__attribute__store__api.html#ga66c4c40720e5271c527c718924261fc6">attribute_store_node_t</a> node)</td></tr>
<tr class="memdesc:ga3b1564df64159c70b31bfe10e9e5b8a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume the resolution on a given node.  <a href="group__attribute__resolver.html#ga3b1564df64159c70b31bfe10e9e5b8a6">More...</a><br /></td></tr>
<tr class="separator:ga3b1564df64159c70b31bfe10e9e5b8a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56ee2ba50adc1bfe2ae861325af21e89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__attribute__resolver.html#ga56ee2ba50adc1bfe2ae861325af21e89">attribute_resolver_set_resolution_listener</a> (<a class="el" href="group__attribute__store__api.html#ga66c4c40720e5271c527c718924261fc6">attribute_store_node_t</a> node, <a class="el" href="group__attribute__resolver.html#gab969c331fd29e45a9e9f2b82635c6bff">attribute_resolver_callback_t</a> callback)</td></tr>
<tr class="memdesc:ga56ee2ba50adc1bfe2ae861325af21e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a listener to be called when a node and all its children has been resolved.  <a href="group__attribute__resolver.html#ga56ee2ba50adc1bfe2ae861325af21e89">More...</a><br /></td></tr>
<tr class="separator:ga56ee2ba50adc1bfe2ae861325af21e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6520e27d300cc764c9281905c486c67c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__attribute__resolver.html#ga6520e27d300cc764c9281905c486c67c">attribute_resolver_clear_resolution_listener</a> (<a class="el" href="group__attribute__store__api.html#ga66c4c40720e5271c527c718924261fc6">attribute_store_node_t</a> node, <a class="el" href="group__attribute__resolver.html#gab969c331fd29e45a9e9f2b82635c6bff">attribute_resolver_callback_t</a> callback)</td></tr>
<tr class="memdesc:ga6520e27d300cc764c9281905c486c67c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a node resolve listener.  <a href="group__attribute__resolver.html#ga6520e27d300cc764c9281905c486c67c">More...</a><br /></td></tr>
<tr class="separator:ga6520e27d300cc764c9281905c486c67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac01b17eb00fbd86b784f697510cd8748"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__attribute__resolver.html#gac01b17eb00fbd86b784f697510cd8748">attribute_resolver_set_resolution_give_up_listener</a> (<a class="el" href="attribute__store_8h.html#ab7b43e61cc3128952b765dc99020b160">attribute_store_type_t</a> node_type, <a class="el" href="group__attribute__resolver.html#gab969c331fd29e45a9e9f2b82635c6bff">attribute_resolver_callback_t</a> callback)</td></tr>
<tr class="memdesc:gac01b17eb00fbd86b784f697510cd8748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a listener that will be informed if we give up trying to perform a Get resolution on a node.  <a href="group__attribute__resolver.html#gac01b17eb00fbd86b784f697510cd8748">More...</a><br /></td></tr>
<tr class="separator:gac01b17eb00fbd86b784f697510cd8748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70fdc04153db66e2d129e5afa0325f66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__attribute__resolver.html#ga70fdc04153db66e2d129e5afa0325f66">attribute_resolver_set_resolution_resumption_listener</a> (<a class="el" href="group__attribute__store__api.html#ga66c4c40720e5271c527c718924261fc6">attribute_store_node_t</a> node, <a class="el" href="group__attribute__resolver.html#gab969c331fd29e45a9e9f2b82635c6bff">attribute_resolver_callback_t</a> callback)</td></tr>
<tr class="memdesc:ga70fdc04153db66e2d129e5afa0325f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a listener for unpausing nodes.  <a href="group__attribute__resolver.html#ga70fdc04153db66e2d129e5afa0325f66">More...</a><br /></td></tr>
<tr class="separator:ga70fdc04153db66e2d129e5afa0325f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90978682657a2122a88a50d2c1994d60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__attribute__resolver.html#ga90978682657a2122a88a50d2c1994d60">attribute_resolver_clear_resolution_resumption_listener</a> (<a class="el" href="group__attribute__store__api.html#ga66c4c40720e5271c527c718924261fc6">attribute_store_node_t</a> node, <a class="el" href="group__attribute__resolver.html#gab969c331fd29e45a9e9f2b82635c6bff">attribute_resolver_callback_t</a> callback)</td></tr>
<tr class="memdesc:ga90978682657a2122a88a50d2c1994d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a listener for unpausing nodes.  <a href="group__attribute__resolver.html#ga90978682657a2122a88a50d2c1994d60">More...</a><br /></td></tr>
<tr class="separator:ga90978682657a2122a88a50d2c1994d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99ff84b41f526fb7a9cfa45b153f9fa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__unify__sl__status__codes.html#ga7e293ad81575c986a476d3065d7ae49f">sl_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__attribute__resolver.html#ga99ff84b41f526fb7a9cfa45b153f9fa8">attribute_resolver_restart_set_resolution</a> (<a class="el" href="group__attribute__store__api.html#ga66c4c40720e5271c527c718924261fc6">attribute_store_node_t</a> node)</td></tr>
<tr class="memdesc:ga99ff84b41f526fb7a9cfa45b153f9fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instructs the resolver to try to resolve a set rule that was pending.  <a href="group__attribute__resolver.html#ga99ff84b41f526fb7a9cfa45b153f9fa8">More...</a><br /></td></tr>
<tr class="separator:ga99ff84b41f526fb7a9cfa45b153f9fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa717e71a6505c12fbc28a2b6f3503e80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__unify__sl__status__codes.html#ga7e293ad81575c986a476d3065d7ae49f">sl_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__attribute__resolver.html#gaa717e71a6505c12fbc28a2b6f3503e80">attribute_resolver_restart_get_resolution</a> (<a class="el" href="group__attribute__store__api.html#ga66c4c40720e5271c527c718924261fc6">attribute_store_node_t</a> node)</td></tr>
<tr class="memdesc:gaa717e71a6505c12fbc28a2b6f3503e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instructs the resolver to try to resolve a get rule that was pending.  <a href="group__attribute__resolver.html#gaa717e71a6505c12fbc28a2b6f3503e80">More...</a><br /></td></tr>
<tr class="separator:gaa717e71a6505c12fbc28a2b6f3503e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c79128630d7e8a30f45f82a62fa1813"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structattribute__resolver__config__t.html">attribute_resolver_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__attribute__resolver.html#ga5c79128630d7e8a30f45f82a62fa1813">attribute_resolver_get_config</a> ()</td></tr>
<tr class="memdesc:ga5c79128630d7e8a30f45f82a62fa1813"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the current configuration for the attribute resolver  <a href="group__attribute__resolver.html#ga5c79128630d7e8a30f45f82a62fa1813">More...</a><br /></td></tr>
<tr class="separator:ga5c79128630d7e8a30f45f82a62fa1813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a69436f0b464f12ae8884357a1bc3b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__attribute__resolver.html#ga1a69436f0b464f12ae8884357a1bc3b8">attribute_resolver_node_or_child_needs_resolution</a> (<a class="el" href="group__attribute__store__api.html#ga66c4c40720e5271c527c718924261fc6">attribute_store_node_t</a> node)</td></tr>
<tr class="memdesc:ga1a69436f0b464f12ae8884357a1bc3b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies if the provided node, or any of its child needs resolution.  <a href="group__attribute__resolver.html#ga1a69436f0b464f12ae8884357a1bc3b8">More...</a><br /></td></tr>
<tr class="separator:ga1a69436f0b464f12ae8884357a1bc3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac219d9eb804a9862ba4dd1e089a72fe3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__attribute__resolver.html#gac219d9eb804a9862ba4dd1e089a72fe3">is_node_or_parent_paused</a> (<a class="el" href="group__attribute__store__api.html#ga66c4c40720e5271c527c718924261fc6">attribute_store_node_t</a> node)</td></tr>
<tr class="memdesc:gac219d9eb804a9862ba4dd1e089a72fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function traverses attribute store to check if any parent of the attribute node is paused or not.  <a href="group__attribute__resolver.html#gac219d9eb804a9862ba4dd1e089a72fe3">More...</a><br /></td></tr>
<tr class="separator:gac219d9eb804a9862ba4dd1e089a72fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad167230e6bf706a5e1bde2d8b75a2b38"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__attribute__resolver.html#gad167230e6bf706a5e1bde2d8b75a2b38">is_node_pending_set_resolution</a> (<a class="el" href="group__attribute__store__api.html#ga66c4c40720e5271c527c718924261fc6">attribute_store_node_t</a> node)</td></tr>
<tr class="memdesc:gad167230e6bf706a5e1bde2d8b75a2b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a node is pending a set resolution. i.e. command has been sent and we are waiting for a state update in the attribute store.  <a href="group__attribute__resolver.html#gad167230e6bf706a5e1bde2d8b75a2b38">More...</a><br /></td></tr>
<tr class="separator:gad167230e6bf706a5e1bde2d8b75a2b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3536d271edf4bd224afc20fc1253d08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__attribute__resolver.html#gaa3536d271edf4bd224afc20fc1253d08">attribute_resolver_state_log</a> ()</td></tr>
<tr class="memdesc:gaa3536d271edf4bd224afc20fc1253d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log the state of the Attribute Resolver using <a class="el" href="group__sl__log.html">Unify Logging system</a>.  <a href="group__attribute__resolver.html#gaa3536d271edf4bd224afc20fc1253d08">More...</a><br /></td></tr>
<tr class="separator:gaa3536d271edf4bd224afc20fc1253d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >The role of the attribute resolver is to locate and resolve missing information in the attribute store. </p>
<p >The role of the attribute resolver is to try to fetch missing information and align reported and desired values in attributes. It does so by holding a rule set for attributes. Two hooks rules are allowed pr attributes,</p>
<ul>
<li>A rule on how to bring the attribute desired value to the reported value. This typically maps to sending a SET command. Several rules could map to the same set command. In other words, if multiple attributes exist in the set. When the SET command is executed, it is filled with the desired value of the attribute that make up the set command.</li>
<li>A rule on how to trigger a reported updated of an attribute, i.e., if the attribute is unresolved. This rule typically maps to a GET command. </li>
</ul>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gae480dcd4682b4ad7442fdd1db297083e" name="gae480dcd4682b4ad7442fdd1db297083e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae480dcd4682b4ad7442fdd1db297083e">&#9670;&nbsp;</a></span>MAX_FRAME_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_FRAME_LEN&#160;&#160;&#160;255</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Maximum size of the buffer that allows to copy rule frames </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gab969c331fd29e45a9e9f2b82635c6bff" name="gab969c331fd29e45a9e9f2b82635c6bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab969c331fd29e45a9e9f2b82635c6bff">&#9670;&nbsp;</a></span>attribute_resolver_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* attribute_resolver_callback_t) (<a class="el" href="group__attribute__store__api.html#ga66c4c40720e5271c527c718924261fc6">attribute_store_node_t</a> node)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback type for notifying about resolver events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The attribute store node for which something happened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1142d2eecafcaca3744a6a4d66d39fcc" name="ga1142d2eecafcaca3744a6a4d66d39fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1142d2eecafcaca3744a6a4d66d39fcc">&#9670;&nbsp;</a></span>attribute_resolver_function_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__unify__sl__status__codes.html#ga7e293ad81575c986a476d3065d7ae49f">sl_status_t</a>(* attribute_resolver_function_t) (<a class="el" href="group__attribute__store__api.html#ga66c4c40720e5271c527c718924261fc6">attribute_store_node_t</a> node, uint8_t *frame, uint16_t *frame_len)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generator function for building PAN frames. </p>
<p >This function prototype is used by the rules engine to retrieve PAN frames that will resolve a get or set attribute.</p>
<p >Resolution functions are expected to return the following return codes:</p><ul>
<li>SL_STATUS_OK : A frame was copied into the frame pointer and should be final to resolve the attribute</li>
<li>SL_STATUS_IN_PROGRESS: A frame was copied into the frame pointer, but this attribute will require more frames to be fully resolved.</li>
<li>SL_STATUS_ALREADY_EXISTS: The Attribute was solved using some calculation/deductions from the Attribute Store and no frame needs to be transmitted.</li>
<li>SL_STATUS_IS_WAITING: The Attribute should not be resolved and should be skipped for now.</li>
<li>SL_STATUS_FAIL: (or other codes) No frame was copied due to an error. The attribute should be skipped for now.</li>
</ul>
<p >Function parameters:</p><ul>
<li>attribute_store_node_t node [in]: The attribute store node to resolve. Resolving functions can use this information to retrieve related information from the <a class="el" href="group__attribute__store.html">Attribute Store</a>.</li>
<li>uint8_t <em>frame [out]: Frame pointer. The data payload for the resolution must be written at the address pointed by this variable</em></li>
<li><em>uint16_t *frame_len [out]: Length variable pointer. The length of the payload written at the frame</em> address must be written here. </li>
</ul>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga6520e27d300cc764c9281905c486c67c" name="ga6520e27d300cc764c9281905c486c67c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6520e27d300cc764c9281905c486c67c">&#9670;&nbsp;</a></span>attribute_resolver_clear_resolution_listener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void attribute_resolver_clear_resolution_listener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__attribute__store__api.html#ga66c4c40720e5271c527c718924261fc6">attribute_store_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__attribute__resolver.html#gab969c331fd29e45a9e9f2b82635c6bff">attribute_resolver_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a node resolve listener. </p>
<p >See <a class="el" href="group__attribute__resolver.html#ga56ee2ba50adc1bfe2ae861325af21e89">attribute_resolver_set_resolution_listener</a> This will clear the callback function registered for the node. If the combination of node and callback is not found, it will do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node to clear listener for </td></tr>
    <tr><td class="paramname">callback</td><td>Callback function to clear from node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga90978682657a2122a88a50d2c1994d60" name="ga90978682657a2122a88a50d2c1994d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90978682657a2122a88a50d2c1994d60">&#9670;&nbsp;</a></span>attribute_resolver_clear_resolution_resumption_listener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void attribute_resolver_clear_resolution_resumption_listener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__attribute__store__api.html#ga66c4c40720e5271c527c718924261fc6">attribute_store_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__attribute__resolver.html#gab969c331fd29e45a9e9f2b82635c6bff">attribute_resolver_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a listener for unpausing nodes. </p>
<p >Listeners to unpausing/resume will get a synchronous callback</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node to set a listener for </td></tr>
    <tr><td class="paramname">callback</td><td>Callback function to invoke when the node is resumed for resolution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5c79128630d7e8a30f45f82a62fa1813" name="ga5c79128630d7e8a30f45f82a62fa1813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c79128630d7e8a30f45f82a62fa1813">&#9670;&nbsp;</a></span>attribute_resolver_get_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structattribute__resolver__config__t.html">attribute_resolver_config_t</a> attribute_resolver_get_config </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the current configuration for the attribute resolver </p>
<dl class="section return"><dt>Returns</dt><dd>current configuration object </dd></dl>

</div>
</div>
<a id="ga9b0ec14c67049440c068de76d41639f5" name="ga9b0ec14c67049440c068de76d41639f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b0ec14c67049440c068de76d41639f5">&#9670;&nbsp;</a></span>attribute_resolver_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__unify__sl__status__codes.html#ga7e293ad81575c986a476d3065d7ae49f">sl_status_t</a> attribute_resolver_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structattribute__resolver__config__t.html">attribute_resolver_config_t</a>&#160;</td>
          <td class="paramname"><em>resolver_config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the attribute resolver. This function will clear the rulebook and reset the resolver state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolver_config</td><td>Attribute resolver configurations bundle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sl_status_t </dd></dl>

</div>
</div>
<a id="ga1a69436f0b464f12ae8884357a1bc3b8" name="ga1a69436f0b464f12ae8884357a1bc3b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a69436f0b464f12ae8884357a1bc3b8">&#9670;&nbsp;</a></span>attribute_resolver_node_or_child_needs_resolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool attribute_resolver_node_or_child_needs_resolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__attribute__store__api.html#ga66c4c40720e5271c527c718924261fc6">attribute_store_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies if the provided node, or any of its child needs resolution. </p>
<p >This can be used in order to detect if paused node would be resolved if unpaused.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to verify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a get or set rule is to be applied on the node or a node of its subtree. false otherwise. </dd></dl>

</div>
</div>
<a id="ga2be726f603b349975aab0498d1457202" name="ga2be726f603b349975aab0498d1457202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2be726f603b349975aab0498d1457202">&#9670;&nbsp;</a></span>attribute_resolver_pause_node_resolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void attribute_resolver_pause_node_resolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__attribute__store__api.html#ga66c4c40720e5271c527c718924261fc6">attribute_store_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pause the resolution on a given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Attribute node that the resolution is paused. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadf861538dd5cb124bd6d0a83526e327c" name="gadf861538dd5cb124bd6d0a83526e327c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf861538dd5cb124bd6d0a83526e327c">&#9670;&nbsp;</a></span>attribute_resolver_register_rule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__unify__sl__status__codes.html#ga7e293ad81575c986a476d3065d7ae49f">sl_status_t</a> attribute_resolver_register_rule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="attribute__store_8h.html#ab7b43e61cc3128952b765dc99020b160">attribute_store_type_t</a>&#160;</td>
          <td class="paramname"><em>node_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__attribute__resolver.html#ga1142d2eecafcaca3744a6a4d66d39fcc">attribute_resolver_function_t</a>&#160;</td>
          <td class="paramname"><em>set_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__attribute__resolver.html#ga1142d2eecafcaca3744a6a4d66d39fcc">attribute_resolver_function_t</a>&#160;</td>
          <td class="paramname"><em>get_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an attribute rule. </p>
<p >This function registers a new rule into the resolver rule book. Only one rule can exist per attribute type. Some attributes have both a set and get rule, some only have a set rule, some have only a get rule, some have no rules.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_type</td><td>Attribute type for which these rules apply. </td></tr>
    <tr><td class="paramname">set_func</td><td>Generator function which will generate the SET command for this attribute type. </td></tr>
    <tr><td class="paramname">get_func</td><td>Generator function which will generate the GET command for this attribute type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sl_status_t </dd></dl>

</div>
</div>
<a id="gaa717e71a6505c12fbc28a2b6f3503e80" name="gaa717e71a6505c12fbc28a2b6f3503e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa717e71a6505c12fbc28a2b6f3503e80">&#9670;&nbsp;</a></span>attribute_resolver_restart_get_resolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__unify__sl__status__codes.html#ga7e293ad81575c986a476d3065d7ae49f">sl_status_t</a> attribute_resolver_restart_get_resolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__attribute__store__api.html#ga66c4c40720e5271c527c718924261fc6">attribute_store_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instructs the resolver to try to resolve a get rule that was pending. </p>
<p >This function will have no effect if the node is not in the pending gets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node to resolve again.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if the node will be retried. SL_STATUS_NOT_FOUND otherwise </dd></dl>

</div>
</div>
<a id="ga99ff84b41f526fb7a9cfa45b153f9fa8" name="ga99ff84b41f526fb7a9cfa45b153f9fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99ff84b41f526fb7a9cfa45b153f9fa8">&#9670;&nbsp;</a></span>attribute_resolver_restart_set_resolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__unify__sl__status__codes.html#ga7e293ad81575c986a476d3065d7ae49f">sl_status_t</a> attribute_resolver_restart_set_resolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__attribute__store__api.html#ga66c4c40720e5271c527c718924261fc6">attribute_store_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instructs the resolver to try to resolve a set rule that was pending. </p>
<p >This function will have no effect if the node is not in the pending sets. It will remove a pending set from its list and try to resolve it again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node to resolve again.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if the node will be retried. SL_STATUS_NOT_FOUND otherwise </dd></dl>

</div>
</div>
<a id="ga3b1564df64159c70b31bfe10e9e5b8a6" name="ga3b1564df64159c70b31bfe10e9e5b8a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b1564df64159c70b31bfe10e9e5b8a6">&#9670;&nbsp;</a></span>attribute_resolver_resume_node_resolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void attribute_resolver_resume_node_resolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__attribute__store__api.html#ga66c4c40720e5271c527c718924261fc6">attribute_store_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume the resolution on a given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Attribute node that the resolution is resumed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga36150b164bf3a1a4bdd7b5c762999473" name="ga36150b164bf3a1a4bdd7b5c762999473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36150b164bf3a1a4bdd7b5c762999473">&#9670;&nbsp;</a></span>attribute_resolver_set_attribute_depth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__unify__sl__status__codes.html#ga7e293ad81575c986a476d3065d7ae49f">sl_status_t</a> attribute_resolver_set_attribute_depth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="attribute__store_8h.html#ab7b43e61cc3128952b765dc99020b160">attribute_store_type_t</a>&#160;</td>
          <td class="paramname"><em>node_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the relative depth of an attribute in the attribute tree. </p>
<p >This functions sets the relative depth of an attribute, this is used when the attribute resolver tries to detect if multiple attributes will be resolved by the same set frame. Normally the resolver will assume that all resolved attribute in a frame are siblings (depth=1), however once an a while the a frame will resolve attribute which are on deeper levels, ie cousins and grand cousins. It is assumed that all attributes resolved in a frame are all on the same level, ie all are siblings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_type</td><td></td></tr>
    <tr><td class="paramname">depth</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sl_status_t </dd></dl>

</div>
</div>
<a id="gac01b17eb00fbd86b784f697510cd8748" name="gac01b17eb00fbd86b784f697510cd8748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac01b17eb00fbd86b784f697510cd8748">&#9670;&nbsp;</a></span>attribute_resolver_set_resolution_give_up_listener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void attribute_resolver_set_resolution_give_up_listener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="attribute__store_8h.html#ab7b43e61cc3128952b765dc99020b160">attribute_store_type_t</a>&#160;</td>
          <td class="paramname"><em>node_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__attribute__resolver.html#gab969c331fd29e45a9e9f2b82635c6bff">attribute_resolver_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a listener that will be informed if we give up trying to perform a Get resolution on a node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_type</td><td>to be informed about </td></tr>
    <tr><td class="paramname">callback</td><td>Function to invoke when the node resolution has been given up </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga56ee2ba50adc1bfe2ae861325af21e89" name="ga56ee2ba50adc1bfe2ae861325af21e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56ee2ba50adc1bfe2ae861325af21e89">&#9670;&nbsp;</a></span>attribute_resolver_set_resolution_listener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void attribute_resolver_set_resolution_listener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__attribute__store__api.html#ga66c4c40720e5271c527c718924261fc6">attribute_store_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__attribute__resolver.html#gab969c331fd29e45a9e9f2b82635c6bff">attribute_resolver_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a listener to be called when a node and all its children has been resolved. </p>
<p >This function allows for a callback to be fired when the resolver has completed and resolved a part of the attribute tree. In other words, the node passed as a parameter and all its children.</p>
<p >This feature is used to send Wake Up No More Information for Z-Wave Wake Up nodes. It is also used by the network monitor to identify when the node is no longer interviewed after inclusion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node to monitor </td></tr>
    <tr><td class="paramname">callback</td><td>Function to invoke when the node resolution is done. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga70fdc04153db66e2d129e5afa0325f66" name="ga70fdc04153db66e2d129e5afa0325f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70fdc04153db66e2d129e5afa0325f66">&#9670;&nbsp;</a></span>attribute_resolver_set_resolution_resumption_listener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void attribute_resolver_set_resolution_resumption_listener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__attribute__store__api.html#ga66c4c40720e5271c527c718924261fc6">attribute_store_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__attribute__resolver.html#gab969c331fd29e45a9e9f2b82635c6bff">attribute_resolver_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a listener for unpausing nodes. </p>
<p >Listeners to unpausing/resume will get a synchronous callback</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node to set a listener for </td></tr>
    <tr><td class="paramname">callback</td><td>Callback function to invoke when the node is resumed for resolution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa3536d271edf4bd224afc20fc1253d08" name="gaa3536d271edf4bd224afc20fc1253d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3536d271edf4bd224afc20fc1253d08">&#9670;&nbsp;</a></span>attribute_resolver_state_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void attribute_resolver_state_log </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Log the state of the Attribute Resolver using <a class="el" href="group__sl__log.html">Unify Logging system</a>. </p>

</div>
</div>
<a id="gaad926dec80fd09bd159b1f2fa0cdf38a" name="gaad926dec80fd09bd159b1f2fa0cdf38a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad926dec80fd09bd159b1f2fa0cdf38a">&#9670;&nbsp;</a></span>attribute_resolver_teardown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int attribute_resolver_teardown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Teardown the attribute resolver. </p>
<p >This function will terminate the attribute resolver process. </p><dl class="section return"><dt>Returns</dt><dd>0 on success, any other value in case of error. </dd></dl>

</div>
</div>
<a id="gac219d9eb804a9862ba4dd1e089a72fe3" name="gac219d9eb804a9862ba4dd1e089a72fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac219d9eb804a9862ba4dd1e089a72fe3">&#9670;&nbsp;</a></span>is_node_or_parent_paused()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_node_or_parent_paused </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__attribute__store__api.html#ga66c4c40720e5271c527c718924261fc6">attribute_store_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function traverses attribute store to check if any parent of the attribute node is paused or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Attribute node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node or any of its parents is paused false if none if the node and none of its parents is paused </dd></dl>

</div>
</div>
<a id="gad167230e6bf706a5e1bde2d8b75a2b38" name="gad167230e6bf706a5e1bde2d8b75a2b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad167230e6bf706a5e1bde2d8b75a2b38">&#9670;&nbsp;</a></span>is_node_pending_set_resolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_node_pending_set_resolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__attribute__store__api.html#ga66c4c40720e5271c527c718924261fc6">attribute_store_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if a node is pending a set resolution. i.e. command has been sent and we are waiting for a state update in the attribute store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Attribute node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node is pending set execution false otherwise </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Feb 13 2025 07:20:10 for Z-Wave Protocol Controller Refrence by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
