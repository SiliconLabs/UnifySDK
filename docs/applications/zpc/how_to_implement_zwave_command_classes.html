<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Guideline for implementing Command Classes &mdash; Unify Host SDK</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/custom_styles.css" type="text/css" />
    <link rel="canonical" href="https://siliconlabs.github.io/UnifySDK/applications/zpc/how_to_implement_zwave_command_classes.html" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/js/charenc.js"></script>
        <script src="../../_static/js/crypt.js"></script>
        <script src="../../_static/js/sha1.js"></script>
        <script src="../../_static/js/html5-qrcode.min.js"></script>
        <script src="../../_static/js/qr_code_scanner.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Zigbee (ZigPC)" href="../../doc/protocol/zigbee/zigpc_introduction.html" />
    <link rel="prev" title="ZPC Debugging Guide" href="../../doc/readme_debug.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../doc/introduction.html" class="icon icon-home"> Unify
            <img src="../../_static/silicon-labs-logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                ver_1.5.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../doc/introduction.html">Unify Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc/running_unify.html">Running Unify on Raspberry Pi</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../doc/UnifySDK.html">Unify Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc/unify_framework_services.html">Framework Services</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../doc/protocol_controllers.html">Protocol Controllers</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../../doc/protocol/zwave/zpc_introduction.html">Z-Wave (ZPC)</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="readme_user.html">ZPC User’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="readme_certification.html">ZPC - Z-Wave (certification) Information</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../doc/readme_debug.html">ZPC Debugging Guide</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Guideline for implementing Command Classes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#defining-the-z-wave-command-class-attribute-state-data-model">Defining the Z-Wave Command Class attribute state data model</a></li>
<li class="toctree-l4"><a class="reference internal" href="#create-the-data-model-in-the-attribute-store">Create the data model in the Attribute Store</a></li>
<li class="toctree-l4"><a class="reference internal" href="#write-the-logic-of-the-command-class">Write the logic of the command class</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mapping-z-wave-to-dotdot-ucl-with-uam-file">Mapping Z-Wave to Dotdot UCL with .uam file</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unit-testing">Unit Testing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#z-wave-self-certification-with-the-compliance-test-tool-ctt">Z-Wave Self-Certification with the Compliance Test Tool (CTT)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="how_to_write_uam_files_for_the_zpc.html">UAM maps for the ZPC</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../doc/protocol/zigbee/zigpc_introduction.html">Zigbee (ZigPC)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../doc/multiprotocol.html">Multiprotocol Host Software</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../doc/protocol/matter/matter_mpc.html">Matter (MPC)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../doc/protocol/aox/aox_introduction.html">Bluetooth AoX (AoXPC)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../doc/unify_iot_services.html">IoT Services</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../doc/getting_started_as_developer.html">Getting Started as a Developer</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../doc/unify_specifications/index.html">Unify Specifications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc/system_requirements.html">System Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc/standards/known-abbreviations.html">Known Abbreviations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc/license.html">License</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../doc/introduction.html">Unify</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <script>
    $(".wy-side-scroll").append("<div class='github-button'><iframe src='https://ghbtns.com/github-btn.html?user=SiliconLabs&repo=UnifySDK&type=watch&count=true&size=large&v=2' allowtransparency='true' frameborder='0' scrolling='0' width='170' height='30'></iframe></div>");
</script>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="guideline-for-implementing-command-classes">
<h1>Guideline for implementing Command Classes<a class="headerlink" href="#guideline-for-implementing-command-classes" title="Permalink to this heading"></a></h1>
<div class="toctree-wrapper compound">
</div>
<p>This guide is meant to guide you to implement a new Z-Wave command class in Unify. We’ll go trough step by step following a real example : implementing the Sound Switch command class.</p>
<p>The following schema shows you a top level view of all the components we are using :</p>
<p><img alt="Overview" src="../../_images/zwave_command_class_integration.png" /></p>
<ul class="simple">
<li><p>The Z-Wave controller handles the Z-Wave commands and update the attribute store if needed.</p></li>
<li><p>The UCL updates the Attribute Store though commands.</p></li>
<li><p>The Attribute Store send events to :</p>
<ul>
<li><p>The attributes monitored by the Z-Wave controller</p></li>
<li><p>The attributes monitored by the UCL that triggers MQTT Broker messages.</p></li>
</ul>
</li>
<li><p>The .uam files allow to automatically update UCL attributes when Z-Wave attributes changes and vice versa.</p></li>
</ul>
<blockquote>
<div><p>NOTE : If you want the simplest example of a command class implementation you can look at the Binary Switch command class.</p>
</div></blockquote>
<section id="defining-the-z-wave-command-class-attribute-state-data-model">
<h2>Defining the Z-Wave Command Class attribute state data model<a class="headerlink" href="#defining-the-z-wave-command-class-attribute-state-data-model" title="Permalink to this heading"></a></h2>
<p>The first step is to define the data model of the Z-Wave Command Class attributes state. A good starting point is the Z-Wave command class specification (also available in the Z-Wave PC Controller tool). You can look at different commands (get/set/report) and see which attributes are worth saving.</p>
<p>A good approach is to also make sure that you can self-certify your command class with the Compliance Test Tool (CTT) proposed by the Z-Wave alliance. You can find out more about that in the <span class="xref myst">Z-Wave Compliance Test Tool (CTT) section</span>. We recommend to validate your implementation against the CTT tool.</p>
<p><img alt="Sound switch commands" src="../../_images/zwave_command_class_sound_switch_commands.png" /></p>
<p>Most of the commands should be already defined in <code class="docutils literal notranslate"><span class="pre">ZW_classcmd.h</span></code>. Not that this file might not contains all the definitions you need, but you can look in the GSDK folder that contains the same file but more up to date. Simply copy the attributes and commands you need in the local <code class="docutils literal notranslate"><span class="pre">ZW_classcmd.h</span></code>.</p>
<blockquote>
<div><p>NOTE : Don’t replace the new file by the old one as you might have some incompatibilities with the current command classes.</p>
</div></blockquote>
<p>Based on the commands we need the following attributes :</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Attribute</th>
<th>Description</th>
<th>Associated command</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tone number</td>
<td>Supported tone number count</td>
<td>Tones Number</td>
</tr>
<tr>
<td>Configured volume</td>
<td>Current default volume on the device</td>
<td>Configuration</td>
</tr>
<tr>
<td>Configured tone</td>
<td>Current default tone on the device</td>
<td>Configuration</td>
</tr>
<tr>
<td>Tone Identifier</td>
<td>One for each tone number reported</td>
<td>Tone Info</td>
</tr>
<tr>
<td>Tone info name</td>
<td>Tone Description (under each Tone Identifier)</td>
<td>Tone Info</td>
</tr>
<tr>
<td>Tone info duration</td>
<td>Tone Duration (under each Tone Identifier)</td>
<td>Tone Info</td>
</tr>
<tr>
<td>Play</td>
<td>The tone ID that the device plays. 0 to stop, 255 to play the default tone (Configuration command) and 1-254 to play a specific tone</td>
<td>Play</td>
</tr>
</tbody>
</table>
<p>With those attributes we cover all the commands needs. The following schema illustrates the attributes we use in our Sound Switch command class implementation :</p>
<p><img alt="Sound Switch" src="../../_images/attribute_store_sound_switch.png" /></p>
<p>Each attribute in our Attribute Store triggers Z-Wave commands.</p>
<p>We use a <code class="docutils literal notranslate"><span class="pre">TONE_INFO_IDENTIFIER</span></code> as a parent of <code class="docutils literal notranslate"><span class="pre">TONE_INFO_DURATION</span></code> and <code class="docutils literal notranslate"><span class="pre">TONE_INFO_NAME</span></code> because they are directly related. The Z-Wave specification tells us to send a <code class="docutils literal notranslate"><span class="pre">Tone</span> <span class="pre">Info</span> <span class="pre">Get</span></code> for each reported Tones Number. This way we can create as many <code class="docutils literal notranslate"><span class="pre">TONE_INFO_IDENTIFIER</span></code> node as needed.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">TONE_INFO_IDENTIFIER</span></code> triggers a Tone Info command while <code class="docutils literal notranslate"><span class="pre">CONFIGURED_DEFAULT_TONE_IDENTIFIER</span></code> triggers a Configuration command.</p>
<p>In the attribute store attributes has two states : defined and reported.</p>
<ul class="simple">
<li><p>If the reported value is missing, the controller sends a GET command to gather the reported value.</p></li>
<li><p>If the defined value is set, the controller sends a SET command to set the desired value.</p></li>
</ul>
<p>This mapping is explained in <span class="xref myst">Get/Set command section</span></p>
</section>
<section id="create-the-data-model-in-the-attribute-store">
<h2>Create the data model in the Attribute Store<a class="headerlink" href="#create-the-data-model-in-the-attribute-store" title="Permalink to this heading"></a></h2>
<p>After defining the data model, the next step is to define the type of each node in the attribute store.</p>
<p>In <code class="docutils literal notranslate"><span class="pre">applications\zpc\components\zpc_attribute_store\include\command_class_types</span></code> create an header that defines the types used in command class implementation. The naming convention is <code class="docutils literal notranslate"><span class="pre">zwave_command_class_{COMMAND_CLASS_NAME}.h</span></code></p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">///&gt; Tone identifier. uint8_t</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">sound_switch_tone_id_t</span><span class="p">;</span>
<span class="c1">///&gt; Tone duration. uint16_t</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">sound_switch_tone_duration_t</span><span class="p">;</span>

<span class="c1">///&gt; Volume representation. uint8_t</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">sound_switch_volume_t</span><span class="p">;</span>
</pre></div>
</div>
<p>You might want to update this file as you are writing the logic. Here we defined 3 attributes we use often in the Sound Switch class : the tone identifier, the tone duration and the volume.</p>
<section id="attribute-definition">
<h3>Attribute definition<a class="headerlink" href="#attribute-definition" title="Permalink to this heading"></a></h3>
<p>Then we need to create the attributes of command class to register them later in the attribute store. This is done in the
<code class="docutils literal notranslate"><span class="pre">attribute_store_defined_attribute_types.h</span></code> header.</p>
<p>To add an attribute you can use the <code class="docutils literal notranslate"><span class="pre">DEFINE_ATTRIBUTE</span></code> macro. Each attribute should have an unique ID on 16 bits :</p>
<div class="highlight-txt notranslate"><div class="highlight"><pre><span></span>[COMMAND_CLASS_ID][UNIQUE_ATTRIBUTE_ID]
[0x79][0x01]
</pre></div>
</div>
<p>Where <code class="docutils literal notranslate"><span class="pre">COMMAND_CLASS_ID</span></code> is the command class ID (found in <code class="docutils literal notranslate"><span class="pre">ZW_classcmd.h</span></code>) and
<code class="docutils literal notranslate"><span class="pre">UNIQUE_ATTRIBUTE_ID</span></code> is an arbitrary and unique ID to the command class.</p>
<p>The first attribute you have to declare is the supported version :</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">/// zwave_cc_version_t</span>
<span class="n">DEFINE_ATTRIBUTE</span><span class="p">(</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_VERSION</span><span class="p">,</span>
<span class="w">                 </span><span class="n">ZWAVE_CC_VERSION_ATTRIBUTE</span><span class="p">(</span><span class="n">COMMAND_CLASS_SOUND_SWITCH</span><span class="p">))</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">ZWAVE_CC_VERSION_ATTRIBUTE</span></code> macro set the unique attribute ID to 0x01. So you have to start your custom attribute listing to 0x02. We can define <code class="docutils literal notranslate"><span class="pre">CONFIGURED_DEFAULT_VOLUME</span></code> like :</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// Configured volume for the Sound Switch</span>
<span class="n">DEFINE_ATTRIBUTE</span><span class="p">(</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_VOLUME</span><span class="p">,</span>
<span class="w">                 </span><span class="p">((</span><span class="n">COMMAND_CLASS_SOUND_SWITCH</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x02</span><span class="p">))</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_VOLUME</span></code> has an ID of <code class="docutils literal notranslate"><span class="pre">0x7902</span></code>. This is used latter for mapping the attribute store Z-Wave attributes to the Dot Dot model.</p>
<p>A complete definition of our classes attribute can be found bellow :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// Sound Switch Command Class</span>
<span class="c1">///&lt; This represents the version of the Sound Switch Command class.</span>
<span class="c1">/// zwave_cc_version_t</span>
<span class="n">DEFINE_ATTRIBUTE</span><span class="p">(</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_VERSION</span><span class="p">,</span>
<span class="w">                 </span><span class="n">ZWAVE_CC_VERSION_ATTRIBUTE</span><span class="p">(</span><span class="n">COMMAND_CLASS_SOUND_SWITCH</span><span class="p">))</span>
<span class="c1">// Configured volume for the Sound Switch</span>
<span class="n">DEFINE_ATTRIBUTE</span><span class="p">(</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_VOLUME</span><span class="p">,</span>
<span class="w">                 </span><span class="p">((</span><span class="n">COMMAND_CLASS_SOUND_SWITCH</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x02</span><span class="p">))</span>
<span class="c1">// Configured tone for the Sound Switch</span>
<span class="n">DEFINE_ATTRIBUTE</span><span class="p">(</span>
<span class="w">  </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_TONE_IDENTIFIER</span><span class="p">,</span>
<span class="w">  </span><span class="p">((</span><span class="n">COMMAND_CLASS_SOUND_SWITCH</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x03</span><span class="p">))</span>
<span class="c1">// Number of tones supported by the receiving node</span>
<span class="n">DEFINE_ATTRIBUTE</span><span class="p">(</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONES_NUMBER</span><span class="p">,</span>
<span class="w">                 </span><span class="p">((</span><span class="n">COMMAND_CLASS_SOUND_SWITCH</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x04</span><span class="p">))</span>
<span class="n">DEFINE_ATTRIBUTE</span><span class="p">(</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_INFO_IDENTIFIER</span><span class="p">,</span>
<span class="w">                 </span><span class="p">((</span><span class="n">COMMAND_CLASS_SOUND_SWITCH</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x05</span><span class="p">))</span>
<span class="n">DEFINE_ATTRIBUTE</span><span class="p">(</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_INFO_DURATION_IN_SECONDS</span><span class="p">,</span>
<span class="w">                 </span><span class="p">((</span><span class="n">COMMAND_CLASS_SOUND_SWITCH</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x06</span><span class="p">))</span>
<span class="n">DEFINE_ATTRIBUTE</span><span class="p">(</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_INFO_NAME</span><span class="p">,</span>
<span class="w">                 </span><span class="p">((</span><span class="n">COMMAND_CLASS_SOUND_SWITCH</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x07</span><span class="p">))</span>
<span class="c1">// Command is used to instruct a supporting node to play (or stop playing) a tone.</span>
<span class="n">DEFINE_ATTRIBUTE</span><span class="p">(</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_PLAY</span><span class="p">,</span>
<span class="w">                 </span><span class="p">((</span><span class="n">COMMAND_CLASS_SOUND_SWITCH</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x08</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="attribute-registration">
<h3>Attribute registration<a class="headerlink" href="#attribute-registration" title="Permalink to this heading"></a></h3>
<p>Now that we have all our attributes defined we must register them in the attribute store. We can do that in the <code class="docutils literal notranslate"><span class="pre">zpc_attribute_store_type_registration.cpp</span></code> file.</p>
<p>You just need to add an new entry with :</p>
<ol class="arabic simple">
<li><p>Our attribute store name defined in <code class="docutils literal notranslate"><span class="pre">attribute_store_defined_attribute_types.h</span></code></p></li>
<li><p>A const String description of the attribute</p></li>
<li><p>The parent node. In most cases it is the <code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_ENDPOINT_ID</span></code>, but you can set it to another attribute if needed. The more attributes we put under the endpoint the poorer performance.</p></li>
<li><p>The type of the attribute. The complete enum can be found in <code class="docutils literal notranslate"><span class="pre">components/uic_attribute_store/include/attribute_store_type_registration.h</span></code>. If set the engine validates the value you try to write in it and raise an error if types are incompatible.</p></li>
</ol>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">{</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_VERSION</span><span class="p">,</span><span class="w">   </span><span class="s">&quot;Sound Switch Version&quot;</span><span class="p">,</span><span class="w">   </span><span class="n">ATTRIBUTE_ENDPOINT_ID</span><span class="p">,</span><span class="w">   </span><span class="n">U8_STORAGE_TYPE</span><span class="p">},</span>
</pre></div>
</div>
<p>The full sample can be found bellow :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="c1">/////////////////////////////////////////////////////////////////////</span>
<span class="w">  </span><span class="c1">//         Sound Switch Command Class attributes</span>
<span class="w">  </span><span class="c1">/////////////////////////////////////////////////////////////////////</span>
<span class="w">  </span><span class="p">{</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_VERSION</span><span class="p">,</span><span class="w">   </span><span class="s">&quot;Sound Switch Version&quot;</span><span class="p">,</span><span class="w">   </span><span class="n">ATTRIBUTE_ENDPOINT_ID</span><span class="p">,</span><span class="w">   </span><span class="n">U8_STORAGE_TYPE</span><span class="p">},</span>
<span class="w">  </span><span class="p">{</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_VOLUME</span><span class="p">,</span><span class="w">   </span><span class="s">&quot;Configured Default Volume&quot;</span><span class="p">,</span><span class="w">   </span><span class="n">ATTRIBUTE_ENDPOINT_ID</span><span class="p">,</span><span class="w">   </span><span class="n">U8_STORAGE_TYPE</span><span class="p">},</span>
<span class="w">  </span><span class="p">{</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_TONE_IDENTIFIER</span><span class="p">,</span><span class="w">   </span><span class="s">&quot;Configured Default Tone Identifier&quot;</span><span class="p">,</span><span class="w">   </span><span class="n">ATTRIBUTE_ENDPOINT_ID</span><span class="p">,</span><span class="w">   </span><span class="n">U8_STORAGE_TYPE</span><span class="p">},</span>
<span class="w">  </span><span class="p">{</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONES_NUMBER</span><span class="p">,</span><span class="w">   </span><span class="s">&quot;Tones Number&quot;</span><span class="p">,</span><span class="w">   </span><span class="n">ATTRIBUTE_ENDPOINT_ID</span><span class="p">,</span><span class="w">   </span><span class="n">U8_STORAGE_TYPE</span><span class="p">},</span>

<span class="w">  </span><span class="p">{</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_INFO_IDENTIFIER</span><span class="p">,</span><span class="w">   </span><span class="s">&quot;Tone Info Identifier&quot;</span><span class="p">,</span><span class="w">  </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONES_NUMBER</span><span class="p">,</span><span class="w">   </span><span class="n">U8_STORAGE_TYPE</span><span class="p">},</span>

<span class="w">  </span><span class="p">{</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_INFO_DURATION_IN_SECONDS</span><span class="p">,</span><span class="w">   </span><span class="s">&quot;Tone Info Duration (seconds)&quot;</span><span class="p">,</span><span class="w">   </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_INFO_IDENTIFIER</span><span class="p">,</span><span class="w">   </span><span class="n">U16_STORAGE_TYPE</span><span class="p">},</span>
<span class="w">  </span><span class="p">{</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_INFO_NAME</span><span class="p">,</span><span class="w">   </span><span class="s">&quot;Tone Info Name&quot;</span><span class="p">,</span><span class="w">   </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_INFO_IDENTIFIER</span><span class="p">,</span><span class="w">   </span><span class="n">C_STRING_STORAGE_TYPE</span><span class="p">},</span>

<span class="w">  </span><span class="p">{</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_PLAY</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Tone Play&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ATTRIBUTE_ENDPOINT_ID</span><span class="p">,</span><span class="w"> </span><span class="n">U8_STORAGE_TYPE</span><span class="p">},</span>
</pre></div>
</div>
<p>You can see that <code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_INFO_DURATION_IN_SECONDS</span></code> and <code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_INFO_NAME</span></code> parents are <code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_INFO_IDENTIFIER</span></code> and not <code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_ENDPOINT_ID</span></code>. This is because those parameters depends directly on the value <code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_INFO_IDENTIFIER</span></code> and we do not want to surcharge our endpoint tree.</p>
</section>
</section>
<section id="write-the-logic-of-the-command-class">
<h2>Write the logic of the command class<a class="headerlink" href="#write-the-logic-of-the-command-class" title="Permalink to this heading"></a></h2>
<section id="base-skeleton-creation">
<h3>Base skeleton creation<a class="headerlink" href="#base-skeleton-creation" title="Permalink to this heading"></a></h3>
<p>Now that our attributes are known to the Attribute Store we can start implementing our command class logic.</p>
<p>You can create a new header in <code class="docutils literal notranslate"><span class="pre">applications\zpc\components\zwave_command_classes\src</span></code> with the following name pattern :
<code class="docutils literal notranslate"><span class="pre">zwave_command_class_{COMMAND_CLASS_NAME}.h</span></code> where <code class="docutils literal notranslate"><span class="pre">{COMMAND_CLASS_NAME}</span></code> is your Z-Wave command class name. In our example our new header is :  <code class="docutils literal notranslate"><span class="pre">zwave_command_class_sound_switch.h</span></code></p>
<p>Repeat this process for the source file. Note that you can use either <code class="docutils literal notranslate"><span class="pre">.c</span></code> or <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> file as long as your header is <code class="docutils literal notranslate"><span class="pre">C</span></code> compatible. For our example we create the file <code class="docutils literal notranslate"><span class="pre">zwave_command_class_sound_switch.c</span></code>.</p>
<p>We need to add the source file to the <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> located in <code class="docutils literal notranslate"><span class="pre">applications\zpc\components\zwave_command_classes\</span></code> :</p>
<div class="highlight-CMake notranslate"><div class="highlight"><pre><span></span><span class="nb">add_library</span><span class="p">(</span>
<span class="w">  </span><span class="s">zwave_command_classes</span>
<span class="w">  </span><span class="s">platform/</span><span class="o">${</span><span class="nv">COMPATIBLE_PLATFORM</span><span class="o">}</span><span class="s">/platform_date_time.c</span>
<span class="w">  </span><span class="s">platform/</span><span class="o">${</span><span class="nv">COMPATIBLE_PLATFORM</span><span class="o">}</span><span class="s">/platform_exec.c</span>
<span class="w">  </span>
<span class="w">  </span><span class="s">//...</span>
<span class="w">  </span>
<span class="w">  </span><span class="s">src/zwave_command_class_sound_switch.c</span>
<span class="w">  </span>
<span class="w">  </span><span class="s">//...</span>
<span class="w">  </span>
<span class="w">  </span><span class="s">src/zwave_command_class_transport_service.c</span><span class="p">)</span>
</pre></div>
</div>
<p>This ensures that our new file is correctly added to the build system. No need to include the header.</p>
<p>We recommend to fill your new header file with the contents of existing command classes header. Doxygen documentation is based on the structure of this header to create the section about the new command class.</p>
<p>We need at least one function to act as an entry point. The naming convention is <code class="docutils literal notranslate"><span class="pre">zwave_command_class_{class_name}_init</span></code>, where <code class="docutils literal notranslate"><span class="pre">{class_name}</span></code> is the current Z-Wave class name. In our example we declare the function <code class="docutils literal notranslate"><span class="pre">zwave_command_class_sound_switch_init</span></code>. Our <code class="docutils literal notranslate"><span class="pre">zwave_command_class_sound_switch.h</span></code> should look like that :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @defgroup zwave_command_class_sound_switch</span>
<span class="cm"> * @brief Sound Switch Command Class handlers and control function</span>
<span class="cm"> *</span>
<span class="cm"> * This module implement some of the functions to control the</span>
<span class="cm"> * Sound Switch Command Class</span>
<span class="cm"> *</span>
<span class="cm"> * @{</span>
<span class="cm"> */</span>

<span class="cp">#ifndef ZWAVE_COMMAND_CLASS_SOUND_SWITCH_H</span>
<span class="cp">#define ZWAVE_COMMAND_CLASS_SOUND_SWITCH_H</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;sl_status.h&quot;</span>

<span class="cp">#ifdef __cplusplus</span>
<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#endif</span>

<span class="n">sl_status_t</span><span class="w"> </span><span class="nf">zwave_command_class_sound_switch_init</span><span class="p">();</span>

<span class="cp">#ifdef __cplusplus</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#endif  </span><span class="c1">//ZWAVE_COMMAND_CLASS_SOUND_SWITCH_H</span>
<span class="cm">/** @} end zwave_command_class_sound_switch */</span>
</pre></div>
</div>
<p>For now we fill our source file with an empty definition :</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// System</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;zwave_command_class_sound_switch.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;zwave_command_classes_utils.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ZW_classcmd.h&quot;</span>

<span class="c1">// Includes from other ZPC Components</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;zwave_command_class_indices.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;zwave_command_handler.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;zwave_command_class_version_types.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;zpc_attribute_store_network_helper.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;attribute_store_defined_attribute_types.h&quot;</span>

<span class="c1">// Unify</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;attribute_resolver.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;attribute_store.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;attribute_store_helper.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;sl_log.h&quot;</span>

<span class="cp">#define LOG_TAG &quot;zwave_command_class_sound_switch&quot;</span>


<span class="n">sl_status_t</span><span class="w"> </span><span class="nf">zwave_command_class_sound_switch_init</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">SL_STATUS_OK</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that some header were also added to the skeleton. They are here for later, but feel free to remove the unused ones when you are finished.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">LOG_TAG</span></code> should be used when calling <code class="docutils literal notranslate"><span class="pre">sl_log_xxx()</span></code> function (<code class="docutils literal notranslate"><span class="pre">sl_log_warning(LOG_TAG,</span> <span class="pre">&quot;My</span> <span class="pre">warning&quot;);</span></code>). This ensure that all messages that comes from this class is under the same tag. This is useful to filter logs based on the component we are interested in.</p>
<p>Now that we have our entry point we have to call it in the <code class="docutils literal notranslate"><span class="pre">zwave_command_class_fixt.c</span></code> file. First we need to include our header and then call it from the function <code class="docutils literal notranslate"><span class="pre">zwave_command_classes_init()</span></code> :</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// ...</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;zwave_command_class_sound_switch.h&quot;</span>
<span class="c1">// ...</span>

<span class="n">sl_status_t</span><span class="w"> </span><span class="nf">zwave_command_classes_init</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">sl_status_t</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SL_STATUS_OK</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Special handlers:</span>
<span class="w">  </span><span class="n">status</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">zwave_command_class_granted_keys_resolver_init</span><span class="p">();</span>
<span class="w">  </span><span class="n">status</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">zwave_command_class_node_info_resolver_init</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Do not abort initialization of other CCs if one fails.</span>
<span class="w">  </span><span class="c1">// Command Class handlers</span>
<span class="w">  </span><span class="c1">// Note: AGI should stay first, it allows others to register commands.</span>
<span class="w">  </span><span class="n">status</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">zwave_command_class_agi_init</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// ...</span>
<span class="w">  </span><span class="n">status</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">zwave_command_class_sound_switch_init</span><span class="p">();</span>
<span class="w">  </span><span class="c1">// ...</span>

<span class="w">  </span><span class="n">zwave_command_handler_print_info</span><span class="p">(</span><span class="mi">-1</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now that our skeleton is up and running we can start implement our new command class.</p>
</section>
<section id="implementation">
<h3>Implementation<a class="headerlink" href="#implementation" title="Permalink to this heading"></a></h3>
<section id="global-handler">
<h4>Global handler<a class="headerlink" href="#global-handler" title="Permalink to this heading"></a></h4>
<p>Let’s populate our initialization function (<code class="docutils literal notranslate"><span class="pre">zwave_command_class_sound_switch_init</span></code>). The first thing to do is to add an command handler :</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">sl_status_t</span><span class="w"> </span><span class="nf">zwave_command_class_sound_switch_init</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">zwave_command_handler_t</span><span class="w"> </span><span class="n">handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="w">  </span><span class="n">handler</span><span class="p">.</span><span class="n">support_handler</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">  </span><span class="n">handler</span><span class="p">.</span><span class="n">control_handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">  </span><span class="n">handler</span><span class="p">.</span><span class="n">minimal_scheme</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">ZWAVE_CONTROLLER_ENCAPSULATION_NONE</span><span class="p">;</span>
<span class="w">  </span><span class="n">handler</span><span class="p">.</span><span class="n">manual_security_validation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">  </span><span class="n">handler</span><span class="p">.</span><span class="n">command_class</span><span class="w">              </span><span class="o">=</span><span class="w"> </span><span class="n">COMMAND_CLASS_SOUND_SWITCH</span><span class="p">;</span>
<span class="w">  </span><span class="n">handler</span><span class="p">.</span><span class="n">version</span><span class="w">                    </span><span class="o">=</span><span class="w"> </span><span class="n">SOUND_SWITCH_VERSION</span><span class="p">;</span>
<span class="w">  </span><span class="n">handler</span><span class="p">.</span><span class="n">command_class_name</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Sound Switch&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">handler</span><span class="p">.</span><span class="n">comments</span><span class="w">                   </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">zwave_command_handler_register_handler</span><span class="p">(</span><span class="n">handler</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This snippet registers the handler for your Z-Wave command class. The handler options are :</p>
<ul class="simple">
<li><p><strong>support_handler</strong> : Support handler for the Z-Wave command class. This allows you to react when receiving Get/Set commands. Some example of this handler can be found in already implemented command classes (<code class="docutils literal notranslate"><span class="pre">indicator</span></code>, <code class="docutils literal notranslate"><span class="pre">powerlevel</span></code>, <code class="docutils literal notranslate"><span class="pre">inclusion_controller</span></code>, …).</p></li>
<li><p><strong>control_handler</strong> : Control handler for the Z-Wave command class. This allows you to react to Report commands.</p></li>
<li><p><strong>minimal_scheme</strong> : The minimal security level which this command is supported on. This is ignored for the control_handler.</p></li>
<li><p><strong>manual_security_validation</strong> : Use manual-security filtering for incoming frames. If set to true, the command class dispatch handler send frames to the handler without validating their security level.If set to false, the command class handler can assume that the frame has been received at an approved security level.</p></li>
<li><p><strong>command_class</strong> : command class ID that this handler implements</p></li>
<li><p><strong>version</strong> : Maximal version supported of the command class</p></li>
<li><p><strong>command_class_name</strong> : Description of the current command class (no need to include “Command class”)</p></li>
<li><p><strong>comments</strong> : Comments about the implementation. It is printed to the log when starting the zpc component.</p></li>
</ul>
<p>Now that we have an handler, let’s implement the get/set/report command classes for <code class="docutils literal notranslate"><span class="pre">Configuration</span></code>.</p>
</section>
<section id="initialize-attributes">
<h4>Initialize attributes<a class="headerlink" href="#initialize-attributes" title="Permalink to this heading"></a></h4>
<p>One of the first thing the controller is doing is to update the version attribute. That’s why the version attribute always has an unique attribute ID of 0x01. You can subscribe to changes to an attribute with the <code class="docutils literal notranslate"><span class="pre">attribute_store_register_callback_by_type</span></code>. This is also the best place to initialize your attributes.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">attribute_store_register_callback_by_type</span></code> function takes 2 arguments :</p>
<ul class="simple">
<li><p>A callback function that takes two arguments :</p>
<ul>
<li><p><strong>attribute_store_node_t</strong> <em>updated_node</em> : The node ID of the attribute</p></li>
<li><p><strong>attribute_store_change_t</strong> <em>change</em> : Type of change</p></li>
</ul>
</li>
<li><p>The attribute to monitor. In our case <code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_VERSION</span></code>.</p></li>
</ul>
<p>We can call this function in our entrypoint <code class="docutils literal notranslate"><span class="pre">zwave_command_class_sound_switch_init</span></code> before the handler definition :</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">sl_status_t</span><span class="w"> </span><span class="nf">zwave_command_class_sound_switch_init</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">attribute_store_register_callback_by_type</span><span class="p">(</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">zwave_command_class_sound_switch_on_version_attribute_update</span><span class="p">,</span>
<span class="w">    </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_VERSION</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// ...</span>
<span class="w">  </span><span class="c1">// handler definition</span>
<span class="w">  </span><span class="c1">// ... </span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">zwave_command_handler_register_handler</span><span class="p">(</span><span class="n">handler</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This calls <code class="docutils literal notranslate"><span class="pre">zwave_command_class_sound_switch_on_version_attribute_update</span></code> on each update of <code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_VERSION</span></code>.</p>
<p>Our implementation of <code class="docutils literal notranslate"><span class="pre">zwave_command_class_sound_switch_on_version_attribute_update</span></code> look like this :</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">zwave_command_class_sound_switch_on_version_attribute_update</span><span class="p">(</span>
<span class="w">  </span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">updated_node</span><span class="p">,</span><span class="w"> </span><span class="n">attribute_store_change_t</span><span class="w"> </span><span class="n">change</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">change</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ATTRIBUTE_DELETED</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">zwave_cc_version_t</span><span class="w"> </span><span class="n">version</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="n">attribute_store_get_reported</span><span class="p">(</span><span class="n">updated_node</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">version</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">version</span><span class="p">));</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">version</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">endpoint_node</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">attribute_store_get_first_parent_with_type</span><span class="p">(</span><span class="n">updated_node</span><span class="p">,</span>
<span class="w">                                                 </span><span class="n">ATTRIBUTE_ENDPOINT_ID</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// The order of the attribute matter since it defines the order of the</span>
<span class="w">  </span><span class="c1">// Z-Wave get command order.</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">attribute_store_type_t</span><span class="w"> </span><span class="n">attributes</span><span class="p">[]</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONES_NUMBER</span><span class="p">,</span><span class="w">       </span>
<span class="w">      </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_VOLUME</span><span class="p">,</span>
<span class="w">      </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_TONE_IDENTIFIER</span><span class="p">,</span>
<span class="w">      </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_INFO_IDENTIFIER</span><span class="p">,</span>
<span class="w">      </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_PLAY</span><span class="p">};</span>

<span class="w">  </span><span class="n">attribute_store_add_if_missing</span><span class="p">(</span><span class="n">endpoint_node</span><span class="p">,</span>
<span class="w">                                 </span><span class="n">attributes</span><span class="p">,</span>
<span class="w">                                 </span><span class="n">COUNT_OF</span><span class="p">(</span><span class="n">attributes</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">change</span></code> attribute tells you which operation is currently performed on this attribute (deleted, added or modified). We then try to get the version from the attribute store. It is possible that we don’t have the value reported yet, so we simply return and do nothing. If we have the version we can create the base structure of our attributes with the <code class="docutils literal notranslate"><span class="pre">attribute_store_add_if_missing</span></code> function.</p>
<blockquote>
<div><p>NOTE : We don’t define our attributes under the <code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_INFO_IDENTIFIER</span></code>, they are created once they are reported. The <code class="docutils literal notranslate"><span class="pre">attribute_store_set_child_reported()</span></code> function adds the attribute in the tree if they are missing. You can check the details in <code class="docutils literal notranslate"><span class="pre">zwave_command_class_sound_switch_handle_tone_info_report</span></code> function.</p>
</div></blockquote>
</section>
<section id="get-set-command">
<h4>Get/Set command<a class="headerlink" href="#get-set-command" title="Permalink to this heading"></a></h4>
<p>We’ll take the example of following commands : <code class="docutils literal notranslate"><span class="pre">CONFIGURATION_GET</span></code> and <code class="docutils literal notranslate"><span class="pre">CONFIGURATION_SET</span></code></p>
<p>We can easily map the set/get function to an attribute of the Attribute Store.
Here we want to map the previously defined attributes :</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_VOLUME</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_TONE_IDENTIFIER</span></code></p></li>
</ul>
<p>Since they are both used in argument of the <code class="docutils literal notranslate"><span class="pre">Z-Wave</span> <span class="pre">set</span></code>.</p>
<p>We can do this with the <code class="docutils literal notranslate"><span class="pre">attribute_resolver_register_rule</span></code> function that takes 3 arguments :</p>
<ul class="simple">
<li><p>The attribute store identifier</p></li>
<li><p>The associated callback for set function (can be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>)</p></li>
<li><p>The associated callback for get function (can be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>)</p></li>
</ul>
<p>This function listen to changes on the given attributes and call the get/set functions accordingly :</p>
<ul class="simple">
<li><p>If ONLY a get function is given, the get function is called if we don’t have a reported value. You can test this behavior with the ZPC command <code class="docutils literal notranslate"><span class="pre">ZPC&gt;</span> <span class="pre">attribute_store_undefine_reported</span> <span class="pre">NodeID</span></code></p></li>
<li><p>If a set function or both functions are given the defined functions are called on desired value change. You can test this behavior with the ZPC command <code class="docutils literal notranslate"><span class="pre">ZPC&gt;</span> <span class="pre">attribute_store_set_desired</span> <span class="pre">NodeID</span></code>.</p></li>
</ul>
<blockquote>
<div><p>NOTE : ZPC CLI is treated in the <span class="xref myst">Testing our implementation</span> section.</p>
</div></blockquote>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">attribute_resolver_register_rule</span><span class="p">(</span>
<span class="w">    </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_VOLUME</span><span class="p">,</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">zwave_command_class_sound_switch_configuration_set</span><span class="p">,</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">zwave_command_class_sound_switch_configuration_get</span><span class="p">);</span>

<span class="w">  </span><span class="n">attribute_resolver_register_rule</span><span class="p">(</span>
<span class="w">    </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_TONE_IDENTIFIER</span><span class="p">,</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">zwave_command_class_sound_switch_configuration_set</span><span class="p">,</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">zwave_command_class_sound_switch_configuration_get</span><span class="p">);</span>
</pre></div>
</div>
<p>Each attribute can have only one rule, but it is not necessary to register a rule for all the attributes. A rule is necessary only for attributes that are used from a set or/and get function.</p>
<p>The callbacks must take 3 arguments :</p>
<ol class="arabic simple">
<li><p><strong>attribute_store_node_t</strong> <em>node</em> : Current node ID of the attribute that trigger this callback.</p></li>
<li><p><strong>int8_t</strong> <em>*frame</em> : A pointer to the frame that will be sent. It has to be filled by the callback.</p></li>
<li><p><strong>uint16_t</strong> <em>*frame_length</em> :  A pointer to the frame length. It has to be filled by the callback.</p></li>
</ol>
<p>The node ID can be visualized with the ZPC commands <code class="docutils literal notranslate"><span class="pre">attribute_store_log_xxx</span></code>. Here is a truncated result of <code class="docutils literal notranslate"><span class="pre">ZPC&gt;</span> <span class="pre">attribute_store_log_search</span> <span class="pre">Tone</span></code> :</p>
<div class="highlight-txt notranslate"><div class="highlight"><pre><span></span>(1) Root node .................................................................     &lt;&gt; (&lt;&gt;)
    │───(2) HomeID ............................................................ [58,27,e5,fc] (&lt;&gt;)
    │   │───(8) NodeID ........................................................      3 (&lt;&gt;)
    │   │   │───(9) Endpoint ID ...............................................      0 (&lt;&gt;)
    │   │   │   │───(80) Configured Default Tone Identifier ...................      4 (&lt;&gt;)
    │   │   │   │───(81) Tones Number .........................................     30 (&lt;&gt;)
    │   │   │   │───(84) Tone Info Identifier .................................      4 (&lt;&gt;)
    │   │   │   │   │───(211) Tone Info Duration ..............................      1 (&lt;&gt;)
    │   │   │   │   │───(212) Tone Info Name .................................. &quot;04 Electric Apartment Buzzer&quot; (&lt;&gt;)
    │   │   │   │───(85) Tone Play ............................................      0 (&lt;&gt;)
</pre></div>
</div>
<p>The node ID is represented by the number between parenthesis. The <em>node</em> argument has the ID of the monitored attribute.</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">Tone</span> <span class="pre">Info</span> <span class="pre">Identifier</span></code> attribute is bonded to a get only function. That means if the reported value is undefined (e.g at startup with an empty attribute store), the get callback for the endpoint 0 has its <em>node</em> argument set to 81.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">Configured</span> <span class="pre">Default</span> <span class="pre">Tone</span> <span class="pre">Identifier</span></code> attribute is bonded to both get and set function. If something changes, the callback (set or get) for the endpoint 0 has its <em>node</em> argument set to 80.</p></li>
</ul>
<p>The get function is the most straight forward : it doesn’t require any argument we only need to send the frame.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">sl_status_t</span><span class="w"> </span><span class="nf">zwave_command_class_sound_switch_configuration_get</span><span class="p">(</span>
<span class="w">  </span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">frame</span><span class="p">,</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="o">*</span><span class="n">frame_length</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">node</span><span class="p">;</span><span class="w">  </span><span class="c1">// unused.</span>
<span class="w">  </span><span class="n">ZW_SOUND_SWITCH_CONFIGURATION_GET_FRAME</span><span class="w"> </span><span class="o">*</span><span class="n">get_frame</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ZW_SOUND_SWITCH_CONFIGURATION_GET_FRAME</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">frame</span><span class="p">;</span>
<span class="w">  </span><span class="n">get_frame</span><span class="o">-&gt;</span><span class="n">cmdClass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">COMMAND_CLASS_SOUND_SWITCH</span><span class="p">;</span>
<span class="w">  </span><span class="n">get_frame</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">SOUND_SWITCH_CONFIGURATION_GET</span><span class="p">;</span>
<span class="w">  </span><span class="o">*</span><span class="n">frame_length</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">ZW_SOUND_SWITCH_CONFIGURATION_GET_FRAME</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">SL_STATUS_OK</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The set function in the other hand is less straight forward : we have to get the elements in the attribute store and give to the <code class="docutils literal notranslate"><span class="pre">Z-Wave</span> <span class="pre">set</span></code> command.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">sl_status_t</span><span class="w"> </span><span class="nf">zwave_command_class_sound_switch_configuration_set</span><span class="p">(</span>
<span class="w">  </span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">frame</span><span class="p">,</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="o">*</span><span class="n">frame_length</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">sound_switch_configuration_t</span><span class="w"> </span><span class="n">configuration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">endpoint_id_node</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">attribute_store_get_first_parent_with_type</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">ATTRIBUTE_ENDPOINT_ID</span><span class="p">);</span>

<span class="w">  </span><span class="n">get_configuration</span><span class="p">(</span><span class="n">endpoint_id_node</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">configuration</span><span class="p">);</span>

<span class="w">  </span><span class="n">ZW_SOUND_SWITCH_CONFIGURATION_SET_FRAME</span><span class="w"> </span><span class="o">*</span><span class="n">set_frame</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ZW_SOUND_SWITCH_CONFIGURATION_SET_FRAME</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">frame</span><span class="p">;</span>
<span class="w">  </span><span class="n">set_frame</span><span class="o">-&gt;</span><span class="n">cmdClass</span><span class="w">              </span><span class="o">=</span><span class="w"> </span><span class="n">COMMAND_CLASS_SOUND_SWITCH</span><span class="p">;</span>
<span class="w">  </span><span class="n">set_frame</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="w">                   </span><span class="o">=</span><span class="w"> </span><span class="n">SOUND_SWITCH_CONFIGURATION_SET</span><span class="p">;</span>
<span class="w">  </span><span class="n">set_frame</span><span class="o">-&gt;</span><span class="n">volume</span><span class="w">                </span><span class="o">=</span><span class="w"> </span><span class="n">configuration</span><span class="p">.</span><span class="n">volume</span><span class="p">;</span>
<span class="w">  </span><span class="n">set_frame</span><span class="o">-&gt;</span><span class="n">defaultToneIdentifier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">configuration</span><span class="p">.</span><span class="n">tone</span><span class="p">;</span>
<span class="w">  </span><span class="o">*</span><span class="n">frame_length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">ZW_SOUND_SWITCH_CONFIGURATION_SET_FRAME</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">SL_STATUS_OK</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You can have a peek in the current attribute store by executing <code class="docutils literal notranslate"><span class="pre">ZPC&gt;</span> <span class="pre">attribute_store_log_search</span> <span class="pre">Tone</span></code> (more info on CLI in the section <span class="xref myst">Testing our implementation</span>). The following sample also has the result of <code class="docutils literal notranslate"><span class="pre">ZPC&gt;</span> <span class="pre">attribute_store_log_search</span> <span class="pre">Volume</span></code> :</p>
<div class="highlight-txt notranslate"><div class="highlight"><pre><span></span>    │   │   │───(9) Endpoint ID ...............................................      0 (&lt;&gt;)
    │   │   │   │───(75) Configured Default Volume ............................      1 (&lt;&gt;)
    │   │   │   │───(80) Configured Default Tone Identifier ...................      4 (&lt;&gt;)
    │   │   │   │───(81) Tones Number .........................................     1 (&lt;&gt;)
    |   │   │   │   │───(84) Tone Info Identifier .................................      1 (&lt;&gt;)
    |   │   │   │   │   │───(211) Tone Info Duration ..............................      10 (&lt;&gt;)
    |   │   │   │   │   │───(212) Tone Info Name .................................. &quot;01 Electric Apartment Buzzer&quot; (&lt;&gt;)
    |   |   │   │   │───(89) Tone Info Identifier .................................      2 (&lt;&gt;)
    |   │   │   │   │   │───(214) Tone Info Duration ..............................      1312 (&lt;&gt;)
    |   │   │   │   │   │───(215) Tone Info Name .................................. &quot;02 Alarm Buzzer&quot; (&lt;&gt;)
    │   │   │   │───(85) Tone Play ............................................      1 (&lt;&gt;)
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">node</span></code> argument here is set to either the node ID of <code class="docutils literal notranslate"><span class="pre">Configured</span> <span class="pre">Default</span> <span class="pre">Volume</span></code> (75) or <code class="docutils literal notranslate"><span class="pre">Configured</span> <span class="pre">Default</span> <span class="pre">Tone</span> <span class="pre">Identifier</span></code> (80).</p>
<p>However we need to access both of those values. To do so we get <code class="docutils literal notranslate"><span class="pre">Endpoint</span> <span class="pre">ID</span></code> node ID : this allows us to have access to all its children.</p>
<p>The function <code class="docutils literal notranslate"><span class="pre">attribute_store_get_first_parent_with_type(node,</span> <span class="pre">ATTRIBUTE_ENDPOINT_ID)</span></code> searches for the first parent with <code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_ENDPOINT_ID</span></code> type : here it is the node (9).</p>
<p>Once we have the parent node ID, we can pass it to the <code class="docutils literal notranslate"><span class="pre">get_configuration()</span></code> function that fetches the information we need :</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sound_switch_configuration</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">sound_switch_volume_t</span><span class="w"> </span><span class="n">volume</span><span class="p">;</span>
<span class="w">  </span><span class="n">sound_switch_tone_id_t</span><span class="w"> </span><span class="n">tone</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">sound_switch_configuration_t</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">get_configuration</span><span class="p">(</span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">state_node</span><span class="p">,</span>
<span class="w">                              </span><span class="n">sound_switch_configuration_t</span><span class="w"> </span><span class="o">*</span><span class="n">configuration</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">volume_node</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">attribute_store_get_first_child_by_type</span><span class="p">(</span><span class="n">state_node</span><span class="p">,</span>
<span class="w">                                              </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_VOLUME</span><span class="p">);</span>

<span class="w">  </span><span class="n">sl_status_t</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">attribute_store_get_desired_else_reported</span><span class="p">(</span><span class="n">volume_node</span><span class="p">,</span><span class="w"> </span>
<span class="w">                              </span><span class="o">&amp;</span><span class="n">configuration</span><span class="o">-&gt;</span><span class="n">volume</span><span class="p">,</span>
<span class="w">                              </span><span class="k">sizeof</span><span class="p">(</span><span class="n">configuration</span><span class="o">-&gt;</span><span class="n">volume</span><span class="p">));</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">status</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">SL_STATUS_OK</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">configuration</span><span class="o">-&gt;</span><span class="n">volume</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">sl_log_warning</span><span class="p">(</span><span class="n">LOG_TAG</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Can&#39;t get CONFIGURED_DEFAULT_VOLUME from attribute store. Value set to 0.&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">tone_node</span><span class="w"> </span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">attribute_store_get_first_child_by_type</span><span class="p">(</span><span class="n">state_node</span><span class="p">,</span>
<span class="w">                                              </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_TONE_IDENTIFIER</span><span class="p">);</span>

<span class="w">  </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">attribute_store_get_desired_else_reported</span><span class="p">(</span><span class="n">tone_node</span><span class="p">,</span>
<span class="w">                             </span><span class="o">&amp;</span><span class="n">configuration</span><span class="o">-&gt;</span><span class="n">tone</span><span class="p">,</span>
<span class="w">                             </span><span class="k">sizeof</span><span class="p">(</span><span class="n">configuration</span><span class="o">-&gt;</span><span class="n">tone</span><span class="p">));</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">status</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">SL_STATUS_OK</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">configuration</span><span class="o">-&gt;</span><span class="n">tone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">sl_log_warning</span><span class="p">(</span><span class="n">LOG_TAG</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Can&#39;t get CONFIGURED_DEFAULT_TONE_IDENTIFIER from attribute store. Value set to 0.&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">attribute_store_get_first_child_by_type()</span></code> function fetches the node ID of given type. Once we have the correct node ID, we can fetch its value with various <code class="docutils literal notranslate"><span class="pre">attribute_store_get_xxx()</span></code> functions. Here we use <code class="docutils literal notranslate"><span class="pre">attribute_store_get_desired_else_reported()</span></code> because we want either the desired or reported value of the attribute. If something goes wrong the function returns an error code and we set default values.</p>
</section>
<section id="report-callback">
<h4>Report callback<a class="headerlink" href="#report-callback" title="Permalink to this heading"></a></h4>
<p>In the handler we defined previously we’ll need to add a control handler :</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="c1">// ...</span>
<span class="w">  </span><span class="n">handler</span><span class="p">.</span><span class="n">control_handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">zwave_command_class_sound_switch_control_handler</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// ...</span>
</pre></div>
</div>
<p>The control handler is called when the controller receives a report command. You can then check which report was sent and update the values in attribute store.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">sl_status_t</span><span class="w"> </span><span class="nf">zwave_command_class_sound_switch_control_handler</span><span class="p">(</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">zwave_controller_connection_info_t</span><span class="w"> </span><span class="o">*</span><span class="n">connection_info</span><span class="p">,</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">frame_data</span><span class="p">,</span>
<span class="w">  </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">frame_length</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">frame_length</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">COMMAND_INDEX</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">SL_STATUS_NOT_SUPPORTED</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">frame_data</span><span class="p">[</span><span class="n">COMMAND_INDEX</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">SOUND_SWITCH_CONFIGURATION_REPORT</span><span class="p">:</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">zwave_command_class_sound_switch_handle_configuration_report</span><span class="p">(</span>
<span class="w">        </span><span class="n">connection_info</span><span class="p">,</span>
<span class="w">        </span><span class="n">frame_data</span><span class="p">,</span>
<span class="w">        </span><span class="n">frame_length</span><span class="p">);</span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">SL_STATUS_NOT_SUPPORTED</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The control handler function takes 3 arguments :</p>
<ul class="simple">
<li><p><strong>zwave_controller_connection_info_t</strong> <em>*connection_info</em> : Structure holding information about the source and destination when transmitting and receiving Z-Wave frames. You can retrieve the endpoint node ID in the attribute store with <code class="docutils literal notranslate"><span class="pre">zwave_command_class_get_endpoint_node(connection_info)</span></code></p></li>
<li><p><strong>uint8_t</strong> <em>*frame_data</em> : frame received</p></li>
<li><p><strong>uint16_t</strong> <em>frame_length</em> : length of frame received</p></li>
</ul>
<p>We can take a look at the function that process the report frame :</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">sl_status_t</span><span class="w"> </span><span class="nf">zwave_command_class_sound_switch_handle_configuration_report</span><span class="p">(</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">zwave_controller_connection_info_t</span><span class="w"> </span><span class="o">*</span><span class="n">connection_info</span><span class="p">,</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">frame_data</span><span class="p">,</span>
<span class="w">  </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">frame_length</span><span class="p">)</span>
<span class="p">{</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">frame_length</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">SL_STATUS_FAIL</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">endpoint_node</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">zwave_command_class_get_endpoint_node</span><span class="p">(</span><span class="n">connection_info</span><span class="p">);</span>

<span class="w">  </span><span class="n">sound_switch_volume_t</span><span class="w"> </span><span class="n">volume</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">frame_data</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">volume</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">sl_log_warning</span><span class="p">(</span><span class="n">LOG_TAG</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Node reported volume higher than 100&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">volume</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">attribute_store_set_child_reported</span><span class="p">(</span>
<span class="w">    </span><span class="n">endpoint_node</span><span class="p">,</span>
<span class="w">    </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_VOLUME</span><span class="p">,</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">volume</span><span class="p">,</span>
<span class="w">    </span><span class="k">sizeof</span><span class="p">(</span><span class="n">volume</span><span class="p">));</span>

<span class="w">  </span><span class="n">sound_switch_tone_id_t</span><span class="w"> </span><span class="n">tone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">frame_data</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

<span class="w">  </span><span class="n">attribute_store_set_child_reported</span><span class="p">(</span>
<span class="w">    </span><span class="n">endpoint_node</span><span class="p">,</span>
<span class="w">    </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_TONE_IDENTIFIER</span><span class="p">,</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">tone</span><span class="p">,</span>
<span class="w">    </span><span class="k">sizeof</span><span class="p">(</span><span class="n">tone</span><span class="p">));</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">SL_STATUS_OK</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It’s good practice to check the frame length before processing. We return <code class="docutils literal notranslate"><span class="pre">SL_STATUS_FAIL</span></code> if something goes wrong parsing the frame. The command handler component uses these return codes to respond to Supervision Get Commands. Returning <code class="docutils literal notranslate"><span class="pre">SL_STATUS_FAIL</span></code> sends a fail status therefore be standard compatible. (More information on Supervision Status code descriptions CC:006C.01.02.11.006 in the Z-Wave standard).</p>
<p><code class="docutils literal notranslate"><span class="pre">zwave_command_class_get_endpoint_node</span></code> allows us to convert a <code class="docutils literal notranslate"><span class="pre">zwave_controller_connection_info_t</span></code> into a node ID and returns the current endpoint node ID. We can use it to update all the attribute we need.</p>
<p><img alt="Report Configuration schema" src="../../_images/zwave_command_class_sound_switch_conf_report.png" /></p>
<p>As we can see the report frame has a total size of 4 bits. We can access the volume part with <code class="docutils literal notranslate"><span class="pre">frame_data[2]</span></code> and the default tone identifier with <code class="docutils literal notranslate"><span class="pre">frame_data[3]</span></code>. We then mark those attributes as reported. Our volume attribute is <code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_VOLUME</span></code> so we set this value as reported with the value of <code class="docutils literal notranslate"><span class="pre">frame_data[2]</span></code> with the function <code class="docutils literal notranslate"><span class="pre">attribute_store_set_child_reported</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">attribute_store_set_child_reported</span></code> allows you to update an attribute located under a node ID. Here we have the endpoint node ID so we can set the value of any attribute right underneath.</p>
<p>Now we can repeat this process for all the available commands (get/set/report) and set/get attribute based on your needs.</p>
</section>
<section id="testing-our-implementation">
<h4>Testing our implementation<a class="headerlink" href="#testing-our-implementation" title="Permalink to this heading"></a></h4>
<p>You can test if the request are correctly sent and received by manually making changes in the attribute store. To do so, you’ll need access to the ZPC CLI. Start the zpc executable directly (and stop the uic-service if running). Once its running press enter to see the <code class="docutils literal notranslate"><span class="pre">ZPC&gt;</span></code> command line. It supports autocompletion and the help command.</p>
<p>You can search for the node ID with the various log functions. The most useful one is <code class="docutils literal notranslate"><span class="pre">attribute_store_log_search</span></code> that allows you to search (case sensitive) for an attribute description.</p>
<p>Once you’ve got the node ID you can use functions such as <code class="docutils literal notranslate"><span class="pre">attribute_store_set_desired</span> <span class="pre">nodeID,value</span></code> or <code class="docutils literal notranslate"><span class="pre">attribute_store_undefine_reported</span> <span class="pre">nodeID</span></code> to trigger some changes.</p>
<p>You can also send raw Z-Wave frames with the <code class="docutils literal notranslate"><span class="pre">zwave_tx</span></code> commands.</p>
</section>
</section>
</section>
<section id="mapping-z-wave-to-dotdot-ucl-with-uam-file">
<h2>Mapping Z-Wave to Dotdot UCL with .uam file<a class="headerlink" href="#mapping-z-wave-to-dotdot-ucl-with-uam-file" title="Permalink to this heading"></a></h2>
<p>You should have some basic knowledge about clusters and UAM files.</p>
<ul class="simple">
<li><p><a class="reference internal" href="../../doc/unify_specifications/Chapter02-ZCL-in-uic.html"><span class="doc std std-doc">Cluster documentation</span></a></p></li>
<li><p><a class="reference internal" href="../../doc/how_to_write_uam_files.html"><span class="doc std std-doc">.uam file documentation</span></a></p></li>
<li><p><a class="reference internal" href="how_to_write_uam_files_for_the_zpc.html"><span class="doc std std-doc">Z-Wave specific .uam files documentation</span></a></p></li>
</ul>
<p>Now that our attribute store is correctly defined and sending the right Z-Wave commands it’s time to map it to the UCL model. This allows our attributes to be controlled by the MQTT broker (and by some extend the dev UI).</p>
<section id="map-z-wave-attribute-to-clusters-attributes">
<h3>Map Z-Wave attribute to clusters attributes<a class="headerlink" href="#map-z-wave-attribute-to-clusters-attributes" title="Permalink to this heading"></a></h3>
<p>The clusters are represented by XML files located in <code class="docutils literal notranslate"><span class="pre">components\uic_dotdot\dotdot-xml</span></code>. Our Sound Switch command class need at least the following features :</p>
<ul class="simple">
<li><p>Play a tone</p></li>
<li><p>Configure volume</p></li>
<li><p>Configure tone ID</p></li>
</ul>
<p>The play tone is basically a switch (0: stop playing, 255: playing). It can be represented by the <code class="docutils literal notranslate"><span class="pre">OnOff</span></code> cluster.</p>
<p>The volume and tone ID are numerical values. It can be represented by the <code class="docutils literal notranslate"><span class="pre">Level</span></code> cluster that can control numerical values.</p>
<p>We’ll start by the simplest one, the <code class="docutils literal notranslate"><span class="pre">OnOff</span></code> cluster. If we take a look at the OnOff cluster we can see the attribute it defines :</p>
<section id="on-off-cluster">
<h4>On/Off cluster<a class="headerlink" href="#on-off-cluster" title="Permalink to this heading"></a></h4>
<div class="highlight-XML notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;zcl:cluster</span>
<span class="w"> </span><span class="na">xmlns:zcl=</span><span class="s">&quot;http://zigbee.org/zcl/clusters&quot;</span>
<span class="w"> </span><span class="na">xmlns:xsi=</span><span class="s">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
<span class="w"> </span><span class="na">xmlns:type=</span><span class="s">&quot;http://zigbee.org/zcl/types&quot;</span>
<span class="w"> </span><span class="na">xmlns:xi=</span><span class="s">&quot;http://www.w3.org/2001/XInclude&quot;</span>
<span class="w"> </span><span class="na">xsi:schemaLocation=</span><span class="s">&quot;http://zigbee.org/zcl/clusters cluster.xsd http://zigbee.org/zcl/types type.xsd&quot;</span>
<span class="w"> </span><span class="na">id=</span><span class="s">&quot;0006&quot;</span><span class="w"> </span><span class="na">revision=</span><span class="s">&quot;2&quot;</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;OnOff&quot;</span><span class="nt">&gt;</span>
<span class="cm">&lt;!-- ... --&gt;</span>
<span class="nt">&lt;server&gt;</span>
<span class="w">    </span><span class="nt">&lt;attributes&gt;</span>
<span class="w">      </span><span class="nt">&lt;attribute</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;0000&quot;</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;OnOff&quot;</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;bool&quot;</span><span class="w"> </span><span class="na">max=</span><span class="s">&quot;1&quot;</span><span class="w"> </span><span class="na">required=</span><span class="s">&quot;true&quot;</span><span class="w"> </span><span class="na">reportRequired=</span><span class="s">&quot;true&quot;</span><span class="w"> </span><span class="na">sceneRequired=</span><span class="s">&quot;true&quot;</span><span class="w"> </span><span class="na">default=</span><span class="s">&quot;0&quot;</span><span class="w"> </span><span class="nt">/&gt;</span>
<span class="w">      </span><span class="cm">&lt;!-- ... --&gt;</span>
<span class="w">    </span><span class="nt">&lt;/attributes&gt;</span>
<span class="w">    </span><span class="cm">&lt;!-- ... --&gt;</span>
<span class="w">  </span><span class="nt">&lt;/server&gt;</span>
<span class="nt">&lt;/zcl:cluster&gt;</span>
</pre></div>
</div>
<p>Here, we are interested in the <code class="docutils literal notranslate"><span class="pre">OnOff</span></code> attribute with id <code class="docutils literal notranslate"><span class="pre">0000</span></code>. It’s that ZCL attribute that is mapped to our <code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_PLAY</span></code> Z-Wave attribute. An other important information is the cluster ID in the <code class="docutils literal notranslate"><span class="pre">zcl:cluster</span></code> attributes (<code class="docutils literal notranslate"><span class="pre">id=&quot;0006&quot;</span></code>).</p>
<p>In <code class="docutils literal notranslate"><span class="pre">applications/zpc/components/dotdot_mapper/rules</span></code> we can create our uam file.
It must be named by the following naming convention : <code class="docutils literal notranslate"><span class="pre">{CLUSTER_NAME}_to_{COMMAND_CLASS_NAME}CC</span></code> where <code class="docutils literal notranslate"><span class="pre">{CLUSTER_NAME}</span></code> is the ZCL cluster name and <code class="docutils literal notranslate"><span class="pre">{COMMAND_CLASS_NAME}</span></code> is your Z-Wave command class name (without spaces). We name our file <code class="docutils literal notranslate"><span class="pre">OnOff_to_SoundSwitchCC.uam</span></code>.</p>
<p>The first thing we’ll do is to define where to find our Z-Wave <code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_PLAY</span></code> attribute. Remember in the beginning <span class="xref myst">when we defined some ID for our Z-Wave attributes</span> ? This is where we’ll use it. Our command class sound switch have the ID <code class="docutils literal notranslate"><span class="pre">0x79</span></code> and  <code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_PLAY</span></code> <code class="docutils literal notranslate"><span class="pre">0x08</span></code>. We can access to this attribute by doing :</p>
<div class="highlight-UAM notranslate"><div class="highlight"><pre><span></span>def zwSOUND_SWITCH_TONE_PLAY 0x7908
</pre></div>
</div>
<p>It works the same way for the OnOff cluster attributes. We take the cluster ID (<code class="docutils literal notranslate"><span class="pre">0006</span></code>) followed by the attribute ID (<code class="docutils literal notranslate"><span class="pre">0000</span></code>) :</p>
<div class="highlight-UAM notranslate"><div class="highlight"><pre><span></span>def zbON_OFF 0x00060000
</pre></div>
</div>
<blockquote>
<div><p>NOTE : The naming convention is to prefix Z-Wave attribute with <code class="docutils literal notranslate"><span class="pre">zw</span></code> and ZCL attributes with <code class="docutils literal notranslate"><span class="pre">zb</span></code>.</p>
</div></blockquote>
<p>We usually use the priority 25 for this kind of rules to have higher priority over generic switches.</p>
<p>We need to prevent <code class="docutils literal notranslate"><span class="pre">chain_reaction</span></code> because we map the Z-Wave to zcl and vice versa.</p>
<ul class="simple">
<li><p><em>Z-Wave to zcl</em> : Used when attribute store is updated (e.g Z-Wave report command)</p></li>
<li><p><em>zcl to Z-Wave</em> : Used when zcl model is updated (e.g with commands)</p></li>
</ul>
<div class="highlight-UAM notranslate"><div class="highlight"><pre><span></span>def zwave_no_sound_switch (e&#39;zwSOUND_SWITCH_TONE_PLAY == 0)

scope 25 chain_reaction(0) {
  // Linking attributes zwave -&gt; zigbee (note : 0 is stop playing)
  r&#39;zbON_OFF =
    if (zwave_no_sound_switch) undefined
    if (r&#39;zwSOUND_SWITCH_TONE_PLAY != 0) 1 0
  d&#39;zbON_OFF =
    if (zwave_no_sound_switch) undefined
    if (d&#39;zwSOUND_SWITCH_TONE_PLAY != 0) 1 0
  
  // Linking attributes zigbee -&gt; zwave
  d&#39;zwSOUND_SWITCH_TONE_PLAY = 
    if (zwave_no_sound_switch) undefined
    if (d&#39;zbON_OFF != 0) 255 0

  r&#39;zwSOUND_SWITCH_TONE_PLAY = 
    if (zwave_no_sound_switch) undefined
    if (r&#39;zbON_OFF != 0) 255 0
}
</pre></div>
</div>
<p>This way we ensure that both attribute are linked no matter if it’s changed in the ZCL world or Z-Wave world. <code class="docutils literal notranslate"><span class="pre">chain_reaction(0)</span></code> prevent the mapper to go in a infinite loop.</p>
<section id="uam-guard">
<h5>UAM Guard<a class="headerlink" href="#uam-guard" title="Permalink to this heading"></a></h5>
<p>In our previous UAM example we have defined an function that checks if the Sound Switch Command Class is active for the current endpoint :</p>
<div class="highlight-uam notranslate"><div class="highlight"><pre><span></span><span class="nb">def</span> <span class="no">zwave_no_sound_switch</span> (<span class="nv">e&#39;zwSOUND_SWITCH_TONE_PLAY</span> <span class="ow">==</span> <span class="no">0</span>)
</pre></div>
</div>
<p>Here we check the existence of <code class="docutils literal notranslate"><span class="pre">zwSOUND_SWITCH_TONE_PLAY</span></code> to see if the endpoint is supporting Sound Switch.</p>
<p>We need to make sure that if we don’t have any sound switch active that :</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">zwSOUND_SWITCH_TONE_PLAY</span></code> should not exist and not be mapped to the <code class="docutils literal notranslate"><span class="pre">zbON_OFF</span></code> value</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">zbON_OFF</span></code> doesn’t take the value of <code class="docutils literal notranslate"><span class="pre">zwSOUND_SWITCH_TONE_PLAY</span></code>. This prevents conflict with other Z-Wave CC (like Binary Switch that also maps to <code class="docutils literal notranslate"><span class="pre">zbON_OFF</span></code>).</p></li>
</ul>
<p>Make sure that your UAM file contains this guard to prevent interferences with other command classes implementation.</p>
</section>
</section>
<section id="level-cluster">
<h4>Level cluster<a class="headerlink" href="#level-cluster" title="Permalink to this heading"></a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">OnOff</span></code> cluster was very straight forward, but the <code class="docutils literal notranslate"><span class="pre">Level</span></code> requires some arbitrary choices. We need to map 2 values :</p>
<ul class="simple">
<li><p>The current volume</p></li>
<li><p>The current tone ID</p></li>
</ul>
<p>Let’s look at the <code class="docutils literal notranslate"><span class="pre">Level</span></code> cluster definition :</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;zcl:cluster</span>
<span class="w">  </span><span class="na">xmlns:zcl=</span><span class="s">&quot;http://zigbee.org/zcl/clusters&quot;</span>
<span class="w">  </span><span class="na">xmlns:xsi=</span><span class="s">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
<span class="w">  </span><span class="na">xmlns:type=</span><span class="s">&quot;http://zigbee.org/zcl/types&quot;</span>
<span class="w">  </span><span class="na">xmlns:xi=</span><span class="s">&quot;http://www.w3.org/2001/XInclude&quot;</span>
<span class="w">  </span><span class="na">xsi:schemaLocation=</span><span class="s">&quot;http://zigbee.org/zcl/clusters cluster.xsd http://zigbee.org/zcl/types type.xsd&quot;</span>
<span class="w">  </span><span class="na">id=</span><span class="s">&quot;0008&quot;</span><span class="w"> </span><span class="na">revision=</span><span class="s">&quot;2&quot;</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;Level&quot;</span><span class="nt">&gt;</span>
<span class="w">  </span><span class="nt">&lt;classification</span><span class="w"> </span><span class="na">role=</span><span class="s">&quot;application&quot;</span><span class="w"> </span><span class="na">picsCode=</span><span class="s">&quot;LVL&quot;</span><span class="w"> </span><span class="na">primaryTransaction=</span><span class="s">&quot;1&quot;</span><span class="w"> </span><span class="nt">/&gt;</span>
<span class="w">  </span><span class="cm">&lt;!-- ... --&gt;</span>
<span class="w">  </span><span class="nt">&lt;server&gt;</span>
<span class="w">    </span><span class="nt">&lt;attributes&gt;</span>
<span class="w">      </span><span class="nt">&lt;attribute</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;0000&quot;</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;CurrentLevel&quot;</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;uint8&quot;</span><span class="w"> </span><span class="na">reportRequired=</span><span class="s">&quot;true&quot;</span><span class="w"> </span><span class="na">sceneRequired=</span><span class="s">&quot;true&quot;</span><span class="w"> </span><span class="na">default=</span><span class="s">&quot;255&quot;</span><span class="w"> </span><span class="na">required=</span><span class="s">&quot;true&quot;</span><span class="nt">&gt;</span>
<span class="w">        </span><span class="nt">&lt;restriction&gt;</span>
<span class="w">          </span><span class="nt">&lt;type:minInclusiveRef</span><span class="w"> </span><span class="na">ref=</span><span class="s">&quot;MinLevel&quot;</span><span class="w"> </span><span class="nt">/&gt;</span>
<span class="w">          </span><span class="nt">&lt;type:maxInclusiveRef</span><span class="w"> </span><span class="na">ref=</span><span class="s">&quot;MaxLevel&quot;</span><span class="w"> </span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;/restriction&gt;</span>
<span class="w">      </span><span class="nt">&lt;/attribute&gt;</span>
<span class="w">      </span><span class="cm">&lt;!-- ... --&gt;</span>
<span class="w">      </span><span class="nt">&lt;attribute</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;0002&quot;</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;MinLevel&quot;</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;uint8&quot;</span><span class="w"> </span><span class="na">default=</span><span class="s">&quot;0&quot;</span><span class="nt">&gt;</span>
<span class="w">        </span><span class="nt">&lt;restriction&gt;</span>
<span class="w">          </span><span class="nt">&lt;type:maxInclusiveRef</span><span class="w"> </span><span class="na">ref=</span><span class="s">&quot;MaxLevel&quot;</span><span class="w"> </span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;/restriction&gt;</span>
<span class="w">      </span><span class="nt">&lt;/attribute&gt;</span>
<span class="w">      </span><span class="nt">&lt;attribute</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;0003&quot;</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;MaxLevel&quot;</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;uint8&quot;</span><span class="w"> </span><span class="na">max=</span><span class="s">&quot;255&quot;</span><span class="w"> </span><span class="na">default=</span><span class="s">&quot;255&quot;</span><span class="nt">&gt;</span>
<span class="w">        </span><span class="nt">&lt;restriction&gt;</span>
<span class="w">          </span><span class="nt">&lt;type:minInclusiveRef</span><span class="w"> </span><span class="na">ref=</span><span class="s">&quot;MinLevel&quot;</span><span class="w"> </span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;/restriction&gt;</span>
<span class="w">      </span><span class="nt">&lt;/attribute&gt;</span>
<span class="w">  </span>
<span class="w">      </span><span class="nt">&lt;attribute</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;0004&quot;</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;CurrentFrequency&quot;</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;uint16&quot;</span><span class="w"> </span><span class="na">reportRequired=</span><span class="s">&quot;true&quot;</span><span class="w"> </span><span class="na">sceneRequired=</span><span class="s">&quot;true&quot;</span><span class="w"> </span><span class="na">default=</span><span class="s">&quot;0&quot;</span><span class="nt">&gt;</span>
<span class="w">        </span><span class="nt">&lt;restriction&gt;</span>
<span class="w">          </span><span class="nt">&lt;type:minInclusiveRef</span><span class="w"> </span><span class="na">ref=</span><span class="s">&quot;MinFrequency&quot;</span><span class="w"> </span><span class="nt">/&gt;</span>
<span class="w">          </span><span class="nt">&lt;type:maxInclusiveRef</span><span class="w"> </span><span class="na">ref=</span><span class="s">&quot;MaxFrequency&quot;</span><span class="w"> </span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;/restriction&gt;</span>
<span class="w">      </span><span class="nt">&lt;/attribute&gt;</span>
<span class="w">      </span><span class="nt">&lt;attribute</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;0005&quot;</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;MinFrequency&quot;</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;uint16&quot;</span><span class="w"> </span><span class="na">default=</span><span class="s">&quot;0&quot;</span><span class="nt">&gt;</span>
<span class="w">        </span><span class="nt">&lt;restriction&gt;</span>
<span class="w">          </span><span class="nt">&lt;type:maxInclusiveRef</span><span class="w"> </span><span class="na">ref=</span><span class="s">&quot;MaxFrequency&quot;</span><span class="w"> </span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;/restriction&gt;</span>
<span class="w">      </span><span class="nt">&lt;/attribute&gt;</span>
<span class="w">      </span><span class="nt">&lt;attribute</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;0006&quot;</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;MaxFrequency&quot;</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;uint16&quot;</span><span class="w"> </span><span class="na">max=</span><span class="s">&quot;65535&quot;</span><span class="w"> </span><span class="na">default=</span><span class="s">&quot;0&quot;</span><span class="nt">&gt;</span>
<span class="w">        </span><span class="nt">&lt;restriction&gt;</span>
<span class="w">          </span><span class="nt">&lt;type:minInclusiveRef</span><span class="w"> </span><span class="na">ref=</span><span class="s">&quot;MinFrequency&quot;</span><span class="w"> </span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;/restriction&gt;</span>
<span class="w">      </span><span class="nt">&lt;/attribute&gt;</span>
<span class="w">      </span><span class="cm">&lt;!-- ... --&gt;</span>
<span class="w">    </span><span class="nt">&lt;/attributes&gt;</span>
<span class="w">    </span><span class="cm">&lt;!-- ... --&gt;</span>
<span class="w">  </span><span class="nt">&lt;/server&gt;</span>
<span class="nt">&lt;/zcl:cluster&gt;</span>
</pre></div>
</div>
<p>We see that we have access to 2 int attributes : <code class="docutils literal notranslate"><span class="pre">CurrentLevel</span></code> and <code class="docutils literal notranslate"><span class="pre">CurrentFrequency</span></code>. We can decide to map the current volume to <code class="docutils literal notranslate"><span class="pre">CurrentLevel</span></code> and current tone ID to <code class="docutils literal notranslate"><span class="pre">CurrentFrequency</span></code> (even if its make little sense). We’ll see how to implement our own cluster if we need more accuracy <span class="xref myst">here</span>.</p>
<p>Both ZCL attributes have a min and a max values, so we need to map those as well.</p>
<p>First we’ll create our file <code class="docutils literal notranslate"><span class="pre">Level_to_SoundSwitchCC.uam</span></code> in <code class="docutils literal notranslate"><span class="pre">applications/zpc/components/dotdot_mapper/rules</span></code>.</p>
<p>Let’s define our Z-Wave attribute definitions :</p>
<div class="highlight-UAM notranslate"><div class="highlight"><pre><span></span>def zwSOUND_SWITCH_CONFIGURED_VOLUME 0x7902
def zwSOUND_SWITCH_TONE_INFO_IDENTIFIER 0x7903
def zwSOUND_SWITCH_TONE_NUMBER 0x7904
</pre></div>
</div>
<p>We bind <code class="docutils literal notranslate"><span class="pre">zwSOUND_SWITCH_TONE_NUMBER</span></code> the to the <code class="docutils literal notranslate"><span class="pre">MaxFrequency</span></code> attribute so that our <code class="docutils literal notranslate"><span class="pre">CurrentFrequency</span></code> doesn’t overflow. Since <code class="docutils literal notranslate"><span class="pre">CurrentFrequency</span></code> here represent our tone ID it must be between 1 and <code class="docutils literal notranslate"><span class="pre">zwSOUND_SWITCH_TONE_NUMBER</span></code>.</p>
<p>And our zcl level attributes :</p>
<div class="highlight-UAM notranslate"><div class="highlight"><pre><span></span>def zbLEVEL_CLUSTER_LEVEL   0x00080000
def zbLEVEL_CLUSTER_MIN_LEVEL 0x00080002
def zbLEVEL_CLUSTER_MAX_LEVEL 0x00080003
def zbLEVEL_CLUSTER_FREQ 0x00080004
def zbLEVEL_CLUSTER_FREQ_MIN 0x00080005
def zbLEVEL_CLUSTER_FREQ_MAX 0x00080006
def zbLEVEL_CLUSTER_TRANSITION_TIME 0x00080010
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">zbLEVEL_CLUSTER_TRANSITION_TIME</span></code> is here to enable the Move command. We define it to make sure we can move our value the way we want to.</p>
<blockquote>
<div><p>NOTE: to understand how we get the various ID see the <span class="xref myst"><code class="docutils literal notranslate"><span class="pre">OnOff</span></code> cluster section</span></p>
</div></blockquote>
<p>We need some constants for the min/max volume also since it is not defined on our command class :</p>
<div class="highlight-UAM notranslate"><div class="highlight"><pre><span></span>def min_level 0
def max_level 100
</pre></div>
</div>
<p>First we’ll map une CurrentLevel and CurrentFrequency attributes with their counterpart :</p>
<div class="highlight-uam notranslate"><div class="highlight"><pre><span></span><span class="nb">def</span> <span class="no">zwave_no_sound_switch</span> (<span class="nv">e&#39;zwSOUND_SWITCH_TONE_PLAY</span> <span class="ow">==</span> <span class="no">0</span>)

<span class="nb">scope</span> <span class="no">25</span>  <span class="no">chain_reaction</span>(<span class="no">0</span>) {
  <span class="c c-Singleline">// Map current level to configured volume</span>
  <span class="c c-Singleline">// zwave -&gt; ucl</span>
  <span class="nv">r&#39;zbLEVEL_CLUSTER_LEVEL</span> <span class="o">=</span> 
    <span class="nb">if</span> (<span class="no">zwave_no_sound_switch</span>) <span class="no">undefined</span>
    <span class="nv">r&#39;zwSOUND_SWITCH_CONFIGURED_VOLUME</span>
  <span class="nv">d&#39;zbLEVEL_CLUSTER_LEVEL</span> <span class="o">=</span> 
    <span class="nb">if</span> (<span class="no">zwave_no_sound_switch</span>) <span class="no">undefined</span>
    <span class="nv">d&#39;zwSOUND_SWITCH_CONFIGURED_VOLUME</span>
  <span class="c c-Singleline">// ucl -&gt; zwave</span>
  <span class="nv">d&#39;zwSOUND_SWITCH_CONFIGURED_VOLUME</span> <span class="o">=</span> 
    <span class="nb">if</span> (<span class="no">zwave_no_sound_switch</span>) <span class="no">undefined</span>
    <span class="nv">d&#39;zbLEVEL_CLUSTER_LEVEL</span>
  <span class="nv">r&#39;zwSOUND_SWITCH_CONFIGURED_VOLUME</span> <span class="o">=</span> 
    <span class="nb">if</span> (<span class="no">zwave_no_sound_switch</span>) <span class="no">undefined</span>
    <span class="nv">r&#39;zbLEVEL_CLUSTER_LEVEL</span>

  <span class="c c-Singleline">// Map frequency to current tone identifier</span>
  <span class="c c-Singleline">// zwave -&gt; ucl</span>
  <span class="nv">r&#39;zbLEVEL_CLUSTER_FREQ</span> <span class="o">=</span> 
    <span class="nb">if</span> (<span class="no">zwave_no_sound_switch</span>) <span class="no">undefined</span>
    <span class="nv">r&#39;zwSOUND_SWITCH_TONE_INFO_IDENTIFIER</span>
  <span class="nv">d&#39;zbLEVEL_CLUSTER_FREQ</span> <span class="o">=</span> 
    <span class="nb">if</span> (<span class="no">zwave_no_sound_switch</span>) <span class="no">undefined</span>
    <span class="nv">d&#39;zwSOUND_SWITCH_TONE_INFO_IDENTIFIER</span>
  <span class="c c-Singleline">// ucl -&gt; zwave</span>
  <span class="nv">d&#39;zwSOUND_SWITCH_TONE_INFO_IDENTIFIER</span> <span class="o">=</span> 
    <span class="nb">if</span> (<span class="no">zwave_no_sound_switch</span>) <span class="no">undefined</span>
    <span class="nv">d&#39;zbLEVEL_CLUSTER_FREQ</span>
  <span class="nv">r&#39;zwSOUND_SWITCH_TONE_INFO_IDENTIFIER</span> <span class="o">=</span> 
    <span class="nb">if</span> (<span class="no">zwave_no_sound_switch</span>) <span class="no">undefined</span>
    <span class="nv">r&#39;zbLEVEL_CLUSTER_FREQ</span>
}
</pre></div>
</div>
<blockquote>
<div><p>NOTE : this process is explained in <span class="xref myst"><code class="docutils literal notranslate"><span class="pre">OnOff</span></code> cluster section</span> and the <code class="docutils literal notranslate"><span class="pre">zwave_no_sound_switch</span></code> in <span class="xref myst"><code class="docutils literal notranslate"><span class="pre">UAM</span> <span class="pre">Guard</span> <span class="pre">section</span></code></span></p>
</div></blockquote>
<p>To bind the min and max values we add those rules :</p>
<div class="highlight-uam notranslate"><div class="highlight"><pre><span></span>  <span class="c c-Singleline">// Min and max volume</span>
  <span class="nv">r&#39;zbLEVEL_CLUSTER_MIN_LEVEL</span> <span class="o">=</span> 
    <span class="nb">if</span> (<span class="no">zwave_no_sound_switch</span>) <span class="no">undefined</span>
    <span class="nb">if</span> (<span class="nv">e&#39;zwSOUND_SWITCH_CONFIGURED_VOLUME</span>) <span class="no">min_level</span> <span class="no">undefined</span>
  <span class="nv">r&#39;zbLEVEL_CLUSTER_MAX_LEVEL</span> <span class="o">=</span> 
    <span class="nb">if</span> (<span class="no">zwave_no_sound_switch</span>) <span class="no">undefined</span>
    <span class="nb">if</span> (<span class="nv">e&#39;zwSOUND_SWITCH_CONFIGURED_VOLUME</span>) <span class="no">max_level</span> <span class="no">undefined</span>
</pre></div>
</div>
<p>We can’t bind value to raw constants so we need to add an condition to it. We choose to define it only if <code class="docutils literal notranslate"><span class="pre">zwSOUND_SWITCH_CONFIGURED_VOLUME</span></code> exists since if it doesn’t the min/max value doesn’t make sense.</p>
<p>Same applies for <code class="docutils literal notranslate"><span class="pre">MinFrequency</span></code> and <code class="docutils literal notranslate"><span class="pre">MaxFrequency</span></code> but instead of constants we use our <code class="docutils literal notranslate"><span class="pre">zwSOUND_SWITCH_TONE_NUMBER</span></code> attribute :</p>
<div class="highlight-uam notranslate"><div class="highlight"><pre><span></span> <span class="nv">r&#39;zbLEVEL_CLUSTER_FREQ_MIN</span> <span class="o">=</span> 
    <span class="nb">if</span> (<span class="no">zwave_no_sound_switch</span>) <span class="no">undefined</span>
    <span class="nb">if</span> (<span class="nv">e&#39;zwSOUND_SWITCH_TONE_NUMBER</span>) <span class="no">1</span> <span class="no">undefined</span>
  <span class="nv">r&#39;zbLEVEL_CLUSTER_FREQ_MAX</span> <span class="o">=</span> 
    <span class="nb">if</span> (<span class="no">zwave_no_sound_switch</span>) <span class="no">undefined</span>
    <span class="nb">if</span> (<span class="nv">e&#39;zwSOUND_SWITCH_TONE_NUMBER</span>) <span class="nv">r&#39;zwSOUND_SWITCH_TONE_NUMBER</span> <span class="no">undefined</span>
</pre></div>
</div>
<p>The last attribute we need to define is <code class="docutils literal notranslate"><span class="pre">zbLEVEL_CLUSTER_TRANSITION_TIME</span></code> to make <code class="docutils literal notranslate"><span class="pre">Level</span></code> commands work. All we need to do is set a value. In our case we choose 0 because we don’t want a transition time when updating our levels.</p>
<div class="highlight-uam notranslate"><div class="highlight"><pre><span></span>  <span class="c c-Singleline">// Required to enable move command </span>
  <span class="nv">d&#39;zbLEVEL_CLUSTER_TRANSITION_TIME</span> <span class="o">=</span> 
    <span class="nb">if</span> (<span class="no">zwave_no_sound_switch</span>) <span class="no">undefined</span>
    <span class="nb">if</span> (<span class="nv">e&#39;zwSOUND_SWITCH_TONE_NUMBER</span>) <span class="no">0</span> <span class="no">undefined</span>
  <span class="nv">r&#39;zbLEVEL_CLUSTER_TRANSITION_TIME</span> <span class="o">=</span> 
    <span class="nb">if</span> (<span class="no">zwave_no_sound_switch</span>) <span class="no">undefined</span>
    <span class="nb">if</span> (<span class="nv">e&#39;zwSOUND_SWITCH_TONE_NUMBER</span>) <span class="no">0</span> <span class="no">undefined</span>
</pre></div>
</div>
<p>Now with those files we should be able to control our device from the MQTT broker and the dev UI since it monitors the ZCL attributes.</p>
</section>
</section>
<section id="quirks">
<h3>Quirks<a class="headerlink" href="#quirks" title="Permalink to this heading"></a></h3>
<p>Sometimes, devices are not acting like they should. The Aeotec Doorbell 6 for example define 9 different endpoints. Each endpoint can have its own configuration (tone ID, volume) and can play a tune. However, the first endpoint is behaving differently from the others.</p>
<p>It acts as a default endpoint that copy the configuration of the second one (ep1). That means if you send a play command to the first endpoint, the second one is also marked as “is playing” and both use the same configuration (tone ID, volume).</p>
<p>When we tell the first endpoint (ep0) to play, the second one (ep1) is also marked as “is playing”, but when the tone finishes only the ep1 receive a report telling the sound is over leading the ep0 in a incorrect state (marked as playing but in reality it’s not).</p>
<p>To address this issue we can use something we call Quirks in UAM. They allow us to execute rules on a specific device. The naming convention is <code class="docutils literal notranslate"><span class="pre">Quirks_{device_name}.uam</span></code> where <code class="docutils literal notranslate"><span class="pre">{device_name}</span></code> is your device name. In our case we can create <code class="docutils literal notranslate"><span class="pre">Quirks_aeotec_doorbell.uam</span></code>.</p>
<p>A device can be identified with 3 parameters : manufacturer ID, product type and product ID. We can have access to it in UAM with the following ID :</p>
<div class="highlight-UAM notranslate"><div class="highlight"><pre><span></span>// Special maps to help controlling the Aeotec doorbell
def zwMANUFACTURER_ID           0x00007202
def zwPRODUCT_TYPE              0x00007203
def zwPRODUCT_ID                0x00007204
</pre></div>
</div>
<p>We the need a reference to the <code class="docutils literal notranslate"><span class="pre">SOUND_SWITCH_TONE_PLAY</span></code> attribute :</p>
<div class="highlight-UAM notranslate"><div class="highlight"><pre><span></span>def zwSOUND_SWITCH_TONE_PLAY 0x7908
</pre></div>
</div>
<p>We also need to have access to the endpoint list :</p>
<div class="highlight-UAM notranslate"><div class="highlight"><pre><span></span>def ep 4
</pre></div>
</div>
<p>This allow us to reference each endpoint by doing <code class="docutils literal notranslate"><span class="pre">ep[0]</span></code> where <code class="docutils literal notranslate"><span class="pre">0</span></code> is the endpoint ID. This notation will be explained soon.</p>
<p>The last definition we need is a condition that returns true if we are controlling our specific device. We use the manufacturer ID, product type and product ID to identify our device. You can find those either in the attribute tree (<code class="docutils literal notranslate"><span class="pre">ZPC&gt;</span> <span class="pre">attribute_store_log_search</span> <span class="pre">Manufacturer</span></code> and <code class="docutils literal notranslate"><span class="pre">ZPC&gt;</span> <span class="pre">attribute_store_log_search</span> <span class="pre">Product</span></code>) or directly in the vendor manual.</p>
<div class="highlight-UAM notranslate"><div class="highlight"><pre><span></span>def aeotec_doorbell ((r&#39;ep[0].zwMANUFACTURER_ID == 881) &amp; (r&#39;ep[0].zwPRODUCT_TYPE == 3) &amp; (r&#39;ep[0].zwPRODUCT_ID == 162))
</pre></div>
</div>
<blockquote>
<div><p>NOTE : We have to write the endpoint (<code class="docutils literal notranslate"><span class="pre">ep[0]</span></code>) before acceding the device identifiers or it will not work. This is explained bellow.</p>
</div></blockquote>
<p>The Quirk need to run as a high priority rule since they are device specific. Most of the Quirks runs as a priority of 500 or higher. Also in our case we need to have access to the endpoint list. Defining <code class="docutils literal notranslate"><span class="pre">ep</span></code> is not all we need to do : we also need <code class="docutils literal notranslate"><span class="pre">common_parent_type(3)</span></code> to our rules :</p>
<div class="highlight-UAM notranslate"><div class="highlight"><pre><span></span>scope 500 common_parent_type(3) {
}
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">common_parent_type(3)</span></code> changes the current scope configuration for this mapping. This allows us to have access to each endpoint (<code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">ep</span> <span class="pre">4</span></code>). The numbers (<code class="docutils literal notranslate"><span class="pre">3</span></code> and <code class="docutils literal notranslate"><span class="pre">4</span></code>) are references to the attributes’ ID. In <code class="docutils literal notranslate"><span class="pre">applications\zpc\components\zpc_attribute_store\include\attribute_store_defined_attribute_types.h</span></code> we can find :</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">///&lt; This represents a Node ID. zwave_node_id_t type.</span>
<span class="n">DEFINE_ATTRIBUTE</span><span class="p">(</span><span class="n">ATTRIBUTE_NODE_ID</span><span class="p">,</span><span class="w"> </span><span class="mh">0x0003</span><span class="p">)</span>
<span class="c1">///&lt; This represents an endpoint. zwave_endpoint_id_t type.</span>
<span class="n">DEFINE_ATTRIBUTE</span><span class="p">(</span><span class="n">ATTRIBUTE_ENDPOINT_ID</span><span class="p">,</span><span class="w"> </span><span class="mh">0x0004</span><span class="p">)</span>
</pre></div>
</div>
<p>If we look at our current attribute store we may see something like that :</p>
<div class="highlight-txt notranslate"><div class="highlight"><pre><span></span>(1) Root node .................................................................     &lt;&gt; (&lt;&gt;)
    │───(2) HomeID ............................................................ [58,27,e5,fc] (&lt;&gt;)
    │   │───(3) NodeID ........................................................      1 (&lt;&gt;)
    │   │   │───(4) Endpoint ID ...............................................      0 (&lt;&gt;)
    │   │───(8) NodeID ........................................................      3 (&lt;&gt;)
    │   │   │───(9) Endpoint ID ...............................................      0 (&lt;&gt;)
    │   │   │───(153) Endpoint ID .............................................      1 (&lt;&gt;)
    │   │   │───(157) Endpoint ID .............................................      2 (&lt;&gt;)
    │   │   │───(161) Endpoint ID .............................................      3 (&lt;&gt;)
    │   │   │───(165) Endpoint ID .............................................      4 (&lt;&gt;)
    │   │   │───(169) Endpoint ID .............................................      5 (&lt;&gt;)
    │   │   │───(173) Endpoint ID .............................................      6 (&lt;&gt;)
    │   │   │───(177) Endpoint ID .............................................      7 (&lt;&gt;)
    │   │   │───(181) Endpoint ID .............................................      8 (&lt;&gt;)
</pre></div>
</div>
<p>If we position ourselves relative to our Node ID we can access each endpoint individually.</p>
<p><code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_NODE_ID</span></code> is defined at <code class="docutils literal notranslate"><span class="pre">0x0003</span></code> and <code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_ENDPOINT_ID</span></code> at <code class="docutils literal notranslate"><span class="pre">0x0004</span></code>. That’s why we defined <code class="docutils literal notranslate"><span class="pre">ep</span></code> to <code class="docutils literal notranslate"><span class="pre">4</span></code> earlier. Now we tell that for this mapping our parent is the <code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_NODE_ID</span></code> with <code class="docutils literal notranslate"><span class="pre">common_parent_type(3)</span></code>. This way <code class="docutils literal notranslate"><span class="pre">ep[0]</span></code> reference the tree under the first endpoint, <code class="docutils literal notranslate"><span class="pre">ep[1]</span></code> the tree under the second endpoint, etc.</p>
<p>This is why we needed to add <code class="docutils literal notranslate"><span class="pre">ep[0]</span></code> before <code class="docutils literal notranslate"><span class="pre">zwMANUFACTURER_ID</span></code> and the other attributes in <code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">aeotec_doorbell</span></code>. Since its evaluated in the <code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_NODE_ID</span></code> context the only attribute directly available is the <code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_ENDPOINT_ID</span></code>. You can find more information about this in <a class="reference internal" href="../../doc/how_to_write_uam_files.html"><span class="doc std std-doc">How to write UAM files</span></a></p>
<p>So we need to map the second endpoint (<code class="docutils literal notranslate"><span class="pre">ep[1]</span></code>) tone play value to match the first one (<code class="docutils literal notranslate"><span class="pre">ep[0]</span></code>) but ONLY when the device is the Aoetec doorbell :</p>
<div class="highlight-UAM notranslate"><div class="highlight"><pre><span></span>scope 500 common_parent_type(3) {
  r&#39;ep[0].zwSOUND_SWITCH_TONE_PLAY = if aeotec_doorbell r&#39;ep[1].zwSOUND_SWITCH_TONE_PLAY undefined
}
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">aeotec_doorbell</span></code> report <code class="docutils literal notranslate"><span class="pre">false</span></code> we set the reported value to <code class="docutils literal notranslate"><span class="pre">undefined</span></code> to let other rules take care of it. Otherwise we map the value to the value reported by the second endpoint.</p>
</section>
</section>
<section id="unit-testing">
<h2>Unit Testing<a class="headerlink" href="#unit-testing" title="Permalink to this heading"></a></h2>
<p>An approach that can be used to implement the test class is to try and think based on the command class specification and the code of the command class the good and bad scenarios that could happen. A suggestion is to try and create a method for each bad scenario, based on the implementation of the command class could be necessary in some occasions to create some nodes to test if any change happens to others.</p>
<p>The test files are located under <code class="docutils literal notranslate"><span class="pre">applications/zpc/components/zwave_command_classes/test</span></code>. The naming convention is <code class="docutils literal notranslate"><span class="pre">zwave_command_class_{COMMAND_CLASS}_test.c</span></code> so in our case the file is named <code class="docutils literal notranslate"><span class="pre">zwave_command_class_sound_switch_test.c</span></code>.</p>
<p>Test are enabled by default in CMake. The CMake variable <code class="docutils literal notranslate"><span class="pre">BUILD_TESTING</span></code> is controlling the test suite. Make sure it is set to <code class="docutils literal notranslate"><span class="pre">ON</span></code> (either via the pseudo-gui <code class="docutils literal notranslate"><span class="pre">ccmake</span></code> or by passing the <code class="docutils literal notranslate"><span class="pre">-DBUILD_TESTING=ON</span></code> to cmake directly).</p>
<p>Once the compilation is done, you can run all the tests with <code class="docutils literal notranslate"><span class="pre">ctest</span></code> in your build directory. You can also run a specific test with the command : <code class="docutils literal notranslate"><span class="pre">ctest</span> <span class="pre">-R</span> <span class="pre">name_of_your_test</span></code>. The name of your test is defined with the <code class="docutils literal notranslate"><span class="pre">NAME</span></code> argument of the <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> in the test folder (see next section for details).</p>
<p>If you need for details about your test result, pass the <code class="docutils literal notranslate"><span class="pre">--verbose</span></code> option.</p>
<section id="add-test-file-to-cmake">
<h3>Add test file to CMake<a class="headerlink" href="#add-test-file-to-cmake" title="Permalink to this heading"></a></h3>
<p>After creating the file we need to add it to the CMake build system. To do so open the <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> located in the test folder and add :</p>
<div class="highlight-CMake notranslate"><div class="highlight"><pre><span></span><span class="c"># Sound switch unit test</span>
<span class="nb">target_add_unittest</span><span class="p">(</span><span class="s">zwave_command_classes</span>

<span class="s">NAME</span><span class="w"> </span><span class="s">zwave_command_class_sound_switch_test</span>
<span class="s">SOURCES</span><span class="w"> </span><span class="s">zwave_command_class_sound_switch_test.c</span>

<span class="s">DEPENDS</span>
<span class="w">  </span><span class="s">zpc_attribute_store_test_helper</span>
<span class="w">  </span><span class="s">zwave_controller</span>
<span class="w">  </span><span class="s">zwave_command_handler_mock</span>
<span class="w">  </span><span class="s">uic_attribute_resolver_mock</span>
<span class="w">  </span><span class="s">zpc_attribute_resolver_mock</span>
<span class="w">  </span><span class="s">uic_dotdot_mqtt_mock</span>
<span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">NAME</span></code> : Same name as the SOURCE argument but without the extension (used if you want to run this specific test with <code class="docutils literal notranslate"><span class="pre">ctest</span> <span class="pre">-R</span> <span class="pre">name_of_your_test</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SOURCES</span></code> : Our test file name with the extension</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DEPENDS</span></code> : Dependencies of our test. You may add some based on your needs. More is available you can look at other test definitions to see them.</p></li>
</ul>
</section>
<section id="base-test-skeleton">
<h3>Base test skeleton<a class="headerlink" href="#base-test-skeleton" title="Permalink to this heading"></a></h3>
<p>Once it is added to our build system, we define the test skeleton like this :</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;zwave_command_class_sound_switch.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;zwave_command_classes_utils.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;unity.h&quot;</span>

<span class="c1">// Generic includes</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>

<span class="c1">// Includes from other components</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;datastore.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;attribute_store.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;attribute_store_helper.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;attribute_store_fixt.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;zpc_attribute_store_type_registration.h&quot;</span>

<span class="c1">// Interface includes</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;attribute_store_defined_attribute_types.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ZW_classcmd.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;zwave_utils.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;zwave_controller_types.h&quot;</span>

<span class="c1">// Test helpers</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;zpc_attribute_store_test_helper.h&quot;</span>

<span class="c1">// Mock includes</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;attribute_resolver_mock.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;zpc_attribute_resolver_mock.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;zwave_command_handler_mock.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;dotdot_mqtt_mock.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;dotdot_mqtt_generated_commands_mock.h&quot;</span>

<span class="c1">/// Setup the test suite (called once before all test_xxx functions are called)</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">suiteSetUp</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">datastore_init</span><span class="p">(</span><span class="s">&quot;:memory:&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">attribute_store_init</span><span class="p">();</span>
<span class="w">  </span><span class="n">zpc_attribute_store_register_known_attribute_types</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">/// Teardown the test suite (called once after all test_xxx functions are called)</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">suiteTearDown</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">num_failures</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">attribute_store_teardown</span><span class="p">();</span>
<span class="w">  </span><span class="n">datastore_teardown</span><span class="p">();</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">num_failures</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// Called before each and every test</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">setUp</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">zpc_attribute_store_test_helper_create_network</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">/// Called after each and every test</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">tearDown</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
</pre></div>
</div>
<p>You can find the different function that is called before/after each test/test suite.</p>
<p>We’ll add to the <code class="docutils literal notranslate"><span class="pre">setUp()</span></code> function the entrypoint of our class :</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Called before each and every test</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">setUp</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">zpc_attribute_store_test_helper_create_network</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Call init</span>
<span class="w">  </span><span class="n">TEST_ASSERT_EQUAL</span><span class="p">(</span><span class="n">SL_STATUS_OK</span><span class="p">,</span><span class="w"> </span><span class="n">zwave_command_class_sound_switch_init</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Unless your specified your attribute creation in this function, your attribute tree is <strong>NOT</strong> available for the test cases. If your attribute creation is bound to the version update, you can set this attribute in the setUp() phase if really needed :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">version_node</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">attribute_store_add_node</span><span class="p">(</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_VERSION</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">endpoint_id_node</span><span class="p">);</span>

<span class="w">  </span><span class="n">zwave_cc_version_t</span><span class="w"> </span><span class="n">version</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="n">attribute_store_set_reported</span><span class="p">(</span><span class="n">version_node</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">version</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">version</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="test-report-z-wave-function">
<h3>Test report Z-Wave function<a class="headerlink" href="#test-report-z-wave-function" title="Permalink to this heading"></a></h3>
<p>We’ll add an handler stub that contains our sound switch handler definition (version, security, control handler,…). The handler stub function looks like this :</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Private variables</span>
<span class="k">static</span><span class="w"> </span><span class="n">zwave_command_handler_t</span><span class="w"> </span><span class="n">handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>

<span class="c1">// Stub for registering command classes</span>
<span class="k">static</span><span class="w"> </span><span class="n">sl_status_t</span><span class="w"> </span><span class="nf">zwave_command_handler_register_handler_stub</span><span class="p">(</span>
<span class="w">  </span><span class="n">zwave_command_handler_t</span><span class="w"> </span><span class="n">new_command_class_handler</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">cmock_num_calls</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_command_class_handler</span><span class="p">;</span>

<span class="w">  </span><span class="n">TEST_ASSERT_EQUAL</span><span class="p">(</span><span class="n">ZWAVE_CONTROLLER_ENCAPSULATION_NONE</span><span class="p">,</span>
<span class="w">                    </span><span class="n">handler</span><span class="p">.</span><span class="n">minimal_scheme</span><span class="p">);</span>
<span class="w">  </span><span class="n">TEST_ASSERT_EQUAL</span><span class="p">(</span><span class="n">COMMAND_CLASS_SOUND_SWITCH</span><span class="p">,</span><span class="w"> </span><span class="n">handler</span><span class="p">.</span><span class="n">command_class</span><span class="p">);</span>
<span class="w">  </span><span class="n">TEST_ASSERT_EQUAL</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">handler</span><span class="p">.</span><span class="n">version</span><span class="p">);</span>
<span class="w">  </span><span class="n">TEST_ASSERT_NOT_NULL</span><span class="p">(</span><span class="n">handler</span><span class="p">.</span><span class="n">control_handler</span><span class="p">);</span>
<span class="w">  </span><span class="n">TEST_ASSERT_NULL</span><span class="p">(</span><span class="n">handler</span><span class="p">.</span><span class="n">support_handler</span><span class="p">);</span>
<span class="w">  </span><span class="n">TEST_ASSERT_FALSE</span><span class="p">(</span><span class="n">handler</span><span class="p">.</span><span class="n">manual_security_validation</span><span class="p">);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">SL_STATUS_OK</span><span class="p">;</span>
</pre></div>
</div>
<p>We save our handler into a global static variable so we can use it later in our test functions. All our test functions must start with the <code class="docutils literal notranslate"><span class="pre">test_</span></code> prefix. If we want to test our configuration report in the best case scenario, we can call this function  <code class="docutils literal notranslate"><span class="pre">test_sound_switch_configuration_report_happy_case()</span></code>. Or if we want to test the volume doesn’t go above 100, we can name it <code class="docutils literal notranslate"><span class="pre">test_sound_switch_configuration_report_volume_over_100()</span></code>.</p>
<p>Then, we add the stub definition in our <code class="docutils literal notranslate"><span class="pre">setUp()</span></code> function :</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Called before each and every test</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">setUp</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">//...</span>

<span class="w">  </span><span class="c1">// Unset previous definition of handler </span>
<span class="w">  </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handler</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">zwave_command_handler_t</span><span class="p">));</span>

<span class="w">  </span><span class="c1">// Handler registration</span>
<span class="w">  </span><span class="n">zwave_command_handler_register_handler_Stub</span><span class="p">(</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">zwave_command_handler_register_handler_stub</span><span class="p">);</span>

<span class="w">  </span><span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It’s good practice to init the handler to its default value before each test. Now we can write a simple test for the configuration report :</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">test_sound_switch_configuration_report_volume_over_100</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">zwave_controller_connection_info_t</span><span class="w"> </span><span class="n">info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="w">  </span><span class="n">info</span><span class="p">.</span><span class="n">remote</span><span class="p">.</span><span class="n">node_id</span><span class="w">                     </span><span class="o">=</span><span class="w"> </span><span class="n">node_id</span><span class="p">;</span>
<span class="w">  </span><span class="n">info</span><span class="p">.</span><span class="n">remote</span><span class="p">.</span><span class="n">endpoint_id</span><span class="w">                 </span><span class="o">=</span><span class="w"> </span><span class="n">endpoint_id</span><span class="p">;</span>
<span class="w">  </span><span class="n">info</span><span class="p">.</span><span class="n">local</span><span class="p">.</span><span class="n">is_multicast</span><span class="w">                 </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">  </span><span class="n">TEST_ASSERT_NOT_NULL</span><span class="p">(</span><span class="n">handler</span><span class="p">.</span><span class="n">control_handler</span><span class="p">);</span>
<span class="w">  </span><span class="n">TEST_ASSERT_EQUAL</span><span class="p">(</span><span class="n">SL_STATUS_FAIL</span><span class="p">,</span>
<span class="w">                    </span><span class="n">handler</span><span class="p">.</span><span class="n">control_handler</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">frame</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">COMMAND_CLASS_SOUND_SWITCH</span><span class="p">,</span>
<span class="w">                           </span><span class="n">SOUND_SWITCH_CONFIGURATION_REPORT</span><span class="p">,</span>
<span class="w">                           </span><span class="mi">101</span><span class="p">,</span>
<span class="w">                           </span><span class="mh">0x55</span><span class="p">};</span>

<span class="w">  </span><span class="n">TEST_ASSERT_EQUAL</span><span class="p">(</span><span class="n">SL_STATUS_OK</span><span class="p">,</span>
<span class="w">                    </span><span class="n">handler</span><span class="p">.</span><span class="n">control_handler</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="n">frame</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">frame</span><span class="p">)));</span>

<span class="w">  </span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">volume_node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">attribute_store_get_node_child_by_type</span><span class="p">(</span>
<span class="w">    </span><span class="n">endpoint_id_node</span><span class="p">,</span>
<span class="w">    </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_VOLUME</span><span class="p">,</span>
<span class="w">    </span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="n">TEST_ASSERT_EQUAL</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="n">attribute_store_get_reported_number</span><span class="p">(</span><span class="n">volume_node</span><span class="p">));</span>

<span class="w">  </span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">tone_node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">attribute_store_get_node_child_by_type</span><span class="p">(</span>
<span class="w">    </span><span class="n">endpoint_id_node</span><span class="p">,</span>
<span class="w">    </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_TONE_IDENTIFIER</span><span class="p">,</span>
<span class="w">    </span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="n">TEST_ASSERT_EQUAL</span><span class="p">(</span><span class="mh">0x55</span><span class="p">,</span><span class="w"> </span><span class="n">attribute_store_get_reported_number</span><span class="p">(</span><span class="n">tone_node</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can send to our control handler a Z-Wave report frame of configuration with <code class="docutils literal notranslate"><span class="pre">handler.control_handler()</span></code> and checks if the attributes are correctly updated in the attribute store. This test ensure that the sound level never goes over 100 even if reported so.</p>
</section>
<section id="test-get-set-z-wave-function">
<h3>Test get/set Z-Wave function<a class="headerlink" href="#test-get-set-z-wave-function" title="Permalink to this heading"></a></h3>
<p>We’ll had an handler stub that contains our sound switch get and set callbacks. We defined our get and set function for <code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_VOLUME</span></code> and <code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONES_NUMBER</span></code> like this :</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">attribute_resolver_register_rule</span><span class="p">(</span>
<span class="w">   </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_VOLUME</span><span class="p">,</span>
<span class="w">   </span><span class="o">&amp;</span><span class="n">zwave_command_class_sound_switch_configuration_set</span><span class="p">,</span>
<span class="w">   </span><span class="o">&amp;</span><span class="n">zwave_command_class_sound_switch_configuration_get</span><span class="p">);</span>

<span class="w">  </span><span class="n">attribute_resolver_register_rule</span><span class="p">(</span>
<span class="w">   </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONES_NUMBER</span><span class="p">,</span>
<span class="w">   </span><span class="nb">NULL</span><span class="p">,</span>
<span class="w">   </span><span class="o">&amp;</span><span class="n">zwave_command_class_sound_switch_tones_number_get</span><span class="p">);</span>
</pre></div>
</div>
<p>So we can access them like this in our test file :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">attribute_resolver_function_t</span><span class="w"> </span><span class="n">configuration_get</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="k">static</span><span class="w"> </span><span class="n">attribute_resolver_function_t</span><span class="w"> </span><span class="n">configuration_set</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="k">static</span><span class="w"> </span><span class="n">attribute_resolver_function_t</span><span class="w"> </span><span class="n">tone_number_get</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="c1">// Buffer for frame</span>
<span class="k">static</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">received_frame</span><span class="p">[</span><span class="mi">255</span><span class="p">]</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="k">static</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">received_frame_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="c1">// Stub functions</span>
<span class="k">static</span><span class="w"> </span><span class="n">sl_status_t</span>
<span class="w">  </span><span class="nf">attribute_resolver_register_rule_stub</span><span class="p">(</span><span class="n">attribute_store_type_t</span><span class="w"> </span><span class="n">node_type</span><span class="p">,</span>
<span class="w">                                        </span><span class="n">attribute_resolver_function_t</span><span class="w"> </span><span class="n">set_func</span><span class="p">,</span>
<span class="w">                                        </span><span class="n">attribute_resolver_function_t</span><span class="w"> </span><span class="n">get_func</span><span class="p">,</span>
<span class="w">                                        </span><span class="kt">int</span><span class="w"> </span><span class="n">cmock_num_calls</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_VOLUME</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">TEST_ASSERT_NOT_NULL</span><span class="p">(</span><span class="n">set_func</span><span class="p">);</span>
<span class="w">    </span><span class="n">TEST_ASSERT_NOT_NULL</span><span class="p">(</span><span class="n">get_func</span><span class="p">);</span>
<span class="w">    </span><span class="n">configuration_get</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_func</span><span class="p">;</span>
<span class="w">    </span><span class="n">configuration_set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">set_func</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONES_NUMBER</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">TEST_ASSERT_NULL</span><span class="p">(</span><span class="n">set_func</span><span class="p">);</span>
<span class="w">    </span><span class="n">TEST_ASSERT_NOT_NULL</span><span class="p">(</span><span class="n">get_func</span><span class="p">);</span>
<span class="w">    </span><span class="n">tone_number_get</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_func</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">SL_STATUS_OK</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that we might don’t have a set and get function for all attributes. We can check the null value of <code class="docutils literal notranslate"><span class="pre">set_func</span></code> or <code class="docutils literal notranslate"><span class="pre">get_func</span></code> with <code class="docutils literal notranslate"><span class="pre">TEST_ASSERT_NULL</span></code>. This way we ensure that our set/get callbacks are correctly defined.</p>
<p>We also define a <code class="docutils literal notranslate"><span class="pre">received_frame</span></code> buffer that allows us to test get/set functions.</p>
<p>Then we add the stub definition in our <code class="docutils literal notranslate"><span class="pre">setUp()</span></code> function :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Called before each and every test</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">setUp</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">//...</span>

<span class="w">  </span><span class="c1">// Unset previous definition get/set functions</span>
<span class="w">  </span><span class="n">configuration_get</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">  </span><span class="n">configuration_set</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">  </span><span class="n">tone_number_get</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">  </span><span class="n">memset</span><span class="p">(</span><span class="n">received_frame</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">received_frame</span><span class="p">));</span>
<span class="w">  </span><span class="n">received_frame_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// Resolution functions</span>
<span class="w">  </span><span class="n">attribute_resolver_register_rule_Stub</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attribute_resolver_register_rule_stub</span><span class="p">);</span>

<span class="w">  </span><span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It’s good practice to init the functions and frame buffer to its default value before each test.</p>
<section id="z-wave-get-test">
<h4>Z-Wave Get test<a class="headerlink" href="#z-wave-get-test" title="Permalink to this heading"></a></h4>
<p>Now we can write a simple test for the configuration get :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">test_sound_switch_configuration_get_happy_case</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Ask for a Get Command, should always be the same</span>
<span class="w">  </span><span class="n">TEST_ASSERT_NOT_NULL</span><span class="p">(</span><span class="n">configuration_get</span><span class="p">);</span>
<span class="w">  </span><span class="n">configuration_get</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">received_frame</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">received_frame_size</span><span class="p">);</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">expected_frame</span><span class="p">[]</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">COMMAND_CLASS_SOUND_SWITCH</span><span class="p">,</span><span class="w"> </span><span class="n">SOUND_SWITCH_CONFIGURATION_GET</span><span class="p">};</span>
<span class="w">  </span><span class="n">TEST_ASSERT_EQUAL</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">expected_frame</span><span class="p">),</span><span class="w"> </span><span class="n">received_frame_size</span><span class="p">);</span>
<span class="w">  </span><span class="n">TEST_ASSERT_EQUAL_UINT8_ARRAY</span><span class="p">(</span><span class="n">expected_frame</span><span class="p">,</span>
<span class="w">                                </span><span class="n">received_frame</span><span class="p">,</span>
<span class="w">                                </span><span class="n">received_frame_size</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Nothing special here we should have the Sound Switch command class ID and the configuration get ID. The next section shows you how to interact with the attribute store. It could be useful if your get function have an argument.</p>
</section>
<section id="z-wave-set-test">
<h4>Z-Wave Set test<a class="headerlink" href="#z-wave-set-test" title="Permalink to this heading"></a></h4>
<p>Let’s now test the set function :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">test_sound_switch_configuration_set_happy_case</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">volume</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">15</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">tone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">30</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Attribute tree is empty as this point so we add it here</span>
<span class="w">  </span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">volume_node</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">attribute_store_add_node</span><span class="p">(</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_VOLUME</span><span class="p">,</span><span class="w"> </span><span class="n">endpoint_id_node</span><span class="p">);</span>
<span class="w">  </span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">tone_node</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">attribute_store_add_node</span><span class="p">(</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_TONE_IDENTIFIER</span><span class="p">,</span><span class="w"> </span><span class="n">endpoint_id_node</span><span class="p">);</span>

<span class="w">  </span><span class="n">attribute_store_set_desired</span><span class="p">(</span><span class="n">volume_node</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">volume</span><span class="p">));</span>
<span class="w">  </span><span class="n">attribute_store_set_desired</span><span class="p">(</span><span class="n">tone_node</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tone</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">tone</span><span class="p">));</span>

<span class="w">  </span><span class="n">TEST_ASSERT_NOT_NULL</span><span class="p">(</span><span class="n">configuration_set</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// We can either set the volume_node or tone_here here.</span>
<span class="w">  </span><span class="n">configuration_set</span><span class="p">(</span><span class="n">volume_node</span><span class="p">,</span><span class="w"> </span><span class="n">received_frame</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">received_frame_size</span><span class="p">);</span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">expected_frame</span><span class="p">[]</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">COMMAND_CLASS_SOUND_SWITCH</span><span class="p">,</span><span class="w"> </span><span class="n">SOUND_SWITCH_CONFIGURATION_SET</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">tone</span><span class="p">};</span>
<span class="w">  </span><span class="n">TEST_ASSERT_EQUAL</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">expected_frame</span><span class="p">),</span><span class="w"> </span><span class="n">received_frame_size</span><span class="p">);</span>
<span class="w">  </span><span class="n">TEST_ASSERT_EQUAL_UINT8_ARRAY</span><span class="p">(</span><span class="n">expected_frame</span><span class="p">,</span>
<span class="w">                                </span><span class="n">received_frame</span><span class="p">,</span>
<span class="w">                                </span><span class="n">received_frame_size</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We need to manually set the node value since the attribute tree should be empty.</p>
<p>We set the desired values in our attribute store (<code class="docutils literal notranslate"><span class="pre">endpoint_id_node</span></code> is automatically set by test helper function) and call the set function. This way, we can see if the set function is correctly getting the attributes from the attribute store.</p>
<p>This should cover the basic of unit testing your Z-Wave command class. Don’t forget to also test edge cases and not just the happy cases.
compliance</p>
</section>
</section>
</section>
<section id="z-wave-self-certification-with-the-compliance-test-tool-ctt">
<h2>Z-Wave Self-Certification with the Compliance Test Tool (CTT)<a class="headerlink" href="#z-wave-self-certification-with-the-compliance-test-tool-ctt" title="Permalink to this heading"></a></h2>
<p>The Z-Wave Compliance Test Tool (CTT) is provided by the Z-Wave Alliance. The CTT is designed to ensure that developers have a tool to assist in performing the self-certification tests required for the Z-Wave certification. Note that the use of the CTT does not guarantee certification, but it is a good starting point to know if your command class implementation is robust.</p>
<section id="prerequisites">
<h3>Prerequisites<a class="headerlink" href="#prerequisites" title="Permalink to this heading"></a></h3>
<p>To test the ZPC controller you’ll need 3 Z-Wave boards:</p>
<ul class="simple">
<li><p>Two flashed with the <code class="docutils literal notranslate"><span class="pre">Z-Wave</span> <span class="pre">-</span> <span class="pre">NCP</span> <span class="pre">Serial</span> <span class="pre">API</span> <span class="pre">Controller</span></code> demo</p>
<ul>
<li><p>One for CTT</p></li>
<li><p>One for ZPC</p></li>
</ul>
</li>
<li><p>One flashed with the <code class="docutils literal notranslate"><span class="pre">Z-Wave</span> <span class="pre">-</span> <span class="pre">NCP</span> <span class="pre">Serial</span> <span class="pre">API</span> <span class="pre">End</span> <span class="pre">Device</span></code> demo</p>
<ul>
<li><p>One for CTT</p></li>
</ul>
</li>
</ul>
<blockquote>
<div><p>WARNING: Make sure you select the demo with the right region.</p>
</div></blockquote>
<p>You need to create an account in <a class="reference external" href="https://certification.z-wavealliance.org">https://certification.z-wavealliance.org</a> to have access to the CTT tool. Once you are in, <a class="reference external" href="https://certification.z-wavealliance.org/wiki/index.php/Compliance_Test_Tool_(CTT)">download the latest version of CTT</a>.</p>
</section>
<section id="setup-the-ctt-project">
<h3>Setup the CTT project<a class="headerlink" href="#setup-the-ctt-project" title="Permalink to this heading"></a></h3>
<p>Launch CTT and create a new project. Select the <code class="docutils literal notranslate"><span class="pre">Project</span> <span class="pre">based</span> <span class="pre">on</span> <span class="pre">data</span> <span class="pre">from</span> <span class="pre">Z-Wave</span> <span class="pre">Device</span></code> option :</p>
<p><img alt="Step 2 - Project type in CTT" src="../../_images/ctt_project_type.png" /></p>
<p>This allows you to not create a whole Certification Case for your product and run specific tests.</p>
<p>Next, select the devices used in CTT. When refreshing the device list you should at least have 2 controllers and 1 end device available :</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Examining available devices...

 * COM3            
 * COM4            - ControllerBridgeLib (Z-Wave 7.20) ZW080x Series detected.
 * COM5            - ControllerBridgeLib (Z-Wave 7.20) ZW070x Series detected.
 * COM8            - EndDeviceLib (Z-Wave 7.20) ZW070x Series detected.

   - 3 devices found -
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Refresh</span> <span class="pre">Device</span> <span class="pre">List</span></code> button should fill the fields automatically :</p>
<p><img alt="Step 3 - CTT devices" src="../../_images/ctt_ctt_devices_setup.png" /></p>
<p>Next, you have to  specify the type of DUT (Device Under Test). Since we want to test a controller we have to select <code class="docutils literal notranslate"><span class="pre">DUT</span> <span class="pre">is</span> <span class="pre">a</span> <span class="pre">Static</span> <span class="pre">Controller</span></code> :</p>
<p><img alt="Step 4 - DUT" src="../../_images/ctt_dut_static_controller.png" /></p>
<p>Next, you should have ZPC running to include the CTT devices.</p>
<blockquote>
<div><p>NOTE : If you use WSL <a class="reference external" href="https://learn.microsoft.com/en-us/windows/wsl/connect-usb"><code class="docutils literal notranslate"><span class="pre">usbipd</span></code></a> can help you connect your Z-Wave controller to ZPC.</p>
</div></blockquote>
<p><strong>You can skip Step 5 - CTT includes DUT and move to the next step DUR includes CTT.</strong></p>
<p>In Step 6 DUT includes CTT, start by pressing Reset for the <code class="docutils literal notranslate"><span class="pre">Reset</span> <span class="pre">CTT</span> <span class="pre">Controller</span></code> step.</p>
<p>Then, you’ll have reset ZPC and start add mode. You can do that either in the Dev GUI or in CLI.</p>
<p><img alt="Step 6 - add mode" src="../../_images/ctt_step_6_reset_dut.png" /></p>
<p>In CLI :</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>ZPC&gt;<span class="w"> </span>zwave_set_default
<span class="m">2023</span>-Nov-29<span class="w"> </span><span class="m">11</span>:49:23.791945<span class="w"> </span>&lt;i&gt;<span class="w"> </span><span class="o">[</span>zwave_command_association<span class="o">]</span><span class="w"> </span>Reset<span class="w"> </span>step:<span class="w"> </span>Associations<span class="w"> </span>clean-up
...

ZPC&gt;<span class="w"> </span>zwave_add_node
<span class="m">2023</span>-Nov-29<span class="w"> </span><span class="m">11</span>:50:13.360236<span class="w"> </span>&lt;i&gt;<span class="w"> </span><span class="o">[</span>zwave_network_managment<span class="o">]</span><span class="w"> </span>Initiating<span class="w"> </span>a<span class="w"> </span>Z-Wave<span class="w"> </span>Network<span class="w"> </span>Inclusion
</pre></div>
</div>
<p>Then, you’ll have to set the DSK to include the CTT controller :</p>
<p><img alt="Step 6 - DSK" src="../../_images/ctt_step_6_dsk.png" /></p>
<p>In CLI:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>ZPC&gt;zwave_accept_dsk<span class="w"> </span><span class="m">34080</span>
<span class="m">2023</span>-Nov-29<span class="w"> </span><span class="m">11</span>:54:38.492938<span class="w"> </span>&lt;W&gt;<span class="w"> </span><span class="o">[</span>process.c<span class="o">]</span><span class="w"> </span>Process<span class="w"> </span>zwave_network_management_process<span class="w"> </span>took<span class="w"> </span><span class="m">59</span><span class="w"> </span>ms<span class="w"> </span>to<span class="w"> </span>execute<span class="w"> </span>event<span class="w"> </span><span class="m">16</span>.<span class="w"> </span>
<span class="m">2023</span>-Nov-29<span class="w"> </span><span class="m">11</span>:54:38.493143<span class="w"> </span>&lt;i&gt;<span class="w"> </span><span class="o">[</span>zwave_controller_dispatch<span class="o">]</span><span class="w"> </span>New<span class="w"> </span>NodeID<span class="w"> </span><span class="m">2</span><span class="w"> </span>has<span class="w"> </span>joined<span class="w"> </span>the<span class="w"> </span>network.<span class="w"> </span>Granted<span class="w"> </span>keys:<span class="w"> </span>0x00<span class="w"> </span>-<span class="w"> </span>Protocol:<span class="w"> </span><span class="m">0</span>
<span class="m">2023</span>-Nov-29<span class="w"> </span><span class="m">11</span>:54:38.493211<span class="w"> </span>&lt;i&gt;<span class="w"> </span><span class="o">[</span>zwave_controller_dispatch<span class="o">]</span><span class="w"> </span>DSK:<span class="w"> </span><span class="m">34080</span>-61449-35120-42836-29835-32220-46142-63322
</pre></div>
</div>
<p>Once it’s included, you can click on the <code class="docutils literal notranslate"><span class="pre">Done</span></code> button of <code class="docutils literal notranslate"><span class="pre">Inclusion</span> <span class="pre">done;</span> <span class="pre">wait</span> <span class="pre">for</span> <span class="pre">DUT</span> <span class="pre">interviewing</span> <span class="pre">CTT</span></code> step.</p>
<p>The setup is now complete and you should see 2 controllers in the Dev Gui :</p>
<p><img alt="Step 6 - final" src="../../_images/ctt_step_6_final.png" /></p>
<p>To finish the project creation you have to answer some questions about the DUT:</p>
<p><img alt="Step 7 - questions" src="../../_images/ctt_step_7_questions.png" /></p>
<p>Select option according to the screenshot above. You can select either the command class you want to test or say yes to all even if they are not supported.</p>
</section>
<section id="run-the-tests">
<h3>Run the tests<a class="headerlink" href="#run-the-tests" title="Permalink to this heading"></a></h3>
<p>The commands class tests can be found under the Interactive Tests section:</p>
<p><img alt="Interactive test" src="../../_images/ctt_interactive_tests.png" /></p>
<p>Click on the pending link to have access to the complete list of command class tests :</p>
<p><img alt="Test list" src="../../_images/ctt_test_list.png" /></p>
<blockquote>
<div><p>NOTE : Only the supported command class you registered as controlled in Step 7 of project creation will show up.</p>
</div></blockquote>
<p>The ZPC prints its supported command class at startup :</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>| Command Class                  | Version | Support | Control | Security Level              | Comment |
| ------------------------------ | ------- | ------- | ------- | --------------------------- | ------- |
| Alarm Sensor                   |       1 |         |       x | N/A                         |         |
| Association                    |       2 |       x |       x | Network Scheme              |         |
| Association Group Info (AGI)   |       3 |       x |       x | Network Scheme              |         |
| Barrier Operator               |       1 |         |       x | N/A                         |         |
| Basic                          |       2 |         |       x | N/A                         |         |
| Battery                        |       3 |         |       x | N/A                         | Control Part is auto-generated. |
| Binary Sensor                  |       1 |         |       x | N/A                         | Control Part is auto-generated. |
| Binary Switch                  |       2 |         |       x | N/A                         |         |
| Central Scene                  |       3 |         |       x | N/A                         | Partial control: key attributes are not displayed in the UI. |
| Color Switch                   |       3 |         |       x | N/A                         | Partial Control:&lt;br&gt;1. Durations are ignored&lt;br&gt;2. No support for Start/Stop Level Change&lt;br&gt;3. No support for other Color Component IDs than 0,1,2,3,4 |
| Configuration                  |       4 |         |       x | N/A                         |         |
| Device Reset Locally           |       1 |       x |       x | Network Scheme              |         |
| Door Lock                      |       4 |         |       x | N/A                         |         |
| Firmware Update                |       7 |       x |       x | Network Scheme              |         |
| Inclusion Controller           |       1 |       x |       x | Unencrypted                 |         |
| Indicator                      |       3 |       x |       x | Network Scheme              |         |
| Manufacturer Specific          |       2 |       x |       x | Network Scheme              |         |
| Meter                          |       6 |         |       x | N/A                         | Partial control: &lt;br&gt;1. Meter Reset Command is not supported due to missing dotdot ZCL equivalent functionality. |
| Multi Channel                  |       4 |         |       x | N/A                         |         |
| Multi Channel Association      |       3 |       x |       x | Network Scheme              |         |
| Multi Command                  |       1 |       x |         | Unencrypted                 |         |
| Multilevel Sensor              |      11 |         |       x | N/A                         | Partial control: &lt;br&gt;1. Not all scales are supported&lt;br&gt;2. Not all types are shown in the UI. |
| Multilevel Switch              |       4 |         |       x | N/A                         |         |
| Notification                   |       8 |         |       x | N/A                         | Partial Control: &lt;br&gt;1. No Push/Pull discovery is done.&lt;br&gt;2. No Pull sensor support. &lt;br&gt;3. Unknown types are not supported. &lt;br&gt;4. No Regular probing is done.  |
| Powerlevel                     |       1 |       x |         | Network Scheme              |         |
| Scene Activation               |       1 |         |       x | N/A                         |         |
| Scene Actuator Configuration   |       1 |         |       x | N/A                         | No interview performed automatically. |
| Scene Controller Configuration |       1 |         |       x | N/A                         |         |
| Security 0                     |       1 |       x |       x | Unencrypted                 |         |
| Security 2                     |       1 |       x |       x | Unencrypted                 |         |
| Sound Switch                   |       1 |         |       x | N/A                         |         |
| Supervision                    |       2 |       x |       x | Unencrypted                 |         |
| Thermostat Mode                |       3 |         |       x | N/A                         | Partial Control: Not all modes can be set |
| Thermostat Setpoint            |       3 |         |       x | N/A                         | Partial Control: &lt;br&gt;1. No discovery of ambiguous types in v1-v2 &lt;br&gt;2. Only a few setpoints can be configured. &lt;br&gt;3. Precision/size fields in the set are determined &lt;br&gt;automatically by the controller.  |
| Time                           |       1 |       x |         | Unencrypted                 |         |
| Transport Service              |       2 |       x |       x | Unencrypted                 |         |
| User Code                      |       2 |         |       x | N/A                         | Partial Control |
| Version                        |       3 |       x |       x | Network Scheme              |         |
| Wake Up                        |       3 |         |       x | N/A                         |         |
| Z-Wave Plus Info               |       2 |       x |       x | Unencrypted                 |         |
</pre></div>
</div>
<p>You can start a test by right clicking on it and press <code class="docutils literal notranslate"><span class="pre">Run</span></code>. The test will ask you some questions about your implementation and to send specific Z-Wave command. Those can be triggered through MQTT or via the Dev GUI.</p>
<p>A set of python scripts are available for you to easily send commands to CTT in
<code class="docutils literal notranslate"><span class="pre">applications/zpc/scripts/certification</span></code>.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer>
    <hr/>
    <p>Copyright © 2023 Silicon Laboratories. All rights reserved.</p>
</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>