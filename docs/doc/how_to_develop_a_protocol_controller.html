<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<meta content="Protocol Controller Developer Guide" name="description" />
<meta content="Protocol, Controller, Developer, Guide" name="keywords" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>How to develop a Protocol Controller &mdash; Unify Host SDK</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom_styles.css" type="text/css" />
    <link rel="canonical" href="https://siliconlabs.github.io/UnifySDK/doc/how_to_develop_a_protocol_controller.html" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/js/charenc.js"></script>
        <script src="../_static/js/crypt.js"></script>
        <script src="../_static/js/sha1.js"></script>
        <script src="../_static/js/html5-qrcode.min.js"></script>
        <script src="../_static/js/qr_code_scanner.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="introduction.html" class="icon icon-home"> Unify
            <img src="../_static/silicon-labs-logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                ver_1.5.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Unify Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="running_unify.html">Running Unify on Raspberry Pi</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="UnifySDK.html">Unify Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="unify_framework_services.html">Framework Services</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="protocol_controllers.html">Protocol Controllers</a></li>
<li class="toctree-l1"><a class="reference internal" href="unify_iot_services.html">IoT Services</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="getting_started_as_developer.html">Getting Started as a Developer</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="unify_specifications/index.html">Unify Specifications</a></li>
<li class="toctree-l1"><a class="reference internal" href="system_requirements.html">System Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="standards/known-abbreviations.html">Known Abbreviations</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="introduction.html">Unify</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <script>
    $(".wy-side-scroll").append("<div class='github-button'><iframe src='https://ghbtns.com/github-btn.html?user=SiliconLabs&repo=UnifySDK&type=watch&count=true&size=large&v=2' allowtransparency='true' frameborder='0' scrolling='0' width='170' height='30'></iframe></div>");
</script>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="how-to-develop-a-protocol-controller">
<span id="how-to-develop-a-protocol-controller-section"></span><h1>How to develop a Protocol Controller<a class="headerlink" href="#how-to-develop-a-protocol-controller" title="Permalink to this heading"></a></h1>
<p>This page provides a guide on how to develop a Protocol Controller. A Protocol
Controller can be a complicated application, but can be developed easily
using the <a class="reference internal" href="unify_library_overview.html"><span class="doc">Unify Library</span></a>.</p>
<section id="what-is-a-protocol-controller">
<h2>What is a Protocol Controller?<a class="headerlink" href="#what-is-a-protocol-controller" title="Permalink to this heading"></a></h2>
<p>Protocol Controllers can be quite different by design. As a minimum, an
application is considered to be a Protocol Controller when it
interacts (send/receive messages) with some nodes/entities using e.g.
networking protocols and allows at least one of the following using
the UCL language:</p>
<ol class="arabic simple">
<li><p>Expose attributes from the nodes it can reach via MQTT.</p></li>
<li><p>Send commands to the nodes it can reach when instructed via MQTT.</p></li>
</ol>
<p>If an application can communicate with a device and proxy
its state and/or functionality using the UCL language, it is considered
a Protocol Controller.</p>
</section>
<section id="before-getting-started">
<h2>Before getting started<a class="headerlink" href="#before-getting-started" title="Permalink to this heading"></a></h2>
<p>First and foremost, take a moment to read the
<a class="reference internal" href="unify_specifications/index.html"><span class="doc">Unify Framework Specifications</span></a>.
They describe how the Protocol Controller will translate and display nodes
using the UCL framework.</p>
<p>If using the Unify repository, make sure to read the
<a class="reference internal" href="readme_developer.html"><span class="doc">Developer README</span></a> before going ahead and creating a new
application. Finally, it is also a good idea to check the
<a class="reference internal" href="standards/coding-standard.html"><span class="doc">Coding Standard</span></a> and adhere to it before creating
a Protocol Controller in the Unify repository.</p>
</section>
<section id="example-protocol-controller">
<h2>Example Protocol Controller<a class="headerlink" href="#example-protocol-controller" title="Permalink to this heading"></a></h2>
<p>An Example Protocol Controller (<strong>EPC</strong>) is provided as part of the Unify Framework.
This example application intends to show how to set up and develop a Protocol
Controller.</p>
<p>We use code snippets from the Example Protocol Controller in this guide, but
it is a good idea to have a look at the <strong>EPC</strong> and use it for inspiration when
developing a new Protocol Controller.</p>
</section>
<section id="getting-started">
<h2>Getting started<a class="headerlink" href="#getting-started" title="Permalink to this heading"></a></h2>
<section id="creating-a-new-application">
<h3>Creating a new application<a class="headerlink" href="#creating-a-new-application" title="Permalink to this heading"></a></h3>
<p>If you are using the Unify repository, start by creating folders and CMake
files that will allow to build a new application. Peek into the other
applications to get quickly started.</p>
</section>
<section id="creating-a-main-loop">
<h3>Creating a main loop<a class="headerlink" href="#creating-a-main-loop" title="Permalink to this heading"></a></h3>
<p>Protocol Controllers designed using the
<a class="reference internal" href="unify_library_overview.html"><span class="doc">Unify Library</span></a> should get started by creating a
main loop.</p>
<p>The main loop can be created by providing a list of functions to invoke for
initialization and teardown, and then invoking <em>uic_main</em>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;uic_main.h&quot;</span>

<span class="c1">// List of init functions.</span>
<span class="k">static</span><span class="w"> </span><span class="n">uic_fixt_setup_step_t</span><span class="w"> </span><span class="n">uic_fixt_setup_steps_list</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">{</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Terminator&quot;</span><span class="p">}};</span>

<span class="c1">// List of shutdown functions</span>
<span class="k">static</span><span class="w"> </span><span class="n">uic_fixt_shutdown_step_t</span><span class="w"> </span><span class="n">uic_fixt_shutdown_steps_list</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">{</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Terminator&quot;</span><span class="p">}};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">uic_main</span><span class="p">(</span><span class="n">uic_fixt_setup_steps_list</span><span class="p">,</span>
<span class="w">                  </span><span class="n">uic_fixt_shutdown_steps_list</span><span class="p">,</span>
<span class="w">                  </span><span class="n">argc</span><span class="p">,</span>
<span class="w">                  </span><span class="n">argv</span><span class="p">,</span>
<span class="w">                  </span><span class="n">CMAKE_PROJECT_VERSION</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Running the main loop without any additional components active will provide a
simple console with a few default functions available. An MQTT broker must be
available and its addresss must be given as argument.</p>
<p>Using the <strong>Example Protocol Controller</strong> application with an empty list of
setup and teardown fixtures will look like this.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">pi@raspberrypi:~/unify/build $ </span>ninja<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>./applications/examples/applications/epc/epc<span class="w"> </span>--log.level<span class="w"> </span>d<span class="w"> </span>--mqtt.host<span class="w"> </span>zpi
</pre></div>
</div>
<figure class="align-center" id="id1">
<a class="reference internal image-reference" href="../_images/epc_bare_minimum_main_loop_running.png"><img alt="EPC Bare minimum main loop" src="../_images/epc_bare_minimum_main_loop_running.png" style="width: 700px;" /></a>
<figcaption>
<p><span class="caption-text">EPC Bare minimum main loop</span><a class="headerlink" href="#id1" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>The order of initialization must be carefully set, so the components that
depend on another can rely on their dependencies to be initialized. For instance,
it is important to initialize the <strong>Datastore</strong> component before
the <strong>Attribute store</strong>. Components will in most cases log warnings or errors
if they cannot initialize as intended.</p>
<p>It is recommended to initialize:</p>
<ol class="arabic simple">
<li><p>All configuration first</p></li>
<li><p>Unify Components that The protocol Controller needs</p></li>
<li><p>Protocol Controller specific components</p></li>
</ol>
<p>The teardown order should be the reverse of the initialization order.</p>
<p>Fixture functions are expected to return status codes that will indicate
if the start sequence should continue. For example:</p>
<ul class="simple">
<li><p>SL_STATUS_OK: Initialization went well</p></li>
<li><p>SL_STATUS_NOT_AVAILABLE: Initialialization failed, but it was not a critical error and the system should continue running</p></li>
<li><p>Any other value: Initialization failed and the program will shutdown immediately.</p></li>
</ul>
</section>
<section id="additional-configuration">
<h3>Additional configuration<a class="headerlink" href="#additional-configuration" title="Permalink to this heading"></a></h3>
<p>The Unify configuration module allows to define configuration keys and values
that will be used by the application. The
<a class="reference internal" href="unify_library_overview.html"><span class="doc">Unify Library</span></a> itself sets up a few of these keys
such as the MQTT broker, port, etc.</p>
<p>To see the current configuration setup for an application, run the application
with <code class="docutils literal notranslate"><span class="pre">--help</span></code>. For example using the EPC:</p>
<figure class="align-center" id="id2">
<a class="reference internal image-reference" href="../_images/epc_help_default_configuration.png"><img alt="EPC Help default configuration" src="../_images/epc_help_default_configuration.png" style="width: 700px;" /></a>
<figcaption>
<p><span class="caption-text">EPC Help default configuration</span><a class="headerlink" href="#id2" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Protocol Controllers should add a component that will initialize all the
additional configuration keys and values that they need. Using the EPC, a
dedicated component holding the list of configuration (<code class="docutils literal notranslate"><span class="pre">epc_config</span></code>) is used
to add more value/keys in the main function.</p>
<p>Protocol Controllers have to initialize all configuration keys and default
values before running the main loop.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Initialize the EPC Configuration, add new keys/default values as needed.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">epc_config_init</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">EXIT_FAILURE</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">sl_log_info</span><span class="p">(</span><span class="n">LOG_TAG</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Starting the EPC main loop&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Run uic_main and return result</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">uic_main</span><span class="p">(</span><span class="n">uic_fixt_setup_steps_list</span><span class="p">,</span>
<span class="w">                  </span><span class="n">uic_fixt_shutdown_steps_list</span><span class="p">,</span>
<span class="w">                  </span><span class="n">argc</span><span class="p">,</span>
<span class="w">                  </span><span class="n">argv</span><span class="p">,</span>
<span class="w">                  </span><span class="n">CMAKE_PROJECT_VERSION</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the example above, the <code class="docutils literal notranslate"><span class="pre">epc_config_init()</span></code> function will for example
initialize the default path that will be used with the persistent storage
database. Components can then rely from the initialization that the
<code class="docutils literal notranslate"><span class="pre">CONFIG_KEY_EPC_DATASTORE_FILE</span></code> configuration is available and be set to a value
that they can use this value for their operation.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">epc_config_init</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">config_status_t</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CONFIG_STATUS_OK</span><span class="p">;</span>
<span class="w">  </span><span class="n">status</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">config_add_string</span><span class="p">(</span><span class="n">CONFIG_KEY_EPC_DATASTORE_FILE</span><span class="p">,</span>
<span class="w">                              </span><span class="s">&quot;EPC datastore database file&quot;</span><span class="p">,</span>
<span class="w">                              </span><span class="n">DEFAULT_EPC_DATASTORE_FILE</span><span class="p">);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">CONFIG_STATUS_OK</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Further, it is recommended to have a cached variable made available for all other
components of the Protocol Controller to access configuration values quickly.
For example, after adding a datastore_file configuration, a wrapper could look
like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">/// File name for datastore/persistent storage</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">datastore_file</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">epc_config_t</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="n">epc_config_t</span><span class="w"> </span><span class="n">config</span><span class="p">;</span>

<span class="n">sl_status_t</span><span class="w"> </span><span class="nf">epc_config_fixt_setup</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">config</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">config</span><span class="p">));</span>
<span class="w">  </span><span class="n">config_status_t</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CONFIG_STATUS_OK</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// Datastore configuration</span>
<span class="w">  </span><span class="n">status</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">config_get_as_string</span><span class="p">(</span><span class="n">CONFIG_KEY_EPC_DATASTORE_FILE</span><span class="p">,</span>
<span class="w">                                </span><span class="o">&amp;</span><span class="n">config</span><span class="p">.</span><span class="n">datastore_file</span><span class="p">);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">CONFIG_STATUS_OK</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">SL_STATUS_OK</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">SL_STATUS_FAIL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span><span class="w"> </span><span class="n">epc_config_t</span><span class="w"> </span><span class="o">*</span><span class="nf">epc_get_config</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="n">config</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finally, make sure to initialize this Protocol Controller specialization of
the configuration as the first initizalized fixture, so that all components
can access the configuration through the cache.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">uic_fixt_setup_step_t</span><span class="w"> </span><span class="n">uic_fixt_setup_steps_list</span><span class="p">[]</span>
<span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">{{</span><span class="o">&amp;</span><span class="n">epc_config_fixt_setup</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;EPC Config&quot;</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Terminator&quot;</span><span class="p">}};</span>
</pre></div>
</div>
<p>From now on, any component in the application will be able to read the
datastore file configuration setting by invoking:
<code class="docutils literal notranslate"><span class="pre">epc_get_config()-&gt;datastore_file</span></code></p>
</section>
<section id="adding-contiki-processes">
<h3>Adding Contiki processes<a class="headerlink" href="#adding-contiki-processes" title="Permalink to this heading"></a></h3>
<p>To keep the system reactive (and not blocking for too long when
performing a chain of operations), Unify Applications and components use Contiki
processes. When an event occurs and can be processed non-sequentially,
it is almost always better to use a Contiki Process.</p>
<p>Note that Contiki Process are not the same as threads, and they still
block each other while executing events. Refer to the Contiki documentation
for details.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;process.h&quot;</span>

<span class="n">PROCESS</span><span class="p">(</span><span class="n">epc_process</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Example Protocol Controller Process&quot;</span><span class="p">);</span>

<span class="c1">// Demo process implementation</span>
<span class="n">PROCESS_THREAD</span><span class="p">(</span><span class="n">epc_process</span><span class="p">,</span><span class="w"> </span><span class="n">ev</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">PROCESS_BEGIN</span><span class="p">()</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">ev</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="no">PROCESS_EVENT_INIT</span><span class="p">:</span>
<span class="w">        </span><span class="c1">// Additional init code here</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="no">PROCESS_EVENT_EXIT</span><span class="p">:</span>
<span class="w">        </span><span class="c1">// Additional teardown code here</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">PROCESS_WAIT_EVENT</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">PROCESS_END</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Processes will get started as part of the initialization fixtures. There is
no need to shutdown the processes on exit.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Fixture starting a process</span>
<span class="n">sl_status_t</span><span class="w"> </span><span class="nf">epc_process_fixt_setup</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">process_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epc_process</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">SL_STATUS_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="n">uic_fixt_setup_step_t</span><span class="w"> </span><span class="n">uic_fixt_setup_steps_list</span><span class="p">[]</span>
<span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">{{</span><span class="o">&amp;</span><span class="n">epc_config_fixt_setup</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;EPC Config&quot;</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="o">&amp;</span><span class="n">epc_process_fixt_setup</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;EPC Process&quot;</span><span class="p">},</span><span class="w"> </span><span class="c1">// Start the Contiki process in initialization</span>
<span class="w">    </span><span class="p">{</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Terminator&quot;</span><span class="p">}};</span>
</pre></div>
</div>
</section>
</section>
<section id="how-to-use-the-attribute-system">
<h2>How to use the attribute system<a class="headerlink" href="#how-to-use-the-attribute-system" title="Permalink to this heading"></a></h2>
<p>The Attribute System aims at providing a very generic solution to storing
network information and making decisions based on any data present in the
network.</p>
<p>It makes the assumption that everything can be stored in an acyclic directed
graph structure, representing the state and knowledge that we have a about
nodes that we can communicate with.</p>
<p>Arbitrary values from 0 to 255 bytes long can be stored in for each attribute
(i.e. it can be any type of numbers, byte-array, structs, strings). Each
attribute has 2 values, a reported (current value reported by the node itself)
and a desired (future/wished value).</p>
<p>An example of a Z-Wave Attribute Store is shown below:</p>
<figure class="align-center" id="id3">
<a class="reference internal image-reference" href="doc/assets/img/attribute_store_representation.png"><img alt="Z-Wave Attribute Store representation" src="doc/assets/img/attribute_store_representation.png" style="width: 95%;" /></a>
<figcaption>
<p><span class="caption-text">Z-Wave Attribute Store representation</span><a class="headerlink" href="#id3" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<section id="defining-attribute-types">
<h3>Defining Attribute Types<a class="headerlink" href="#defining-attribute-types" title="Permalink to this heading"></a></h3>
<p>Attribute types are identified by a unique <em>uint32_t</em> value, and only 0
(invalid type) and 1 (root attribute) are reserved. The rest of the range can
be assigned by an application.</p>
<p>As the list of defined types is application specific, each application is
free to define for example that type = 2 represents a UNID string, type = 3
represents a uint16_t port number, etc.</p>
<p>To fully leverage the Attribute System, attribute types should be registered
to the Attribute Store using the <em>attribute_store_regisration</em> API. For example,
below, registering the “NodeID” attribute, indicating that it will be placed
under HomeID attributes and uses a <em>uint16_t</em> format for storage.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">status</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">attribute_store_register_type</span><span class="p">(</span><span class="n">ATTRIBUTE_NODE_ID</span><span class="p">,</span><span class="w"> </span><span class="c1">// ATTRIBUTE_NODE_ID is a unique uint32_t number, e.g. 3</span>
<span class="w">                                        </span><span class="s">&quot;NodeID&quot;</span><span class="p">,</span>
<span class="w">                                        </span><span class="n">ATTRIBUTE_HOME_ID</span><span class="p">,</span><span class="w"> </span><span class="c1">// ATTRIBUTE_HOME_ID is a unique uint32_t number, e.g. 2</span>
<span class="w">                                        </span><span class="n">U16_STORAGE_TYPE</span><span class="p">);</span>
</pre></div>
</div>
<p>This is particularly important if a Protocol Controller needs to use the
<strong>Attribute Mapper</strong>, as it will allow it to interpret the values of each
attribute.</p>
<section id="pre-defined-attribute-types">
<h4>Pre-defined attribute types<a class="headerlink" href="#pre-defined-attribute-types" title="Permalink to this heading"></a></h4>
<p>A shared DotDot attribute store component (<strong>UIC DotDot Attribute Store</strong>)
defines automatically ZCL attribute types for usage in the <strong>Attribute Store</strong>.
It is not mandatory to use it, but intends to provide a very easy solution to
storing the ZCL state of nodes, which serves as a basis for publishing
attributes or receiving commands via MQTT.</p>
<p>Attribute types are <em>uint32_t</em> values, so 4 bytes long.
The DotDot pre-defined attributes use the following range:
<code class="docutils literal notranslate"><span class="pre">(ZigBee</span> <span class="pre">Cluster</span> <span class="pre">ID</span> <span class="pre">(2</span> <span class="pre">bytes)</span> <span class="pre">&lt;&lt;16)</span> <span class="pre">|</span> <span class="pre">Zigbee</span> <span class="pre">attribute</span> <span class="pre">ID</span> <span class="pre">(2</span> <span class="pre">bytes)</span></code></p>
<p>The value 0 (Basic Cluster ID) has been replaced to value 0xBA5C, so the range
0x00000002 to 0x0000FFFF is guaranteed to be available for Protocol Controllers
to define their proprietary attributes.</p>
<p>Protocol Controllers must then use this reserved range to assign their own
application attribute definitions. Additionally, attributes allowing to
identify networking addresses/PAN nodes must also be defined by the Protocol
Controllers themselves.</p>
</section>
<section id="attribute-store-and-addressing">
<h4>Attribute Store and addressing<a class="headerlink" href="#attribute-store-and-addressing" title="Permalink to this heading"></a></h4>
<p>Using the reserved attribute type range, Protocol Controllers must come up
with an addressing/identifying schema for their networking protocol.</p>
<p>These types should be defined in a manner that will make it easy for the
Protocol Controller to retrieve addresses (either networking addresses,
or UNID/Endpoint addresses) of the resources based on their location in the
attribute tree.</p>
<p>An example of the 2 possible strategies is given in the subsections below.</p>
<section id="networking-addresses-approach">
<h5>Networking addresses approach<a class="headerlink" href="#networking-addresses-approach" title="Permalink to this heading"></a></h5>
<p>The <strong>ZPC</strong> for example uses the networking address strategy, where it stores
Z-Wave addresses under the <strong>Attribute Store</strong> tree root. Application level
attributes are then placed under Endpoints.</p>
<figure class="align-center">
<p class="plantuml">
<img src="../_images/plantuml-09314ca873c4152e43325cbba5bba59c1cea89f7.png" alt="!theme plain
title Attribute Store tree networking addressing example

object root
root : Attribute Type = TREE_ROOT
root : value = Desired: [], Reported: []

object &quot;HomeID&quot; as home_id #fffae6
home_id : Attribute Type = ATTRIBUTE_HOME_ID
home_id : value = Desired: [], Reported: [FB E6 8C CE]

object &quot;NodeID&quot; as node_id_1 #f2ffe6
node_id_1 : Attribute Type = ATTRIBUTE_NODE_ID
node_id_1 : value = Desired: [], Reported: [03]

object &quot;NodeID&quot; as node_id_2 #f2ffe6
node_id_2 : Attribute Type = ATTRIBUTE_NODE_ID
node_id_2 : value = Desired: [], Reported: [04]

object &quot;Endpoint&quot; as endpoint_1 #e6fff7
endpoint_1 : Attribute Type = ATTRIBUTE_ENDPOINT_ID
endpoint_1 : value = Desired: [], Reported: [00]

object &quot;Endpoint&quot; as endpoint_2 #e6fff7
endpoint_2 : Attribute Type = ATTRIBUTE_ENDPOINT_ID
endpoint_2 : value = Desired: [], Reported: [01]

object &quot;Endpoint&quot; as endpoint_3 #e6fff7
endpoint_3 : Attribute Type = ATTRIBUTE_ENDPOINT_ID
endpoint_3 : value = Desired: [], Reported: [00]

object &quot;OnOff attribute&quot; as node_1_ep_2_on_off #FFFFFF
node_1_ep_2_on_off : Attribute Type = DOTDOT_ATTRIBUTE_ID_ON_OFF_ON_OFF
node_1_ep_2_on_off : value = Desired: [01], Reported: [00]

root *-- home_id
home_id *-- node_id_1
home_id *-- node_id_2
node_id_1 *-- endpoint_1
node_id_1 *-- endpoint_2
node_id_2 *-- endpoint_3
endpoint_2 *-- node_1_ep_2_on_off"/>
</p>
</figure>
<p>Using this methodology, to publish the state of the OnOff attribute when updated,
the <strong>ZPC</strong> navigates up the <strong>Attribute Store</strong>, collects the value of the
Endpoint, NodeID, HomeID and derives the UNID (from the NodeID / HomeID) and
Endpoint. The <strong>ZPC</strong> can subsequently make these 2 publications:</p>
<div class="highlight-mqtt notranslate"><div class="highlight"><pre><span></span><span class="ow">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/OnOff/Attributes/OnOff/Desired</span> - {<span class="w"> </span><span class="nt">&quot;value&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span>}
<span class="ow">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/OnOff/Attributes/OnOff/Reported</span> - {<span class="w"> </span><span class="nt">&quot;value&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span>}
</pre></div>
</div>
<p>If a frame is to be sent using the Protocol Controller networking protocol,
the addressing information (Endpoint, NodeID, HomeID) is also easy to collect
navigating up the <strong>Attribute Store</strong>.</p>
<p>This method is advantageous if there is a need to store more information
alongside netorking entities, like granted keys for a node, or shared
network properties under for example the HomeID.</p>
</section>
<section id="unid-endpoint-approach">
<h5>UNID/Endpoint approach<a class="headerlink" href="#unid-endpoint-approach" title="Permalink to this heading"></a></h5>
<p>The <strong>AoXPC</strong> uses a more UNID-like strategy, where the UNIDs are directly saved
under the <strong>Attribute Store</strong> tree root.</p>
<figure class="align-center">
<p class="plantuml">
<img src="../_images/plantuml-61208c548cf26b54717d665f06b16f1c0a01bfed.png" alt="!theme plain
title Attribute Store tree UNID addressing example

object &quot;Root&quot; as root #DEDEDE
root : Attribute Type = TREE_ROOT
root : value = Desired: [], Reported: []

object &quot;BLE-UNID&quot; as node_1 #fffae6
node_1 : Attribute Type = ATTRIBUTE_BLE_UNID
node_1 : value = Desired: [], Reported: [&quot;ble-pd-588E81A54788&quot;]

object &quot;Endpoint&quot; as endpoint_1 #f2ffe6
endpoint_1 : Attribute Type = ATTRIBUTE_ENDPOINT_ID
endpoint_1 : value = Desired: [], Reported: [00]

object &quot;Endpoint&quot; as endpoint_2 #f2ffe6
endpoint_2 : Attribute Type = ATTRIBUTE_ENDPOINT_ID
endpoint_2 : value = Desired: [], Reported: [01]

object &quot;BLE-UNID&quot; as node_2 #fffae6
node_2 : Attribute Type = ATTRIBUTE_BLE_UNID
node_2 : value = Desired: [], Reported: [&quot;ble-pd-588E81A54788&quot;]

object &quot;Endpoint&quot; as endpoint_3 #f2ffe6
endpoint_3 : Attribute Type = ATTRIBUTE_ENDPOINT_ID
endpoint_3 : value = Desired: [], Reported: [00]

object &quot;OnOff attribute&quot; as node_1_ep_2_on_off #FFFFFF
node_1_ep_2_on_off : Attribute Type = DOTDOT_ATTRIBUTE_ID_ON_OFF_ON_OFF
node_1_ep_2_on_off : value = Desired: [01], Reported: [00]

root *-- node_1
root *-- node_2
node_1 *-- endpoint_1
node_1 *-- endpoint_2
node_2 *-- endpoint_3
endpoint_2 *-- node_1_ep_2_on_off"/>
</p>
</figure>
<p>Using this methodology, to publish the state of the OnOff attribute when updated,
the <strong>AoxPC</strong> navigates up the <strong>Attribute Store</strong>, collects the value of the
Endpoint, UNID, and does require any further calculation.
The <strong>AoxPC</strong> can subsequently make these 2 publications:</p>
<div class="highlight-mqtt notranslate"><div class="highlight"><pre><span></span><span class="ow">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/OnOff/Attributes/OnOff/Desired</span> - {<span class="w"> </span><span class="nt">&quot;value&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kc">true</span>}
<span class="ow">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/OnOff/Attributes/OnOff/Reported</span> - {<span class="w"> </span><span class="nt">&quot;value&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kc">false</span>}
</pre></div>
</div>
<p>However, when using UNIDs, if a frame is to be sent using the Protocol
Controller networking protocol, the reverse logic needs to be applied and
whenever an attribute triggers the <strong>Attribute Resolver</strong> to send a frame to
a destination, the frame sending functions needs to calculate networking
addresses based on the UNID/Endpoint data in the <strong>Attribute Store</strong>.</p>
</section>
</section>
</section>
<section id="attribute-resolution">
<h3>Attribute resolution<a class="headerlink" href="#attribute-resolution" title="Permalink to this heading"></a></h3>
<p>When a Protocol Controller has defined its own proprietary atttributes
(both addressing and application-level attributes), it
can start using the <strong>Attribute Resolver</strong> to schedule and send frames.</p>
<p>Let’s assume a Protocol Controller using UNID addressing strategy in the
<strong>Attribute Store</strong>. To enable the <strong>Attribute Resolver</strong>, a few additional
components will be needed:</p>
<ul class="simple">
<li><p>An NCP component, that allows to send and/or receive frames over the networking protocol.</p></li>
<li><p>A frame/message handler, that writes down the state of the node</p></li>
<li><p>A frame/message generator, that generates an hexadecimal payload to send</p></li>
</ul>
<p>The mechanics of the <strong>Attribute Resolver</strong> is shown in the diagram below.</p>
<figure class="align-center">
<p class="plantuml">
<img src="../_images/plantuml-aa60fd058ac06bb93ebcfc91515e162ab22673a5.png" alt="legend top
    |Background color | description |
    |&lt;#ff9999&gt;| Unify Component |
    |&lt;#acffa0&gt;| Protocol Controller Component |
endlegend

!theme plain
title Attribute Resolution

Package &quot;Attribute Store&quot; &lt;&lt;Database&gt;&gt; #ff9999 {

  object &quot;Root&quot; as root #DEDEDE
  object &quot;UNID Attribute&quot; as unid #f2ffe6

  unid : Attribute Type = ATTRIBUTE_UNID
  unid : value = Desired: [] - Reported: [&quot;unid-123&quot;]

  object &quot;Endpoint Attribute&quot; as ep #e6fff7
  ep : Attribute Type = ATTRIBUTE_ENDPOINT_ID
  ep : value = Desired: [] - Reported: [01]

  root *-- unid
  unid *-- ep

  Package &quot;DotDot\nAttribute Space&quot; #f3acb1 {
    map &quot;DotDot Attribute&quot; as dotdot_attribute_1 {
      Reported =&gt; [03]
      Desired  =&gt; [01 02 03]
    }
    ep *-- dotdot_attribute_1
  }

  Package &quot;Protocol Controller\nAttribute Space&quot; #acffa0 {
    map &quot;Proprietary Attribute&quot; as attribute_1 #FFFFFF {
      Reported =&gt; [FF]
      Desired  =&gt; [00]
    }
    ep *-- attribute_1
  }
}

Package &quot;Attribute Resolver&quot; as attribute_resolver #ff9999 {
  map &quot;Rule book&quot; as rule_book #acffa0 {
    Function 1 =&gt; Attribute type A
    Function 2 =&gt; Attribute type B
    Function 3 =&gt; Attribute type C
  }
}

Package &quot;Addressing resolver&quot; as address_resolver #acffa0 {
  object &quot;Address resolver&quot; as dedicated_address_resolver #FFFFFF
  dedicated_address_resolver : Takes an attribute, navigate up the tree
  dedicated_address_resolver : and find out proprietary addressing
  dedicated_address_resolver : information and forwards payload/frame
  dedicated_address_resolver : to the NCP component
}

Package &quot;Frame/Message handlers&quot; as frame_handlers #acffa0 {
  object &quot;Frame handler&quot; as frame_handler #FFFFFF
  frame_handler : Parses frames, converts to
  frame_handler : attributes and saves values
  frame_handler : in the Attribute Store
}

Package &quot;Frame/Message generator&quot; as frame_generator #acffa0 {
  object &quot;Attribute Rule&quot; as rule_1 #FFFFFF
  rule_1 : Takes an attribute of a certain
  rule_1 : type and generates a payload/frame
  rule_1 : to send to a node
}

Package &quot;NCP&quot; as ncp_component #acffa0 {
  object &quot;Tx/Rx Module&quot; as tx_rx_module #FFFFFF
  tx_rx_module : send and/or receive
  tx_rx_module : network messages
}

package &quot;PAN&quot; &lt;&lt;Cloud&gt;&gt; {
  package &quot;Node / Endpoint&quot; as pan_node &lt;&lt;Node&gt;&gt; #FFFFFF {
  }
}

rule_1 -l-&gt; rule_book : Registers itself\nfor Attribute Type X

attribute_1 -&gt; attribute_resolver : Notify on value update

attribute_resolver -u-&gt; dedicated_address_resolver : Send Frame / Attribute
dedicated_address_resolver -u-&gt; tx_rx_module : Send Frame with address
pan_node -d-&gt; tx_rx_module : Receive Frame
tx_rx_module -u-&gt; pan_node : Send Frame

ncp_component --&gt; frame_handler : Incoming frames
frame_handler --&gt; attribute_1 : Update value"/>
</p>
</figure>
<p>The <strong>Frame/Message Generator</strong> is a set of functions that allow the resolver
to generate a payload (i.e. byte stream). that will sent to the PAN node,
which in turn should Write or Read an attribute.</p>
<p><strong>Frame/Message Generator functions</strong> can return static frames at times,
or frames that depend on the attribute store values.
For example, in ZCL, to find out the reported value of an <em>OnOff</em> attribute should
always be the same payload (ZCL Read Attribute Command with the OnOff attribute ID).
To set the value of an OnOff attribute, the frame generator function would have
to read the value and return either an <em>On Command</em> or an <em>Off Command</em>.</p>
<p>The payload returned by the <strong>Frame/Message Generator</strong> is an application payload.
Other encapsulations layers (e.g. segmentation, encryption, addressing etc.)
are supposed to be added by the <strong>Addressing resolver</strong> and <strong>NCP</strong> components.</p>
<p>The <strong>Addressing resolver</strong> function is to take the paylaod generated by the
<strong>Frame/Message Generator</strong>, and navigate up the attribute store to find out
the full addressing information. For example, in Z-Wave, it would find out
what is the Endpoint, NodeID, Security Keys to use with the destination, before
it sends it forward to the <strong>NCP</strong>.</p>
</section>
<section id="attribute-mapping">
<h3>Attribute Mapping<a class="headerlink" href="#attribute-mapping" title="Permalink to this heading"></a></h3>
<p>Ultimately, the Protocol Controller needs to set the state of attributes
for the DotDot model, so that they can be published using the UCL language.</p>
<p>The <strong>Attribute Mapper</strong> is able to create attribute rules,
which allow to manipulate attributes. It can be configured using <em>.uam</em> files,
which describes relations between attributes.</p>
<p>For example, it is possible to as the <strong>Attribute Mapper</strong> to create an OnOff
attribute and set it to a certain value whenever a corresponding
Protocol Controller Specific attribute is updated.</p>
<figure class="align-center">
<p class="plantuml">
<img src="../_images/plantuml-5851f0814f4d750a7c037b9ebb7087a8e8f2b719.png" alt="legend top
    |Background color | description |
    |&lt;#ff9999&gt;| Unify Component |
    |&lt;#acffa0&gt;| Protocol Controller Component |
endlegend

!theme plain
allowmixing
title Attribute Mapping

Package &quot;Attribute Store&quot; &lt;&lt;Database&gt;&gt; #ff9999 {

  object &quot;Root&quot; as root #DEDEDE
  object &quot;UNID Attribute&quot; as unid #f2ffe6

  unid : Attribute Type = ATTRIBUTE_UNID
  unid : value = Desired: [] - Reported: [&quot;unid-123&quot;]

  object &quot;Endpoint Attribute&quot; as ep #e6fff7
  ep : Attribute Type = ATTRIBUTE_ENDPOINT_ID
  ep : value = Desired: [] - Reported: [01]

  root *- unid
  unid *- ep

  Package &quot;DotDot\nAttribute Space&quot; #f3acb1 {
    map &quot;DotDot Attribute 1&quot; as dotdot_attribute_1 {
      Reported =&gt; [03]
      Desired  =&gt; [01 02 03]
    }
    map &quot;DotDot Attribute 2&quot; as dotdot_attribute_2 {
      Reported =&gt; [&quot;Device Name&quot;]
      Desired  =&gt; []
    }
    ep *-- dotdot_attribute_1
    ep *-- dotdot_attribute_2
  }

  Package &quot;Protocol Controller\nAttribute Space&quot; #acffa0 {
    map &quot;Proprietary Attribute 1&quot; as attribute_1 #FFFFFF {
      Reported =&gt; [FF]
      Desired  =&gt; [00]
    }
    map &quot;Proprietary Attribute 2&quot; as attribute_2 #FFFFFF {
      Reported =&gt; [3C]
      Desired  =&gt; []
    }
    ep *-- attribute_1
    ep *-- attribute_2
  }
}

Package &quot;Attribute Mapper&quot; as attribute_mapper #ff9999 {
  () &quot;Maps Callbacks&quot; as maps_callbacks
  () &quot;Maps Eval&quot; as maps_evaluations
  map &quot;Mappings&quot; as maps #acffa0 {
    Rule 1 =&gt; r'1 =  2 * r'2
    Rule 2 =&gt; d'2 =  d'1 / 2
    Rule 3 =&gt; r'3 =  r'4 + r'2
  }
  maps_callbacks --&gt; maps
  maps_evaluations &lt;-- maps
}

skinparam {
ArrowColor #FF6655
ArrowFontColor #FF6655
}

attribute_1 -d-&gt; maps_callbacks : Read
attribute_2 -d-&gt; maps_callbacks
dotdot_attribute_1 -d-&gt; maps_callbacks
dotdot_attribute_2 -d-&gt; maps_callbacks

skinparam {
ArrowColor #5566FF
ArrowFontColor #5566FF
}

maps_evaluations -u-&gt; attribute_1
maps_evaluations -u-&gt; attribute_2
maps_evaluations -u-&gt; dotdot_attribute_1
maps_evaluations -u-&gt; dotdot_attribute_2 : Write"/>
</p>
</figure>
<p>The <strong>Attribute Mapper</strong> is a very versatile tool allowing to perform attribute
operations. It is used for mapping, but can also be used as information
database in some cases.</p>
<p>A tutorial and examples on how to create <em>.uam</em> files are given in the
<a class="reference internal" href="how_to_write_uam_files.html#how-to-write-uam-files-section"><span class="std std-ref">How to write UAM files</span></a>:</p>
</section>
</section>
<section id="connecting-the-attribute-store-and-mqtt">
<h2>Connecting the Attribute Store and MQTT<a class="headerlink" href="#connecting-the-attribute-store-and-mqtt" title="Permalink to this heading"></a></h2>
<p>When the attributes are set in the Attribute Store, it is time to advertise
them using MQTT.</p>
<p>There are a few things to set in place to get the Protocol Controller to follow the
<a class="reference internal" href="unify_specifications/index.html"><span class="doc">Unify Framework Specifications</span></a>.</p>
<section id="listening-to-incoming-mqtt-commands">
<h3>Listening to incoming MQTT commands<a class="headerlink" href="#listening-to-incoming-mqtt-commands" title="Permalink to this heading"></a></h3>
<p>A large set of auto-generated files in the <strong>UIC DotDot MQTT</strong> components
provide a uniform way to subscribe and listen to incoming commands.
The component will take a callback function for each Cluster/Command combination,
and in turn will take care of publishing the list of SupportedCommands.</p>
<div class="highlight-mqtt notranslate"><div class="highlight"><pre><span></span><span class="ow">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Level/SupportedCommands</span> - {<span class="w"> </span><span class="nt">&quot;value&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;Move&quot;</span><span class="p">,</span><span class="s2">&quot;MoveToLevel&quot;</span><span class="p">]</span><span class="w"> </span>}
</pre></div>
</div>
<p>When such a publication to a command is received, e.g. :</p>
<div class="highlight-mqtt notranslate"><div class="highlight"><pre><span></span><span class="ow">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Level/Commands/MoveToLevel</span> -
{
<span class="w">  </span><span class="nt">&quot;Level&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;TransitionTime&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;OptionsMask&quot;</span><span class="p">:</span><span class="w"> </span>{
<span class="w">    </span><span class="nt">&quot;ExecuteIfOff&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;CoupleColorTempToLevel&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span>
<span class="w">  </span>}<span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;OptionsOverride&quot;</span><span class="p">:</span><span class="w"> </span>{
<span class="w">    </span><span class="nt">&quot;ExecuteIfOff&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;CoupleColorTempToLevel&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span>
<span class="w">  </span>}
}
</pre></div>
</div>
<p>It would parse the UNID, Endpoint, JSON payload, and dispatch it to to the
registered callback. An illustration of how the component works is shown below.</p>
<figure class="align-center">
<p class="plantuml">
<img src="../_images/plantuml-079997219eaf165036cce78f24db40322d1fa3a2.png" alt="legend top
    |Background color | description |
    |&lt;#ff9999&gt;| Unify Component |
    |&lt;#acffa0&gt;| Protocol Controller Component |
endlegend

!theme plain
title Dispatching incoming UCL commands

Package &quot;Unify DotDot\nAttribute Store&quot; as dotdot_attribute_store #ff9999 {
  map &quot;Command callbacks&quot; as dotdot_attribute_store_command_callbacks #ff9999 {
    OnOff_On =&gt; function1
    OnOff_Off =&gt; function2
    OnOff_toggle =&gt; function3
    Level_move =&gt; function4
  }
  map &quot;Protocol Controller configuration&quot; as dotdot_attribute_store_configuration #acffa0 {
    update_attribute_desired_values =&gt; true
    clear_reported_values =&gt; false
    supported_commands =&gt; true
    force_read_attributes =&gt; false
    write_attributes =&gt; true
    publish_attributes =&gt; true
  }
  map &quot;Protocol Controller functions&quot; as dotdot_attribute_store_functions #acffa0 {
    get_endpoint_attribute =&gt; function_A
    get_unid_endpoint_id =&gt; function_B
  }

   dotdot_attribute_store_command_callbacks -[hidden]down- dotdot_attribute_store_configuration
   dotdot_attribute_store_configuration -[hidden]down- dotdot_attribute_store_functions
}

Package &quot;UIC DotDot MQTT&quot; as uic_dotdot_mqtt #ff9999 {
  object &quot;DotDot MQTT handler&quot; as uic_dotdot_mqtt_component #FFFFFF
  uic_dotdot_mqtt_component : Saves callbacks for commands from user
  uic_dotdot_mqtt_component : components, makes the corresponding
  uic_dotdot_mqtt_component : MQTT subscriptions and dispatches
  uic_dotdot_mqtt_component : incoming messages
}

rectangle &quot;Optional if using Attribute Resolver&quot; {
  Package &quot;Protocol Controller\nCommand Dispatch&quot; as protocol_controller_command_dispatch #acffa0 {
    map &quot;Command callbacks&quot; as protocol_controller_command_callbacks #acffa0 {
      OnOff_On =&gt; function1
      OnOff_Off =&gt; function2
      OnOff_toggle =&gt; function3
      Level_move =&gt; function4
    }
  }
  Package &quot;Command Mapper&quot; as command_mapper #acffa0 {
    object &quot;Command/Address selection&quot; as command_address_selection #FFFFFF
    command_address_selection : Resolve PAN node address
    command_address_selection : Maps dotdot command to PAN node command
  }
  Package &quot;NCP&quot; as ncp_component #acffa0 {
    object &quot;Tx/Rx Module&quot; as tx_rx_module #FFFFFF
    tx_rx_module : send and/or receive
    tx_rx_module : network messages
  }
  package &quot;PAN&quot; &lt;&lt;Cloud&gt;&gt; {
    package &quot;Node / Endpoint&quot; as pan_node &lt;&lt;Node&gt;&gt; #FFFFFF {
    }
  }
}

Package &quot;Attribute Store&quot; &lt;&lt;Database&gt;&gt; #ff9999 {

  object &quot;Root&quot; as root #DEDEDE
  object &quot;UNID Attribute&quot; as unid #f2ffe6

  unid : Attribute Type = ATTRIBUTE_UNID
  unid : value = Desired: [] - Reported: [&quot;unid-123&quot;]

  object &quot;Endpoint Attribute&quot; as ep #e6fff7
  ep : Attribute Type = ATTRIBUTE_ENDPOINT_ID
  ep : value = Desired: [] - Reported: [01]

  root *- unid
  unid *- ep

  Package &quot;DotDot\nAttribute Space&quot; #f3acb1 {
    map &quot;DotDot Attribute 1&quot; as dotdot_attribute_1 {
      Reported =&gt; [00]
      Desired  =&gt; [01]
    }
    map &quot;DotDot Attribute 2&quot; as dotdot_attribute_2 {
      Reported =&gt; [00 01]
      Desired  =&gt; []
    }
    ep *-- dotdot_attribute_1
    ep *-- dotdot_attribute_2
  }

  Package &quot;Protocol Controller\nAttribute Space&quot; #acffa0 {
    map &quot;Proprietary Attribute 1&quot; as attribute_1 #FFFFFF {
      Reported =&gt; [FF]
      Desired  =&gt; [00]
    }
    map &quot;Proprietary Attribute 2&quot; as attribute_2 #FFFFFF {
      Reported =&gt; [3C]
      Desired  =&gt; []
    }
    ep *-- attribute_1
    ep *-- attribute_2
  }
}

Package &quot;MQTT Client&quot; as mqtt_client #ff9999 {
  map &quot;Subscriptions callbacks&quot; as mqtt_client_subscriptions #FFFFFF {
    topic_filter_1 =&gt; function1
    topic_filter_2 =&gt; function2
    topic_filter_3 =&gt; function3
  }
}


skinparam {
  ArrowColor #5566FF
  ArrowFontColor #5566FF
}

mqtt_client_subscriptions::topic_filter_2 -&gt; uic_dotdot_mqtt_component
uic_dotdot_mqtt_component -&gt; dotdot_attribute_store_command_callbacks::OnOff_toggle
uic_dotdot_mqtt_component -down-&gt; protocol_controller_command_callbacks

dotdot_attribute_store_command_callbacks -u-&gt; dotdot_attribute_1 : Write the desired value\nin the DotDot space

() &quot;MQTT DotDot\nCommand Publication&quot; as command_publication #5566FF
command_publication --&gt; mqtt_client_subscriptions

skinparam {
  ArrowColor #FF6655
  ArrowFontColor #FF6655
}

dotdot_attribute_store_command_callbacks -&gt; uic_dotdot_mqtt_component : Register command handlers
protocol_controller_command_callbacks -u-&gt; uic_dotdot_mqtt_component : Register additional command callbacks
uic_dotdot_mqtt_component -&gt; mqtt_client_subscriptions : Subscribe to relevant topics to\nreceving incoming publications

skinparam {
  ArrowColor #5566FF
  ArrowFontColor #5566FF
}
protocol_controller_command_dispatch -l-&gt; command_address_selection
command_address_selection -d-&gt; tx_rx_module : Send Command to PAN Node
tx_rx_module -l-&gt; pan_node : Send Command"/>
</p>
</figure>
<p>The Protocol Controller has to provide a component that registers callbacks
for a given DotDot Command. When this command is received, the callback
is expected to locate the UNID/Endpoint in the Attribute Store and perform
the attribute updates that the command effect have on the device.</p>
<p>For example, if the Protocol Controller wants to receive directly the commands
from the OnOff cluster:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;dotdot_mqtt.h&quot;</span>

<span class="kt">bool</span><span class="w"> </span><span class="nf">dotdot_command_dispatch_init</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// We listen to OnOff cluster On, Off and Toggle command</span>
<span class="w">  </span><span class="n">uic_mqtt_dotdot_on_off_on_callback_set</span><span class="p">(</span><span class="n">on_on_off_cluster_on_command_received</span><span class="p">);</span>
<span class="w">  </span><span class="n">uic_mqtt_dotdot_on_off_off_callback_set</span><span class="p">(</span><span class="n">on_on_off_cluster_off_command_received</span><span class="p">);</span>
<span class="w">  </span><span class="n">uic_mqtt_dotdot_on_off_toggle_callback_set</span><span class="p">(</span><span class="n">on_on_off_cluster_toggle_command_received</span><span class="p">);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Unless the Protocol Controller needs to do something specific with a command,
it can let the <strong>Unify DotDot Attribute Store</strong> component process them
automatically.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;unify_dotdot_attribute_store.h&quot;</span>

<span class="c1">// EPC Configuration for the Unify DotDot Attribute Store</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">unify_dotdot_attribute_store_configuration_t</span><span class="w"> </span><span class="n">epc_configuration</span>
<span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">{.</span><span class="n">get_endpoint_node_function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">attribute_store_network_helper_get_endpoint_node</span><span class="p">,</span>
<span class="w">     </span><span class="p">.</span><span class="n">get_unid_endpoint_function</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">attribute_store_network_helper_get_unid_endpoint_from_node</span><span class="p">,</span>
<span class="w">     </span><span class="p">.</span><span class="n">get_unid_function</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">attribute_store_network_helper_get_unid_from_node</span><span class="p">,</span>
<span class="w">     </span><span class="p">.</span><span class="n">update_attribute_desired_values_on_commands</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span>
<span class="w">     </span><span class="p">.</span><span class="n">clear_reported_on_desired_updates</span><span class="w">           </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span>
<span class="w">     </span><span class="p">.</span><span class="n">automatic_deduction_of_supported_commands</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span>
<span class="w">     </span><span class="p">.</span><span class="n">force_read_attributes_enabled</span><span class="w">               </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span>
<span class="w">     </span><span class="p">.</span><span class="n">write_attributes_enabled</span><span class="w">                    </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span>
<span class="w">     </span><span class="p">.</span><span class="n">publish_attribute_values_to_mqtt</span><span class="w">            </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="w"> </span><span class="p">};</span>

<span class="n">sl_status_t</span><span class="w"> </span><span class="nf">epc_dotdot_attribute_store_init</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="c1">// Provide Unify DotDot Attribute Store with a function that locates Endpoint Attributes.</span>
<span class="w">  </span><span class="n">unify_dotdot_attribute_store_set_endpoint_node_function</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epc_attribute_store_get_endpoint_node</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Configure Unify DotDot Attribute Store to do the work for us.</span>
<span class="w">  </span><span class="n">unify_dotdot_attribute_store_set_configuration</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epc_configuration</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Init Unify DotDot Attribute Store</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">unify_dotdot_attribute_store_init</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If not using the <strong>Unify DotDot Attribute Store</strong> component, the Protocol
Controller is expected to find out the corresponding attributes in the
Attribute Store based on the UNID/Endpoint combination, and
update the value of the DotDot Attribute.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">sl_status_t</span>
<span class="w">  </span><span class="nf">on_on_off_cluster_on_command_received</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">dotdot_unid_t</span><span class="w"> </span><span class="n">unid</span><span class="p">,</span>
<span class="w">                                        </span><span class="k">const</span><span class="w"> </span><span class="n">dotdot_endpoint_id_t</span><span class="w"> </span><span class="n">endpoint</span><span class="p">,</span>
<span class="w">                                        </span><span class="n">uic_mqtt_dotdot_callback_call_type_t</span><span class="w"> </span><span class="n">callback_type</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Take the UNID/Endpoint and locate the node in the attribute store.</span>
<span class="w">  </span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">endpoint_node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_endpoint_node_from_unid_endpoint</span><span class="p">(</span><span class="n">unid</span><span class="p">,</span><span class="w"> </span><span class="n">endpoint</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// On Command will affect the OnOff attribute and set it to true</span>
<span class="w">  </span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">on_off_attribute_node</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">attribute_store_get_first_child_by_type</span><span class="p">(</span><span class="n">endpoint_node</span><span class="p">,</span>
<span class="w">                                            </span><span class="n">DOTDOT_ATTRIBUTE_ID_ON_OFF_ON_OFF</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// This is used by DotDot MQTT to publish SupportedCommands</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">callback_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">on_off_attribute_node</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ATTRIBUTE_STORE_INVALID_NODE</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">SL_STATUS_OK</span>
<span class="w">                                                                  </span><span class="o">:</span><span class="w"> </span><span class="n">SL_STATUS_FAIL</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Else set the value to true.</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">new_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">attribute_store_set_desired</span><span class="p">(</span><span class="n">on_off_attribute_node</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">new_value</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">new_value</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>At this point, if an IoT Service publishes a command such as</p>
<div class="highlight-mqtt notranslate"><div class="highlight"><pre><span></span><span class="ow">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/OnOff/Commands/On</span> - {}
</pre></div>
</div>
<p>The command will be received, passed forward to the right command handler, and
the corresponding OnOff attribute in the <strong>Attribute Store</strong> will be updated to match
the wish of the IoT Service. Note that there is no official list of affected
Attributes for a received command. It is <strong>strongly</strong> recommended to use the
<strong>Unify DotDot Attribute Store</strong> component to provide a uniform behavior accross
protocol controllers</p>
<p>Using the <strong>Attribute Mapper</strong>, the update of the desired value OnOff attribute
should trigger an update of the desired value of the corresponding mapped
proprietary attribute.</p>
<p>Subsequently, the <strong>Attribute Resolver</strong>, will be notified that an update occured
and should determine if a frame is to be sent to the PAN node.</p>
<p>Finally, if the node reports that the corresponding proprietary attribute
reported value is updated back, an attribute map should ensure that the reported
value of the DotDot OnOff attribute gets in turn updated.</p>
</section>
<section id="publishing-the-dotdot-attribute-state-of-nodes">
<h3>Publishing the DotDot Attribute state of nodes<a class="headerlink" href="#publishing-the-dotdot-attribute-state-of-nodes" title="Permalink to this heading"></a></h3>
<p>Using the <strong>Attribute Store</strong> and the <strong>UIC DotDot MQTT</strong> components, a Protocol
Controller can easily publish the state of the DotDot attributes.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">sl_status_t</span><span class="w"> </span><span class="nf">dotdot_attribute_publisher_init</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// For Each Cluster/Attribute that needs to be published</span>
<span class="w">  </span><span class="n">attribute_store_register_callback_by_type_and_state</span><span class="p">(</span>
<span class="w">    </span><span class="n">on_off_cluster_on_attribute_desired_state_publisher_callback</span><span class="p">,</span>
<span class="w">      </span><span class="n">DOTDOT_ATTRIBUTE_ID_ON_OFF_ON_OFF</span><span class="p">,</span>
<span class="w">      </span><span class="n">DESIRED_ATTRIBUTE</span><span class="p">);</span>
<span class="w">  </span><span class="n">attribute_store_register_callback_by_type_and_state</span><span class="p">(</span>
<span class="w">    </span><span class="n">on_off_cluster_on_attribute_reported_state_publisher_callback</span><span class="p">,</span>
<span class="w">      </span><span class="n">DOTDOT_ATTRIBUTE_ID_ON_OFF_ON_OFF</span><span class="p">,</span>
<span class="w">      </span><span class="n">REPORTED_ATTRIBUTE</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">SL_STATUS_OK</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With these callbacks set, the <strong>Attribute Store</strong> will invoke these function
when the values get updated. Subsequently, the functions can use <strong>UIC DotDot MQTT</strong>
to publish the updated state.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">on_off_cluster_on_attribute_desired_state_publisher_callback</span><span class="p">(</span>
<span class="w">  </span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">updated_node</span><span class="p">,</span><span class="w"> </span><span class="n">attribute_store_change_t</span><span class="w"> </span><span class="n">change</span><span class="p">)</span>

<span class="w">  </span><span class="c1">// Ignore creation and deletion events</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">change</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ATTRIBUTE_DELETED</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">change</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ATTRIBUTE_CREATED</span><span class="p">){</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Take the attribute store node and determine the UNID/Endpoint from the attribute store.</span>
<span class="w">  </span><span class="n">dotdot_unid_t</span><span class="w"> </span><span class="n">unid</span><span class="p">;</span>
<span class="w">  </span><span class="n">dotdot_endpoint_id_t</span><span class="w"> </span><span class="n">endpoint_id</span><span class="p">;</span>
<span class="w">  </span><span class="n">get_unid_endpoint_from_attribute_store_node</span><span class="p">(</span><span class="n">updated_node</span><span class="p">,</span><span class="w"> </span><span class="n">unid</span><span class="p">,</span><span class="w"> </span><span class="n">endpoint</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Prepare the basic topic</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">stringstream</span><span class="w"> </span><span class="n">base_topic</span><span class="p">;</span>
<span class="w">  </span><span class="n">base_topic</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;ucl/by-unid/&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">unid</span><span class="p">);</span>
<span class="w">  </span><span class="n">base_topic</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;/ep&quot;</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">endpoint_id</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Get the value of the attribute</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">  </span><span class="n">attribute_store_get_desired</span><span class="p">(</span><span class="n">updated_node</span><span class="p">,</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>

<span class="w">  </span><span class="c1">// Call the corresponding DotDot MQTT helper to make the publication</span>
<span class="w">  </span><span class="n">uic_mqtt_dotdot_on_off_on_off_publish</span><span class="p">(</span>
<span class="w">    </span><span class="n">base_topic</span><span class="p">.</span><span class="n">str</span><span class="p">().</span><span class="n">c_str</span><span class="p">(),</span>
<span class="w">    </span><span class="n">value</span><span class="p">,</span>
<span class="w">    </span><span class="n">UCL_MQTT_PUBLISH_TYPE_DESIRED</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>
<section id="ucl-node-state">
<h2>UCL node state<a class="headerlink" href="#ucl-node-state" title="Permalink to this heading"></a></h2>
<section id="ucl-node-state-overview">
<h3>UCL node state overview<a class="headerlink" href="#ucl-node-state-overview" title="Permalink to this heading"></a></h3>
<p>When the Protocol Controller is setup to publish attributes, process incoming
commands, map in between attribute spaces, resolve and/or send frames when
needed, there is one final step to set up: The UCL node state.</p>
<p>The node state topic is a special topic, which does not fully follow
the standard cluster attributes publications.
Refer to the <a class="reference internal" href="unify_specifications/index.html"><span class="doc">Unify Framework Specifications</span></a>
for details.</p>
<p>Protocol Controllers must publish the node state for each node they can
access, so that IoT services can build up a list of entities.
If possible, the state should be published after publishing the list of
attributes/cluster functionalities, so that IoT Services have a full picture
of the node’s capabilities when it is announced to be <em>“Online Functional”</em>.</p>
<p>The Protocol Controller UCL node state component should listen
to its proprietary attributes and/or components to determine
when nodes are ready to be operated by IoT Services.</p>
<p>Additionally, the node state has to be republished every time one of the properties
change:</p>
<ul class="simple">
<li><p>NetworkStatus</p></li>
<li><p>Security</p></li>
<li><p>MaximumCommandDelay</p></li>
</ul>
<p>At the end, the component must be able to publish for all reachable nodes the
following topic:</p>
<div class="highlight-mqtt notranslate"><div class="highlight"><pre><span></span><span class="ow">ucl/by-unid/&lt;UNID&gt;/State</span> -
{
<span class="w">  </span><span class="nt">&quot;NetworkStatus&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Online functional&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;Security&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Z-Wave S2 Authenticated&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;MaximumCommandDelay&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span>
}
</pre></div>
</div>
<figure class="align-center">
<p class="plantuml">
<img src="../_images/plantuml-dbc82895e0171f64da692ee76204ca798cf5b3b3.png" alt="legend top
    |Background color | description |
    |&lt;#ff9999&gt;| Unify Component |
    |&lt;#acffa0&gt;| Protocol Controller Component |
endlegend

!theme plain
title Publishing the UCL node state

Package &quot;Attribute Store&quot; &lt;&lt;Database&gt;&gt; #ff9999 {

  object &quot;Root&quot; as root #DEDEDE
  object &quot;UNID Attribute&quot; as unid #f2ffe6

  unid : Attribute Type = ATTRIBUTE_UNID
  unid : value = Desired: [] - Reported: [&quot;unid-123&quot;]

  object &quot;Endpoint Attribute&quot; as ep #e6fff7
  ep : Attribute Type = ATTRIBUTE_ENDPOINT_ID
  ep : value = Desired: [] - Reported: [01]

  root *- unid
  unid *- ep

  Package &quot;DotDot\nAttribute Space&quot; #f3acb1 {
    map &quot;DotDot Attribute 1&quot; as dotdot_attribute_1 {
      Reported =&gt; [00]
      Desired  =&gt; [01]
    }
    map &quot;DotDot Attribute 2&quot; as dotdot_attribute_2 {
      Reported =&gt; [00 01]
      Desired  =&gt; []
    }
    ep *-- dotdot_attribute_1
    ep *-- dotdot_attribute_2
  }

  Package &quot;Protocol Controller\nAttribute Space&quot; #acffa0 {
    map &quot;Proprietary Attribute 1&quot; as attribute_1 #FFFFFF {
      Reported =&gt; [FF]
      Desired  =&gt; [00]
    }
    map &quot;Proprietary Attribute 2&quot; as attribute_2 #FFFFFF {
      Reported =&gt; [3C]
      Desired  =&gt; []
    }
    ep *-- attribute_1
    ep *-- attribute_2
  }
}

Package &quot;Other\nComponent&quot; as other_component #acffa0 {
  object &quot;Other component&quot; as other_component #FFFFFF
  other_component : May generate relevant events to the
  other_component : node states, like when the Protocol
  other_component : Controller shuts down
}

Package &quot;UCL\nNode State&quot; as ucl_node_state #acffa0 {
  object &quot;Node State publisher&quot; as ucl_node_state_publisher #FFFFFF
  ucl_node_state_publisher : Listens to events from the Attribute
  ucl_node_state_publisher : store or from other components
  ucl_node_state_publisher : to publish node states.
}

Package &quot;MQTT Client&quot; as mqtt_client #ff9999 {
  map &quot;Publication queue&quot; as mqtt_client_publications #FFFFFF {
    topic1 =&gt; payload1
    topic2 =&gt; payload2
    topic3 =&gt; payload2
  }
}

skinparam {
ArrowColor #5566FF
ArrowFontColor #5566FF
}

ucl_node_state_publisher -&gt; mqtt_client_publications : Publish node state

skinparam {
ArrowColor #FF6655
ArrowFontColor #FF6655
}

attribute_1 --&gt; ucl_node_state_publisher : Read
attribute_2 --&gt; ucl_node_state_publisher
dotdot_attribute_1 --&gt; ucl_node_state_publisher
dotdot_attribute_2 --&gt; ucl_node_state_publisher
other_component -&gt; ucl_node_state_publisher : Relevant events"/>
</p>
</figure>
<p>Some attributes may be located directly under the UNID for the network
status, but Endpoint 0 is also a good place to store such data.</p>
<p>A couple of helpers are available in the <strong>UIC DotDot MQTT</strong> component
to publish State related information, such as the state SupportedCommands.</p>
</section>
<section id="start-up-and-shutdown">
<h3>Start-up and shutdown<a class="headerlink" href="#start-up-and-shutdown" title="Permalink to this heading"></a></h3>
<p>A Protocol Controller is expected to unretain (almost) all topics that it
published during runtime when it is being shutdown. The node state topic
will be the only one that will stay after the Protocol Controller is shut down.</p>
<p>For example, the <strong>ZPC</strong> on shutdown iterates through its entire list of PAN nodes
and publish that they will be unavailable, right before removing all other
topics that have published for the PAN nodes.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">ucl_node_state_teardown</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// get node list and publish the node state unavailable</span>
<span class="w">  </span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">home_id_node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_zpc_network_node</span><span class="p">();</span>
<span class="w">  </span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">node_id_node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ATTRIBUTE_STORE_INVALID_NODE</span><span class="p">;</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">num_child</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">attribute_store_get_node_child_count</span><span class="p">(</span><span class="n">home_id_node</span><span class="p">);</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_child</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">node_id_node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">attribute_store_get_node_child_by_type</span><span class="p">(</span><span class="n">home_id_node</span><span class="p">,</span>
<span class="w">                                                          </span><span class="n">ATTRIBUTE_NODE_ID</span><span class="p">,</span>
<span class="w">                                                          </span><span class="n">i</span><span class="p">);</span>
<span class="w">    </span><span class="n">publish_node_state</span><span class="p">(</span><span class="n">node_id_node</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">//Remove all retained topics except ucl/by-unid/&lt;xxxxx&gt;/State</span>
<span class="w">  </span><span class="n">uic_mqtt_unretain_by_regex</span><span class="p">(</span><span class="s">&quot;^(?!ucl</span><span class="se">\\</span><span class="s">/by-unid</span><span class="se">\\</span><span class="s">/.*</span><span class="se">\\</span><span class="s">/State$).*&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This will have the effect of publishing an unavailable state for all nodes:</p>
<div class="highlight-mqtt notranslate"><div class="highlight"><pre><span></span><span class="ow">ucl/by-unid/zw-D4BFAE7D-0001/State</span> - {<span class="nt">&quot;NetworkStatus&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Unavailable&quot;</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;Security&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Z-Wave S2 Access Control&quot;</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;MaximumCommandDelay&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span>}
<span class="ow">ucl/by-unid/zw-D4BFAE7D-000C/State</span> - {<span class="nt">&quot;NetworkStatus&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Unavailable&quot;</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;Security&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;None&quot;</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;MaximumCommandDelay&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">4200</span>}
<span class="ow">ucl/by-unid/zw-D4BFAE7D-000D/State</span> - {<span class="nt">&quot;NetworkStatus&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Unavailable&quot;</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;Security&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Z-Wave S2 Authenticated&quot;</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;MaximumCommandDelay&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span>}
</pre></div>
</div>
<p>Whenever the Protocol Controller starts again, it needs to iterate over the
list of nodes and publish their state, as well as the Dotdot attributes and commands.</p>
<p>An initialization function can use the <strong>Attribute Store</strong>
<em>attribute_store_refresh_node_and_children_callbacks</em> function, that will simulate
that all attributes just got updated in the Attribute Store and will trigger a
publication.</p>
</section>
</section>
<section id="general-recommendations">
<h2>General recommendations<a class="headerlink" href="#general-recommendations" title="Permalink to this heading"></a></h2>
<section id="mqtt-publications-vs-attribute-store-resolution-and-mapping">
<h3>MQTT publications vs Attribute Store resolution and mapping<a class="headerlink" href="#mqtt-publications-vs-attribute-store-resolution-and-mapping" title="Permalink to this heading"></a></h3>
<p>Whenever a component wants to publish the state of an attribute, it can
(and in certain cases should) verify if the <strong>Attribute Mapper</strong> and/or
<strong>Attribute Resolver</strong> are still working on the <strong>Attribute Store</strong> tree.</p>
<p>The <strong>Attribute Resolver</strong> can give notifications when a node and all
its children have been resolved. This can be used to move the UCL node
state from “Online interviewing” to “Online functional”.</p>
<p>The <strong>Attribute Mapper</strong> can indicate if it still is modifying the
<strong>Attribute Store</strong> due to pending evaluations.</p>
<p>Re-invoking the same function can be done with the <strong>Attribute Timeouts</strong>
component. Here is an example.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">on_zcl_attribute_update</span><span class="p">(</span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">updated_node</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// If the Mapper is still working, wait with the publication:</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">attribute_mapper_has_pending_evaluations</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Wait that the mapper has reached a final state.</span>
<span class="w">    </span><span class="c1">// Try again in 200 ms</span>
<span class="w">    </span><span class="n">sl_log_debug</span><span class="p">(</span><span class="n">LOG_TAG</span><span class="p">,</span>
<span class="w">                </span><span class="s">&quot;Mapper is still working. &quot;</span>
<span class="w">                </span><span class="s">&quot;Postponing DotDot attribute publications by 200ms.&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">attribute_timeout_set_callback</span><span class="p">(</span><span class="n">updated_node</span><span class="p">,</span>
<span class="w">                                  </span><span class="mi">200</span><span class="p">,</span>
<span class="w">                                  </span><span class="o">&amp;</span><span class="n">on_zcl_attribute_update</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Else publish the ZCL attribute</span>
<span class="w">  </span><span class="c1">// [...]</span>
</pre></div>
</div>
</section>
</section>
<section id="network-management">
<h2>Network Management<a class="headerlink" href="#network-management" title="Permalink to this heading"></a></h2>
<p>Network management is an optional feature of Protocol Controllers, and should
be implemented only if their networking protocol allows them to
perform such operations.</p>
<section id="manual-network-management-operations">
<h3>Manual Network Management operations<a class="headerlink" href="#manual-network-management-operations" title="Permalink to this heading"></a></h3>
<p>If a Protocol Controller is able to join/leave a network or add/remove nodes
to a network, they are expected to implement the
<code class="docutils literal notranslate"><span class="pre">ucl/by-unid/&lt;UNID&gt;/ProtocolController/NetworkManagement</span></code> topic.</p>
<p>Protocol Controllers ables to perform network management functionalities
should implement a component publishing and subscribing to NetworkManagement
commands.</p>
<p>There is no shared component helping for this function at the moment.</p>
</section>
<section id="using-smartstart-for-network-inclusions">
<h3>Using SmartStart for network inclusions<a class="headerlink" href="#using-smartstart-for-network-inclusions" title="Permalink to this heading"></a></h3>
<p>A dedicated Unify component named <strong>UIC SmartStart Management</strong> is available
for Protocol Controller that would like to use SmartStart. It will enable
them to receive the SmartStart information automatically.</p>
</section>
</section>
<section id="additional-shared-components">
<h2>Additional shared components<a class="headerlink" href="#additional-shared-components" title="Permalink to this heading"></a></h2>
<p>In general, it is recommended to use components that are provided as part of the
<a class="reference internal" href="unify_library_overview.html"><span class="doc">Unify Library</span></a>. Not all of these shared components
are designed for Protocol Controllers in particular, but most will provide
some useful functionalities.</p>
<p>For example, the <strong>UIC OTA</strong> provides a simple interface to advertise, receive
and apply firmware updates to end nodes. <strong>Unify Attribute poll</strong> will manage
a list of attributes types that must be read periodically.</p>
</section>
</section>


           </div>
          </div>
          <footer>
    <hr/>
    <p>Copyright © 2023 Silicon Laboratories. All rights reserved.</p>
</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>