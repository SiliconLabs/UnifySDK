<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zigbee Protocol Controller: MapperEngine Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Zigbee Protocol Controller<span id="projectnumber">&#160;1.6.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classMapperEngine.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classMapperEngine-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">MapperEngine Class Reference<div class="ingroups"><a class="el" href="group__unify__components.html">Unify Components</a> &raquo; <a class="el" href="group__unify__attribute__mapper.html">Unify Attribute Mapper</a> &raquo; <a class="el" href="group__attribute__mapper__engine.html">Mapper engine</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Mapper Engine.  
 <a href="classMapperEngine.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="attribute__mapper__engine_8hpp_source.html">attribute_mapper_engine.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a59464c485d29100afb95f912aedfb0c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapperEngine.html#a59464c485d29100afb95f912aedfb0c4">reset</a> ()</td></tr>
<tr class="memdesc:a59464c485d29100afb95f912aedfb0c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the mapper engine and clear all releations.  <a href="classMapperEngine.html#a59464c485d29100afb95f912aedfb0c4">More...</a><br /></td></tr>
<tr class="separator:a59464c485d29100afb95f912aedfb0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d473a46e2ad44e611a2485611e0e28c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapperEngine.html#a0d473a46e2ad44e611a2485611e0e28c">load_path</a> (const std::string &amp;uam_path)</td></tr>
<tr class="memdesc:a0d473a46e2ad44e611a2485611e0e28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load engine with all uam file in a given directory.  <a href="classMapperEngine.html#a0d473a46e2ad44e611a2485611e0e28c">More...</a><br /></td></tr>
<tr class="separator:a0d473a46e2ad44e611a2485611e0e28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b27b01f0ebb8373828974b99bafb7b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapperEngine.html#a4b27b01f0ebb8373828974b99bafb7b5">load_file</a> (std::string uam_file_name)</td></tr>
<tr class="memdesc:a4b27b01f0ebb8373828974b99bafb7b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load engine with single uam file.  <a href="classMapperEngine.html#a4b27b01f0ebb8373828974b99bafb7b5">More...</a><br /></td></tr>
<tr class="separator:a4b27b01f0ebb8373828974b99bafb7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d90a71af2f7809eef7d3a636edc78f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapperEngine.html#a9d90a71af2f7809eef7d3a636edc78f2">add_expression</a> (const std::string expression)</td></tr>
<tr class="memdesc:a9d90a71af2f7809eef7d3a636edc78f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add uam expression to the ast.  <a href="classMapperEngine.html#a9d90a71af2f7809eef7d3a636edc78f2">More...</a><br /></td></tr>
<tr class="separator:a9d90a71af2f7809eef7d3a636edc78f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84fb83ab17983d26060561cb760adf5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapperEngine.html#ad84fb83ab17983d26060561cb760adf5">update_dependencies</a> (const <a class="el" href="structast_1_1ast__tree.html">ast::ast_tree</a> &amp;ast)</td></tr>
<tr class="memdesc:ad84fb83ab17983d26060561cb760adf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-calculate dependencies of a the ast,.  <a href="classMapperEngine.html#ad84fb83ab17983d26060561cb760adf5">More...</a><br /></td></tr>
<tr class="separator:ad84fb83ab17983d26060561cb760adf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4efbc2e6e94c3d9512e885bd59fe16e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapperEngine.html#af4efbc2e6e94c3d9512e885bd59fe16e">has_unknown_functions_in_tree</a> (const <a class="el" href="structast_1_1ast__tree.html">ast::ast_tree</a> &amp;ast)</td></tr>
<tr class="memdesc:af4efbc2e6e94c3d9512e885bd59fe16e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the AST for built-in function names and return true if one or more functions are unknown.  <a href="classMapperEngine.html#af4efbc2e6e94c3d9512e885bd59fe16e">More...</a><br /></td></tr>
<tr class="separator:af4efbc2e6e94c3d9512e885bd59fe16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3745c19c18c4e6502af8073eca8cb1f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapperEngine.html#a3745c19c18c4e6502af8073eca8cb1f4">set_common_parent_type</a> (<a class="el" href="attribute__store_8h.html#ab7b43e61cc3128952b765dc99020b160">attribute_store_type_t</a> t)</td></tr>
<tr class="memdesc:a3745c19c18c4e6502af8073eca8cb1f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Common Attribute type which should be used as start context for all attribute evaluations.  <a href="classMapperEngine.html#a3745c19c18c4e6502af8073eca8cb1f4">More...</a><br /></td></tr>
<tr class="separator:a3745c19c18c4e6502af8073eca8cb1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a07128530343dc2a63147506b65e08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapperEngine.html#a55a07128530343dc2a63147506b65e08">on_attribute_updated</a> (<a class="el" href="group__attribute__store__api.html#ga66c4c40720e5271c527c718924261fc6">attribute_store_node_t</a> node, <a class="el" href="group__attribute__store__api.html#ga296998251b25382f24977825b7193e18">attribute_store_node_value_state_t</a> state, <a class="el" href="group__attribute__store__api.html#ga27a25d4910253f286d7e355ad9874699">attribute_store_change_t</a> change)</td></tr>
<tr class="memdesc:a55a07128530343dc2a63147506b65e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an attribute is updated.  <a href="classMapperEngine.html#a55a07128530343dc2a63147506b65e08">More...</a><br /></td></tr>
<tr class="separator:a55a07128530343dc2a63147506b65e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a65d8d04d681a6af3f78ed599c542729f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classMapperEngine.html">MapperEngine</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapperEngine.html#a65d8d04d681a6af3f78ed599c542729f">get_instance</a> ()</td></tr>
<tr class="memdesc:a65d8d04d681a6af3f78ed599c542729f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the singletron.  <a href="classMapperEngine.html#a65d8d04d681a6af3f78ed599c542729f">More...</a><br /></td></tr>
<tr class="separator:a65d8d04d681a6af3f78ed599c542729f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ac7bd4f2fad327ac372685d361f1a74a6"><td class="memItemLeft" align="right" valign="top">attribute_store::attribute&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapperEngine.html#ac7bd4f2fad327ac372685d361f1a74a6">get_destination_for_attribute</a> (const attribute_store::attribute &amp;endpoint, const <a class="el" href="structast_1_1attribute.html">ast::attribute</a> &amp;attribute, bool create_if_missing) const</td></tr>
<tr class="memdesc:ac7bd4f2fad327ac372685d361f1a74a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the destination for attribute.  <a href="classMapperEngine.html#ac7bd4f2fad327ac372685d361f1a74a6">More...</a><br /></td></tr>
<tr class="separator:ac7bd4f2fad327ac372685d361f1a74a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a639ae3aca8dbb0cae245a3e4903ed18a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__attribute__mapper__engine.html#gaeaad976733ee1551c5313cb5a712e8a0">equivalent_assignments_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapperEngine.html#a639ae3aca8dbb0cae245a3e4903ed18a">get_equivalent_assignments</a> (std::shared_ptr&lt; <a class="el" href="structast_1_1assignment.html">ast::assignment</a> &gt; assignment)</td></tr>
<tr class="memdesc:a639ae3aca8dbb0cae245a3e4903ed18a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the engine has other assigments assigning the same attribute type / value type.  <a href="classMapperEngine.html#a639ae3aca8dbb0cae245a3e4903ed18a">More...</a><br /></td></tr>
<tr class="separator:a639ae3aca8dbb0cae245a3e4903ed18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad760ef887ffed523f4c290c11dbe46bb"><td class="memItemLeft" align="right" valign="top">attribute_store::attribute&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapperEngine.html#ad760ef887ffed523f4c290c11dbe46bb">get_assigment_potential_destination</a> (std::shared_ptr&lt; <a class="el" href="structast_1_1assignment.html">ast::assignment</a> &gt; assignment, attribute_store::attribute original_node)</td></tr>
<tr class="memdesc:ad760ef887ffed523f4c290c11dbe46bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks what would be the destination attribute affected by an assigment, if applied.  <a href="classMapperEngine.html#ad760ef887ffed523f4c290c11dbe46bb">More...</a><br /></td></tr>
<tr class="separator:ad760ef887ffed523f4c290c11dbe46bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7445804f00f882b027d0d75ca8fc1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapperEngine.html#a5f7445804f00f882b027d0d75ca8fc1d">assignment_matches_destination</a> (std::shared_ptr&lt; <a class="el" href="structast_1_1assignment.html">ast::assignment</a> &gt; assignment, attribute_store::attribute destination)</td></tr>
<tr class="memdesc:a5f7445804f00f882b027d0d75ca8fc1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an assignment (lhs) path matches the attribute for a destination.  <a href="classMapperEngine.html#a5f7445804f00f882b027d0d75ca8fc1d">More...</a><br /></td></tr>
<tr class="separator:a5f7445804f00f882b027d0d75ca8fc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe06cd167737c438827a90173cf57046"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapperEngine.html#abe06cd167737c438827a90173cf57046">run_assignments</a> (<a class="el" href="group__attribute__mapper__engine.html#gaeaad976733ee1551c5313cb5a712e8a0">equivalent_assignments_t</a> assignments_to_check, attribute_store::attribute assigment_destination, attribute_store::attribute original_node)</td></tr>
<tr class="memdesc:abe06cd167737c438827a90173cf57046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a list of assignments with a possible destination, and run.  <a href="classMapperEngine.html#abe06cd167737c438827a90173cf57046">More...</a><br /></td></tr>
<tr class="separator:abe06cd167737c438827a90173cf57046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab034cf278bae51c4f73b43c49657bb02"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapperEngine.html#ab034cf278bae51c4f73b43c49657bb02">run_assignment</a> (std::shared_ptr&lt; <a class="el" href="structast_1_1assignment.html">ast::assignment</a> &gt; assignment, attribute_store::attribute assigment_destination, attribute_store::attribute original_node)</td></tr>
<tr class="memdesc:ab034cf278bae51c4f73b43c49657bb02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a single assigment and verifies if a value was applied.  <a href="classMapperEngine.html#ab034cf278bae51c4f73b43c49657bb02">More...</a><br /></td></tr>
<tr class="separator:ab034cf278bae51c4f73b43c49657bb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7efda3bc18a9660637f7559a1024585"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapperEngine.html#ab7efda3bc18a9660637f7559a1024585">apply_regular_assignment</a> (attribute_store::attribute common_parent, attribute_store::attribute destination, attribute_store::attribute original_node, const <a class="el" href="namespaceast.html#aef0d3c13d88a76613ad4519f04810f4b">ast::scope_settings_t</a> &amp;settings, <a class="el" href="group__attribute__mapper__ast.html#gae9a62cfdebf78872a00d83a2d12eeb64">result_type_t</a> evaluated_value, std::shared_ptr&lt; <a class="el" href="structast_1_1assignment.html">ast::assignment</a> &gt; assignment) const</td></tr>
<tr class="memdesc:ab7efda3bc18a9660637f7559a1024585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a regular assigment.  <a href="classMapperEngine.html#ab7efda3bc18a9660637f7559a1024585">More...</a><br /></td></tr>
<tr class="separator:ab7efda3bc18a9660637f7559a1024585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06eb313d3e223c5183a052a3e8fbe28c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapperEngine.html#a06eb313d3e223c5183a052a3e8fbe28c">apply_instance_assignment</a> (attribute_store::attribute common_parent, float evaluated_value, std::shared_ptr&lt; <a class="el" href="structast_1_1assignment.html">ast::assignment</a> &gt; assignment, bool chain_reaction)</td></tr>
<tr class="memdesc:a06eb313d3e223c5183a052a3e8fbe28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an instance assigment, which will verify if an attribute path with a certain value exists.  <a href="classMapperEngine.html#a06eb313d3e223c5183a052a3e8fbe28c">More...</a><br /></td></tr>
<tr class="separator:a06eb313d3e223c5183a052a3e8fbe28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a64e5bbbe739f6d2cb7674daee4566f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapperEngine.html#a7a64e5bbbe739f6d2cb7674daee4566f">apply_clearance_assignment</a> (attribute_store::attribute common_parent, float evaluated_value, std::shared_ptr&lt; <a class="el" href="structast_1_1assignment.html">ast::assignment</a> &gt; assignment)</td></tr>
<tr class="memdesc:a7a64e5bbbe739f6d2cb7674daee4566f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a clearance assigment, which may undefine values.  <a href="classMapperEngine.html#a7a64e5bbbe739f6d2cb7674daee4566f">More...</a><br /></td></tr>
<tr class="separator:a7a64e5bbbe739f6d2cb7674daee4566f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:af122c9ca8dd2666fdd220a900cd90beb"><td class="memItemLeft" align="right" valign="top">std::multimap&lt; <a class="el" href="namespaceast.html#accf202c9a5e9a1bf3dab9ace8075ccc1">ast::attribute_dependency_t</a>, std::shared_ptr&lt; <a class="el" href="structast_1_1assignment.html">ast::assignment</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapperEngine.html#af122c9ca8dd2666fdd220a900cd90beb">relations</a></td></tr>
<tr class="separator:af122c9ca8dd2666fdd220a900cd90beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783337aacd2fa0cf920d5e90bcd370d5"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::shared_ptr&lt; <a class="el" href="structast_1_1assignment.html">ast::assignment</a> &gt;, std::shared_ptr&lt; <a class="el" href="namespaceast.html#aef0d3c13d88a76613ad4519f04810f4b">ast::scope_settings_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapperEngine.html#a783337aacd2fa0cf920d5e90bcd370d5">assignment_settings</a></td></tr>
<tr class="separator:a783337aacd2fa0cf920d5e90bcd370d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae640c03ab4beb46fb4e650c44dfc93e3"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::shared_ptr&lt; <a class="el" href="structast_1_1assignment.html">ast::assignment</a> &gt;, <a class="el" href="group__attribute__mapper__engine.html#ga8464bd651a8a81b4945ae593ff47661c">assignment_properties_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapperEngine.html#ae640c03ab4beb46fb4e650c44dfc93e3">assignment_properties</a></td></tr>
<tr class="separator:ae640c03ab4beb46fb4e650c44dfc93e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2672111a117d96def897cf8e0a7b0aa6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attribute__store_8h.html#ab7b43e61cc3128952b765dc99020b160">attribute_store_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapperEngine.html#a2672111a117d96def897cf8e0a7b0aa6">common_parent_type</a> = <a class="el" href="group__attribute__store__api.html#gad8f68eed88ca297167f815f46297ad7c">ATTRIBUTE_STORE_INVALID_NODE</a></td></tr>
<tr class="separator:a2672111a117d96def897cf8e0a7b0aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Mapper Engine. </p>
<p >The purpose of the mapping engine define relations between attributes in the attribute store, in general the relation between the Z-Wave attribute and the Zigbee attributes. The actions performed by the mapping engine is quite similar to the actions performed by a compiler. A compiler parses a text document and builds an Abstract Syntax Tree(AST). The AST is then optimized and the AST nodes are translated into machine op codes. In the attribute mapper we are not translating AST nodes to opcodes but instead we are keeping the AST in memory.</p>
<p >The mapping engine only interacts with the attribute store. An example of a simple mapping is the relation between the zigbee attribute OnOf.value and the Z-Wave attribute binary_switch.value, if desired of OnOf.value is update the binary_switch.value should be update. The the same applies to the reported value in the reverse direction. So in a meta description we could describe this behaviour with the following:</p>
<p >r'OnOff_Value = r'BinarySwitch_Value d'BinarySwitch_Value = d'OnOff_Value</p>
<p >This means when the reported value of BinarySwitch_Value changes we would like to update the repported value of OnOff_Value. Actually we will also create the OnOff_Value if it does not exists (this will only happen with reported values). For the desired value we update BinarySwitch_Value if OnOff_Value changes.</p>
<p >For simplicity the attribute mapper evaluates every thing as int32. This mean that All attributes the mapper deals with must be int32.</p>
<p >The AST of the rule set is stored in memory because when an attribute changes, we should locate dependencies using the AST. The value of each AST node can be calculated in the context of an attribute node. Let's look at the example where an attribute is updated and the node type of that attribute is a leaf nodes in the AST. Then we need to try to re-calculate the value of all AST nodes that depends on the updated node. The update may lead to a write of another attribute. In the example above an update leads to an update of the OnOff value. There could be cases where some node in the AST cannot be evaluated in a given context, for example if one attribute depends on two other attributes but only one of them is defined. Then the AST will not be fully evaluated in the given context (the node does not support all the required command classes). In this case the update will not lead to an attribute write.</p>
<p >In some cases there could be multiple ways to calculate a mapping. Let's take a fictive example of some ZigBee LED color command class. On the Zigbee side colors are defined as RGBW on the Z-Wave side the color may be in RGBW or may be in just RGB.</p>
<p >A mapping could look like this</p>
<p >zbColorW = zwColor[W] or ((zwColor[R] + zwColor[G] + zwColor[B])*1000 ) / 3333</p>
<p >Here we would persue the relation using zwColor[W] first, if that is not possible we would fall back to ((zwColor[R] + zwColor[G] + zwColor[B])*1000) /3333</p>
<p >The mapping engine uses a number of C++ classes to perform its tasks.</p>
<ul>
<li>The ast::UAMGrammar class defnies how we translate a text document into our ast using the boost spirit framework.</li>
<li>The ast::dep_evel class is used to build a graph of relations between attributes.</li>
<li>The <a class="el" href="structast_1_1eval.html" title="AST evaluator.">ast::eval</a> class is used to evaluate expressions when a change in a attribute value occurs</li>
</ul>
<div class="plantumlgraph">
<object type="image/svg+xml" data="inline_umlgraph_13.svg"></object>
</div>
 </div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a9d90a71af2f7809eef7d3a636edc78f2" name="a9d90a71af2f7809eef7d3a636edc78f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d90a71af2f7809eef7d3a636edc78f2">&#9670;&nbsp;</a></span>add_expression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MapperEngine::add_expression </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>expression</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add uam expression to the ast. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expression</td><td>Expression given as string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If load succeed </dd>
<dd>
false Some error occurred in parsing of AST validation </dd></dl>

</div>
</div>
<a id="a7a64e5bbbe739f6d2cb7674daee4566f" name="a7a64e5bbbe739f6d2cb7674daee4566f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a64e5bbbe739f6d2cb7674daee4566f">&#9670;&nbsp;</a></span>apply_clearance_assignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MapperEngine::apply_clearance_assignment </td>
          <td>(</td>
          <td class="paramtype">attribute_store::attribute&#160;</td>
          <td class="paramname"><em>common_parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>evaluated_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structast_1_1assignment.html">ast::assignment</a> &gt;&#160;</td>
          <td class="paramname"><em>assignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a clearance assigment, which may undefine values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">common_parent</td><td>Common parent Attribute for the assignment </td></tr>
    <tr><td class="paramname">evaluated_value</td><td>Evaluated value from the right-hand side of the assignment </td></tr>
    <tr><td class="paramname">assignment</td><td>Pointer to the assignment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a value was applied to the left-hand side </dd>
<dd>
false otherwise </dd></dl>

</div>
</div>
<a id="a06eb313d3e223c5183a052a3e8fbe28c" name="a06eb313d3e223c5183a052a3e8fbe28c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06eb313d3e223c5183a052a3e8fbe28c">&#9670;&nbsp;</a></span>apply_instance_assignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MapperEngine::apply_instance_assignment </td>
          <td>(</td>
          <td class="paramtype">attribute_store::attribute&#160;</td>
          <td class="paramname"><em>common_parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>evaluated_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structast_1_1assignment.html">ast::assignment</a> &gt;&#160;</td>
          <td class="paramname"><em>assignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>chain_reaction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an instance assigment, which will verify if an attribute path with a certain value exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">common_parent</td><td>Common parent Attribute for the assignment </td></tr>
    <tr><td class="paramname">evaluated_value</td><td>Evaluated value from the right-hand side of the assignment </td></tr>
    <tr><td class="paramname">assignment</td><td>Pointer to the assignment </td></tr>
    <tr><td class="paramname">chain_reaction</td><td>Chain reaction setting from the scope </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a value was applied to the left-hand side </dd>
<dd>
false otherwise </dd></dl>

</div>
</div>
<a id="ab7efda3bc18a9660637f7559a1024585" name="ab7efda3bc18a9660637f7559a1024585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7efda3bc18a9660637f7559a1024585">&#9670;&nbsp;</a></span>apply_regular_assignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MapperEngine::apply_regular_assignment </td>
          <td>(</td>
          <td class="paramtype">attribute_store::attribute&#160;</td>
          <td class="paramname"><em>common_parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">attribute_store::attribute&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">attribute_store::attribute&#160;</td>
          <td class="paramname"><em>original_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceast.html#aef0d3c13d88a76613ad4519f04810f4b">ast::scope_settings_t</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__attribute__mapper__ast.html#gae9a62cfdebf78872a00d83a2d12eeb64">result_type_t</a>&#160;</td>
          <td class="paramname"><em>evaluated_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structast_1_1assignment.html">ast::assignment</a> &gt;&#160;</td>
          <td class="paramname"><em>assignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a regular assigment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">common_parent</td><td>Common parent Attribute for the assignment </td></tr>
    <tr><td class="paramname">destination</td><td>Destination Attribute for the assignment </td></tr>
    <tr><td class="paramname">original_node</td><td>Original node that triggered the assignment evaluation </td></tr>
    <tr><td class="paramname">settings</td><td>Score settings associated with the assignment </td></tr>
    <tr><td class="paramname">evaluated_value</td><td>Evaluated value from the right-hand side of the assignment </td></tr>
    <tr><td class="paramname">assignment</td><td>Pointer to the assignment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a value was applied to the left-hand side </dd>
<dd>
false otherwise </dd></dl>

</div>
</div>
<a id="a5f7445804f00f882b027d0d75ca8fc1d" name="a5f7445804f00f882b027d0d75ca8fc1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f7445804f00f882b027d0d75ca8fc1d">&#9670;&nbsp;</a></span>assignment_matches_destination()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MapperEngine::assignment_matches_destination </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structast_1_1assignment.html">ast::assignment</a> &gt;&#160;</td>
          <td class="paramname"><em>assignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">attribute_store::attribute&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if an assignment (lhs) path matches the attribute for a destination. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assignment</td><td>Assignemnt to check if the lhs path matches the destination attribute </td></tr>
    <tr><td class="paramname">destination</td><td>Destination attribute to match with the assignment LHS. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If it matches </dd>
<dd>
false if it does not match </dd></dl>

</div>
</div>
<a id="ad760ef887ffed523f4c290c11dbe46bb" name="ad760ef887ffed523f4c290c11dbe46bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad760ef887ffed523f4c290c11dbe46bb">&#9670;&nbsp;</a></span>get_assigment_potential_destination()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">attribute_store::attribute MapperEngine::get_assigment_potential_destination </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structast_1_1assignment.html">ast::assignment</a> &gt;&#160;</td>
          <td class="paramname"><em>assignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">attribute_store::attribute&#160;</td>
          <td class="paramname"><em>original_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks what would be the destination attribute affected by an assigment, if applied. </p>
<p >Returns INVALID_NODE if the destination</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assignment</td><td>The assignment to look for a destination </td></tr>
    <tr><td class="paramname">original_node</td><td>Original attribute that was updated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Attribute Store node </dd></dl>

</div>
</div>
<a id="ac7bd4f2fad327ac372685d361f1a74a6" name="ac7bd4f2fad327ac372685d361f1a74a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7bd4f2fad327ac372685d361f1a74a6">&#9670;&nbsp;</a></span>get_destination_for_attribute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">attribute_store::attribute MapperEngine::get_destination_for_attribute </td>
          <td>(</td>
          <td class="paramtype">const attribute_store::attribute &amp;&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structast_1_1attribute.html">ast::attribute</a> &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>create_if_missing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the destination for attribute. </p>
<p >Try to resolve the attribute node from the AST attribute path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>endpoint to start from </td></tr>
    <tr><td class="paramname">attribute</td><td>Attribute (path) to resolve </td></tr>
    <tr><td class="paramname">create_if_missing</td><td>If true the destination attribute is created if it does not exists </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>destination attribute, if no destination is found we return INVALID_ATTRIBUTE </dd></dl>

</div>
</div>
<a id="a639ae3aca8dbb0cae245a3e4903ed18a" name="a639ae3aca8dbb0cae245a3e4903ed18a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a639ae3aca8dbb0cae245a3e4903ed18a">&#9670;&nbsp;</a></span>get_equivalent_assignments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__attribute__mapper__engine.html#gaeaad976733ee1551c5313cb5a712e8a0">equivalent_assignments_t</a> MapperEngine::get_equivalent_assignments </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structast_1_1assignment.html">ast::assignment</a> &gt;&#160;</td>
          <td class="paramname"><em>assignment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the engine has other assigments assigning the same attribute type / value type. </p>
<p >Try to resolve the attribute node from the AST attribute path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assignment</td><td>The assignment to take for a start. comparing with all others </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map of assignments assigning the same value tyep and attribute type, sorted by priority. </dd></dl>

</div>
</div>
<a id="a65d8d04d681a6af3f78ed599c542729f" name="a65d8d04d681a6af3f78ed599c542729f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65d8d04d681a6af3f78ed599c542729f">&#9670;&nbsp;</a></span>get_instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classMapperEngine.html">MapperEngine</a> &amp; MapperEngine::get_instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the singletron. </p>
<dl class="section return"><dt>Returns</dt><dd>The singletron </dd></dl>

</div>
</div>
<a id="af4efbc2e6e94c3d9512e885bd59fe16e" name="af4efbc2e6e94c3d9512e885bd59fe16e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4efbc2e6e94c3d9512e885bd59fe16e">&#9670;&nbsp;</a></span>has_unknown_functions_in_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MapperEngine::has_unknown_functions_in_tree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structast_1_1ast__tree.html">ast::ast_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>ast</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the AST for built-in function names and return true if one or more functions are unknown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ast</td><td>AST loaded from the UAM files. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there are some unknown functions in the AST, false otherwise </dd></dl>

</div>
</div>
<a id="a4b27b01f0ebb8373828974b99bafb7b5" name="a4b27b01f0ebb8373828974b99bafb7b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b27b01f0ebb8373828974b99bafb7b5">&#9670;&nbsp;</a></span>load_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MapperEngine::load_file </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>uam_file_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load engine with single uam file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uam_file_name</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true </dd>
<dd>
false </dd></dl>

</div>
</div>
<a id="a0d473a46e2ad44e611a2485611e0e28c" name="a0d473a46e2ad44e611a2485611e0e28c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d473a46e2ad44e611a2485611e0e28c">&#9670;&nbsp;</a></span>load_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MapperEngine::load_path </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>uam_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load engine with all uam file in a given directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uam_path</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If load succeed </dd>
<dd>
false Some error occurred in parsing of AST validation </dd></dl>

</div>
</div>
<a id="a55a07128530343dc2a63147506b65e08" name="a55a07128530343dc2a63147506b65e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a07128530343dc2a63147506b65e08">&#9670;&nbsp;</a></span>on_attribute_updated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MapperEngine::on_attribute_updated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__attribute__store__api.html#ga66c4c40720e5271c527c718924261fc6">attribute_store_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__attribute__store__api.html#ga296998251b25382f24977825b7193e18">attribute_store_node_value_state_t</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__attribute__store__api.html#ga27a25d4910253f286d7e355ad9874699">attribute_store_change_t</a>&#160;</td>
          <td class="paramname"><em>change</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when an attribute is updated. </p>
<p >This function will do a look up the updated attribute in the relation table and evaluate the expressios which depends on the attribute.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node that has been updated </td></tr>
    <tr><td class="paramname">state</td><td>What updated desired or reported </td></tr>
    <tr><td class="paramname">change</td><td>Type of update, create, delete, value change </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59464c485d29100afb95f912aedfb0c4" name="a59464c485d29100afb95f912aedfb0c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59464c485d29100afb95f912aedfb0c4">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MapperEngine::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the mapper engine and clear all releations. </p>

</div>
</div>
<a id="ab034cf278bae51c4f73b43c49657bb02" name="ab034cf278bae51c4f73b43c49657bb02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab034cf278bae51c4f73b43c49657bb02">&#9670;&nbsp;</a></span>run_assignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MapperEngine::run_assignment </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structast_1_1assignment.html">ast::assignment</a> &gt;&#160;</td>
          <td class="paramname"><em>assignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">attribute_store::attribute&#160;</td>
          <td class="paramname"><em>assigment_destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">attribute_store::attribute&#160;</td>
          <td class="paramname"><em>original_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runs a single assigment and verifies if a value was applied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assignment</td><td>Pointer to the assignment </td></tr>
    <tr><td class="paramname">assigment_destination</td><td>Destination attribute for the assignment </td></tr>
    <tr><td class="paramname">original_node</td><td>Original node that triggered the assignment evaluation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a value was applied to the left-hand side </dd>
<dd>
false otherwise </dd></dl>

</div>
</div>
<a id="abe06cd167737c438827a90173cf57046" name="abe06cd167737c438827a90173cf57046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe06cd167737c438827a90173cf57046">&#9670;&nbsp;</a></span>run_assignments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MapperEngine::run_assignments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__attribute__mapper__engine.html#gaeaad976733ee1551c5313cb5a712e8a0">equivalent_assignments_t</a>&#160;</td>
          <td class="paramname"><em>assignments_to_check</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">attribute_store::attribute&#160;</td>
          <td class="paramname"><em>assigment_destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">attribute_store::attribute&#160;</td>
          <td class="paramname"><em>original_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes a list of assignments with a possible destination, and run. </p>
<ol type="1">
<li>the highest priority assigment if the destination exists</li>
<li>All of them from low to high priority if the destination does not exist</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assignments_to_check</td><td>List of assigment to execute </td></tr>
    <tr><td class="paramname">assigment_destination</td><td>Destination attribute </td></tr>
    <tr><td class="paramname">original_node</td><td>Original attribute that triggered these assignments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3745c19c18c4e6502af8073eca8cb1f4" name="a3745c19c18c4e6502af8073eca8cb1f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3745c19c18c4e6502af8073eca8cb1f4">&#9670;&nbsp;</a></span>set_common_parent_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MapperEngine::set_common_parent_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="attribute__store_8h.html#ab7b43e61cc3128952b765dc99020b160">attribute_store_type_t</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Common Attribute type which should be used as start context for all attribute evaluations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Type to use as start context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad84fb83ab17983d26060561cb760adf5" name="ad84fb83ab17983d26060561cb760adf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad84fb83ab17983d26060561cb760adf5">&#9670;&nbsp;</a></span>update_dependencies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MapperEngine::update_dependencies </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structast_1_1ast__tree.html">ast::ast_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>ast</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Re-calculate dependencies of a the ast,. </p>
<p >this should be called if the AST is updated.</p>
<dl class="section return"><dt>Returns</dt><dd>true If load succeed </dd>
<dd>
false Some error occurred in parsing of AST validation </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae640c03ab4beb46fb4e650c44dfc93e3" name="ae640c03ab4beb46fb4e650c44dfc93e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae640c03ab4beb46fb4e650c44dfc93e3">&#9670;&nbsp;</a></span>assignment_properties</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::shared_ptr&lt;<a class="el" href="structast_1_1assignment.html">ast::assignment</a>&gt;, <a class="el" href="group__attribute__mapper__engine.html#ga8464bd651a8a81b4945ae593ff47661c">assignment_properties_t</a>&gt; MapperEngine::assignment_properties</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a783337aacd2fa0cf920d5e90bcd370d5" name="a783337aacd2fa0cf920d5e90bcd370d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a783337aacd2fa0cf920d5e90bcd370d5">&#9670;&nbsp;</a></span>assignment_settings</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::shared_ptr&lt;<a class="el" href="structast_1_1assignment.html">ast::assignment</a>&gt;, std::shared_ptr&lt;<a class="el" href="namespaceast.html#aef0d3c13d88a76613ad4519f04810f4b">ast::scope_settings_t</a>&gt; &gt; MapperEngine::assignment_settings</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2672111a117d96def897cf8e0a7b0aa6" name="a2672111a117d96def897cf8e0a7b0aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2672111a117d96def897cf8e0a7b0aa6">&#9670;&nbsp;</a></span>common_parent_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attribute__store_8h.html#ab7b43e61cc3128952b765dc99020b160">attribute_store_type_t</a> MapperEngine::common_parent_type = <a class="el" href="group__attribute__store__api.html#gad8f68eed88ca297167f815f46297ad7c">ATTRIBUTE_STORE_INVALID_NODE</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af122c9ca8dd2666fdd220a900cd90beb" name="af122c9ca8dd2666fdd220a900cd90beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af122c9ca8dd2666fdd220a900cd90beb">&#9670;&nbsp;</a></span>relations</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::multimap&lt;<a class="el" href="namespaceast.html#accf202c9a5e9a1bf3dab9ace8075ccc1">ast::attribute_dependency_t</a>, std::shared_ptr&lt;<a class="el" href="structast_1_1assignment.html">ast::assignment</a>&gt; &gt; MapperEngine::relations</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>components/uic_attribute_mapper/src/<a class="el" href="attribute__mapper__engine_8hpp_source.html">attribute_mapper_engine.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classMapperEngine.html">MapperEngine</a></li>
    <li class="footer">Generated on Wed Aug 7 2024 15:21:47 for Zigbee Protocol Controller by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
