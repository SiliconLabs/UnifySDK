/******************************************************************************
 * # License
 * <b>Copyright 2022 Silicon Laboratories Inc. www.silabs.com</b>
 ******************************************************************************
 * The licensor of this software is Silicon Laboratories Inc. Your use of this
 * software is governed by the terms of Silicon Labs Master Software License
 * Agreement (MSLA) available at
 * www.silabs.com/about-us/legal/master-software-license-agreement. This
 * software is distributed to you in Source Code format and is governed by the
 * sections of the MSLA applicable to Source Code.
 *
 *****************************************************************************/
// clang-format off
// This file is generated by ZCL Advanced Platform generator. Please don't edit manually.  // clang-format on
#include "unify_dotdot_attribute_store.h"
#include "unify_dotdot_attribute_store_attribute_publisher.h"
#include "unify_dotdot_attribute_store_helpers.h"
#include "unify_dotdot_attribute_store_configuration.h"
#include "unify_dotdot_defined_attribute_types.h"

// Unify Components
#include "attribute_store_helper.h"
#include "attribute.hpp"
#include "dotdot_mqtt.h"

// Generic includes
#include <string>

#include "sl_log.h"
#define LOG_TAG "unify_dotdot_attribute_store_attribute_publisher"

// clang-format off

/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the Basic cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void basic_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_BASIC_ZCL_VERSION) {
          uic_mqtt_dotdot_basic_zcl_version_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_APPLICATION_VERSION) {
          uic_mqtt_dotdot_basic_application_version_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_STACK_VERSION) {
          uic_mqtt_dotdot_basic_stack_version_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_HW_VERSION) {
          uic_mqtt_dotdot_basic_hw_version_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_MANUFACTURER_NAME) {
          std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
          uic_mqtt_dotdot_basic_manufacturer_name_publish(
            base_topic.c_str(),
            static_cast<const char*>(str_desired.data()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_MODEL_IDENTIFIER) {
          std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
          uic_mqtt_dotdot_basic_model_identifier_publish(
            base_topic.c_str(),
            static_cast<const char*>(str_desired.data()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_DATE_CODE) {
          std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
          uic_mqtt_dotdot_basic_date_code_publish(
            base_topic.c_str(),
            static_cast<const char*>(str_desired.data()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_POWER_SOURCE) {
          uic_mqtt_dotdot_basic_power_source_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_GENERIC_DEVICE_CLASS) {
          uic_mqtt_dotdot_basic_generic_device_class_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_GENERIC_DEVICE_TYPE) {
          uic_mqtt_dotdot_basic_generic_device_type_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCT_CODE) {
          std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
          uic_mqtt_dotdot_basic_product_code_publish(
            base_topic.c_str(),
            static_cast<const char*>(str_desired.data()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCTURL) {
          std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
          uic_mqtt_dotdot_basic_producturl_publish(
            base_topic.c_str(),
            static_cast<const char*>(str_desired.data()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_MANUFACTURER_VERSION_DETAILS) {
          std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
          uic_mqtt_dotdot_basic_manufacturer_version_details_publish(
            base_topic.c_str(),
            static_cast<const char*>(str_desired.data()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_SERIAL_NUMBER) {
          std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
          uic_mqtt_dotdot_basic_serial_number_publish(
            base_topic.c_str(),
            static_cast<const char*>(str_desired.data()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCT_LABEL) {
          std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
          uic_mqtt_dotdot_basic_product_label_publish(
            base_topic.c_str(),
            static_cast<const char*>(str_desired.data()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_LOCATION_DESCRIPTION) {
          std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
          uic_mqtt_dotdot_basic_location_description_publish(
            base_topic.c_str(),
            static_cast<const char*>(str_desired.data()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_PHYSICAL_ENVIRONMENT) {
          uic_mqtt_dotdot_basic_physical_environment_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_DEVICE_ENABLED) {
          uic_mqtt_dotdot_basic_device_enabled_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.desired_or_reported<bool>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_ALARM_MASK) {
          uic_mqtt_dotdot_basic_alarm_mask_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_DISABLE_LOCAL_CONFIG) {
          uic_mqtt_dotdot_basic_disable_local_config_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_SW_BUILDID) {
          std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
          uic_mqtt_dotdot_basic_sw_buildid_publish(
            base_topic.c_str(),
            static_cast<const char*>(str_desired.data()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the Basic cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void basic_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_BASIC_ZCL_VERSION:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Basic::ZCLVersion under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_basic_zcl_version_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BASIC_APPLICATION_VERSION:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Basic::ApplicationVersion under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_basic_application_version_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BASIC_STACK_VERSION:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Basic::StackVersion under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_basic_stack_version_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BASIC_HW_VERSION:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Basic::HWVersion under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_basic_hw_version_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BASIC_MANUFACTURER_NAME:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Basic::ManufacturerName under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_basic_manufacturer_name_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BASIC_MODEL_IDENTIFIER:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Basic::ModelIdentifier under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_basic_model_identifier_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BASIC_DATE_CODE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Basic::DateCode under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_basic_date_code_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BASIC_POWER_SOURCE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Basic::PowerSource under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_basic_power_source_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BASIC_GENERIC_DEVICE_CLASS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Basic::GenericDevice-Class under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_basic_generic_device_class_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BASIC_GENERIC_DEVICE_TYPE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Basic::GenericDevice-Type under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_basic_generic_device_type_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCT_CODE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Basic::ProductCode under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_basic_product_code_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCTURL:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Basic::ProductURL under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_basic_producturl_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BASIC_MANUFACTURER_VERSION_DETAILS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Basic::ManufacturerVersionDetails under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_basic_manufacturer_version_details_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BASIC_SERIAL_NUMBER:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Basic::SerialNumber under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_basic_serial_number_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCT_LABEL:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Basic::ProductLabel under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_basic_product_label_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BASIC_LOCATION_DESCRIPTION:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Basic::LocationDescription under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_basic_location_description_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BASIC_PHYSICAL_ENVIRONMENT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Basic::PhysicalEnvironment under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_basic_physical_environment_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BASIC_DEVICE_ENABLED:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Basic::DeviceEnabled under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_basic_device_enabled_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BASIC_ALARM_MASK:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Basic::AlarmMask under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_basic_alarm_mask_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BASIC_DISABLE_LOCAL_CONFIG:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Basic::DisableLocalConfig under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_basic_disable_local_config_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BASIC_SW_BUILDID:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Basic::SWBuildID under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_basic_sw_buildid_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_BASIC_ZCL_VERSION) {
          uic_mqtt_dotdot_basic_zcl_version_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_APPLICATION_VERSION) {
          uic_mqtt_dotdot_basic_application_version_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_STACK_VERSION) {
          uic_mqtt_dotdot_basic_stack_version_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_HW_VERSION) {
          uic_mqtt_dotdot_basic_hw_version_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_MANUFACTURER_NAME) {
          std::vector<char> str_desired = attr.reported<std::vector<char>>();
          uic_mqtt_dotdot_basic_manufacturer_name_publish(
            base_topic.c_str(),
            static_cast<const char*>( str_desired.data() ),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_MODEL_IDENTIFIER) {
          std::vector<char> str_desired = attr.reported<std::vector<char>>();
          uic_mqtt_dotdot_basic_model_identifier_publish(
            base_topic.c_str(),
            static_cast<const char*>( str_desired.data() ),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_DATE_CODE) {
          std::vector<char> str_desired = attr.reported<std::vector<char>>();
          uic_mqtt_dotdot_basic_date_code_publish(
            base_topic.c_str(),
            static_cast<const char*>( str_desired.data() ),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_POWER_SOURCE) {
          uic_mqtt_dotdot_basic_power_source_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_GENERIC_DEVICE_CLASS) {
          uic_mqtt_dotdot_basic_generic_device_class_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_GENERIC_DEVICE_TYPE) {
          uic_mqtt_dotdot_basic_generic_device_type_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCT_CODE) {
          std::vector<char> str_desired = attr.reported<std::vector<char>>();
          uic_mqtt_dotdot_basic_product_code_publish(
            base_topic.c_str(),
            static_cast<const char*>( str_desired.data() ),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCTURL) {
          std::vector<char> str_desired = attr.reported<std::vector<char>>();
          uic_mqtt_dotdot_basic_producturl_publish(
            base_topic.c_str(),
            static_cast<const char*>( str_desired.data() ),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_MANUFACTURER_VERSION_DETAILS) {
          std::vector<char> str_desired = attr.reported<std::vector<char>>();
          uic_mqtt_dotdot_basic_manufacturer_version_details_publish(
            base_topic.c_str(),
            static_cast<const char*>( str_desired.data() ),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_SERIAL_NUMBER) {
          std::vector<char> str_desired = attr.reported<std::vector<char>>();
          uic_mqtt_dotdot_basic_serial_number_publish(
            base_topic.c_str(),
            static_cast<const char*>( str_desired.data() ),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCT_LABEL) {
          std::vector<char> str_desired = attr.reported<std::vector<char>>();
          uic_mqtt_dotdot_basic_product_label_publish(
            base_topic.c_str(),
            static_cast<const char*>( str_desired.data() ),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_LOCATION_DESCRIPTION) {
          std::vector<char> str_desired = attr.reported<std::vector<char>>();
          uic_mqtt_dotdot_basic_location_description_publish(
            base_topic.c_str(),
            static_cast<const char*>( str_desired.data() ),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_PHYSICAL_ENVIRONMENT) {
          uic_mqtt_dotdot_basic_physical_environment_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_DEVICE_ENABLED) {
          uic_mqtt_dotdot_basic_device_enabled_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.reported<bool>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_ALARM_MASK) {
          uic_mqtt_dotdot_basic_alarm_mask_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_DISABLE_LOCAL_CONFIG) {
          uic_mqtt_dotdot_basic_disable_local_config_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BASIC_SW_BUILDID) {
          std::vector<char> str_desired = attr.reported<std::vector<char>>();
          uic_mqtt_dotdot_basic_sw_buildid_publish(
            base_topic.c_str(),
            static_cast<const char*>( str_desired.data() ),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void basic_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/Basic/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_basic_publish_cluster_revision(base_topic.c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_basic_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/Basic";
      sl_log_debug(LOG_TAG, "No more attributes supported for Basic cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the PowerConfiguration cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void power_configuration_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE) {
          uic_mqtt_dotdot_power_configuration_mains_voltage_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_FREQUENCY) {
          uic_mqtt_dotdot_power_configuration_mains_frequency_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_ALARM_MASK) {
          uic_mqtt_dotdot_power_configuration_mains_alarm_mask_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_MIN_THRESHOLD) {
          uic_mqtt_dotdot_power_configuration_mains_voltage_min_threshold_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_MAX_THRESHOLD) {
          uic_mqtt_dotdot_power_configuration_mains_voltage_max_threshold_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_DWELL_TRIP_POINT) {
          uic_mqtt_dotdot_power_configuration_mains_voltage_dwell_trip_point_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE) {
          uic_mqtt_dotdot_power_configuration_battery_voltage_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_REMAINING) {
          uic_mqtt_dotdot_power_configuration_battery_percentage_remaining_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_MANUFACTURER) {
          std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
          uic_mqtt_dotdot_power_configuration_battery_manufacturer_publish(
            base_topic.c_str(),
            static_cast<const char*>(str_desired.data()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_SIZE) {
          uic_mqtt_dotdot_power_configuration_battery_size_publish(
            base_topic.c_str(),
            static_cast<BatterySize>(attr.desired_or_reported<BatterySize>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERYA_HR_RATING) {
          uic_mqtt_dotdot_power_configuration_batterya_hr_rating_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_QUANTITY) {
          uic_mqtt_dotdot_power_configuration_battery_quantity_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_RATED_VOLTAGE) {
          uic_mqtt_dotdot_power_configuration_battery_rated_voltage_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_ALARM_MASK) {
          uic_mqtt_dotdot_power_configuration_battery_alarm_mask_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_MIN_THRESHOLD) {
          uic_mqtt_dotdot_power_configuration_battery_voltage_min_threshold_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD1) {
          uic_mqtt_dotdot_power_configuration_battery_voltage_threshold1_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD2) {
          uic_mqtt_dotdot_power_configuration_battery_voltage_threshold2_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD3) {
          uic_mqtt_dotdot_power_configuration_battery_voltage_threshold3_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_MIN_THRESHOLD) {
          uic_mqtt_dotdot_power_configuration_battery_percentage_min_threshold_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD1) {
          uic_mqtt_dotdot_power_configuration_battery_percentage_threshold1_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD2) {
          uic_mqtt_dotdot_power_configuration_battery_percentage_threshold2_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD3) {
          uic_mqtt_dotdot_power_configuration_battery_percentage_threshold3_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_ALARM_STATE) {
          uic_mqtt_dotdot_power_configuration_battery_alarm_state_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE) {
          uic_mqtt_dotdot_power_configuration_battery2_voltage_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_REMAINING) {
          uic_mqtt_dotdot_power_configuration_battery2_percentage_remaining_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_MANUFACTURER) {
          std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
          uic_mqtt_dotdot_power_configuration_battery2_manufacturer_publish(
            base_topic.c_str(),
            static_cast<const char*>(str_desired.data()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_SIZE) {
          uic_mqtt_dotdot_power_configuration_battery2_size_publish(
            base_topic.c_str(),
            static_cast<BatterySize>(attr.desired_or_reported<BatterySize>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2A_HR_RATING) {
          uic_mqtt_dotdot_power_configuration_battery2a_hr_rating_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_QUANTITY) {
          uic_mqtt_dotdot_power_configuration_battery2_quantity_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_RATED_VOLTAGE) {
          uic_mqtt_dotdot_power_configuration_battery2_rated_voltage_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_ALARM_MASK) {
          uic_mqtt_dotdot_power_configuration_battery2_alarm_mask_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_MIN_THRESHOLD) {
          uic_mqtt_dotdot_power_configuration_battery2_voltage_min_threshold_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD1) {
          uic_mqtt_dotdot_power_configuration_battery2_voltage_threshold1_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD2) {
          uic_mqtt_dotdot_power_configuration_battery2_voltage_threshold2_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD3) {
          uic_mqtt_dotdot_power_configuration_battery2_voltage_threshold3_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_MIN_THRESHOLD) {
          uic_mqtt_dotdot_power_configuration_battery2_percentage_min_threshold_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD1) {
          uic_mqtt_dotdot_power_configuration_battery2_percentage_threshold1_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD2) {
          uic_mqtt_dotdot_power_configuration_battery2_percentage_threshold2_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD3) {
          uic_mqtt_dotdot_power_configuration_battery2_percentage_threshold3_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_ALARM_STATE) {
          uic_mqtt_dotdot_power_configuration_battery2_alarm_state_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE) {
          uic_mqtt_dotdot_power_configuration_battery3_voltage_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_REMAINING) {
          uic_mqtt_dotdot_power_configuration_battery3_percentage_remaining_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_MANUFACTURER) {
          std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
          uic_mqtt_dotdot_power_configuration_battery3_manufacturer_publish(
            base_topic.c_str(),
            static_cast<const char*>(str_desired.data()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_SIZE) {
          uic_mqtt_dotdot_power_configuration_battery3_size_publish(
            base_topic.c_str(),
            static_cast<BatterySize>(attr.desired_or_reported<BatterySize>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3A_HR_RATING) {
          uic_mqtt_dotdot_power_configuration_battery3a_hr_rating_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_QUANTITY) {
          uic_mqtt_dotdot_power_configuration_battery3_quantity_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_RATED_VOLTAGE) {
          uic_mqtt_dotdot_power_configuration_battery3_rated_voltage_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_ALARM_MASK) {
          uic_mqtt_dotdot_power_configuration_battery3_alarm_mask_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_MIN_THRESHOLD) {
          uic_mqtt_dotdot_power_configuration_battery3_voltage_min_threshold_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD1) {
          uic_mqtt_dotdot_power_configuration_battery3_voltage_threshold1_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD2) {
          uic_mqtt_dotdot_power_configuration_battery3_voltage_threshold2_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD3) {
          uic_mqtt_dotdot_power_configuration_battery3_voltage_threshold3_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_MIN_THRESHOLD) {
          uic_mqtt_dotdot_power_configuration_battery3_percentage_min_threshold_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD1) {
          uic_mqtt_dotdot_power_configuration_battery3_percentage_threshold1_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD2) {
          uic_mqtt_dotdot_power_configuration_battery3_percentage_threshold2_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD3) {
          uic_mqtt_dotdot_power_configuration_battery3_percentage_threshold3_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_ALARM_STATE) {
          uic_mqtt_dotdot_power_configuration_battery3_alarm_state_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the PowerConfiguration cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void power_configuration_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::MainsVoltage under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_mains_voltage_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_FREQUENCY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::MainsFrequency under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_mains_frequency_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_ALARM_MASK:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::MainsAlarmMask under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_mains_alarm_mask_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_MIN_THRESHOLD:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::MainsVoltageMinThreshold under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_mains_voltage_min_threshold_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_MAX_THRESHOLD:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::MainsVoltageMaxThreshold under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_mains_voltage_max_threshold_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_DWELL_TRIP_POINT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::MainsVoltageDwellTripPoint under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_mains_voltage_dwell_trip_point_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::BatteryVoltage under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery_voltage_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_REMAINING:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::BatteryPercentageRemaining under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery_percentage_remaining_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_MANUFACTURER:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::BatteryManufacturer under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery_manufacturer_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_SIZE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::BatterySize under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery_size_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERYA_HR_RATING:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::BatteryAHrRating under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_batterya_hr_rating_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_QUANTITY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::BatteryQuantity under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery_quantity_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_RATED_VOLTAGE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::BatteryRatedVoltage under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery_rated_voltage_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_ALARM_MASK:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::BatteryAlarmMask under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery_alarm_mask_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_MIN_THRESHOLD:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::BatteryVoltageMinThreshold under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery_voltage_min_threshold_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD1:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::BatteryVoltageThreshold1 under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery_voltage_threshold1_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD2:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::BatteryVoltageThreshold2 under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery_voltage_threshold2_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD3:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::BatteryVoltageThreshold3 under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery_voltage_threshold3_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_MIN_THRESHOLD:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::BatteryPercentageMinThreshold under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery_percentage_min_threshold_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD1:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::BatteryPercentageThreshold1 under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery_percentage_threshold1_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD2:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::BatteryPercentageThreshold2 under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery_percentage_threshold2_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD3:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::BatteryPercentageThreshold3 under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery_percentage_threshold3_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_ALARM_STATE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::BatteryAlarmState under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery_alarm_state_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::Battery2Voltage under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery2_voltage_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_REMAINING:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::Battery2PercentageRemaining under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery2_percentage_remaining_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_MANUFACTURER:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::Battery2Manufacturer under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery2_manufacturer_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_SIZE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::Battery2Size under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery2_size_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2A_HR_RATING:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::Battery2AHrRating under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery2a_hr_rating_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_QUANTITY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::Battery2Quantity under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery2_quantity_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_RATED_VOLTAGE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::Battery2RatedVoltage under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery2_rated_voltage_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_ALARM_MASK:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::Battery2AlarmMask under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery2_alarm_mask_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_MIN_THRESHOLD:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::Battery2VoltageMinThreshold under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery2_voltage_min_threshold_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD1:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::Battery2VoltageThreshold1 under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery2_voltage_threshold1_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD2:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::Battery2VoltageThreshold2 under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery2_voltage_threshold2_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD3:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::Battery2VoltageThreshold3 under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery2_voltage_threshold3_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_MIN_THRESHOLD:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::Battery2PercentageMinThreshold under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery2_percentage_min_threshold_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD1:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::Battery2PercentageThreshold1 under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery2_percentage_threshold1_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD2:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::Battery2PercentageThreshold2 under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery2_percentage_threshold2_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD3:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::Battery2PercentageThreshold3 under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery2_percentage_threshold3_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_ALARM_STATE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::Battery2AlarmState under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery2_alarm_state_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::Battery3Voltage under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery3_voltage_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_REMAINING:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::Battery3PercentageRemaining under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery3_percentage_remaining_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_MANUFACTURER:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::Battery3Manufacturer under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery3_manufacturer_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_SIZE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::Battery3Size under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery3_size_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3A_HR_RATING:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::Battery3AHrRating under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery3a_hr_rating_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_QUANTITY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::Battery3Quantity under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery3_quantity_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_RATED_VOLTAGE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::Battery3RatedVoltage under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery3_rated_voltage_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_ALARM_MASK:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::Battery3AlarmMask under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery3_alarm_mask_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_MIN_THRESHOLD:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::Battery3VoltageMinThreshold under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery3_voltage_min_threshold_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD1:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::Battery3VoltageThreshold1 under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery3_voltage_threshold1_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD2:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::Battery3VoltageThreshold2 under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery3_voltage_threshold2_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD3:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::Battery3VoltageThreshold3 under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery3_voltage_threshold3_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_MIN_THRESHOLD:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::Battery3PercentageMinThreshold under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery3_percentage_min_threshold_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD1:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::Battery3PercentageThreshold1 under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery3_percentage_threshold1_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD2:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::Battery3PercentageThreshold2 under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery3_percentage_threshold2_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD3:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::Battery3PercentageThreshold3 under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery3_percentage_threshold3_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_ALARM_STATE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PowerConfiguration::Battery3AlarmState under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_power_configuration_battery3_alarm_state_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE) {
          uic_mqtt_dotdot_power_configuration_mains_voltage_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_FREQUENCY) {
          uic_mqtt_dotdot_power_configuration_mains_frequency_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_ALARM_MASK) {
          uic_mqtt_dotdot_power_configuration_mains_alarm_mask_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_MIN_THRESHOLD) {
          uic_mqtt_dotdot_power_configuration_mains_voltage_min_threshold_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_MAX_THRESHOLD) {
          uic_mqtt_dotdot_power_configuration_mains_voltage_max_threshold_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_DWELL_TRIP_POINT) {
          uic_mqtt_dotdot_power_configuration_mains_voltage_dwell_trip_point_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE) {
          uic_mqtt_dotdot_power_configuration_battery_voltage_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_REMAINING) {
          uic_mqtt_dotdot_power_configuration_battery_percentage_remaining_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_MANUFACTURER) {
          std::vector<char> str_desired = attr.reported<std::vector<char>>();
          uic_mqtt_dotdot_power_configuration_battery_manufacturer_publish(
            base_topic.c_str(),
            static_cast<const char*>( str_desired.data() ),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_SIZE) {
          uic_mqtt_dotdot_power_configuration_battery_size_publish(
            base_topic.c_str(),
            static_cast<BatterySize>(attr.reported<BatterySize>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERYA_HR_RATING) {
          uic_mqtt_dotdot_power_configuration_batterya_hr_rating_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_QUANTITY) {
          uic_mqtt_dotdot_power_configuration_battery_quantity_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_RATED_VOLTAGE) {
          uic_mqtt_dotdot_power_configuration_battery_rated_voltage_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_ALARM_MASK) {
          uic_mqtt_dotdot_power_configuration_battery_alarm_mask_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_MIN_THRESHOLD) {
          uic_mqtt_dotdot_power_configuration_battery_voltage_min_threshold_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD1) {
          uic_mqtt_dotdot_power_configuration_battery_voltage_threshold1_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD2) {
          uic_mqtt_dotdot_power_configuration_battery_voltage_threshold2_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD3) {
          uic_mqtt_dotdot_power_configuration_battery_voltage_threshold3_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_MIN_THRESHOLD) {
          uic_mqtt_dotdot_power_configuration_battery_percentage_min_threshold_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD1) {
          uic_mqtt_dotdot_power_configuration_battery_percentage_threshold1_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD2) {
          uic_mqtt_dotdot_power_configuration_battery_percentage_threshold2_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD3) {
          uic_mqtt_dotdot_power_configuration_battery_percentage_threshold3_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_ALARM_STATE) {
          uic_mqtt_dotdot_power_configuration_battery_alarm_state_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE) {
          uic_mqtt_dotdot_power_configuration_battery2_voltage_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_REMAINING) {
          uic_mqtt_dotdot_power_configuration_battery2_percentage_remaining_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_MANUFACTURER) {
          std::vector<char> str_desired = attr.reported<std::vector<char>>();
          uic_mqtt_dotdot_power_configuration_battery2_manufacturer_publish(
            base_topic.c_str(),
            static_cast<const char*>( str_desired.data() ),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_SIZE) {
          uic_mqtt_dotdot_power_configuration_battery2_size_publish(
            base_topic.c_str(),
            static_cast<BatterySize>(attr.reported<BatterySize>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2A_HR_RATING) {
          uic_mqtt_dotdot_power_configuration_battery2a_hr_rating_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_QUANTITY) {
          uic_mqtt_dotdot_power_configuration_battery2_quantity_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_RATED_VOLTAGE) {
          uic_mqtt_dotdot_power_configuration_battery2_rated_voltage_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_ALARM_MASK) {
          uic_mqtt_dotdot_power_configuration_battery2_alarm_mask_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_MIN_THRESHOLD) {
          uic_mqtt_dotdot_power_configuration_battery2_voltage_min_threshold_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD1) {
          uic_mqtt_dotdot_power_configuration_battery2_voltage_threshold1_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD2) {
          uic_mqtt_dotdot_power_configuration_battery2_voltage_threshold2_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD3) {
          uic_mqtt_dotdot_power_configuration_battery2_voltage_threshold3_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_MIN_THRESHOLD) {
          uic_mqtt_dotdot_power_configuration_battery2_percentage_min_threshold_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD1) {
          uic_mqtt_dotdot_power_configuration_battery2_percentage_threshold1_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD2) {
          uic_mqtt_dotdot_power_configuration_battery2_percentage_threshold2_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD3) {
          uic_mqtt_dotdot_power_configuration_battery2_percentage_threshold3_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_ALARM_STATE) {
          uic_mqtt_dotdot_power_configuration_battery2_alarm_state_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE) {
          uic_mqtt_dotdot_power_configuration_battery3_voltage_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_REMAINING) {
          uic_mqtt_dotdot_power_configuration_battery3_percentage_remaining_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_MANUFACTURER) {
          std::vector<char> str_desired = attr.reported<std::vector<char>>();
          uic_mqtt_dotdot_power_configuration_battery3_manufacturer_publish(
            base_topic.c_str(),
            static_cast<const char*>( str_desired.data() ),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_SIZE) {
          uic_mqtt_dotdot_power_configuration_battery3_size_publish(
            base_topic.c_str(),
            static_cast<BatterySize>(attr.reported<BatterySize>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3A_HR_RATING) {
          uic_mqtt_dotdot_power_configuration_battery3a_hr_rating_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_QUANTITY) {
          uic_mqtt_dotdot_power_configuration_battery3_quantity_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_RATED_VOLTAGE) {
          uic_mqtt_dotdot_power_configuration_battery3_rated_voltage_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_ALARM_MASK) {
          uic_mqtt_dotdot_power_configuration_battery3_alarm_mask_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_MIN_THRESHOLD) {
          uic_mqtt_dotdot_power_configuration_battery3_voltage_min_threshold_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD1) {
          uic_mqtt_dotdot_power_configuration_battery3_voltage_threshold1_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD2) {
          uic_mqtt_dotdot_power_configuration_battery3_voltage_threshold2_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD3) {
          uic_mqtt_dotdot_power_configuration_battery3_voltage_threshold3_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_MIN_THRESHOLD) {
          uic_mqtt_dotdot_power_configuration_battery3_percentage_min_threshold_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD1) {
          uic_mqtt_dotdot_power_configuration_battery3_percentage_threshold1_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD2) {
          uic_mqtt_dotdot_power_configuration_battery3_percentage_threshold2_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD3) {
          uic_mqtt_dotdot_power_configuration_battery3_percentage_threshold3_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_ALARM_STATE) {
          uic_mqtt_dotdot_power_configuration_battery3_alarm_state_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void power_configuration_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/PowerConfiguration/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_power_configuration_publish_cluster_revision(base_topic.c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_power_configuration_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/PowerConfiguration";
      sl_log_debug(LOG_TAG, "No more attributes supported for PowerConfiguration cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the DeviceTemperatureConfiguration cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void device_temperature_configuration_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_CURRENT_TEMPERATURE) {
          uic_mqtt_dotdot_device_temperature_configuration_current_temperature_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_MIN_TEMP_EXPERIENCED) {
          uic_mqtt_dotdot_device_temperature_configuration_min_temp_experienced_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_MAX_TEMP_EXPERIENCED) {
          uic_mqtt_dotdot_device_temperature_configuration_max_temp_experienced_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_OVER_TEMP_TOTAL_DWELL) {
          uic_mqtt_dotdot_device_temperature_configuration_over_temp_total_dwell_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_DEVICE_TEMP_ALARM_MASK) {
          uic_mqtt_dotdot_device_temperature_configuration_device_temp_alarm_mask_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_LOW_TEMP_THRESHOLD) {
          uic_mqtt_dotdot_device_temperature_configuration_low_temp_threshold_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_HIGH_TEMP_THRESHOLD) {
          uic_mqtt_dotdot_device_temperature_configuration_high_temp_threshold_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_LOW_TEMP_DWELL_TRIP_POINT) {
          uic_mqtt_dotdot_device_temperature_configuration_low_temp_dwell_trip_point_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_HIGH_TEMP_DWELL_TRIP_POINT) {
          uic_mqtt_dotdot_device_temperature_configuration_high_temp_dwell_trip_point_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the DeviceTemperatureConfiguration cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void device_temperature_configuration_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_CURRENT_TEMPERATURE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DeviceTemperatureConfiguration::CurrentTemperature under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_device_temperature_configuration_current_temperature_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_MIN_TEMP_EXPERIENCED:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DeviceTemperatureConfiguration::MinTempExperienced under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_device_temperature_configuration_min_temp_experienced_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_MAX_TEMP_EXPERIENCED:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DeviceTemperatureConfiguration::MaxTempExperienced under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_device_temperature_configuration_max_temp_experienced_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_OVER_TEMP_TOTAL_DWELL:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DeviceTemperatureConfiguration::OverTempTotalDwell under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_device_temperature_configuration_over_temp_total_dwell_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_DEVICE_TEMP_ALARM_MASK:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DeviceTemperatureConfiguration::DeviceTempAlarmMask under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_device_temperature_configuration_device_temp_alarm_mask_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_LOW_TEMP_THRESHOLD:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DeviceTemperatureConfiguration::LowTempThreshold under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_device_temperature_configuration_low_temp_threshold_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_HIGH_TEMP_THRESHOLD:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DeviceTemperatureConfiguration::HighTempThreshold under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_device_temperature_configuration_high_temp_threshold_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_LOW_TEMP_DWELL_TRIP_POINT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DeviceTemperatureConfiguration::LowTempDwellTripPoint under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_device_temperature_configuration_low_temp_dwell_trip_point_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_HIGH_TEMP_DWELL_TRIP_POINT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DeviceTemperatureConfiguration::HighTempDwellTripPoint under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_device_temperature_configuration_high_temp_dwell_trip_point_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_CURRENT_TEMPERATURE) {
          uic_mqtt_dotdot_device_temperature_configuration_current_temperature_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_MIN_TEMP_EXPERIENCED) {
          uic_mqtt_dotdot_device_temperature_configuration_min_temp_experienced_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_MAX_TEMP_EXPERIENCED) {
          uic_mqtt_dotdot_device_temperature_configuration_max_temp_experienced_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_OVER_TEMP_TOTAL_DWELL) {
          uic_mqtt_dotdot_device_temperature_configuration_over_temp_total_dwell_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_DEVICE_TEMP_ALARM_MASK) {
          uic_mqtt_dotdot_device_temperature_configuration_device_temp_alarm_mask_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_LOW_TEMP_THRESHOLD) {
          uic_mqtt_dotdot_device_temperature_configuration_low_temp_threshold_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_HIGH_TEMP_THRESHOLD) {
          uic_mqtt_dotdot_device_temperature_configuration_high_temp_threshold_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_LOW_TEMP_DWELL_TRIP_POINT) {
          uic_mqtt_dotdot_device_temperature_configuration_low_temp_dwell_trip_point_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_HIGH_TEMP_DWELL_TRIP_POINT) {
          uic_mqtt_dotdot_device_temperature_configuration_high_temp_dwell_trip_point_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void device_temperature_configuration_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/DeviceTemperatureConfiguration/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_device_temperature_configuration_publish_cluster_revision(base_topic.c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_device_temperature_configuration_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/DeviceTemperatureConfiguration";
      sl_log_debug(LOG_TAG, "No more attributes supported for DeviceTemperatureConfiguration cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the Identify cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void identify_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_IDENTIFY_IDENTIFY_TIME) {
          uic_mqtt_dotdot_identify_identify_time_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the Identify cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void identify_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_IDENTIFY_IDENTIFY_TIME:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Identify::IdentifyTime under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_identify_identify_time_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_IDENTIFY_IDENTIFY_TIME) {
          uic_mqtt_dotdot_identify_identify_time_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void identify_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/Identify/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_identify_publish_cluster_revision(base_topic.c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_identify_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/Identify";
      sl_log_debug(LOG_TAG, "No more attributes supported for Identify cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the Groups cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void groups_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_GROUPS_NAME_SUPPORT) {
          uic_mqtt_dotdot_groups_name_support_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the Groups cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void groups_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_GROUPS_NAME_SUPPORT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Groups::NameSupport under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_groups_name_support_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_GROUPS_NAME_SUPPORT) {
          uic_mqtt_dotdot_groups_name_support_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void groups_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/Groups/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_groups_publish_cluster_revision(base_topic.c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_groups_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/Groups";
      sl_log_debug(LOG_TAG, "No more attributes supported for Groups cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the Scenes cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void scenes_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_COUNT) {
          uic_mqtt_dotdot_scenes_scene_count_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SCENES_CURRENT_SCENE) {
          uic_mqtt_dotdot_scenes_current_scene_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SCENES_CURRENT_GROUP) {
          uic_mqtt_dotdot_scenes_current_group_publish(
            base_topic.c_str(),
            static_cast<SGroupId>(attr.desired_or_reported<SGroupId>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_VALID) {
          uic_mqtt_dotdot_scenes_scene_valid_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.desired_or_reported<bool>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SCENES_NAME_SUPPORT) {
          uic_mqtt_dotdot_scenes_name_support_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SCENES_LAST_CONFIGURED_BY) {
          uic_mqtt_dotdot_scenes_last_configured_by_publish(
            base_topic.c_str(),
            static_cast<EUI64>(attr.desired_or_reported<EUI64>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
        // Skip attribute SceneTable because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish desired value for attribute Scenes SceneTable. Arrays are not supported");
  } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the Scenes cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void scenes_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_COUNT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Scenes::SceneCount under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_scenes_scene_count_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SCENES_CURRENT_SCENE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Scenes::CurrentScene under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_scenes_current_scene_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SCENES_CURRENT_GROUP:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Scenes::CurrentGroup under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_scenes_current_group_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_VALID:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Scenes::SceneValid under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_scenes_scene_valid_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SCENES_NAME_SUPPORT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Scenes::NameSupport under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_scenes_name_support_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SCENES_LAST_CONFIGURED_BY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Scenes::LastConfiguredBy under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_scenes_last_configured_by_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Scenes::SceneTable under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_scenes_scene_table_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_COUNT) {
          uic_mqtt_dotdot_scenes_scene_count_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SCENES_CURRENT_SCENE) {
          uic_mqtt_dotdot_scenes_current_scene_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SCENES_CURRENT_GROUP) {
          uic_mqtt_dotdot_scenes_current_group_publish(
            base_topic.c_str(),
            static_cast<SGroupId>(attr.reported<SGroupId>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_VALID) {
          uic_mqtt_dotdot_scenes_scene_valid_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.reported<bool>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SCENES_NAME_SUPPORT) {
          uic_mqtt_dotdot_scenes_name_support_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SCENES_LAST_CONFIGURED_BY) {
          uic_mqtt_dotdot_scenes_last_configured_by_publish(
            base_topic.c_str(),
            static_cast<EUI64>(attr.reported<EUI64>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
        // Skip attribute SceneTable because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish reported value for attribute Scenes SceneTable. Arrays are not supported");
  } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void scenes_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/Scenes/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_scenes_publish_cluster_revision(base_topic.c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_scenes_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/Scenes";
      sl_log_debug(LOG_TAG, "No more attributes supported for Scenes cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the OnOff cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void on_off_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_ON_OFF_ON_OFF) {
          uic_mqtt_dotdot_on_off_on_off_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.desired_or_reported<bool>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ON_OFF_GLOBAL_SCENE_CONTROL) {
          uic_mqtt_dotdot_on_off_global_scene_control_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.desired_or_reported<bool>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ON_OFF_ON_TIME) {
          uic_mqtt_dotdot_on_off_on_time_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ON_OFF_OFF_WAIT_TIME) {
          uic_mqtt_dotdot_on_off_off_wait_time_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ON_OFF_START_UP_ON_OFF) {
          uic_mqtt_dotdot_on_off_start_up_on_off_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the OnOff cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void on_off_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_ON_OFF_ON_OFF:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining OnOff::OnOff under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_on_off_on_off_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ON_OFF_GLOBAL_SCENE_CONTROL:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining OnOff::GlobalSceneControl under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_on_off_global_scene_control_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ON_OFF_ON_TIME:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining OnOff::OnTime under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_on_off_on_time_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ON_OFF_OFF_WAIT_TIME:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining OnOff::OffWaitTime under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_on_off_off_wait_time_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ON_OFF_START_UP_ON_OFF:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining OnOff::StartUpOnOff under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_on_off_start_up_on_off_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_ON_OFF_ON_OFF) {
          uic_mqtt_dotdot_on_off_on_off_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.reported<bool>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ON_OFF_GLOBAL_SCENE_CONTROL) {
          uic_mqtt_dotdot_on_off_global_scene_control_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.reported<bool>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ON_OFF_ON_TIME) {
          uic_mqtt_dotdot_on_off_on_time_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ON_OFF_OFF_WAIT_TIME) {
          uic_mqtt_dotdot_on_off_off_wait_time_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ON_OFF_START_UP_ON_OFF) {
          uic_mqtt_dotdot_on_off_start_up_on_off_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void on_off_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/OnOff/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_on_off_publish_cluster_revision(base_topic.c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_on_off_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/OnOff";
      sl_log_debug(LOG_TAG, "No more attributes supported for OnOff cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the Level cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void level_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_LEVEL_CURRENT_LEVEL) {
          uic_mqtt_dotdot_level_current_level_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_LEVEL_REMAINING_TIME) {
          uic_mqtt_dotdot_level_remaining_time_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_LEVEL_MIN_LEVEL) {
          uic_mqtt_dotdot_level_min_level_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_LEVEL_MAX_LEVEL) {
          uic_mqtt_dotdot_level_max_level_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_LEVEL_CURRENT_FREQUENCY) {
          uic_mqtt_dotdot_level_current_frequency_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_LEVEL_MIN_FREQUENCY) {
          uic_mqtt_dotdot_level_min_frequency_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_LEVEL_MAX_FREQUENCY) {
          uic_mqtt_dotdot_level_max_frequency_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_LEVEL_OPTIONS) {
          uic_mqtt_dotdot_level_options_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_LEVEL_ON_OFF_TRANSITION_TIME) {
          uic_mqtt_dotdot_level_on_off_transition_time_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_LEVEL_ON_LEVEL) {
          uic_mqtt_dotdot_level_on_level_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_LEVEL_ON_TRANSITION_TIME) {
          uic_mqtt_dotdot_level_on_transition_time_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_LEVEL_OFF_TRANSITION_TIME) {
          uic_mqtt_dotdot_level_off_transition_time_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_LEVEL_DEFAULT_MOVE_RATE) {
          uic_mqtt_dotdot_level_default_move_rate_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_LEVEL_START_UP_CURRENT_LEVEL) {
          uic_mqtt_dotdot_level_start_up_current_level_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the Level cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void level_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_LEVEL_CURRENT_LEVEL:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Level::CurrentLevel under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_level_current_level_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_LEVEL_REMAINING_TIME:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Level::RemainingTime under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_level_remaining_time_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_LEVEL_MIN_LEVEL:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Level::MinLevel under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_level_min_level_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_LEVEL_MAX_LEVEL:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Level::MaxLevel under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_level_max_level_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_LEVEL_CURRENT_FREQUENCY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Level::CurrentFrequency under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_level_current_frequency_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_LEVEL_MIN_FREQUENCY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Level::MinFrequency under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_level_min_frequency_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_LEVEL_MAX_FREQUENCY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Level::MaxFrequency under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_level_max_frequency_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_LEVEL_OPTIONS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Level::Options under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_level_options_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_LEVEL_ON_OFF_TRANSITION_TIME:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Level::OnOffTransitionTime under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_level_on_off_transition_time_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_LEVEL_ON_LEVEL:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Level::OnLevel under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_level_on_level_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_LEVEL_ON_TRANSITION_TIME:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Level::OnTransitionTime under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_level_on_transition_time_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_LEVEL_OFF_TRANSITION_TIME:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Level::OffTransitionTime under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_level_off_transition_time_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_LEVEL_DEFAULT_MOVE_RATE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Level::DefaultMoveRate under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_level_default_move_rate_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_LEVEL_START_UP_CURRENT_LEVEL:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Level::StartUpCurrentLevel under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_level_start_up_current_level_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_LEVEL_CURRENT_LEVEL) {
          uic_mqtt_dotdot_level_current_level_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_LEVEL_REMAINING_TIME) {
          uic_mqtt_dotdot_level_remaining_time_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_LEVEL_MIN_LEVEL) {
          uic_mqtt_dotdot_level_min_level_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_LEVEL_MAX_LEVEL) {
          uic_mqtt_dotdot_level_max_level_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_LEVEL_CURRENT_FREQUENCY) {
          uic_mqtt_dotdot_level_current_frequency_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_LEVEL_MIN_FREQUENCY) {
          uic_mqtt_dotdot_level_min_frequency_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_LEVEL_MAX_FREQUENCY) {
          uic_mqtt_dotdot_level_max_frequency_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_LEVEL_OPTIONS) {
          uic_mqtt_dotdot_level_options_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_LEVEL_ON_OFF_TRANSITION_TIME) {
          uic_mqtt_dotdot_level_on_off_transition_time_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_LEVEL_ON_LEVEL) {
          uic_mqtt_dotdot_level_on_level_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_LEVEL_ON_TRANSITION_TIME) {
          uic_mqtt_dotdot_level_on_transition_time_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_LEVEL_OFF_TRANSITION_TIME) {
          uic_mqtt_dotdot_level_off_transition_time_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_LEVEL_DEFAULT_MOVE_RATE) {
          uic_mqtt_dotdot_level_default_move_rate_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_LEVEL_START_UP_CURRENT_LEVEL) {
          uic_mqtt_dotdot_level_start_up_current_level_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void level_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/Level/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_level_publish_cluster_revision(base_topic.c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_level_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/Level";
      sl_log_debug(LOG_TAG, "No more attributes supported for Level cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the Alarms cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void alarms_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_ALARMS_ALARM_COUNT) {
          uic_mqtt_dotdot_alarms_alarm_count_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the Alarms cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void alarms_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_ALARMS_ALARM_COUNT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Alarms::AlarmCount under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_alarms_alarm_count_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_ALARMS_ALARM_COUNT) {
          uic_mqtt_dotdot_alarms_alarm_count_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void alarms_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/Alarms/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_alarms_publish_cluster_revision(base_topic.c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_alarms_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/Alarms";
      sl_log_debug(LOG_TAG, "No more attributes supported for Alarms cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the Time cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void time_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_TIME_TIME) {
          uic_mqtt_dotdot_time_time_publish(
            base_topic.c_str(),
            static_cast<UTC>(attr.desired_or_reported<UTC>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_TIME_TIME_STATUS) {
          uic_mqtt_dotdot_time_time_status_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_TIME_TIME_ZONE) {
          uic_mqtt_dotdot_time_time_zone_publish(
            base_topic.c_str(),
            static_cast<int32_t>(attr.desired_or_reported<int32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_TIME_DST_START) {
          uic_mqtt_dotdot_time_dst_start_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_TIME_DST_END) {
          uic_mqtt_dotdot_time_dst_end_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_TIME_DST_SHIFT) {
          uic_mqtt_dotdot_time_dst_shift_publish(
            base_topic.c_str(),
            static_cast<int32_t>(attr.desired_or_reported<int32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_TIME_STANDARD_TIME) {
          uic_mqtt_dotdot_time_standard_time_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_TIME_LOCAL_TIME) {
          uic_mqtt_dotdot_time_local_time_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_TIME_LAST_SET_TIME) {
          uic_mqtt_dotdot_time_last_set_time_publish(
            base_topic.c_str(),
            static_cast<UTC>(attr.desired_or_reported<UTC>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_TIME_VALID_UNTIL_TIME) {
          uic_mqtt_dotdot_time_valid_until_time_publish(
            base_topic.c_str(),
            static_cast<UTC>(attr.desired_or_reported<UTC>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the Time cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void time_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_TIME_TIME:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Time::Time under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_time_time_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_TIME_TIME_STATUS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Time::TimeStatus under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_time_time_status_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_TIME_TIME_ZONE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Time::TimeZone under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_time_time_zone_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_TIME_DST_START:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Time::DstStart under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_time_dst_start_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_TIME_DST_END:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Time::DstEnd under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_time_dst_end_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_TIME_DST_SHIFT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Time::DstShift under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_time_dst_shift_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_TIME_STANDARD_TIME:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Time::StandardTime under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_time_standard_time_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_TIME_LOCAL_TIME:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Time::LocalTime under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_time_local_time_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_TIME_LAST_SET_TIME:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Time::LastSetTime under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_time_last_set_time_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_TIME_VALID_UNTIL_TIME:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Time::ValidUntilTime under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_time_valid_until_time_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_TIME_TIME) {
          uic_mqtt_dotdot_time_time_publish(
            base_topic.c_str(),
            static_cast<UTC>(attr.reported<UTC>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_TIME_TIME_STATUS) {
          uic_mqtt_dotdot_time_time_status_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_TIME_TIME_ZONE) {
          uic_mqtt_dotdot_time_time_zone_publish(
            base_topic.c_str(),
            static_cast<int32_t>(attr.reported<int32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_TIME_DST_START) {
          uic_mqtt_dotdot_time_dst_start_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_TIME_DST_END) {
          uic_mqtt_dotdot_time_dst_end_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_TIME_DST_SHIFT) {
          uic_mqtt_dotdot_time_dst_shift_publish(
            base_topic.c_str(),
            static_cast<int32_t>(attr.reported<int32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_TIME_STANDARD_TIME) {
          uic_mqtt_dotdot_time_standard_time_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_TIME_LOCAL_TIME) {
          uic_mqtt_dotdot_time_local_time_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_TIME_LAST_SET_TIME) {
          uic_mqtt_dotdot_time_last_set_time_publish(
            base_topic.c_str(),
            static_cast<UTC>(attr.reported<UTC>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_TIME_VALID_UNTIL_TIME) {
          uic_mqtt_dotdot_time_valid_until_time_publish(
            base_topic.c_str(),
            static_cast<UTC>(attr.reported<UTC>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void time_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/Time/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_time_publish_cluster_revision(base_topic.c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_time_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/Time";
      sl_log_debug(LOG_TAG, "No more attributes supported for Time cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the PollControl cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void poll_control_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_CHECK_IN_INTERVAL) {
          uic_mqtt_dotdot_poll_control_check_in_interval_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_LONG_POLL_INTERVAL) {
          uic_mqtt_dotdot_poll_control_long_poll_interval_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_SHORT_POLL_INTERVAL) {
          uic_mqtt_dotdot_poll_control_short_poll_interval_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_FAST_POLL_TIMEOUT) {
          uic_mqtt_dotdot_poll_control_fast_poll_timeout_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_CHECK_IN_INTERVAL_MIN) {
          uic_mqtt_dotdot_poll_control_check_in_interval_min_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_LONG_POLL_INTERVAL_MIN) {
          uic_mqtt_dotdot_poll_control_long_poll_interval_min_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_FAST_POLL_TIMEOUT_MAX) {
          uic_mqtt_dotdot_poll_control_fast_poll_timeout_max_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the PollControl cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void poll_control_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_CHECK_IN_INTERVAL:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PollControl::CheckInInterval under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_poll_control_check_in_interval_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_LONG_POLL_INTERVAL:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PollControl::LongPollInterval under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_poll_control_long_poll_interval_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_SHORT_POLL_INTERVAL:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PollControl::ShortPollInterval under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_poll_control_short_poll_interval_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_FAST_POLL_TIMEOUT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PollControl::FastPollTimeout under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_poll_control_fast_poll_timeout_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_CHECK_IN_INTERVAL_MIN:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PollControl::CheckInIntervalMin under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_poll_control_check_in_interval_min_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_LONG_POLL_INTERVAL_MIN:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PollControl::LongPollIntervalMin under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_poll_control_long_poll_interval_min_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_FAST_POLL_TIMEOUT_MAX:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PollControl::FastPollTimeoutMax under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_poll_control_fast_poll_timeout_max_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_CHECK_IN_INTERVAL) {
          uic_mqtt_dotdot_poll_control_check_in_interval_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_LONG_POLL_INTERVAL) {
          uic_mqtt_dotdot_poll_control_long_poll_interval_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_SHORT_POLL_INTERVAL) {
          uic_mqtt_dotdot_poll_control_short_poll_interval_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_FAST_POLL_TIMEOUT) {
          uic_mqtt_dotdot_poll_control_fast_poll_timeout_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_CHECK_IN_INTERVAL_MIN) {
          uic_mqtt_dotdot_poll_control_check_in_interval_min_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_LONG_POLL_INTERVAL_MIN) {
          uic_mqtt_dotdot_poll_control_long_poll_interval_min_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_FAST_POLL_TIMEOUT_MAX) {
          uic_mqtt_dotdot_poll_control_fast_poll_timeout_max_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void poll_control_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/PollControl/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_poll_control_publish_cluster_revision(base_topic.c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_poll_control_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/PollControl";
      sl_log_debug(LOG_TAG, "No more attributes supported for PollControl cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the ShadeConfiguration cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void shade_configuration_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_PHYSICAL_CLOSED_LIMIT) {
          uic_mqtt_dotdot_shade_configuration_physical_closed_limit_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_MOTOR_STEP_SIZE) {
          uic_mqtt_dotdot_shade_configuration_motor_step_size_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_STATUS) {
          uic_mqtt_dotdot_shade_configuration_status_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_CLOSED_LIMIT) {
          uic_mqtt_dotdot_shade_configuration_closed_limit_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_MODE) {
          uic_mqtt_dotdot_shade_configuration_mode_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the ShadeConfiguration cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void shade_configuration_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_PHYSICAL_CLOSED_LIMIT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ShadeConfiguration::PhysicalClosedLimit under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_shade_configuration_physical_closed_limit_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_MOTOR_STEP_SIZE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ShadeConfiguration::MotorStepSize under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_shade_configuration_motor_step_size_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_STATUS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ShadeConfiguration::Status under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_shade_configuration_status_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_CLOSED_LIMIT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ShadeConfiguration::ClosedLimit under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_shade_configuration_closed_limit_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_MODE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ShadeConfiguration::Mode under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_shade_configuration_mode_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_PHYSICAL_CLOSED_LIMIT) {
          uic_mqtt_dotdot_shade_configuration_physical_closed_limit_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_MOTOR_STEP_SIZE) {
          uic_mqtt_dotdot_shade_configuration_motor_step_size_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_STATUS) {
          uic_mqtt_dotdot_shade_configuration_status_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_CLOSED_LIMIT) {
          uic_mqtt_dotdot_shade_configuration_closed_limit_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_MODE) {
          uic_mqtt_dotdot_shade_configuration_mode_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void shade_configuration_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/ShadeConfiguration/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_shade_configuration_publish_cluster_revision(base_topic.c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_shade_configuration_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/ShadeConfiguration";
      sl_log_debug(LOG_TAG, "No more attributes supported for ShadeConfiguration cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the DoorLock cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void door_lock_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LOCK_STATE) {
          uic_mqtt_dotdot_door_lock_lock_state_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LOCK_TYPE) {
          uic_mqtt_dotdot_door_lock_lock_type_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ACTUATOR_ENABLED) {
          uic_mqtt_dotdot_door_lock_actuator_enabled_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.desired_or_reported<bool>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_STATE) {
          uic_mqtt_dotdot_door_lock_door_state_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_OPEN_EVENTS) {
          uic_mqtt_dotdot_door_lock_door_open_events_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_CLOSED_EVENTS) {
          uic_mqtt_dotdot_door_lock_door_closed_events_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_OPEN_PERIOD) {
          uic_mqtt_dotdot_door_lock_open_period_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_LOG_RECORDS_SUPPORTED) {
          uic_mqtt_dotdot_door_lock_number_of_log_records_supported_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_TOTAL_USERS_SUPPORTED) {
          uic_mqtt_dotdot_door_lock_number_of_total_users_supported_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_PIN_USERS_SUPPORTED) {
          uic_mqtt_dotdot_door_lock_number_of_pin_users_supported_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_RFID_USERS_SUPPORTED) {
          uic_mqtt_dotdot_door_lock_number_of_rfid_users_supported_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_WEEK_DAY_SCHEDULES_SUPPORTED_PER_USER) {
          uic_mqtt_dotdot_door_lock_number_of_week_day_schedules_supported_per_user_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_YEAR_DAY_SCHEDULES_SUPPORTED_PER_USER) {
          uic_mqtt_dotdot_door_lock_number_of_year_day_schedules_supported_per_user_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_HOLIDAY_SCHEDULES_SUPPORTED) {
          uic_mqtt_dotdot_door_lock_number_of_holiday_schedules_supported_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MAX_PIN_CODE_LENGTH) {
          uic_mqtt_dotdot_door_lock_max_pin_code_length_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MIN_PIN_CODE_LENGTH) {
          uic_mqtt_dotdot_door_lock_min_pin_code_length_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MAX_RFID_CODE_LENGTH) {
          uic_mqtt_dotdot_door_lock_max_rfid_code_length_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MIN_RFID_CODE_LENGTH) {
          uic_mqtt_dotdot_door_lock_min_rfid_code_length_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_CREDENTIAL_RULES_SUPPORT) {
          uic_mqtt_dotdot_door_lock_credential_rules_support_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_CREDENTIALS_SUPPORTED_PER_USER) {
          uic_mqtt_dotdot_door_lock_number_of_credentials_supported_per_user_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_LOGGING) {
          uic_mqtt_dotdot_door_lock_enable_logging_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.desired_or_reported<bool>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LANGUAGE) {
          std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
          uic_mqtt_dotdot_door_lock_language_publish(
            base_topic.c_str(),
            static_cast<const char*>(str_desired.data()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LED_SETTINGS) {
          uic_mqtt_dotdot_door_lock_led_settings_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_AUTO_RELOCK_TIME) {
          uic_mqtt_dotdot_door_lock_auto_relock_time_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SOUND_VOLUME) {
          uic_mqtt_dotdot_door_lock_sound_volume_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_OPERATING_MODE) {
          uic_mqtt_dotdot_door_lock_operating_mode_publish(
            base_topic.c_str(),
            static_cast<DrlkOperMode>(attr.desired_or_reported<DrlkOperMode>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SUPPORTED_OPERATING_MODES) {
          uic_mqtt_dotdot_door_lock_supported_operating_modes_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DEFAULT_CONFIGURATION_REGISTER) {
          uic_mqtt_dotdot_door_lock_default_configuration_register_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_LOCAL_PROGRAMMING) {
          uic_mqtt_dotdot_door_lock_enable_local_programming_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.desired_or_reported<bool>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_ONE_TOUCH_LOCKING) {
          uic_mqtt_dotdot_door_lock_enable_one_touch_locking_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.desired_or_reported<bool>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_INSIDE_STATUSLED) {
          uic_mqtt_dotdot_door_lock_enable_inside_statusled_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.desired_or_reported<bool>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_PRIVACY_MODE_BUTTON) {
          uic_mqtt_dotdot_door_lock_enable_privacy_mode_button_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.desired_or_reported<bool>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LOCAL_PROGRAMMING_FEATURES) {
          uic_mqtt_dotdot_door_lock_local_programming_features_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_WRONG_CODE_ENTRY_LIMIT) {
          uic_mqtt_dotdot_door_lock_wrong_code_entry_limit_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_USER_CODE_TEMPORARY_DISABLE_TIME) {
          uic_mqtt_dotdot_door_lock_user_code_temporary_disable_time_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SEND_PIN_OVER_THE_AIR) {
          uic_mqtt_dotdot_door_lock_send_pin_over_the_air_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.desired_or_reported<bool>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_REQUIRE_PI_NFOR_RF_OPERATION) {
          uic_mqtt_dotdot_door_lock_require_pi_nfor_rf_operation_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.desired_or_reported<bool>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SECURITY_LEVEL) {
          uic_mqtt_dotdot_door_lock_security_level_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_EXPIRING_USER_TIMEOUT) {
          uic_mqtt_dotdot_door_lock_expiring_user_timeout_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ALARM_MASK) {
          uic_mqtt_dotdot_door_lock_alarm_mask_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_KEYPAD_OPERATION_EVENT_MASK) {
          uic_mqtt_dotdot_door_lock_keypad_operation_event_mask_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RF_OPERATION_EVENT_MASK) {
          uic_mqtt_dotdot_door_lock_rf_operation_event_mask_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MANUAL_OPERATION_EVENT_MASK) {
          uic_mqtt_dotdot_door_lock_manual_operation_event_mask_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RFID_OPERATION_EVENT_MASK) {
          uic_mqtt_dotdot_door_lock_rfid_operation_event_mask_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_KEYPAD_PROGRAMMING_EVENT_MASK) {
          uic_mqtt_dotdot_door_lock_keypad_programming_event_mask_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RF_PROGRAMMING_EVENT_MASK) {
          uic_mqtt_dotdot_door_lock_rf_programming_event_mask_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RFID_PROGRAMMING_EVENT_MASK) {
          uic_mqtt_dotdot_door_lock_rfid_programming_event_mask_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_FEATURE_MAP) {
          uic_mqtt_dotdot_door_lock_feature_map_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the DoorLock cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void door_lock_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LOCK_STATE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::LockState under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_lock_state_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LOCK_TYPE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::LockType under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_lock_type_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ACTUATOR_ENABLED:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::ActuatorEnabled under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_actuator_enabled_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_STATE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::DoorState under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_door_state_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_OPEN_EVENTS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::DoorOpenEvents under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_door_open_events_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_CLOSED_EVENTS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::DoorClosedEvents under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_door_closed_events_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_OPEN_PERIOD:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::OpenPeriod under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_open_period_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_LOG_RECORDS_SUPPORTED:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::NumberOfLogRecordsSupported under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_number_of_log_records_supported_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_TOTAL_USERS_SUPPORTED:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::NumberOfTotalUsersSupported under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_number_of_total_users_supported_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_PIN_USERS_SUPPORTED:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::NumberOfPINUsersSupported under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_number_of_pin_users_supported_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_RFID_USERS_SUPPORTED:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::NumberOfRFIDUsersSupported under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_number_of_rfid_users_supported_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_WEEK_DAY_SCHEDULES_SUPPORTED_PER_USER:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::NumberOfWeekDaySchedulesSupportedPerUser under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_number_of_week_day_schedules_supported_per_user_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_YEAR_DAY_SCHEDULES_SUPPORTED_PER_USER:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::NumberOfYearDaySchedulesSupportedPerUser under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_number_of_year_day_schedules_supported_per_user_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_HOLIDAY_SCHEDULES_SUPPORTED:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::NumberOfHolidaySchedulesSupported under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_number_of_holiday_schedules_supported_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MAX_PIN_CODE_LENGTH:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::MaxPINCodeLength under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_max_pin_code_length_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MIN_PIN_CODE_LENGTH:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::MinPINCodeLength under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_min_pin_code_length_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MAX_RFID_CODE_LENGTH:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::MaxRFIDCodeLength under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_max_rfid_code_length_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MIN_RFID_CODE_LENGTH:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::MinRFIDCodeLength under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_min_rfid_code_length_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_CREDENTIAL_RULES_SUPPORT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::CredentialRulesSupport under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_credential_rules_support_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_CREDENTIALS_SUPPORTED_PER_USER:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::NumberOfCredentialsSupportedPerUser under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_number_of_credentials_supported_per_user_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_LOGGING:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::EnableLogging under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_enable_logging_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LANGUAGE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::Language under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_language_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LED_SETTINGS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::LEDSettings under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_led_settings_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_AUTO_RELOCK_TIME:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::AutoRelockTime under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_auto_relock_time_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SOUND_VOLUME:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::SoundVolume under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_sound_volume_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_OPERATING_MODE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::OperatingMode under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_operating_mode_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SUPPORTED_OPERATING_MODES:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::SupportedOperatingModes under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_supported_operating_modes_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DEFAULT_CONFIGURATION_REGISTER:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::DefaultConfigurationRegister under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_default_configuration_register_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_LOCAL_PROGRAMMING:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::EnableLocalProgramming under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_enable_local_programming_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_ONE_TOUCH_LOCKING:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::EnableOneTouchLocking under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_enable_one_touch_locking_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_INSIDE_STATUSLED:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::EnableInsideStatusLED under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_enable_inside_statusled_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_PRIVACY_MODE_BUTTON:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::EnablePrivacyModeButton under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_enable_privacy_mode_button_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LOCAL_PROGRAMMING_FEATURES:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::LocalProgrammingFeatures under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_local_programming_features_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_WRONG_CODE_ENTRY_LIMIT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::WrongCodeEntryLimit under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_wrong_code_entry_limit_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_USER_CODE_TEMPORARY_DISABLE_TIME:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::UserCodeTemporaryDisableTime under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_user_code_temporary_disable_time_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SEND_PIN_OVER_THE_AIR:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::SendPINOverTheAir under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_send_pin_over_the_air_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_REQUIRE_PI_NFOR_RF_OPERATION:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::RequirePINforRFOperation under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_require_pi_nfor_rf_operation_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SECURITY_LEVEL:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::SecurityLevel under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_security_level_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_EXPIRING_USER_TIMEOUT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::ExpiringUserTimeout under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_expiring_user_timeout_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ALARM_MASK:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::AlarmMask under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_alarm_mask_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_KEYPAD_OPERATION_EVENT_MASK:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::KeypadOperationEventMask under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_keypad_operation_event_mask_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RF_OPERATION_EVENT_MASK:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::RFOperationEventMask under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_rf_operation_event_mask_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MANUAL_OPERATION_EVENT_MASK:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::ManualOperationEventMask under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_manual_operation_event_mask_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RFID_OPERATION_EVENT_MASK:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::RFIDOperationEventMask under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_rfid_operation_event_mask_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_KEYPAD_PROGRAMMING_EVENT_MASK:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::KeypadProgrammingEventMask under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_keypad_programming_event_mask_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RF_PROGRAMMING_EVENT_MASK:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::RFProgrammingEventMask under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_rf_programming_event_mask_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RFID_PROGRAMMING_EVENT_MASK:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::RFIDProgrammingEventMask under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_rfid_programming_event_mask_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_FEATURE_MAP:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DoorLock::FeatureMap under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_door_lock_feature_map_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LOCK_STATE) {
          uic_mqtt_dotdot_door_lock_lock_state_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LOCK_TYPE) {
          uic_mqtt_dotdot_door_lock_lock_type_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ACTUATOR_ENABLED) {
          uic_mqtt_dotdot_door_lock_actuator_enabled_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.reported<bool>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_STATE) {
          uic_mqtt_dotdot_door_lock_door_state_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_OPEN_EVENTS) {
          uic_mqtt_dotdot_door_lock_door_open_events_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_CLOSED_EVENTS) {
          uic_mqtt_dotdot_door_lock_door_closed_events_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_OPEN_PERIOD) {
          uic_mqtt_dotdot_door_lock_open_period_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_LOG_RECORDS_SUPPORTED) {
          uic_mqtt_dotdot_door_lock_number_of_log_records_supported_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_TOTAL_USERS_SUPPORTED) {
          uic_mqtt_dotdot_door_lock_number_of_total_users_supported_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_PIN_USERS_SUPPORTED) {
          uic_mqtt_dotdot_door_lock_number_of_pin_users_supported_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_RFID_USERS_SUPPORTED) {
          uic_mqtt_dotdot_door_lock_number_of_rfid_users_supported_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_WEEK_DAY_SCHEDULES_SUPPORTED_PER_USER) {
          uic_mqtt_dotdot_door_lock_number_of_week_day_schedules_supported_per_user_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_YEAR_DAY_SCHEDULES_SUPPORTED_PER_USER) {
          uic_mqtt_dotdot_door_lock_number_of_year_day_schedules_supported_per_user_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_HOLIDAY_SCHEDULES_SUPPORTED) {
          uic_mqtt_dotdot_door_lock_number_of_holiday_schedules_supported_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MAX_PIN_CODE_LENGTH) {
          uic_mqtt_dotdot_door_lock_max_pin_code_length_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MIN_PIN_CODE_LENGTH) {
          uic_mqtt_dotdot_door_lock_min_pin_code_length_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MAX_RFID_CODE_LENGTH) {
          uic_mqtt_dotdot_door_lock_max_rfid_code_length_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MIN_RFID_CODE_LENGTH) {
          uic_mqtt_dotdot_door_lock_min_rfid_code_length_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_CREDENTIAL_RULES_SUPPORT) {
          uic_mqtt_dotdot_door_lock_credential_rules_support_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_CREDENTIALS_SUPPORTED_PER_USER) {
          uic_mqtt_dotdot_door_lock_number_of_credentials_supported_per_user_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_LOGGING) {
          uic_mqtt_dotdot_door_lock_enable_logging_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.reported<bool>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LANGUAGE) {
          std::vector<char> str_desired = attr.reported<std::vector<char>>();
          uic_mqtt_dotdot_door_lock_language_publish(
            base_topic.c_str(),
            static_cast<const char*>( str_desired.data() ),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LED_SETTINGS) {
          uic_mqtt_dotdot_door_lock_led_settings_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_AUTO_RELOCK_TIME) {
          uic_mqtt_dotdot_door_lock_auto_relock_time_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SOUND_VOLUME) {
          uic_mqtt_dotdot_door_lock_sound_volume_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_OPERATING_MODE) {
          uic_mqtt_dotdot_door_lock_operating_mode_publish(
            base_topic.c_str(),
            static_cast<DrlkOperMode>(attr.reported<DrlkOperMode>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SUPPORTED_OPERATING_MODES) {
          uic_mqtt_dotdot_door_lock_supported_operating_modes_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DEFAULT_CONFIGURATION_REGISTER) {
          uic_mqtt_dotdot_door_lock_default_configuration_register_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_LOCAL_PROGRAMMING) {
          uic_mqtt_dotdot_door_lock_enable_local_programming_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.reported<bool>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_ONE_TOUCH_LOCKING) {
          uic_mqtt_dotdot_door_lock_enable_one_touch_locking_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.reported<bool>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_INSIDE_STATUSLED) {
          uic_mqtt_dotdot_door_lock_enable_inside_statusled_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.reported<bool>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_PRIVACY_MODE_BUTTON) {
          uic_mqtt_dotdot_door_lock_enable_privacy_mode_button_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.reported<bool>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LOCAL_PROGRAMMING_FEATURES) {
          uic_mqtt_dotdot_door_lock_local_programming_features_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_WRONG_CODE_ENTRY_LIMIT) {
          uic_mqtt_dotdot_door_lock_wrong_code_entry_limit_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_USER_CODE_TEMPORARY_DISABLE_TIME) {
          uic_mqtt_dotdot_door_lock_user_code_temporary_disable_time_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SEND_PIN_OVER_THE_AIR) {
          uic_mqtt_dotdot_door_lock_send_pin_over_the_air_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.reported<bool>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_REQUIRE_PI_NFOR_RF_OPERATION) {
          uic_mqtt_dotdot_door_lock_require_pi_nfor_rf_operation_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.reported<bool>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SECURITY_LEVEL) {
          uic_mqtt_dotdot_door_lock_security_level_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_EXPIRING_USER_TIMEOUT) {
          uic_mqtt_dotdot_door_lock_expiring_user_timeout_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ALARM_MASK) {
          uic_mqtt_dotdot_door_lock_alarm_mask_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_KEYPAD_OPERATION_EVENT_MASK) {
          uic_mqtt_dotdot_door_lock_keypad_operation_event_mask_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RF_OPERATION_EVENT_MASK) {
          uic_mqtt_dotdot_door_lock_rf_operation_event_mask_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MANUAL_OPERATION_EVENT_MASK) {
          uic_mqtt_dotdot_door_lock_manual_operation_event_mask_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RFID_OPERATION_EVENT_MASK) {
          uic_mqtt_dotdot_door_lock_rfid_operation_event_mask_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_KEYPAD_PROGRAMMING_EVENT_MASK) {
          uic_mqtt_dotdot_door_lock_keypad_programming_event_mask_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RF_PROGRAMMING_EVENT_MASK) {
          uic_mqtt_dotdot_door_lock_rf_programming_event_mask_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RFID_PROGRAMMING_EVENT_MASK) {
          uic_mqtt_dotdot_door_lock_rfid_programming_event_mask_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_FEATURE_MAP) {
          uic_mqtt_dotdot_door_lock_feature_map_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void door_lock_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/DoorLock/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_door_lock_publish_cluster_revision(base_topic.c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_door_lock_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/DoorLock";
      sl_log_debug(LOG_TAG, "No more attributes supported for DoorLock cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the WindowCovering cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void window_covering_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_WINDOW_COVERING_TYPE) {
          uic_mqtt_dotdot_window_covering_window_covering_type_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_PHYSICAL_CLOSED_LIMIT_LIFT) {
          uic_mqtt_dotdot_window_covering_physical_closed_limit_lift_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_PHYSICAL_CLOSED_LIMIT_TILT) {
          uic_mqtt_dotdot_window_covering_physical_closed_limit_tilt_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_LIFT) {
          uic_mqtt_dotdot_window_covering_current_position_lift_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_TILT) {
          uic_mqtt_dotdot_window_covering_current_position_tilt_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_NUMBER_OF_ACTUATIONS_LIFT) {
          uic_mqtt_dotdot_window_covering_number_of_actuations_lift_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_NUMBER_OF_ACTUATIONS_TILT) {
          uic_mqtt_dotdot_window_covering_number_of_actuations_tilt_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CONFIG_OR_STATUS) {
          uic_mqtt_dotdot_window_covering_config_or_status_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_LIFT_PERCENTAGE) {
          uic_mqtt_dotdot_window_covering_current_position_lift_percentage_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_TILT_PERCENTAGE) {
          uic_mqtt_dotdot_window_covering_current_position_tilt_percentage_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_OPEN_LIMIT_LIFT) {
          uic_mqtt_dotdot_window_covering_installed_open_limit_lift_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_CLOSED_LIMIT_LIFT) {
          uic_mqtt_dotdot_window_covering_installed_closed_limit_lift_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_OPEN_LIMIT_TILT) {
          uic_mqtt_dotdot_window_covering_installed_open_limit_tilt_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_CLOSED_LIMIT_TILT) {
          uic_mqtt_dotdot_window_covering_installed_closed_limit_tilt_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_VELOCITY_LIFT) {
          uic_mqtt_dotdot_window_covering_velocity_lift_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_ACCELERATION_TIME_LIFT) {
          uic_mqtt_dotdot_window_covering_acceleration_time_lift_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_DECELERATION_TIME_LIFT) {
          uic_mqtt_dotdot_window_covering_deceleration_time_lift_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_MODE) {
          uic_mqtt_dotdot_window_covering_mode_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INTERMEDIATE_SETPOINTS_LIFT) {
          std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
          uic_mqtt_dotdot_window_covering_intermediate_setpoints_lift_publish(
            base_topic.c_str(),
            static_cast<const char*>(str_desired.data()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INTERMEDIATE_SETPOINTS_TILT) {
          std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
          uic_mqtt_dotdot_window_covering_intermediate_setpoints_tilt_publish(
            base_topic.c_str(),
            static_cast<const char*>(str_desired.data()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the WindowCovering cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void window_covering_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_WINDOW_COVERING_TYPE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining WindowCovering::WindowCoveringType under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_window_covering_window_covering_type_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_PHYSICAL_CLOSED_LIMIT_LIFT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining WindowCovering::PhysicalClosedLimitLift under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_window_covering_physical_closed_limit_lift_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_PHYSICAL_CLOSED_LIMIT_TILT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining WindowCovering::PhysicalClosedLimitTilt under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_window_covering_physical_closed_limit_tilt_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_LIFT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining WindowCovering::CurrentPositionLift under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_window_covering_current_position_lift_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_TILT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining WindowCovering::CurrentPositionTilt under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_window_covering_current_position_tilt_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_NUMBER_OF_ACTUATIONS_LIFT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining WindowCovering::NumberOfActuationsLift under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_window_covering_number_of_actuations_lift_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_NUMBER_OF_ACTUATIONS_TILT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining WindowCovering::NumberOfActuationsTilt under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_window_covering_number_of_actuations_tilt_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CONFIG_OR_STATUS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining WindowCovering::ConfigOrStatus under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_window_covering_config_or_status_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_LIFT_PERCENTAGE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining WindowCovering::CurrentPositionLiftPercentage under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_window_covering_current_position_lift_percentage_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_TILT_PERCENTAGE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining WindowCovering::CurrentPositionTiltPercentage under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_window_covering_current_position_tilt_percentage_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_OPEN_LIMIT_LIFT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining WindowCovering::InstalledOpenLimitLift under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_window_covering_installed_open_limit_lift_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_CLOSED_LIMIT_LIFT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining WindowCovering::InstalledClosedLimitLift under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_window_covering_installed_closed_limit_lift_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_OPEN_LIMIT_TILT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining WindowCovering::InstalledOpenLimitTilt under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_window_covering_installed_open_limit_tilt_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_CLOSED_LIMIT_TILT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining WindowCovering::InstalledClosedLimitTilt under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_window_covering_installed_closed_limit_tilt_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_VELOCITY_LIFT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining WindowCovering::VelocityLift under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_window_covering_velocity_lift_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_ACCELERATION_TIME_LIFT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining WindowCovering::AccelerationTimeLift under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_window_covering_acceleration_time_lift_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_DECELERATION_TIME_LIFT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining WindowCovering::DecelerationTimeLift under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_window_covering_deceleration_time_lift_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_MODE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining WindowCovering::Mode under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_window_covering_mode_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INTERMEDIATE_SETPOINTS_LIFT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining WindowCovering::IntermediateSetpointsLift under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_window_covering_intermediate_setpoints_lift_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INTERMEDIATE_SETPOINTS_TILT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining WindowCovering::IntermediateSetpointsTilt under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_window_covering_intermediate_setpoints_tilt_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_WINDOW_COVERING_TYPE) {
          uic_mqtt_dotdot_window_covering_window_covering_type_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_PHYSICAL_CLOSED_LIMIT_LIFT) {
          uic_mqtt_dotdot_window_covering_physical_closed_limit_lift_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_PHYSICAL_CLOSED_LIMIT_TILT) {
          uic_mqtt_dotdot_window_covering_physical_closed_limit_tilt_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_LIFT) {
          uic_mqtt_dotdot_window_covering_current_position_lift_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_TILT) {
          uic_mqtt_dotdot_window_covering_current_position_tilt_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_NUMBER_OF_ACTUATIONS_LIFT) {
          uic_mqtt_dotdot_window_covering_number_of_actuations_lift_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_NUMBER_OF_ACTUATIONS_TILT) {
          uic_mqtt_dotdot_window_covering_number_of_actuations_tilt_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CONFIG_OR_STATUS) {
          uic_mqtt_dotdot_window_covering_config_or_status_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_LIFT_PERCENTAGE) {
          uic_mqtt_dotdot_window_covering_current_position_lift_percentage_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_TILT_PERCENTAGE) {
          uic_mqtt_dotdot_window_covering_current_position_tilt_percentage_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_OPEN_LIMIT_LIFT) {
          uic_mqtt_dotdot_window_covering_installed_open_limit_lift_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_CLOSED_LIMIT_LIFT) {
          uic_mqtt_dotdot_window_covering_installed_closed_limit_lift_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_OPEN_LIMIT_TILT) {
          uic_mqtt_dotdot_window_covering_installed_open_limit_tilt_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_CLOSED_LIMIT_TILT) {
          uic_mqtt_dotdot_window_covering_installed_closed_limit_tilt_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_VELOCITY_LIFT) {
          uic_mqtt_dotdot_window_covering_velocity_lift_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_ACCELERATION_TIME_LIFT) {
          uic_mqtt_dotdot_window_covering_acceleration_time_lift_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_DECELERATION_TIME_LIFT) {
          uic_mqtt_dotdot_window_covering_deceleration_time_lift_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_MODE) {
          uic_mqtt_dotdot_window_covering_mode_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INTERMEDIATE_SETPOINTS_LIFT) {
          std::vector<char> str_desired = attr.reported<std::vector<char>>();
          uic_mqtt_dotdot_window_covering_intermediate_setpoints_lift_publish(
            base_topic.c_str(),
            static_cast<const char*>( str_desired.data() ),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INTERMEDIATE_SETPOINTS_TILT) {
          std::vector<char> str_desired = attr.reported<std::vector<char>>();
          uic_mqtt_dotdot_window_covering_intermediate_setpoints_tilt_publish(
            base_topic.c_str(),
            static_cast<const char*>( str_desired.data() ),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void window_covering_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/WindowCovering/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_window_covering_publish_cluster_revision(base_topic.c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_window_covering_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/WindowCovering";
      sl_log_debug(LOG_TAG, "No more attributes supported for WindowCovering cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the BarrierControl cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void barrier_control_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_MOVING_STATE) {
          uic_mqtt_dotdot_barrier_control_moving_state_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_SAFETY_STATUS) {
          uic_mqtt_dotdot_barrier_control_safety_status_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CAPABILITIES) {
          uic_mqtt_dotdot_barrier_control_capabilities_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_OPEN_EVENTS) {
          uic_mqtt_dotdot_barrier_control_open_events_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CLOSE_EVENTS) {
          uic_mqtt_dotdot_barrier_control_close_events_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_COMMAND_OPEN_EVENTS) {
          uic_mqtt_dotdot_barrier_control_command_open_events_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_COMMAND_CLOSE_EVENTS) {
          uic_mqtt_dotdot_barrier_control_command_close_events_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_OPEN_PERIOD) {
          uic_mqtt_dotdot_barrier_control_open_period_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CLOSE_PERIOD) {
          uic_mqtt_dotdot_barrier_control_close_period_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_BARRIER_POSITION) {
          uic_mqtt_dotdot_barrier_control_barrier_position_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the BarrierControl cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void barrier_control_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_MOVING_STATE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining BarrierControl::MovingState under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_barrier_control_moving_state_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_SAFETY_STATUS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining BarrierControl::SafetyStatus under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_barrier_control_safety_status_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CAPABILITIES:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining BarrierControl::Capabilities under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_barrier_control_capabilities_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_OPEN_EVENTS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining BarrierControl::OpenEvents under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_barrier_control_open_events_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CLOSE_EVENTS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining BarrierControl::CloseEvents under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_barrier_control_close_events_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_COMMAND_OPEN_EVENTS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining BarrierControl::CommandOpenEvents under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_barrier_control_command_open_events_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_COMMAND_CLOSE_EVENTS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining BarrierControl::CommandCloseEvents under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_barrier_control_command_close_events_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_OPEN_PERIOD:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining BarrierControl::OpenPeriod under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_barrier_control_open_period_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CLOSE_PERIOD:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining BarrierControl::ClosePeriod under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_barrier_control_close_period_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_BARRIER_POSITION:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining BarrierControl::BarrierPosition under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_barrier_control_barrier_position_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_MOVING_STATE) {
          uic_mqtt_dotdot_barrier_control_moving_state_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_SAFETY_STATUS) {
          uic_mqtt_dotdot_barrier_control_safety_status_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CAPABILITIES) {
          uic_mqtt_dotdot_barrier_control_capabilities_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_OPEN_EVENTS) {
          uic_mqtt_dotdot_barrier_control_open_events_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CLOSE_EVENTS) {
          uic_mqtt_dotdot_barrier_control_close_events_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_COMMAND_OPEN_EVENTS) {
          uic_mqtt_dotdot_barrier_control_command_open_events_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_COMMAND_CLOSE_EVENTS) {
          uic_mqtt_dotdot_barrier_control_command_close_events_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_OPEN_PERIOD) {
          uic_mqtt_dotdot_barrier_control_open_period_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CLOSE_PERIOD) {
          uic_mqtt_dotdot_barrier_control_close_period_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_BARRIER_POSITION) {
          uic_mqtt_dotdot_barrier_control_barrier_position_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void barrier_control_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/BarrierControl/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_barrier_control_publish_cluster_revision(base_topic.c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_barrier_control_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/BarrierControl";
      sl_log_debug(LOG_TAG, "No more attributes supported for BarrierControl cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the PumpConfigurationAndControl cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void pump_configuration_and_control_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_PRESSURE) {
          uic_mqtt_dotdot_pump_configuration_and_control_max_pressure_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_SPEED) {
          uic_mqtt_dotdot_pump_configuration_and_control_max_speed_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_FLOW) {
          uic_mqtt_dotdot_pump_configuration_and_control_max_flow_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_PRESSURE) {
          uic_mqtt_dotdot_pump_configuration_and_control_min_const_pressure_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_PRESSURE) {
          uic_mqtt_dotdot_pump_configuration_and_control_max_const_pressure_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_COMP_PRESSURE) {
          uic_mqtt_dotdot_pump_configuration_and_control_min_comp_pressure_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_COMP_PRESSURE) {
          uic_mqtt_dotdot_pump_configuration_and_control_max_comp_pressure_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_SPEED) {
          uic_mqtt_dotdot_pump_configuration_and_control_min_const_speed_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_SPEED) {
          uic_mqtt_dotdot_pump_configuration_and_control_max_const_speed_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_FLOW) {
          uic_mqtt_dotdot_pump_configuration_and_control_min_const_flow_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_FLOW) {
          uic_mqtt_dotdot_pump_configuration_and_control_max_const_flow_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_TEMP) {
          uic_mqtt_dotdot_pump_configuration_and_control_min_const_temp_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_TEMP) {
          uic_mqtt_dotdot_pump_configuration_and_control_max_const_temp_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_PUMP_STATUS) {
          uic_mqtt_dotdot_pump_configuration_and_control_pump_status_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_EFFECTIVE_OPERATION_MODE) {
          uic_mqtt_dotdot_pump_configuration_and_control_effective_operation_mode_publish(
            base_topic.c_str(),
            static_cast<PumpOperationMode>(attr.desired_or_reported<PumpOperationMode>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_EFFECTIVE_CONTROL_MODE) {
          uic_mqtt_dotdot_pump_configuration_and_control_effective_control_mode_publish(
            base_topic.c_str(),
            static_cast<PumpControlMode>(attr.desired_or_reported<PumpControlMode>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_CAPACITY) {
          uic_mqtt_dotdot_pump_configuration_and_control_capacity_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_SPEED) {
          uic_mqtt_dotdot_pump_configuration_and_control_speed_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_LIFETIME_RUNNING_HOURS) {
          uic_mqtt_dotdot_pump_configuration_and_control_lifetime_running_hours_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_POWER) {
          uic_mqtt_dotdot_pump_configuration_and_control_power_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_LIFETIME_ENERGY_CONSUMED) {
          uic_mqtt_dotdot_pump_configuration_and_control_lifetime_energy_consumed_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_OPERATION_MODE) {
          uic_mqtt_dotdot_pump_configuration_and_control_operation_mode_publish(
            base_topic.c_str(),
            static_cast<PumpOperationMode>(attr.desired_or_reported<PumpOperationMode>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_CONTROL_MODE) {
          uic_mqtt_dotdot_pump_configuration_and_control_control_mode_publish(
            base_topic.c_str(),
            static_cast<PumpControlMode>(attr.desired_or_reported<PumpControlMode>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_ALARM_MASK) {
          uic_mqtt_dotdot_pump_configuration_and_control_alarm_mask_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the PumpConfigurationAndControl cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void pump_configuration_and_control_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_PRESSURE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PumpConfigurationAndControl::MaxPressure under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pump_configuration_and_control_max_pressure_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_SPEED:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PumpConfigurationAndControl::MaxSpeed under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pump_configuration_and_control_max_speed_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_FLOW:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PumpConfigurationAndControl::MaxFlow under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pump_configuration_and_control_max_flow_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_PRESSURE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PumpConfigurationAndControl::MinConstPressure under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pump_configuration_and_control_min_const_pressure_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_PRESSURE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PumpConfigurationAndControl::MaxConstPressure under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pump_configuration_and_control_max_const_pressure_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_COMP_PRESSURE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PumpConfigurationAndControl::MinCompPressure under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pump_configuration_and_control_min_comp_pressure_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_COMP_PRESSURE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PumpConfigurationAndControl::MaxCompPressure under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pump_configuration_and_control_max_comp_pressure_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_SPEED:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PumpConfigurationAndControl::MinConstSpeed under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pump_configuration_and_control_min_const_speed_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_SPEED:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PumpConfigurationAndControl::MaxConstSpeed under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pump_configuration_and_control_max_const_speed_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_FLOW:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PumpConfigurationAndControl::MinConstFlow under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pump_configuration_and_control_min_const_flow_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_FLOW:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PumpConfigurationAndControl::MaxConstFlow under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pump_configuration_and_control_max_const_flow_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_TEMP:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PumpConfigurationAndControl::MinConstTemp under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pump_configuration_and_control_min_const_temp_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_TEMP:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PumpConfigurationAndControl::MaxConstTemp under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pump_configuration_and_control_max_const_temp_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_PUMP_STATUS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PumpConfigurationAndControl::PumpStatus under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pump_configuration_and_control_pump_status_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_EFFECTIVE_OPERATION_MODE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PumpConfigurationAndControl::EffectiveOperationMode under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pump_configuration_and_control_effective_operation_mode_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_EFFECTIVE_CONTROL_MODE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PumpConfigurationAndControl::EffectiveControlMode under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pump_configuration_and_control_effective_control_mode_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_CAPACITY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PumpConfigurationAndControl::Capacity under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pump_configuration_and_control_capacity_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_SPEED:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PumpConfigurationAndControl::Speed under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pump_configuration_and_control_speed_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_LIFETIME_RUNNING_HOURS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PumpConfigurationAndControl::LifetimeRunningHours under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pump_configuration_and_control_lifetime_running_hours_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_POWER:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PumpConfigurationAndControl::Power under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pump_configuration_and_control_power_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_LIFETIME_ENERGY_CONSUMED:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PumpConfigurationAndControl::LifetimeEnergyConsumed under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pump_configuration_and_control_lifetime_energy_consumed_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_OPERATION_MODE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PumpConfigurationAndControl::OperationMode under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pump_configuration_and_control_operation_mode_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_CONTROL_MODE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PumpConfigurationAndControl::ControlMode under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pump_configuration_and_control_control_mode_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_ALARM_MASK:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PumpConfigurationAndControl::AlarmMask under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pump_configuration_and_control_alarm_mask_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_PRESSURE) {
          uic_mqtt_dotdot_pump_configuration_and_control_max_pressure_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_SPEED) {
          uic_mqtt_dotdot_pump_configuration_and_control_max_speed_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_FLOW) {
          uic_mqtt_dotdot_pump_configuration_and_control_max_flow_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_PRESSURE) {
          uic_mqtt_dotdot_pump_configuration_and_control_min_const_pressure_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_PRESSURE) {
          uic_mqtt_dotdot_pump_configuration_and_control_max_const_pressure_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_COMP_PRESSURE) {
          uic_mqtt_dotdot_pump_configuration_and_control_min_comp_pressure_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_COMP_PRESSURE) {
          uic_mqtt_dotdot_pump_configuration_and_control_max_comp_pressure_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_SPEED) {
          uic_mqtt_dotdot_pump_configuration_and_control_min_const_speed_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_SPEED) {
          uic_mqtt_dotdot_pump_configuration_and_control_max_const_speed_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_FLOW) {
          uic_mqtt_dotdot_pump_configuration_and_control_min_const_flow_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_FLOW) {
          uic_mqtt_dotdot_pump_configuration_and_control_max_const_flow_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_TEMP) {
          uic_mqtt_dotdot_pump_configuration_and_control_min_const_temp_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_TEMP) {
          uic_mqtt_dotdot_pump_configuration_and_control_max_const_temp_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_PUMP_STATUS) {
          uic_mqtt_dotdot_pump_configuration_and_control_pump_status_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_EFFECTIVE_OPERATION_MODE) {
          uic_mqtt_dotdot_pump_configuration_and_control_effective_operation_mode_publish(
            base_topic.c_str(),
            static_cast<PumpOperationMode>(attr.reported<PumpOperationMode>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_EFFECTIVE_CONTROL_MODE) {
          uic_mqtt_dotdot_pump_configuration_and_control_effective_control_mode_publish(
            base_topic.c_str(),
            static_cast<PumpControlMode>(attr.reported<PumpControlMode>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_CAPACITY) {
          uic_mqtt_dotdot_pump_configuration_and_control_capacity_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_SPEED) {
          uic_mqtt_dotdot_pump_configuration_and_control_speed_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_LIFETIME_RUNNING_HOURS) {
          uic_mqtt_dotdot_pump_configuration_and_control_lifetime_running_hours_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_POWER) {
          uic_mqtt_dotdot_pump_configuration_and_control_power_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_LIFETIME_ENERGY_CONSUMED) {
          uic_mqtt_dotdot_pump_configuration_and_control_lifetime_energy_consumed_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_OPERATION_MODE) {
          uic_mqtt_dotdot_pump_configuration_and_control_operation_mode_publish(
            base_topic.c_str(),
            static_cast<PumpOperationMode>(attr.reported<PumpOperationMode>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_CONTROL_MODE) {
          uic_mqtt_dotdot_pump_configuration_and_control_control_mode_publish(
            base_topic.c_str(),
            static_cast<PumpControlMode>(attr.reported<PumpControlMode>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_ALARM_MASK) {
          uic_mqtt_dotdot_pump_configuration_and_control_alarm_mask_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void pump_configuration_and_control_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/PumpConfigurationAndControl/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_pump_configuration_and_control_publish_cluster_revision(base_topic.c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_pump_configuration_and_control_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/PumpConfigurationAndControl";
      sl_log_debug(LOG_TAG, "No more attributes supported for PumpConfigurationAndControl cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the Thermostat cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void thermostat_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_LOCAL_TEMPERATURE) {
          uic_mqtt_dotdot_thermostat_local_temperature_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OUTDOOR_TEMPERATURE) {
          uic_mqtt_dotdot_thermostat_outdoor_temperature_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPANCY) {
          uic_mqtt_dotdot_thermostat_occupancy_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MIN_HEAT_SETPOINT_LIMIT) {
          uic_mqtt_dotdot_thermostat_abs_min_heat_setpoint_limit_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MAX_HEAT_SETPOINT_LIMIT) {
          uic_mqtt_dotdot_thermostat_abs_max_heat_setpoint_limit_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MIN_COOL_SETPOINT_LIMIT) {
          uic_mqtt_dotdot_thermostat_abs_min_cool_setpoint_limit_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MAX_COOL_SETPOINT_LIMIT) {
          uic_mqtt_dotdot_thermostat_abs_max_cool_setpoint_limit_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_PI_COOLING_DEMAND) {
          uic_mqtt_dotdot_thermostat_pi_cooling_demand_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_PI_HEATING_DEMAND) {
          uic_mqtt_dotdot_thermostat_pi_heating_demand_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_HVAC_SYSTEM_TYPE_CONFIGURATION) {
          uic_mqtt_dotdot_thermostat_hvac_system_type_configuration_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_LOCAL_TEMPERATURE_CALIBRATION) {
          uic_mqtt_dotdot_thermostat_local_temperature_calibration_publish(
            base_topic.c_str(),
            static_cast<int8_t>(attr.desired_or_reported<int8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_COOLING_SETPOINT) {
          uic_mqtt_dotdot_thermostat_occupied_cooling_setpoint_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_HEATING_SETPOINT) {
          uic_mqtt_dotdot_thermostat_occupied_heating_setpoint_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_COOLING_SETPOINT) {
          uic_mqtt_dotdot_thermostat_unoccupied_cooling_setpoint_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_HEATING_SETPOINT) {
          uic_mqtt_dotdot_thermostat_unoccupied_heating_setpoint_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_HEAT_SETPOINT_LIMIT) {
          uic_mqtt_dotdot_thermostat_min_heat_setpoint_limit_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MAX_HEAT_SETPOINT_LIMIT) {
          uic_mqtt_dotdot_thermostat_max_heat_setpoint_limit_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_COOL_SETPOINT_LIMIT) {
          uic_mqtt_dotdot_thermostat_min_cool_setpoint_limit_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MAX_COOL_SETPOINT_LIMIT) {
          uic_mqtt_dotdot_thermostat_max_cool_setpoint_limit_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_SETPOINT_DEAD_BAND) {
          uic_mqtt_dotdot_thermostat_min_setpoint_dead_band_publish(
            base_topic.c_str(),
            static_cast<int8_t>(attr.desired_or_reported<int8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_REMOTE_SENSING) {
          uic_mqtt_dotdot_thermostat_remote_sensing_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_CONTROL_SEQUENCE_OF_OPERATION) {
          uic_mqtt_dotdot_thermostat_control_sequence_of_operation_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SYSTEM_MODE) {
          uic_mqtt_dotdot_thermostat_system_mode_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ALARM_MASK) {
          uic_mqtt_dotdot_thermostat_alarm_mask_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_RUNNING_MODE) {
          uic_mqtt_dotdot_thermostat_thermostat_running_mode_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_START_OF_WEEK) {
          uic_mqtt_dotdot_thermostat_start_of_week_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_NUMBER_OF_WEEKLY_TRANSITIONS) {
          uic_mqtt_dotdot_thermostat_number_of_weekly_transitions_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_NUMBER_OF_DAILY_TRANSITIONS) {
          uic_mqtt_dotdot_thermostat_number_of_daily_transitions_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_TEMPERATURE_SETPOINT_HOLD) {
          uic_mqtt_dotdot_thermostat_temperature_setpoint_hold_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_TEMPERATURE_SETPOINT_HOLD_DURATION) {
          uic_mqtt_dotdot_thermostat_temperature_setpoint_hold_duration_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_PROGRAMMING_OPERATION_MODE) {
          uic_mqtt_dotdot_thermostat_thermostat_programming_operation_mode_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_RUNNING_STATE) {
          uic_mqtt_dotdot_thermostat_thermostat_running_state_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_SOURCE) {
          uic_mqtt_dotdot_thermostat_setpoint_change_source_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_AMOUNT) {
          uic_mqtt_dotdot_thermostat_setpoint_change_amount_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_SOURCE_TIMESTAMP) {
          uic_mqtt_dotdot_thermostat_setpoint_change_source_timestamp_publish(
            base_topic.c_str(),
            static_cast<UTC>(attr.desired_or_reported<UTC>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK) {
          uic_mqtt_dotdot_thermostat_occupied_setback_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK_MIN) {
          uic_mqtt_dotdot_thermostat_occupied_setback_min_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK_MAX) {
          uic_mqtt_dotdot_thermostat_occupied_setback_max_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK) {
          uic_mqtt_dotdot_thermostat_unoccupied_setback_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK_MIN) {
          uic_mqtt_dotdot_thermostat_unoccupied_setback_min_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK_MAX) {
          uic_mqtt_dotdot_thermostat_unoccupied_setback_max_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_EMERGENCY_HEAT_DELTA) {
          uic_mqtt_dotdot_thermostat_emergency_heat_delta_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_TYPE) {
          uic_mqtt_dotdot_thermostat_ac_type_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_CAPACITY) {
          uic_mqtt_dotdot_thermostat_ac_capacity_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_REFRIGERANT_TYPE) {
          uic_mqtt_dotdot_thermostat_ac_refrigerant_type_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_COMPRESSOR_TYPE) {
          uic_mqtt_dotdot_thermostat_ac_compressor_type_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_ERROR_CODE) {
          uic_mqtt_dotdot_thermostat_ac_error_code_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_LOUVER_POSITION) {
          uic_mqtt_dotdot_thermostat_ac_louver_position_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_COIL_TEMPERATURE) {
          uic_mqtt_dotdot_thermostat_ac_coil_temperature_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_CAPACITY_FORMAT) {
          uic_mqtt_dotdot_thermostat_ac_capacity_format_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the Thermostat cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void thermostat_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_LOCAL_TEMPERATURE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::LocalTemperature under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_local_temperature_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OUTDOOR_TEMPERATURE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::OutdoorTemperature under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_outdoor_temperature_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPANCY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::Occupancy under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_occupancy_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MIN_HEAT_SETPOINT_LIMIT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::AbsMinHeatSetpointLimit under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_abs_min_heat_setpoint_limit_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MAX_HEAT_SETPOINT_LIMIT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::AbsMaxHeatSetpointLimit under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_abs_max_heat_setpoint_limit_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MIN_COOL_SETPOINT_LIMIT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::AbsMinCoolSetpointLimit under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_abs_min_cool_setpoint_limit_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MAX_COOL_SETPOINT_LIMIT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::AbsMaxCoolSetpointLimit under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_abs_max_cool_setpoint_limit_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_PI_COOLING_DEMAND:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::PICoolingDemand under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_pi_cooling_demand_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_PI_HEATING_DEMAND:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::PIHeatingDemand under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_pi_heating_demand_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_HVAC_SYSTEM_TYPE_CONFIGURATION:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::HVACSystemTypeConfiguration under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_hvac_system_type_configuration_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_LOCAL_TEMPERATURE_CALIBRATION:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::LocalTemperatureCalibration under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_local_temperature_calibration_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_COOLING_SETPOINT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::OccupiedCoolingSetpoint under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_occupied_cooling_setpoint_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_HEATING_SETPOINT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::OccupiedHeatingSetpoint under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_occupied_heating_setpoint_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_COOLING_SETPOINT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::UnoccupiedCoolingSetpoint under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_unoccupied_cooling_setpoint_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_HEATING_SETPOINT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::UnoccupiedHeatingSetpoint under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_unoccupied_heating_setpoint_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_HEAT_SETPOINT_LIMIT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::MinHeatSetpointLimit under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_min_heat_setpoint_limit_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MAX_HEAT_SETPOINT_LIMIT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::MaxHeatSetpointLimit under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_max_heat_setpoint_limit_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_COOL_SETPOINT_LIMIT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::MinCoolSetpointLimit under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_min_cool_setpoint_limit_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MAX_COOL_SETPOINT_LIMIT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::MaxCoolSetpointLimit under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_max_cool_setpoint_limit_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_SETPOINT_DEAD_BAND:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::MinSetpointDeadBand under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_min_setpoint_dead_band_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_REMOTE_SENSING:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::RemoteSensing under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_remote_sensing_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_CONTROL_SEQUENCE_OF_OPERATION:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::ControlSequenceOfOperation under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_control_sequence_of_operation_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SYSTEM_MODE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::SystemMode under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_system_mode_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ALARM_MASK:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::AlarmMask under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_alarm_mask_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_RUNNING_MODE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::ThermostatRunningMode under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_thermostat_running_mode_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_START_OF_WEEK:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::StartOfWeek under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_start_of_week_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_NUMBER_OF_WEEKLY_TRANSITIONS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::NumberOfWeeklyTransitions under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_number_of_weekly_transitions_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_NUMBER_OF_DAILY_TRANSITIONS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::NumberOfDailyTransitions under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_number_of_daily_transitions_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_TEMPERATURE_SETPOINT_HOLD:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::TemperatureSetpointHold under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_temperature_setpoint_hold_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_TEMPERATURE_SETPOINT_HOLD_DURATION:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::TemperatureSetpointHoldDuration under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_temperature_setpoint_hold_duration_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_PROGRAMMING_OPERATION_MODE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::ThermostatProgrammingOperationMode under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_thermostat_programming_operation_mode_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_RUNNING_STATE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::ThermostatRunningState under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_thermostat_running_state_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_SOURCE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::SetpointChangeSource under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_setpoint_change_source_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_AMOUNT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::SetpointChangeAmount under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_setpoint_change_amount_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_SOURCE_TIMESTAMP:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::SetpointChangeSourceTimestamp under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_setpoint_change_source_timestamp_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::OccupiedSetback under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_occupied_setback_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK_MIN:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::OccupiedSetbackMin under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_occupied_setback_min_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK_MAX:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::OccupiedSetbackMax under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_occupied_setback_max_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::UnoccupiedSetback under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_unoccupied_setback_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK_MIN:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::UnoccupiedSetbackMin under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_unoccupied_setback_min_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK_MAX:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::UnoccupiedSetbackMax under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_unoccupied_setback_max_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_EMERGENCY_HEAT_DELTA:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::EmergencyHeatDelta under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_emergency_heat_delta_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_TYPE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::ACType under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_ac_type_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_CAPACITY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::ACCapacity under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_ac_capacity_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_REFRIGERANT_TYPE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::ACRefrigerantType under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_ac_refrigerant_type_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_COMPRESSOR_TYPE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::ACCompressorType under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_ac_compressor_type_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_ERROR_CODE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::ACErrorCode under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_ac_error_code_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_LOUVER_POSITION:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::ACLouverPosition under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_ac_louver_position_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_COIL_TEMPERATURE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::ACCoilTemperature under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_ac_coil_temperature_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_CAPACITY_FORMAT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Thermostat::ACCapacityFormat under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_ac_capacity_format_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_LOCAL_TEMPERATURE) {
          uic_mqtt_dotdot_thermostat_local_temperature_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OUTDOOR_TEMPERATURE) {
          uic_mqtt_dotdot_thermostat_outdoor_temperature_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPANCY) {
          uic_mqtt_dotdot_thermostat_occupancy_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MIN_HEAT_SETPOINT_LIMIT) {
          uic_mqtt_dotdot_thermostat_abs_min_heat_setpoint_limit_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MAX_HEAT_SETPOINT_LIMIT) {
          uic_mqtt_dotdot_thermostat_abs_max_heat_setpoint_limit_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MIN_COOL_SETPOINT_LIMIT) {
          uic_mqtt_dotdot_thermostat_abs_min_cool_setpoint_limit_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MAX_COOL_SETPOINT_LIMIT) {
          uic_mqtt_dotdot_thermostat_abs_max_cool_setpoint_limit_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_PI_COOLING_DEMAND) {
          uic_mqtt_dotdot_thermostat_pi_cooling_demand_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_PI_HEATING_DEMAND) {
          uic_mqtt_dotdot_thermostat_pi_heating_demand_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_HVAC_SYSTEM_TYPE_CONFIGURATION) {
          uic_mqtt_dotdot_thermostat_hvac_system_type_configuration_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_LOCAL_TEMPERATURE_CALIBRATION) {
          uic_mqtt_dotdot_thermostat_local_temperature_calibration_publish(
            base_topic.c_str(),
            static_cast<int8_t>(attr.reported<int8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_COOLING_SETPOINT) {
          uic_mqtt_dotdot_thermostat_occupied_cooling_setpoint_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_HEATING_SETPOINT) {
          uic_mqtt_dotdot_thermostat_occupied_heating_setpoint_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_COOLING_SETPOINT) {
          uic_mqtt_dotdot_thermostat_unoccupied_cooling_setpoint_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_HEATING_SETPOINT) {
          uic_mqtt_dotdot_thermostat_unoccupied_heating_setpoint_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_HEAT_SETPOINT_LIMIT) {
          uic_mqtt_dotdot_thermostat_min_heat_setpoint_limit_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MAX_HEAT_SETPOINT_LIMIT) {
          uic_mqtt_dotdot_thermostat_max_heat_setpoint_limit_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_COOL_SETPOINT_LIMIT) {
          uic_mqtt_dotdot_thermostat_min_cool_setpoint_limit_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MAX_COOL_SETPOINT_LIMIT) {
          uic_mqtt_dotdot_thermostat_max_cool_setpoint_limit_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_SETPOINT_DEAD_BAND) {
          uic_mqtt_dotdot_thermostat_min_setpoint_dead_band_publish(
            base_topic.c_str(),
            static_cast<int8_t>(attr.reported<int8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_REMOTE_SENSING) {
          uic_mqtt_dotdot_thermostat_remote_sensing_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_CONTROL_SEQUENCE_OF_OPERATION) {
          uic_mqtt_dotdot_thermostat_control_sequence_of_operation_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SYSTEM_MODE) {
          uic_mqtt_dotdot_thermostat_system_mode_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ALARM_MASK) {
          uic_mqtt_dotdot_thermostat_alarm_mask_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_RUNNING_MODE) {
          uic_mqtt_dotdot_thermostat_thermostat_running_mode_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_START_OF_WEEK) {
          uic_mqtt_dotdot_thermostat_start_of_week_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_NUMBER_OF_WEEKLY_TRANSITIONS) {
          uic_mqtt_dotdot_thermostat_number_of_weekly_transitions_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_NUMBER_OF_DAILY_TRANSITIONS) {
          uic_mqtt_dotdot_thermostat_number_of_daily_transitions_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_TEMPERATURE_SETPOINT_HOLD) {
          uic_mqtt_dotdot_thermostat_temperature_setpoint_hold_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_TEMPERATURE_SETPOINT_HOLD_DURATION) {
          uic_mqtt_dotdot_thermostat_temperature_setpoint_hold_duration_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_PROGRAMMING_OPERATION_MODE) {
          uic_mqtt_dotdot_thermostat_thermostat_programming_operation_mode_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_RUNNING_STATE) {
          uic_mqtt_dotdot_thermostat_thermostat_running_state_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_SOURCE) {
          uic_mqtt_dotdot_thermostat_setpoint_change_source_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_AMOUNT) {
          uic_mqtt_dotdot_thermostat_setpoint_change_amount_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_SOURCE_TIMESTAMP) {
          uic_mqtt_dotdot_thermostat_setpoint_change_source_timestamp_publish(
            base_topic.c_str(),
            static_cast<UTC>(attr.reported<UTC>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK) {
          uic_mqtt_dotdot_thermostat_occupied_setback_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK_MIN) {
          uic_mqtt_dotdot_thermostat_occupied_setback_min_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK_MAX) {
          uic_mqtt_dotdot_thermostat_occupied_setback_max_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK) {
          uic_mqtt_dotdot_thermostat_unoccupied_setback_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK_MIN) {
          uic_mqtt_dotdot_thermostat_unoccupied_setback_min_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK_MAX) {
          uic_mqtt_dotdot_thermostat_unoccupied_setback_max_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_EMERGENCY_HEAT_DELTA) {
          uic_mqtt_dotdot_thermostat_emergency_heat_delta_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_TYPE) {
          uic_mqtt_dotdot_thermostat_ac_type_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_CAPACITY) {
          uic_mqtt_dotdot_thermostat_ac_capacity_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_REFRIGERANT_TYPE) {
          uic_mqtt_dotdot_thermostat_ac_refrigerant_type_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_COMPRESSOR_TYPE) {
          uic_mqtt_dotdot_thermostat_ac_compressor_type_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_ERROR_CODE) {
          uic_mqtt_dotdot_thermostat_ac_error_code_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_LOUVER_POSITION) {
          uic_mqtt_dotdot_thermostat_ac_louver_position_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_COIL_TEMPERATURE) {
          uic_mqtt_dotdot_thermostat_ac_coil_temperature_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_CAPACITY_FORMAT) {
          uic_mqtt_dotdot_thermostat_ac_capacity_format_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void thermostat_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/Thermostat/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_thermostat_publish_cluster_revision(base_topic.c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_thermostat_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/Thermostat";
      sl_log_debug(LOG_TAG, "No more attributes supported for Thermostat cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the FanControl cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void fan_control_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_FAN_CONTROL_FAN_MODE) {
          uic_mqtt_dotdot_fan_control_fan_mode_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_FAN_CONTROL_FAN_MODE_SEQUENCE) {
          uic_mqtt_dotdot_fan_control_fan_mode_sequence_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the FanControl cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void fan_control_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_FAN_CONTROL_FAN_MODE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining FanControl::FanMode under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_fan_control_fan_mode_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_FAN_CONTROL_FAN_MODE_SEQUENCE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining FanControl::FanModeSequence under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_fan_control_fan_mode_sequence_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_FAN_CONTROL_FAN_MODE) {
          uic_mqtt_dotdot_fan_control_fan_mode_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_FAN_CONTROL_FAN_MODE_SEQUENCE) {
          uic_mqtt_dotdot_fan_control_fan_mode_sequence_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void fan_control_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/FanControl/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_fan_control_publish_cluster_revision(base_topic.c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_fan_control_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/FanControl";
      sl_log_debug(LOG_TAG, "No more attributes supported for FanControl cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the DehumidificationControl cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void dehumidification_control_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY) {
          uic_mqtt_dotdot_dehumidification_control_relative_humidity_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_COOLING) {
          uic_mqtt_dotdot_dehumidification_control_dehumidification_cooling_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RH_DEHUMIDIFICATION_SETPOINT) {
          uic_mqtt_dotdot_dehumidification_control_rh_dehumidification_setpoint_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_MODE) {
          uic_mqtt_dotdot_dehumidification_control_relative_humidity_mode_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_LOCKOUT) {
          uic_mqtt_dotdot_dehumidification_control_dehumidification_lockout_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_HYSTERESIS) {
          uic_mqtt_dotdot_dehumidification_control_dehumidification_hysteresis_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_MAX_COOL) {
          uic_mqtt_dotdot_dehumidification_control_dehumidification_max_cool_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_DISPLAY) {
          uic_mqtt_dotdot_dehumidification_control_relative_humidity_display_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the DehumidificationControl cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void dehumidification_control_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DehumidificationControl::RelativeHumidity under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_dehumidification_control_relative_humidity_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_COOLING:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DehumidificationControl::DehumidificationCooling under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_dehumidification_control_dehumidification_cooling_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RH_DEHUMIDIFICATION_SETPOINT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DehumidificationControl::RHDehumidificationSetpoint under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_dehumidification_control_rh_dehumidification_setpoint_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_MODE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DehumidificationControl::RelativeHumidityMode under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_dehumidification_control_relative_humidity_mode_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_LOCKOUT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DehumidificationControl::DehumidificationLockout under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_dehumidification_control_dehumidification_lockout_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_HYSTERESIS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DehumidificationControl::DehumidificationHysteresis under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_dehumidification_control_dehumidification_hysteresis_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_MAX_COOL:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DehumidificationControl::DehumidificationMaxCool under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_dehumidification_control_dehumidification_max_cool_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_DISPLAY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining DehumidificationControl::RelativeHumidityDisplay under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_dehumidification_control_relative_humidity_display_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY) {
          uic_mqtt_dotdot_dehumidification_control_relative_humidity_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_COOLING) {
          uic_mqtt_dotdot_dehumidification_control_dehumidification_cooling_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RH_DEHUMIDIFICATION_SETPOINT) {
          uic_mqtt_dotdot_dehumidification_control_rh_dehumidification_setpoint_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_MODE) {
          uic_mqtt_dotdot_dehumidification_control_relative_humidity_mode_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_LOCKOUT) {
          uic_mqtt_dotdot_dehumidification_control_dehumidification_lockout_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_HYSTERESIS) {
          uic_mqtt_dotdot_dehumidification_control_dehumidification_hysteresis_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_MAX_COOL) {
          uic_mqtt_dotdot_dehumidification_control_dehumidification_max_cool_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_DISPLAY) {
          uic_mqtt_dotdot_dehumidification_control_relative_humidity_display_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void dehumidification_control_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/DehumidificationControl/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_dehumidification_control_publish_cluster_revision(base_topic.c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_dehumidification_control_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/DehumidificationControl";
      sl_log_debug(LOG_TAG, "No more attributes supported for DehumidificationControl cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the ThermostatUserInterfaceConfiguration cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void thermostat_user_interface_configuration_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_TEMPERATURE_DISPLAY_MODE) {
          uic_mqtt_dotdot_thermostat_user_interface_configuration_temperature_display_mode_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_KEYPAD_LOCKOUT) {
          uic_mqtt_dotdot_thermostat_user_interface_configuration_keypad_lockout_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_SCHEDULE_PROGRAMMING_VISIBILITY) {
          uic_mqtt_dotdot_thermostat_user_interface_configuration_schedule_programming_visibility_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the ThermostatUserInterfaceConfiguration cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void thermostat_user_interface_configuration_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_TEMPERATURE_DISPLAY_MODE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ThermostatUserInterfaceConfiguration::TemperatureDisplayMode under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_user_interface_configuration_temperature_display_mode_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_KEYPAD_LOCKOUT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ThermostatUserInterfaceConfiguration::KeypadLockout under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_user_interface_configuration_keypad_lockout_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_SCHEDULE_PROGRAMMING_VISIBILITY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ThermostatUserInterfaceConfiguration::ScheduleProgrammingVisibility under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_thermostat_user_interface_configuration_schedule_programming_visibility_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_TEMPERATURE_DISPLAY_MODE) {
          uic_mqtt_dotdot_thermostat_user_interface_configuration_temperature_display_mode_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_KEYPAD_LOCKOUT) {
          uic_mqtt_dotdot_thermostat_user_interface_configuration_keypad_lockout_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_SCHEDULE_PROGRAMMING_VISIBILITY) {
          uic_mqtt_dotdot_thermostat_user_interface_configuration_schedule_programming_visibility_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void thermostat_user_interface_configuration_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/ThermostatUserInterfaceConfiguration/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_thermostat_user_interface_configuration_publish_cluster_revision(base_topic.c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_thermostat_user_interface_configuration_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/ThermostatUserInterfaceConfiguration";
      sl_log_debug(LOG_TAG, "No more attributes supported for ThermostatUserInterfaceConfiguration cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the ColorControl cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void color_control_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENT_HUE) {
          uic_mqtt_dotdot_color_control_current_hue_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENT_SATURATION) {
          uic_mqtt_dotdot_color_control_current_saturation_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_REMAINING_TIME) {
          uic_mqtt_dotdot_color_control_remaining_time_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENTX) {
          uic_mqtt_dotdot_color_control_currentx_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENTY) {
          uic_mqtt_dotdot_color_control_currenty_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_DRIFT_COMPENSATION) {
          uic_mqtt_dotdot_color_control_drift_compensation_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COMPENSATION_TEXT) {
          std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
          uic_mqtt_dotdot_color_control_compensation_text_publish(
            base_topic.c_str(),
            static_cast<const char*>(str_desired.data()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMPERATURE_MIREDS) {
          uic_mqtt_dotdot_color_control_color_temperature_mireds_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_MODE) {
          uic_mqtt_dotdot_color_control_color_mode_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_OPTIONS) {
          uic_mqtt_dotdot_color_control_options_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_NUMBER_OF_PRIMARIES) {
          uic_mqtt_dotdot_color_control_number_of_primaries_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1X) {
          uic_mqtt_dotdot_color_control_primary1x_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1Y) {
          uic_mqtt_dotdot_color_control_primary1y_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1_INTENSITY) {
          uic_mqtt_dotdot_color_control_primary1_intensity_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2X) {
          uic_mqtt_dotdot_color_control_primary2x_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2Y) {
          uic_mqtt_dotdot_color_control_primary2y_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2_INTENSITY) {
          uic_mqtt_dotdot_color_control_primary2_intensity_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3X) {
          uic_mqtt_dotdot_color_control_primary3x_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3Y) {
          uic_mqtt_dotdot_color_control_primary3y_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3_INTENSITY) {
          uic_mqtt_dotdot_color_control_primary3_intensity_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4X) {
          uic_mqtt_dotdot_color_control_primary4x_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4Y) {
          uic_mqtt_dotdot_color_control_primary4y_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4_INTENSITY) {
          uic_mqtt_dotdot_color_control_primary4_intensity_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5X) {
          uic_mqtt_dotdot_color_control_primary5x_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5Y) {
          uic_mqtt_dotdot_color_control_primary5y_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5_INTENSITY) {
          uic_mqtt_dotdot_color_control_primary5_intensity_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6X) {
          uic_mqtt_dotdot_color_control_primary6x_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6Y) {
          uic_mqtt_dotdot_color_control_primary6y_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6_INTENSITY) {
          uic_mqtt_dotdot_color_control_primary6_intensity_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_WHITE_POINTX) {
          uic_mqtt_dotdot_color_control_white_pointx_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_WHITE_POINTY) {
          uic_mqtt_dotdot_color_control_white_pointy_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTRX) {
          uic_mqtt_dotdot_color_control_color_pointrx_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTRY) {
          uic_mqtt_dotdot_color_control_color_pointry_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTR_INTENSITY) {
          uic_mqtt_dotdot_color_control_color_pointr_intensity_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTGX) {
          uic_mqtt_dotdot_color_control_color_pointgx_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTGY) {
          uic_mqtt_dotdot_color_control_color_pointgy_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTG_INTENSITY) {
          uic_mqtt_dotdot_color_control_color_pointg_intensity_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTBX) {
          uic_mqtt_dotdot_color_control_color_pointbx_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTBY) {
          uic_mqtt_dotdot_color_control_color_pointby_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTB_INTENSITY) {
          uic_mqtt_dotdot_color_control_color_pointb_intensity_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_ENHANCED_CURRENT_HUE) {
          uic_mqtt_dotdot_color_control_enhanced_current_hue_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_ENHANCED_COLOR_MODE) {
          uic_mqtt_dotdot_color_control_enhanced_color_mode_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_ACTIVE) {
          uic_mqtt_dotdot_color_control_color_loop_active_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_DIRECTION) {
          uic_mqtt_dotdot_color_control_color_loop_direction_publish(
            base_topic.c_str(),
            static_cast<CCColorLoopDirection>(attr.desired_or_reported<CCColorLoopDirection>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_TIME) {
          uic_mqtt_dotdot_color_control_color_loop_time_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_START_ENHANCED_HUE) {
          uic_mqtt_dotdot_color_control_color_loop_start_enhanced_hue_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_STORED_ENHANCED_HUE) {
          uic_mqtt_dotdot_color_control_color_loop_stored_enhanced_hue_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_CAPABILITIES) {
          uic_mqtt_dotdot_color_control_color_capabilities_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMP_PHYSICAL_MIN_MIREDS) {
          uic_mqtt_dotdot_color_control_color_temp_physical_min_mireds_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMP_PHYSICAL_MAX_MIREDS) {
          uic_mqtt_dotdot_color_control_color_temp_physical_max_mireds_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COUPLE_COLOR_TEMP_TO_LEVEL_MIN_MIREDS) {
          uic_mqtt_dotdot_color_control_couple_color_temp_to_level_min_mireds_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_START_UP_COLOR_TEMPERATURE_MIREDS) {
          uic_mqtt_dotdot_color_control_start_up_color_temperature_mireds_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the ColorControl cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void color_control_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENT_HUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::CurrentHue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_current_hue_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENT_SATURATION:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::CurrentSaturation under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_current_saturation_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_REMAINING_TIME:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::RemainingTime under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_remaining_time_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENTX:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::CurrentX under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_currentx_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENTY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::CurrentY under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_currenty_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_DRIFT_COMPENSATION:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::DriftCompensation under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_drift_compensation_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COMPENSATION_TEXT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::CompensationText under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_compensation_text_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMPERATURE_MIREDS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::ColorTemperatureMireds under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_color_temperature_mireds_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_MODE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::ColorMode under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_color_mode_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_OPTIONS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::Options under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_options_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_NUMBER_OF_PRIMARIES:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::NumberOfPrimaries under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_number_of_primaries_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1X:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::Primary1X under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_primary1x_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1Y:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::Primary1Y under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_primary1y_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1_INTENSITY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::Primary1Intensity under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_primary1_intensity_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2X:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::Primary2X under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_primary2x_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2Y:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::Primary2Y under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_primary2y_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2_INTENSITY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::Primary2Intensity under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_primary2_intensity_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3X:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::Primary3X under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_primary3x_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3Y:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::Primary3Y under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_primary3y_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3_INTENSITY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::Primary3Intensity under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_primary3_intensity_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4X:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::Primary4X under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_primary4x_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4Y:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::Primary4Y under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_primary4y_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4_INTENSITY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::Primary4Intensity under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_primary4_intensity_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5X:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::Primary5X under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_primary5x_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5Y:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::Primary5Y under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_primary5y_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5_INTENSITY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::Primary5Intensity under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_primary5_intensity_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6X:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::Primary6X under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_primary6x_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6Y:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::Primary6Y under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_primary6y_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6_INTENSITY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::Primary6Intensity under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_primary6_intensity_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_WHITE_POINTX:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::WhitePointX under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_white_pointx_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_WHITE_POINTY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::WhitePointY under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_white_pointy_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTRX:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::ColorPointRX under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_color_pointrx_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTRY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::ColorPointRY under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_color_pointry_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTR_INTENSITY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::ColorPointRIntensity under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_color_pointr_intensity_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTGX:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::ColorPointGX under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_color_pointgx_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTGY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::ColorPointGY under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_color_pointgy_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTG_INTENSITY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::ColorPointGIntensity under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_color_pointg_intensity_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTBX:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::ColorPointBX under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_color_pointbx_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTBY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::ColorPointBY under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_color_pointby_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTB_INTENSITY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::ColorPointBIntensity under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_color_pointb_intensity_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_ENHANCED_CURRENT_HUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::EnhancedCurrentHue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_enhanced_current_hue_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_ENHANCED_COLOR_MODE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::EnhancedColorMode under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_enhanced_color_mode_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_ACTIVE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::ColorLoopActive under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_color_loop_active_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_DIRECTION:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::ColorLoopDirection under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_color_loop_direction_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_TIME:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::ColorLoopTime under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_color_loop_time_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_START_ENHANCED_HUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::ColorLoopStartEnhancedHue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_color_loop_start_enhanced_hue_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_STORED_ENHANCED_HUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::ColorLoopStoredEnhancedHue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_color_loop_stored_enhanced_hue_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_CAPABILITIES:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::ColorCapabilities under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_color_capabilities_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMP_PHYSICAL_MIN_MIREDS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::ColorTempPhysicalMinMireds under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_color_temp_physical_min_mireds_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMP_PHYSICAL_MAX_MIREDS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::ColorTempPhysicalMaxMireds under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_color_temp_physical_max_mireds_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COUPLE_COLOR_TEMP_TO_LEVEL_MIN_MIREDS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::CoupleColorTempToLevelMinMireds under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_couple_color_temp_to_level_min_mireds_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_START_UP_COLOR_TEMPERATURE_MIREDS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ColorControl::StartUpColorTemperatureMireds under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_color_control_start_up_color_temperature_mireds_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENT_HUE) {
          uic_mqtt_dotdot_color_control_current_hue_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENT_SATURATION) {
          uic_mqtt_dotdot_color_control_current_saturation_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_REMAINING_TIME) {
          uic_mqtt_dotdot_color_control_remaining_time_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENTX) {
          uic_mqtt_dotdot_color_control_currentx_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENTY) {
          uic_mqtt_dotdot_color_control_currenty_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_DRIFT_COMPENSATION) {
          uic_mqtt_dotdot_color_control_drift_compensation_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COMPENSATION_TEXT) {
          std::vector<char> str_desired = attr.reported<std::vector<char>>();
          uic_mqtt_dotdot_color_control_compensation_text_publish(
            base_topic.c_str(),
            static_cast<const char*>( str_desired.data() ),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMPERATURE_MIREDS) {
          uic_mqtt_dotdot_color_control_color_temperature_mireds_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_MODE) {
          uic_mqtt_dotdot_color_control_color_mode_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_OPTIONS) {
          uic_mqtt_dotdot_color_control_options_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_NUMBER_OF_PRIMARIES) {
          uic_mqtt_dotdot_color_control_number_of_primaries_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1X) {
          uic_mqtt_dotdot_color_control_primary1x_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1Y) {
          uic_mqtt_dotdot_color_control_primary1y_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1_INTENSITY) {
          uic_mqtt_dotdot_color_control_primary1_intensity_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2X) {
          uic_mqtt_dotdot_color_control_primary2x_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2Y) {
          uic_mqtt_dotdot_color_control_primary2y_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2_INTENSITY) {
          uic_mqtt_dotdot_color_control_primary2_intensity_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3X) {
          uic_mqtt_dotdot_color_control_primary3x_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3Y) {
          uic_mqtt_dotdot_color_control_primary3y_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3_INTENSITY) {
          uic_mqtt_dotdot_color_control_primary3_intensity_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4X) {
          uic_mqtt_dotdot_color_control_primary4x_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4Y) {
          uic_mqtt_dotdot_color_control_primary4y_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4_INTENSITY) {
          uic_mqtt_dotdot_color_control_primary4_intensity_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5X) {
          uic_mqtt_dotdot_color_control_primary5x_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5Y) {
          uic_mqtt_dotdot_color_control_primary5y_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5_INTENSITY) {
          uic_mqtt_dotdot_color_control_primary5_intensity_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6X) {
          uic_mqtt_dotdot_color_control_primary6x_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6Y) {
          uic_mqtt_dotdot_color_control_primary6y_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6_INTENSITY) {
          uic_mqtt_dotdot_color_control_primary6_intensity_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_WHITE_POINTX) {
          uic_mqtt_dotdot_color_control_white_pointx_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_WHITE_POINTY) {
          uic_mqtt_dotdot_color_control_white_pointy_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTRX) {
          uic_mqtt_dotdot_color_control_color_pointrx_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTRY) {
          uic_mqtt_dotdot_color_control_color_pointry_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTR_INTENSITY) {
          uic_mqtt_dotdot_color_control_color_pointr_intensity_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTGX) {
          uic_mqtt_dotdot_color_control_color_pointgx_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTGY) {
          uic_mqtt_dotdot_color_control_color_pointgy_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTG_INTENSITY) {
          uic_mqtt_dotdot_color_control_color_pointg_intensity_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTBX) {
          uic_mqtt_dotdot_color_control_color_pointbx_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTBY) {
          uic_mqtt_dotdot_color_control_color_pointby_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTB_INTENSITY) {
          uic_mqtt_dotdot_color_control_color_pointb_intensity_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_ENHANCED_CURRENT_HUE) {
          uic_mqtt_dotdot_color_control_enhanced_current_hue_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_ENHANCED_COLOR_MODE) {
          uic_mqtt_dotdot_color_control_enhanced_color_mode_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_ACTIVE) {
          uic_mqtt_dotdot_color_control_color_loop_active_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_DIRECTION) {
          uic_mqtt_dotdot_color_control_color_loop_direction_publish(
            base_topic.c_str(),
            static_cast<CCColorLoopDirection>(attr.reported<CCColorLoopDirection>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_TIME) {
          uic_mqtt_dotdot_color_control_color_loop_time_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_START_ENHANCED_HUE) {
          uic_mqtt_dotdot_color_control_color_loop_start_enhanced_hue_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_STORED_ENHANCED_HUE) {
          uic_mqtt_dotdot_color_control_color_loop_stored_enhanced_hue_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_CAPABILITIES) {
          uic_mqtt_dotdot_color_control_color_capabilities_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMP_PHYSICAL_MIN_MIREDS) {
          uic_mqtt_dotdot_color_control_color_temp_physical_min_mireds_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMP_PHYSICAL_MAX_MIREDS) {
          uic_mqtt_dotdot_color_control_color_temp_physical_max_mireds_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COUPLE_COLOR_TEMP_TO_LEVEL_MIN_MIREDS) {
          uic_mqtt_dotdot_color_control_couple_color_temp_to_level_min_mireds_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_START_UP_COLOR_TEMPERATURE_MIREDS) {
          uic_mqtt_dotdot_color_control_start_up_color_temperature_mireds_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void color_control_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/ColorControl/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_color_control_publish_cluster_revision(base_topic.c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_color_control_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/ColorControl";
      sl_log_debug(LOG_TAG, "No more attributes supported for ColorControl cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the BallastConfiguration cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void ballast_configuration_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_PHYSICAL_MIN_LEVEL) {
          uic_mqtt_dotdot_ballast_configuration_physical_min_level_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_PHYSICAL_MAX_LEVEL) {
          uic_mqtt_dotdot_ballast_configuration_physical_max_level_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_BALLAST_STATUS) {
          uic_mqtt_dotdot_ballast_configuration_ballast_status_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_MIN_LEVEL) {
          uic_mqtt_dotdot_ballast_configuration_min_level_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_MAX_LEVEL) {
          uic_mqtt_dotdot_ballast_configuration_max_level_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_POWER_ON_LEVEL) {
          uic_mqtt_dotdot_ballast_configuration_power_on_level_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_POWER_ON_FADE_TIME) {
          uic_mqtt_dotdot_ballast_configuration_power_on_fade_time_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_INTRINSIC_BALLAST_FACTOR) {
          uic_mqtt_dotdot_ballast_configuration_intrinsic_ballast_factor_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_BALLAST_FACTOR_ADJUSTMENT) {
          uic_mqtt_dotdot_ballast_configuration_ballast_factor_adjustment_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_QUANTITY) {
          uic_mqtt_dotdot_ballast_configuration_lamp_quantity_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_TYPE) {
          std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
          uic_mqtt_dotdot_ballast_configuration_lamp_type_publish(
            base_topic.c_str(),
            static_cast<const char*>(str_desired.data()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_MANUFACTURER) {
          std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
          uic_mqtt_dotdot_ballast_configuration_lamp_manufacturer_publish(
            base_topic.c_str(),
            static_cast<const char*>(str_desired.data()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_RATED_HOURS) {
          uic_mqtt_dotdot_ballast_configuration_lamp_rated_hours_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_BURN_HOURS) {
          uic_mqtt_dotdot_ballast_configuration_lamp_burn_hours_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_ALARM_MODE) {
          uic_mqtt_dotdot_ballast_configuration_lamp_alarm_mode_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_BURN_HOURS_TRIP_POINT) {
          uic_mqtt_dotdot_ballast_configuration_lamp_burn_hours_trip_point_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the BallastConfiguration cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void ballast_configuration_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_PHYSICAL_MIN_LEVEL:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining BallastConfiguration::PhysicalMinLevel under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_ballast_configuration_physical_min_level_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_PHYSICAL_MAX_LEVEL:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining BallastConfiguration::PhysicalMaxLevel under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_ballast_configuration_physical_max_level_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_BALLAST_STATUS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining BallastConfiguration::BallastStatus under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_ballast_configuration_ballast_status_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_MIN_LEVEL:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining BallastConfiguration::MinLevel under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_ballast_configuration_min_level_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_MAX_LEVEL:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining BallastConfiguration::MaxLevel under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_ballast_configuration_max_level_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_POWER_ON_LEVEL:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining BallastConfiguration::PowerOnLevel under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_ballast_configuration_power_on_level_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_POWER_ON_FADE_TIME:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining BallastConfiguration::PowerOnFadeTime under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_ballast_configuration_power_on_fade_time_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_INTRINSIC_BALLAST_FACTOR:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining BallastConfiguration::IntrinsicBallastFactor under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_ballast_configuration_intrinsic_ballast_factor_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_BALLAST_FACTOR_ADJUSTMENT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining BallastConfiguration::BallastFactorAdjustment under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_ballast_configuration_ballast_factor_adjustment_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_QUANTITY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining BallastConfiguration::LampQuantity under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_ballast_configuration_lamp_quantity_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_TYPE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining BallastConfiguration::LampType under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_ballast_configuration_lamp_type_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_MANUFACTURER:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining BallastConfiguration::LampManufacturer under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_ballast_configuration_lamp_manufacturer_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_RATED_HOURS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining BallastConfiguration::LampRatedHours under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_ballast_configuration_lamp_rated_hours_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_BURN_HOURS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining BallastConfiguration::LampBurnHours under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_ballast_configuration_lamp_burn_hours_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_ALARM_MODE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining BallastConfiguration::LampAlarmMode under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_ballast_configuration_lamp_alarm_mode_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_BURN_HOURS_TRIP_POINT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining BallastConfiguration::LampBurnHoursTripPoint under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_ballast_configuration_lamp_burn_hours_trip_point_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_PHYSICAL_MIN_LEVEL) {
          uic_mqtt_dotdot_ballast_configuration_physical_min_level_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_PHYSICAL_MAX_LEVEL) {
          uic_mqtt_dotdot_ballast_configuration_physical_max_level_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_BALLAST_STATUS) {
          uic_mqtt_dotdot_ballast_configuration_ballast_status_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_MIN_LEVEL) {
          uic_mqtt_dotdot_ballast_configuration_min_level_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_MAX_LEVEL) {
          uic_mqtt_dotdot_ballast_configuration_max_level_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_POWER_ON_LEVEL) {
          uic_mqtt_dotdot_ballast_configuration_power_on_level_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_POWER_ON_FADE_TIME) {
          uic_mqtt_dotdot_ballast_configuration_power_on_fade_time_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_INTRINSIC_BALLAST_FACTOR) {
          uic_mqtt_dotdot_ballast_configuration_intrinsic_ballast_factor_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_BALLAST_FACTOR_ADJUSTMENT) {
          uic_mqtt_dotdot_ballast_configuration_ballast_factor_adjustment_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_QUANTITY) {
          uic_mqtt_dotdot_ballast_configuration_lamp_quantity_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_TYPE) {
          std::vector<char> str_desired = attr.reported<std::vector<char>>();
          uic_mqtt_dotdot_ballast_configuration_lamp_type_publish(
            base_topic.c_str(),
            static_cast<const char*>( str_desired.data() ),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_MANUFACTURER) {
          std::vector<char> str_desired = attr.reported<std::vector<char>>();
          uic_mqtt_dotdot_ballast_configuration_lamp_manufacturer_publish(
            base_topic.c_str(),
            static_cast<const char*>( str_desired.data() ),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_RATED_HOURS) {
          uic_mqtt_dotdot_ballast_configuration_lamp_rated_hours_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_BURN_HOURS) {
          uic_mqtt_dotdot_ballast_configuration_lamp_burn_hours_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_ALARM_MODE) {
          uic_mqtt_dotdot_ballast_configuration_lamp_alarm_mode_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_BURN_HOURS_TRIP_POINT) {
          uic_mqtt_dotdot_ballast_configuration_lamp_burn_hours_trip_point_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void ballast_configuration_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/BallastConfiguration/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_ballast_configuration_publish_cluster_revision(base_topic.c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_ballast_configuration_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/BallastConfiguration";
      sl_log_debug(LOG_TAG, "No more attributes supported for BallastConfiguration cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the IlluminanceMeasurement cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void illuminance_measurement_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MEASURED_VALUE) {
          uic_mqtt_dotdot_illuminance_measurement_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MIN_MEASURED_VALUE) {
          uic_mqtt_dotdot_illuminance_measurement_min_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MAX_MEASURED_VALUE) {
          uic_mqtt_dotdot_illuminance_measurement_max_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_TOLERANCE) {
          uic_mqtt_dotdot_illuminance_measurement_tolerance_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_LIGHT_SENSOR_TYPE) {
          uic_mqtt_dotdot_illuminance_measurement_light_sensor_type_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the IlluminanceMeasurement cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void illuminance_measurement_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining IlluminanceMeasurement::MeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_illuminance_measurement_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MIN_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining IlluminanceMeasurement::MinMeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_illuminance_measurement_min_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MAX_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining IlluminanceMeasurement::MaxMeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_illuminance_measurement_max_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_TOLERANCE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining IlluminanceMeasurement::Tolerance under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_illuminance_measurement_tolerance_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_LIGHT_SENSOR_TYPE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining IlluminanceMeasurement::LightSensorType under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_illuminance_measurement_light_sensor_type_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MEASURED_VALUE) {
          uic_mqtt_dotdot_illuminance_measurement_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MIN_MEASURED_VALUE) {
          uic_mqtt_dotdot_illuminance_measurement_min_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MAX_MEASURED_VALUE) {
          uic_mqtt_dotdot_illuminance_measurement_max_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_TOLERANCE) {
          uic_mqtt_dotdot_illuminance_measurement_tolerance_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_LIGHT_SENSOR_TYPE) {
          uic_mqtt_dotdot_illuminance_measurement_light_sensor_type_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void illuminance_measurement_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/IlluminanceMeasurement/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_illuminance_measurement_publish_cluster_revision(base_topic.c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_illuminance_measurement_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/IlluminanceMeasurement";
      sl_log_debug(LOG_TAG, "No more attributes supported for IlluminanceMeasurement cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the IlluminanceLevelSensing cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void illuminance_level_sensing_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_LEVEL_STATUS) {
          uic_mqtt_dotdot_illuminance_level_sensing_level_status_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_LIGHT_SENSOR_TYPE) {
          uic_mqtt_dotdot_illuminance_level_sensing_light_sensor_type_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_ILLUMINANCE_TARGET_LEVEL) {
          uic_mqtt_dotdot_illuminance_level_sensing_illuminance_target_level_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the IlluminanceLevelSensing cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void illuminance_level_sensing_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_LEVEL_STATUS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining IlluminanceLevelSensing::LevelStatus under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_illuminance_level_sensing_level_status_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_LIGHT_SENSOR_TYPE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining IlluminanceLevelSensing::LightSensorType under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_illuminance_level_sensing_light_sensor_type_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_ILLUMINANCE_TARGET_LEVEL:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining IlluminanceLevelSensing::IlluminanceTargetLevel under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_illuminance_level_sensing_illuminance_target_level_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_LEVEL_STATUS) {
          uic_mqtt_dotdot_illuminance_level_sensing_level_status_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_LIGHT_SENSOR_TYPE) {
          uic_mqtt_dotdot_illuminance_level_sensing_light_sensor_type_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_ILLUMINANCE_TARGET_LEVEL) {
          uic_mqtt_dotdot_illuminance_level_sensing_illuminance_target_level_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void illuminance_level_sensing_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/IlluminanceLevelSensing/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_illuminance_level_sensing_publish_cluster_revision(base_topic.c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_illuminance_level_sensing_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/IlluminanceLevelSensing";
      sl_log_debug(LOG_TAG, "No more attributes supported for IlluminanceLevelSensing cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the TemperatureMeasurement cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void temperature_measurement_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MEASURED_VALUE) {
          uic_mqtt_dotdot_temperature_measurement_measured_value_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MIN_MEASURED_VALUE) {
          uic_mqtt_dotdot_temperature_measurement_min_measured_value_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MAX_MEASURED_VALUE) {
          uic_mqtt_dotdot_temperature_measurement_max_measured_value_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_TOLERANCE) {
          uic_mqtt_dotdot_temperature_measurement_tolerance_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the TemperatureMeasurement cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void temperature_measurement_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining TemperatureMeasurement::MeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_temperature_measurement_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MIN_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining TemperatureMeasurement::MinMeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_temperature_measurement_min_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MAX_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining TemperatureMeasurement::MaxMeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_temperature_measurement_max_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_TOLERANCE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining TemperatureMeasurement::Tolerance under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_temperature_measurement_tolerance_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MEASURED_VALUE) {
          uic_mqtt_dotdot_temperature_measurement_measured_value_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MIN_MEASURED_VALUE) {
          uic_mqtt_dotdot_temperature_measurement_min_measured_value_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MAX_MEASURED_VALUE) {
          uic_mqtt_dotdot_temperature_measurement_max_measured_value_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_TOLERANCE) {
          uic_mqtt_dotdot_temperature_measurement_tolerance_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void temperature_measurement_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/TemperatureMeasurement/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_temperature_measurement_publish_cluster_revision(base_topic.c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_temperature_measurement_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/TemperatureMeasurement";
      sl_log_debug(LOG_TAG, "No more attributes supported for TemperatureMeasurement cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the PressureMeasurement cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void pressure_measurement_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MEASURED_VALUE) {
          uic_mqtt_dotdot_pressure_measurement_measured_value_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MIN_MEASURED_VALUE) {
          uic_mqtt_dotdot_pressure_measurement_min_measured_value_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MAX_MEASURED_VALUE) {
          uic_mqtt_dotdot_pressure_measurement_max_measured_value_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_TOLERANCE) {
          uic_mqtt_dotdot_pressure_measurement_tolerance_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALED_VALUE) {
          uic_mqtt_dotdot_pressure_measurement_scaled_value_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MIN_SCALED_VALUE) {
          uic_mqtt_dotdot_pressure_measurement_min_scaled_value_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MAX_SCALED_VALUE) {
          uic_mqtt_dotdot_pressure_measurement_max_scaled_value_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALED_TOLERANCE) {
          uic_mqtt_dotdot_pressure_measurement_scaled_tolerance_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALE) {
          uic_mqtt_dotdot_pressure_measurement_scale_publish(
            base_topic.c_str(),
            static_cast<int8_t>(attr.desired_or_reported<int8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the PressureMeasurement cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void pressure_measurement_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PressureMeasurement::MeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pressure_measurement_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MIN_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PressureMeasurement::MinMeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pressure_measurement_min_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MAX_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PressureMeasurement::MaxMeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pressure_measurement_max_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_TOLERANCE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PressureMeasurement::Tolerance under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pressure_measurement_tolerance_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PressureMeasurement::ScaledValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pressure_measurement_scaled_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MIN_SCALED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PressureMeasurement::MinScaledValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pressure_measurement_min_scaled_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MAX_SCALED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PressureMeasurement::MaxScaledValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pressure_measurement_max_scaled_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALED_TOLERANCE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PressureMeasurement::ScaledTolerance under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pressure_measurement_scaled_tolerance_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PressureMeasurement::Scale under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pressure_measurement_scale_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MEASURED_VALUE) {
          uic_mqtt_dotdot_pressure_measurement_measured_value_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MIN_MEASURED_VALUE) {
          uic_mqtt_dotdot_pressure_measurement_min_measured_value_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MAX_MEASURED_VALUE) {
          uic_mqtt_dotdot_pressure_measurement_max_measured_value_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_TOLERANCE) {
          uic_mqtt_dotdot_pressure_measurement_tolerance_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALED_VALUE) {
          uic_mqtt_dotdot_pressure_measurement_scaled_value_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MIN_SCALED_VALUE) {
          uic_mqtt_dotdot_pressure_measurement_min_scaled_value_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MAX_SCALED_VALUE) {
          uic_mqtt_dotdot_pressure_measurement_max_scaled_value_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALED_TOLERANCE) {
          uic_mqtt_dotdot_pressure_measurement_scaled_tolerance_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALE) {
          uic_mqtt_dotdot_pressure_measurement_scale_publish(
            base_topic.c_str(),
            static_cast<int8_t>(attr.reported<int8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void pressure_measurement_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/PressureMeasurement/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_pressure_measurement_publish_cluster_revision(base_topic.c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_pressure_measurement_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/PressureMeasurement";
      sl_log_debug(LOG_TAG, "No more attributes supported for PressureMeasurement cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the FlowMeasurement cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void flow_measurement_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MEASURED_VALUE) {
          uic_mqtt_dotdot_flow_measurement_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MIN_MEASURED_VALUE) {
          uic_mqtt_dotdot_flow_measurement_min_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MAX_MEASURED_VALUE) {
          uic_mqtt_dotdot_flow_measurement_max_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_TOLERANCE) {
          uic_mqtt_dotdot_flow_measurement_tolerance_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the FlowMeasurement cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void flow_measurement_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining FlowMeasurement::MeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_flow_measurement_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MIN_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining FlowMeasurement::MinMeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_flow_measurement_min_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MAX_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining FlowMeasurement::MaxMeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_flow_measurement_max_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_TOLERANCE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining FlowMeasurement::Tolerance under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_flow_measurement_tolerance_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MEASURED_VALUE) {
          uic_mqtt_dotdot_flow_measurement_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MIN_MEASURED_VALUE) {
          uic_mqtt_dotdot_flow_measurement_min_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MAX_MEASURED_VALUE) {
          uic_mqtt_dotdot_flow_measurement_max_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_TOLERANCE) {
          uic_mqtt_dotdot_flow_measurement_tolerance_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void flow_measurement_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/FlowMeasurement/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_flow_measurement_publish_cluster_revision(base_topic.c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_flow_measurement_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/FlowMeasurement";
      sl_log_debug(LOG_TAG, "No more attributes supported for FlowMeasurement cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the RelativityHumidity cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void relativity_humidity_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MEASURED_VALUE) {
          uic_mqtt_dotdot_relativity_humidity_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MIN_MEASURED_VALUE) {
          uic_mqtt_dotdot_relativity_humidity_min_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MAX_MEASURED_VALUE) {
          uic_mqtt_dotdot_relativity_humidity_max_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_TOLERANCE) {
          uic_mqtt_dotdot_relativity_humidity_tolerance_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the RelativityHumidity cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void relativity_humidity_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining RelativityHumidity::MeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_relativity_humidity_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MIN_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining RelativityHumidity::MinMeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_relativity_humidity_min_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MAX_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining RelativityHumidity::MaxMeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_relativity_humidity_max_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_TOLERANCE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining RelativityHumidity::Tolerance under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_relativity_humidity_tolerance_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MEASURED_VALUE) {
          uic_mqtt_dotdot_relativity_humidity_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MIN_MEASURED_VALUE) {
          uic_mqtt_dotdot_relativity_humidity_min_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MAX_MEASURED_VALUE) {
          uic_mqtt_dotdot_relativity_humidity_max_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_TOLERANCE) {
          uic_mqtt_dotdot_relativity_humidity_tolerance_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void relativity_humidity_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/RelativityHumidity/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_relativity_humidity_publish_cluster_revision(base_topic.c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_relativity_humidity_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/RelativityHumidity";
      sl_log_debug(LOG_TAG, "No more attributes supported for RelativityHumidity cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the OccupancySensing cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void occupancy_sensing_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY) {
          uic_mqtt_dotdot_occupancy_sensing_occupancy_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY_SENSOR_TYPE) {
          uic_mqtt_dotdot_occupancy_sensing_occupancy_sensor_type_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY_SENSOR_TYPE_BITMAP) {
          uic_mqtt_dotdot_occupancy_sensing_occupancy_sensor_type_bitmap_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_OCCUPIED_TO_UNOCCUPIED_DELAY) {
          uic_mqtt_dotdot_occupancy_sensing_pir_occupied_to_unoccupied_delay_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_UNOCCUPIED_TO_OCCUPIED_DELAY) {
          uic_mqtt_dotdot_occupancy_sensing_pir_unoccupied_to_occupied_delay_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_UNOCCUPIED_TO_OCCUPIED_THRESHOLD) {
          uic_mqtt_dotdot_occupancy_sensing_pir_unoccupied_to_occupied_threshold_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_OCCUPIED_TO_UNOCCUPIED_DELAY) {
          uic_mqtt_dotdot_occupancy_sensing_ultrasonic_occupied_to_unoccupied_delay_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_DELAY) {
          uic_mqtt_dotdot_occupancy_sensing_ultrasonic_unoccupied_to_occupied_delay_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_THRESHOLD) {
          uic_mqtt_dotdot_occupancy_sensing_ultrasonic_unoccupied_to_occupied_threshold_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_OCCUPIED_TO_UNOCCUPIED_DELAY) {
          uic_mqtt_dotdot_occupancy_sensing_physical_contact_occupied_to_unoccupied_delay_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_DELAY) {
          uic_mqtt_dotdot_occupancy_sensing_physical_contact_unoccupied_to_occupied_delay_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_THRESHOLD) {
          uic_mqtt_dotdot_occupancy_sensing_physical_contact_unoccupied_to_occupied_threshold_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the OccupancySensing cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void occupancy_sensing_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining OccupancySensing::Occupancy under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_occupancy_sensing_occupancy_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY_SENSOR_TYPE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining OccupancySensing::OccupancySensorType under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_occupancy_sensing_occupancy_sensor_type_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY_SENSOR_TYPE_BITMAP:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining OccupancySensing::OccupancySensorTypeBitmap under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_occupancy_sensing_occupancy_sensor_type_bitmap_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_OCCUPIED_TO_UNOCCUPIED_DELAY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining OccupancySensing::PIROccupiedToUnoccupiedDelay under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_occupancy_sensing_pir_occupied_to_unoccupied_delay_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_UNOCCUPIED_TO_OCCUPIED_DELAY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining OccupancySensing::PIRUnoccupiedToOccupiedDelay under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_occupancy_sensing_pir_unoccupied_to_occupied_delay_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_UNOCCUPIED_TO_OCCUPIED_THRESHOLD:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining OccupancySensing::PIRUnoccupiedToOccupiedThreshold under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_occupancy_sensing_pir_unoccupied_to_occupied_threshold_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_OCCUPIED_TO_UNOCCUPIED_DELAY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining OccupancySensing::UltrasonicOccupiedToUnoccupiedDelay under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_occupancy_sensing_ultrasonic_occupied_to_unoccupied_delay_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_DELAY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining OccupancySensing::UltrasonicUnoccupiedToOccupiedDelay under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_occupancy_sensing_ultrasonic_unoccupied_to_occupied_delay_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_THRESHOLD:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining OccupancySensing::UltrasonicUnoccupiedToOccupiedThreshold under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_occupancy_sensing_ultrasonic_unoccupied_to_occupied_threshold_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_OCCUPIED_TO_UNOCCUPIED_DELAY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining OccupancySensing::PhysicalContactOccupiedToUnoccupiedDelay under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_occupancy_sensing_physical_contact_occupied_to_unoccupied_delay_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_DELAY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining OccupancySensing::PhysicalContactUnoccupiedToOccupiedDelay under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_occupancy_sensing_physical_contact_unoccupied_to_occupied_delay_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_THRESHOLD:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining OccupancySensing::PhysicalContactUnoccupiedToOccupiedThreshold under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_occupancy_sensing_physical_contact_unoccupied_to_occupied_threshold_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY) {
          uic_mqtt_dotdot_occupancy_sensing_occupancy_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY_SENSOR_TYPE) {
          uic_mqtt_dotdot_occupancy_sensing_occupancy_sensor_type_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY_SENSOR_TYPE_BITMAP) {
          uic_mqtt_dotdot_occupancy_sensing_occupancy_sensor_type_bitmap_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_OCCUPIED_TO_UNOCCUPIED_DELAY) {
          uic_mqtt_dotdot_occupancy_sensing_pir_occupied_to_unoccupied_delay_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_UNOCCUPIED_TO_OCCUPIED_DELAY) {
          uic_mqtt_dotdot_occupancy_sensing_pir_unoccupied_to_occupied_delay_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_UNOCCUPIED_TO_OCCUPIED_THRESHOLD) {
          uic_mqtt_dotdot_occupancy_sensing_pir_unoccupied_to_occupied_threshold_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_OCCUPIED_TO_UNOCCUPIED_DELAY) {
          uic_mqtt_dotdot_occupancy_sensing_ultrasonic_occupied_to_unoccupied_delay_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_DELAY) {
          uic_mqtt_dotdot_occupancy_sensing_ultrasonic_unoccupied_to_occupied_delay_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_THRESHOLD) {
          uic_mqtt_dotdot_occupancy_sensing_ultrasonic_unoccupied_to_occupied_threshold_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_OCCUPIED_TO_UNOCCUPIED_DELAY) {
          uic_mqtt_dotdot_occupancy_sensing_physical_contact_occupied_to_unoccupied_delay_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_DELAY) {
          uic_mqtt_dotdot_occupancy_sensing_physical_contact_unoccupied_to_occupied_delay_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_THRESHOLD) {
          uic_mqtt_dotdot_occupancy_sensing_physical_contact_unoccupied_to_occupied_threshold_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void occupancy_sensing_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/OccupancySensing/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_occupancy_sensing_publish_cluster_revision(base_topic.c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_occupancy_sensing_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/OccupancySensing";
      sl_log_debug(LOG_TAG, "No more attributes supported for OccupancySensing cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the SoilMoisture cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void soil_moisture_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_SOIL_MOISTURE_MEASURED_VALUE) {
          uic_mqtt_dotdot_soil_moisture_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SOIL_MOISTURE_MIN_MEASURED_VALUE) {
          uic_mqtt_dotdot_soil_moisture_min_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SOIL_MOISTURE_MAX_MEASURED_VALUE) {
          uic_mqtt_dotdot_soil_moisture_max_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SOIL_MOISTURE_TOLERANCE) {
          uic_mqtt_dotdot_soil_moisture_tolerance_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the SoilMoisture cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void soil_moisture_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_SOIL_MOISTURE_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining SoilMoisture::MeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_soil_moisture_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SOIL_MOISTURE_MIN_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining SoilMoisture::MinMeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_soil_moisture_min_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SOIL_MOISTURE_MAX_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining SoilMoisture::MaxMeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_soil_moisture_max_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SOIL_MOISTURE_TOLERANCE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining SoilMoisture::Tolerance under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_soil_moisture_tolerance_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_SOIL_MOISTURE_MEASURED_VALUE) {
          uic_mqtt_dotdot_soil_moisture_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SOIL_MOISTURE_MIN_MEASURED_VALUE) {
          uic_mqtt_dotdot_soil_moisture_min_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SOIL_MOISTURE_MAX_MEASURED_VALUE) {
          uic_mqtt_dotdot_soil_moisture_max_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SOIL_MOISTURE_TOLERANCE) {
          uic_mqtt_dotdot_soil_moisture_tolerance_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void soil_moisture_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/SoilMoisture/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_soil_moisture_publish_cluster_revision(base_topic.c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_soil_moisture_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/SoilMoisture";
      sl_log_debug(LOG_TAG, "No more attributes supported for SoilMoisture cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the PhMeasurement cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void ph_measurement_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MEASURED_VALUE) {
          uic_mqtt_dotdot_ph_measurement_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MIN_MEASURED_VALUE) {
          uic_mqtt_dotdot_ph_measurement_min_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MAX_MEASURED_VALUE) {
          uic_mqtt_dotdot_ph_measurement_max_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_TOLERANCE) {
          uic_mqtt_dotdot_ph_measurement_tolerance_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the PhMeasurement cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void ph_measurement_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PhMeasurement::MeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_ph_measurement_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MIN_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PhMeasurement::MinMeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_ph_measurement_min_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MAX_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PhMeasurement::MaxMeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_ph_measurement_max_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_TOLERANCE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PhMeasurement::Tolerance under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_ph_measurement_tolerance_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MEASURED_VALUE) {
          uic_mqtt_dotdot_ph_measurement_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MIN_MEASURED_VALUE) {
          uic_mqtt_dotdot_ph_measurement_min_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MAX_MEASURED_VALUE) {
          uic_mqtt_dotdot_ph_measurement_max_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_TOLERANCE) {
          uic_mqtt_dotdot_ph_measurement_tolerance_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void ph_measurement_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/PhMeasurement/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_ph_measurement_publish_cluster_revision(base_topic.c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_ph_measurement_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/PhMeasurement";
      sl_log_debug(LOG_TAG, "No more attributes supported for PhMeasurement cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the ElectricalConductivityMeasurement cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void electrical_conductivity_measurement_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MEASURED_VALUE) {
          uic_mqtt_dotdot_electrical_conductivity_measurement_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MIN_MEASURED_VALUE) {
          uic_mqtt_dotdot_electrical_conductivity_measurement_min_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MAX_MEASURED_VALUE) {
          uic_mqtt_dotdot_electrical_conductivity_measurement_max_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_TOLERANCE) {
          uic_mqtt_dotdot_electrical_conductivity_measurement_tolerance_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the ElectricalConductivityMeasurement cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void electrical_conductivity_measurement_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalConductivityMeasurement::MeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_conductivity_measurement_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MIN_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalConductivityMeasurement::MinMeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_conductivity_measurement_min_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MAX_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalConductivityMeasurement::MaxMeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_conductivity_measurement_max_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_TOLERANCE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalConductivityMeasurement::Tolerance under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_conductivity_measurement_tolerance_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MEASURED_VALUE) {
          uic_mqtt_dotdot_electrical_conductivity_measurement_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MIN_MEASURED_VALUE) {
          uic_mqtt_dotdot_electrical_conductivity_measurement_min_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MAX_MEASURED_VALUE) {
          uic_mqtt_dotdot_electrical_conductivity_measurement_max_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_TOLERANCE) {
          uic_mqtt_dotdot_electrical_conductivity_measurement_tolerance_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void electrical_conductivity_measurement_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/ElectricalConductivityMeasurement/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_electrical_conductivity_measurement_publish_cluster_revision(base_topic.c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_electrical_conductivity_measurement_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/ElectricalConductivityMeasurement";
      sl_log_debug(LOG_TAG, "No more attributes supported for ElectricalConductivityMeasurement cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the WindSpeedMeasurement cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void wind_speed_measurement_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MEASURED_VALUE) {
          uic_mqtt_dotdot_wind_speed_measurement_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MIN_MEASURED_VALUE) {
          uic_mqtt_dotdot_wind_speed_measurement_min_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MAX_MEASURED_VALUE) {
          uic_mqtt_dotdot_wind_speed_measurement_max_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_TOLERANCE) {
          uic_mqtt_dotdot_wind_speed_measurement_tolerance_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the WindSpeedMeasurement cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void wind_speed_measurement_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining WindSpeedMeasurement::MeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_wind_speed_measurement_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MIN_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining WindSpeedMeasurement::MinMeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_wind_speed_measurement_min_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MAX_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining WindSpeedMeasurement::MaxMeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_wind_speed_measurement_max_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_TOLERANCE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining WindSpeedMeasurement::Tolerance under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_wind_speed_measurement_tolerance_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MEASURED_VALUE) {
          uic_mqtt_dotdot_wind_speed_measurement_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MIN_MEASURED_VALUE) {
          uic_mqtt_dotdot_wind_speed_measurement_min_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MAX_MEASURED_VALUE) {
          uic_mqtt_dotdot_wind_speed_measurement_max_measured_value_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_TOLERANCE) {
          uic_mqtt_dotdot_wind_speed_measurement_tolerance_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void wind_speed_measurement_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/WindSpeedMeasurement/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_wind_speed_measurement_publish_cluster_revision(base_topic.c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_wind_speed_measurement_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/WindSpeedMeasurement";
      sl_log_debug(LOG_TAG, "No more attributes supported for WindSpeedMeasurement cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the CarbonMonoxide cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void carbon_monoxide_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MEASURED_VALUE) {
          uic_mqtt_dotdot_carbon_monoxide_measured_value_publish(
            base_topic.c_str(),
            static_cast<float>(attr.desired_or_reported<float>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MIN_MEASURED_VALUE) {
          uic_mqtt_dotdot_carbon_monoxide_min_measured_value_publish(
            base_topic.c_str(),
            static_cast<float>(attr.desired_or_reported<float>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MAX_MEASURED_VALUE) {
          uic_mqtt_dotdot_carbon_monoxide_max_measured_value_publish(
            base_topic.c_str(),
            static_cast<float>(attr.desired_or_reported<float>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_TOLERANCE) {
          uic_mqtt_dotdot_carbon_monoxide_tolerance_publish(
            base_topic.c_str(),
            static_cast<float>(attr.desired_or_reported<float>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the CarbonMonoxide cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void carbon_monoxide_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining CarbonMonoxide::MeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_carbon_monoxide_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MIN_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining CarbonMonoxide::MinMeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_carbon_monoxide_min_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MAX_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining CarbonMonoxide::MaxMeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_carbon_monoxide_max_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_TOLERANCE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining CarbonMonoxide::Tolerance under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_carbon_monoxide_tolerance_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MEASURED_VALUE) {
          uic_mqtt_dotdot_carbon_monoxide_measured_value_publish(
            base_topic.c_str(),
            static_cast<float>(attr.reported<float>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MIN_MEASURED_VALUE) {
          uic_mqtt_dotdot_carbon_monoxide_min_measured_value_publish(
            base_topic.c_str(),
            static_cast<float>(attr.reported<float>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MAX_MEASURED_VALUE) {
          uic_mqtt_dotdot_carbon_monoxide_max_measured_value_publish(
            base_topic.c_str(),
            static_cast<float>(attr.reported<float>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_TOLERANCE) {
          uic_mqtt_dotdot_carbon_monoxide_tolerance_publish(
            base_topic.c_str(),
            static_cast<float>(attr.reported<float>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void carbon_monoxide_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/CarbonMonoxide/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_carbon_monoxide_publish_cluster_revision(base_topic.c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_carbon_monoxide_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/CarbonMonoxide";
      sl_log_debug(LOG_TAG, "No more attributes supported for CarbonMonoxide cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the CarbonDioxide cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void carbon_dioxide_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_CARBON_DIOXIDE_MEASURED_VALUE) {
          uic_mqtt_dotdot_carbon_dioxide_measured_value_publish(
            base_topic.c_str(),
            static_cast<float>(attr.desired_or_reported<float>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_CARBON_DIOXIDE_MIN_MEASURED_VALUE) {
          uic_mqtt_dotdot_carbon_dioxide_min_measured_value_publish(
            base_topic.c_str(),
            static_cast<float>(attr.desired_or_reported<float>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_CARBON_DIOXIDE_MAX_MEASURED_VALUE) {
          uic_mqtt_dotdot_carbon_dioxide_max_measured_value_publish(
            base_topic.c_str(),
            static_cast<float>(attr.desired_or_reported<float>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_CARBON_DIOXIDE_TOLERANCE) {
          uic_mqtt_dotdot_carbon_dioxide_tolerance_publish(
            base_topic.c_str(),
            static_cast<float>(attr.desired_or_reported<float>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the CarbonDioxide cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void carbon_dioxide_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_CARBON_DIOXIDE_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining CarbonDioxide::MeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_carbon_dioxide_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_CARBON_DIOXIDE_MIN_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining CarbonDioxide::MinMeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_carbon_dioxide_min_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_CARBON_DIOXIDE_MAX_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining CarbonDioxide::MaxMeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_carbon_dioxide_max_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_CARBON_DIOXIDE_TOLERANCE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining CarbonDioxide::Tolerance under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_carbon_dioxide_tolerance_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_CARBON_DIOXIDE_MEASURED_VALUE) {
          uic_mqtt_dotdot_carbon_dioxide_measured_value_publish(
            base_topic.c_str(),
            static_cast<float>(attr.reported<float>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_CARBON_DIOXIDE_MIN_MEASURED_VALUE) {
          uic_mqtt_dotdot_carbon_dioxide_min_measured_value_publish(
            base_topic.c_str(),
            static_cast<float>(attr.reported<float>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_CARBON_DIOXIDE_MAX_MEASURED_VALUE) {
          uic_mqtt_dotdot_carbon_dioxide_max_measured_value_publish(
            base_topic.c_str(),
            static_cast<float>(attr.reported<float>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_CARBON_DIOXIDE_TOLERANCE) {
          uic_mqtt_dotdot_carbon_dioxide_tolerance_publish(
            base_topic.c_str(),
            static_cast<float>(attr.reported<float>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void carbon_dioxide_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/CarbonDioxide/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_carbon_dioxide_publish_cluster_revision(base_topic.c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_carbon_dioxide_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/CarbonDioxide";
      sl_log_debug(LOG_TAG, "No more attributes supported for CarbonDioxide cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the PM25 cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void pm25_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_PM25_MEASURED_VALUE) {
          uic_mqtt_dotdot_pm25_measured_value_publish(
            base_topic.c_str(),
            static_cast<float>(attr.desired_or_reported<float>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PM25_MIN_MEASURED_VALUE) {
          uic_mqtt_dotdot_pm25_min_measured_value_publish(
            base_topic.c_str(),
            static_cast<float>(attr.desired_or_reported<float>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PM25_MAX_MEASURED_VALUE) {
          uic_mqtt_dotdot_pm25_max_measured_value_publish(
            base_topic.c_str(),
            static_cast<float>(attr.desired_or_reported<float>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PM25_TOLERANCE) {
          uic_mqtt_dotdot_pm25_tolerance_publish(
            base_topic.c_str(),
            static_cast<float>(attr.desired_or_reported<float>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the PM25 cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void pm25_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_PM25_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PM25::MeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pm25_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PM25_MIN_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PM25::MinMeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pm25_min_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PM25_MAX_MEASURED_VALUE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PM25::MaxMeasuredValue under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pm25_max_measured_value_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PM25_TOLERANCE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining PM25::Tolerance under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_pm25_tolerance_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_PM25_MEASURED_VALUE) {
          uic_mqtt_dotdot_pm25_measured_value_publish(
            base_topic.c_str(),
            static_cast<float>(attr.reported<float>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PM25_MIN_MEASURED_VALUE) {
          uic_mqtt_dotdot_pm25_min_measured_value_publish(
            base_topic.c_str(),
            static_cast<float>(attr.reported<float>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PM25_MAX_MEASURED_VALUE) {
          uic_mqtt_dotdot_pm25_max_measured_value_publish(
            base_topic.c_str(),
            static_cast<float>(attr.reported<float>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PM25_TOLERANCE) {
          uic_mqtt_dotdot_pm25_tolerance_publish(
            base_topic.c_str(),
            static_cast<float>(attr.reported<float>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void pm25_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/PM25/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_pm25_publish_cluster_revision(base_topic.c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_pm25_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/PM25";
      sl_log_debug(LOG_TAG, "No more attributes supported for PM25 cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the IASZone cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void ias_zone_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_STATE) {
          uic_mqtt_dotdot_ias_zone_zone_state_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_TYPE) {
          uic_mqtt_dotdot_ias_zone_zone_type_publish(
            base_topic.c_str(),
            static_cast<IasZoneType>(attr.desired_or_reported<IasZoneType>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_STATUS) {
          uic_mqtt_dotdot_ias_zone_zone_status_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_IAS_ZONE_IASCIE_ADDRESS) {
          uic_mqtt_dotdot_ias_zone_iascie_address_publish(
            base_topic.c_str(),
            static_cast<EUI64>(attr.desired_or_reported<EUI64>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONEID) {
          uic_mqtt_dotdot_ias_zone_zoneid_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_IAS_ZONE_NUMBER_OF_ZONE_SENSITIVITY_LEVELS_SUPPORTED) {
          uic_mqtt_dotdot_ias_zone_number_of_zone_sensitivity_levels_supported_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_IAS_ZONE_CURRENT_ZONE_SENSITIVITY_LEVEL) {
          uic_mqtt_dotdot_ias_zone_current_zone_sensitivity_level_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the IASZone cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void ias_zone_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_STATE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining IASZone::ZoneState under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_ias_zone_zone_state_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_TYPE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining IASZone::ZoneType under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_ias_zone_zone_type_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_STATUS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining IASZone::ZoneStatus under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_ias_zone_zone_status_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_IAS_ZONE_IASCIE_ADDRESS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining IASZone::IASCIEAddress under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_ias_zone_iascie_address_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONEID:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining IASZone::ZoneID under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_ias_zone_zoneid_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_IAS_ZONE_NUMBER_OF_ZONE_SENSITIVITY_LEVELS_SUPPORTED:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining IASZone::NumberOfZoneSensitivityLevelsSupported under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_ias_zone_number_of_zone_sensitivity_levels_supported_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_IAS_ZONE_CURRENT_ZONE_SENSITIVITY_LEVEL:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining IASZone::CurrentZoneSensitivityLevel under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_ias_zone_current_zone_sensitivity_level_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_STATE) {
          uic_mqtt_dotdot_ias_zone_zone_state_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_TYPE) {
          uic_mqtt_dotdot_ias_zone_zone_type_publish(
            base_topic.c_str(),
            static_cast<IasZoneType>(attr.reported<IasZoneType>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_STATUS) {
          uic_mqtt_dotdot_ias_zone_zone_status_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_IAS_ZONE_IASCIE_ADDRESS) {
          uic_mqtt_dotdot_ias_zone_iascie_address_publish(
            base_topic.c_str(),
            static_cast<EUI64>(attr.reported<EUI64>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONEID) {
          uic_mqtt_dotdot_ias_zone_zoneid_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_IAS_ZONE_NUMBER_OF_ZONE_SENSITIVITY_LEVELS_SUPPORTED) {
          uic_mqtt_dotdot_ias_zone_number_of_zone_sensitivity_levels_supported_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_IAS_ZONE_CURRENT_ZONE_SENSITIVITY_LEVEL) {
          uic_mqtt_dotdot_ias_zone_current_zone_sensitivity_level_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void ias_zone_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/IASZone/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_ias_zone_publish_cluster_revision(base_topic.c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_ias_zone_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/IASZone";
      sl_log_debug(LOG_TAG, "No more attributes supported for IASZone cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the IASWD cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void iaswd_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_IASWD_MAX_DURATION) {
          uic_mqtt_dotdot_iaswd_max_duration_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the IASWD cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void iaswd_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_IASWD_MAX_DURATION:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining IASWD::MaxDuration under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_iaswd_max_duration_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_IASWD_MAX_DURATION) {
          uic_mqtt_dotdot_iaswd_max_duration_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void iaswd_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/IASWD/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_iaswd_publish_cluster_revision(base_topic.c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_iaswd_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/IASWD";
      sl_log_debug(LOG_TAG, "No more attributes supported for IASWD cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the Metering cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void metering_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_SUMMATION_DELIVERED) {
          uic_mqtt_dotdot_metering_current_summation_delivered_publish(
            base_topic.c_str(),
            static_cast<uint64_t>(attr.desired_or_reported<uint64_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_SUMMATION_RECEIVED) {
          uic_mqtt_dotdot_metering_current_summation_received_publish(
            base_topic.c_str(),
            static_cast<uint64_t>(attr.desired_or_reported<uint64_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_DELIVERED) {
          uic_mqtt_dotdot_metering_current_max_demand_delivered_publish(
            base_topic.c_str(),
            static_cast<uint64_t>(attr.desired_or_reported<uint64_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_RECEIVED) {
          uic_mqtt_dotdot_metering_current_max_demand_received_publish(
            base_topic.c_str(),
            static_cast<int8_t>(attr.desired_or_reported<int8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_POWER_FACTOR) {
          uic_mqtt_dotdot_metering_power_factor_publish(
            base_topic.c_str(),
            static_cast<int8_t>(attr.desired_or_reported<int8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_READING_SNAP_SHOT_TIME) {
          uic_mqtt_dotdot_metering_reading_snap_shot_time_publish(
            base_topic.c_str(),
            static_cast<UTC>(attr.desired_or_reported<UTC>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_DELIVERED_TIME) {
          uic_mqtt_dotdot_metering_current_max_demand_delivered_time_publish(
            base_topic.c_str(),
            static_cast<UTC>(attr.desired_or_reported<UTC>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_RECEIVED_TIME) {
          uic_mqtt_dotdot_metering_current_max_demand_received_time_publish(
            base_topic.c_str(),
            static_cast<UTC>(attr.desired_or_reported<UTC>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_DEFAULT_UPDATE_PERIOD) {
          uic_mqtt_dotdot_metering_default_update_period_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_SUPPLY_STATUS) {
          uic_mqtt_dotdot_metering_supply_status_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_INLET_ENERGY_CARRIER_SUMMATION) {
          uic_mqtt_dotdot_metering_current_inlet_energy_carrier_summation_publish(
            base_topic.c_str(),
            static_cast<uint64_t>(attr.desired_or_reported<uint64_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_OUTLET_ENERGY_CARRIER_SUMMATION) {
          uic_mqtt_dotdot_metering_current_outlet_energy_carrier_summation_publish(
            base_topic.c_str(),
            static_cast<uint64_t>(attr.desired_or_reported<uint64_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_INLET_TEMPERATURE) {
          uic_mqtt_dotdot_metering_inlet_temperature_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_OUTLET_TEMPERATURE) {
          uic_mqtt_dotdot_metering_outlet_temperature_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_UNITOF_MEASURE) {
          uic_mqtt_dotdot_metering_unitof_measure_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_MULTIPLIER) {
          uic_mqtt_dotdot_metering_multiplier_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_DIVISOR) {
          uic_mqtt_dotdot_metering_divisor_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_SUMMATION_FORMATTING) {
          uic_mqtt_dotdot_metering_summation_formatting_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_DEMAND_FORMATTING) {
          uic_mqtt_dotdot_metering_demand_formatting_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_HISTORICAL_CONSUMPTION_FORMATTING) {
          uic_mqtt_dotdot_metering_historical_consumption_formatting_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_METERING_DEVICE_TYPE) {
          uic_mqtt_dotdot_metering_metering_device_type_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_UNIT_OF_MEASURE) {
          uic_mqtt_dotdot_metering_energy_carrier_unit_of_measure_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_SUMMATION_FORMATTING) {
          uic_mqtt_dotdot_metering_energy_carrier_summation_formatting_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_DEMAND_FORMATTING) {
          uic_mqtt_dotdot_metering_energy_carrier_demand_formatting_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_TEMPERATURE_UNIT_OF_MEASURE) {
          uic_mqtt_dotdot_metering_temperature_unit_of_measure_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_TEMPERATURE_FORMATTING) {
          uic_mqtt_dotdot_metering_temperature_formatting_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the Metering cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void metering_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_SUMMATION_DELIVERED:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Metering::CurrentSummationDelivered under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_metering_current_summation_delivered_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_SUMMATION_RECEIVED:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Metering::CurrentSummationReceived under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_metering_current_summation_received_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_DELIVERED:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Metering::CurrentMaxDemandDelivered under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_metering_current_max_demand_delivered_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_RECEIVED:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Metering::CurrentMaxDemandReceived under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_metering_current_max_demand_received_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_METERING_POWER_FACTOR:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Metering::PowerFactor under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_metering_power_factor_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_METERING_READING_SNAP_SHOT_TIME:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Metering::ReadingSnapShotTime under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_metering_reading_snap_shot_time_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_DELIVERED_TIME:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Metering::CurrentMaxDemandDeliveredTime under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_metering_current_max_demand_delivered_time_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_RECEIVED_TIME:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Metering::CurrentMaxDemandReceivedTime under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_metering_current_max_demand_received_time_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_METERING_DEFAULT_UPDATE_PERIOD:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Metering::DefaultUpdatePeriod under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_metering_default_update_period_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_METERING_SUPPLY_STATUS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Metering::SupplyStatus under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_metering_supply_status_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_INLET_ENERGY_CARRIER_SUMMATION:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Metering::CurrentInletEnergyCarrierSummation under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_metering_current_inlet_energy_carrier_summation_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_OUTLET_ENERGY_CARRIER_SUMMATION:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Metering::CurrentOutletEnergyCarrierSummation under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_metering_current_outlet_energy_carrier_summation_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_METERING_INLET_TEMPERATURE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Metering::InletTemperature under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_metering_inlet_temperature_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_METERING_OUTLET_TEMPERATURE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Metering::OutletTemperature under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_metering_outlet_temperature_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_METERING_UNITOF_MEASURE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Metering::UnitofMeasure under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_metering_unitof_measure_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_METERING_MULTIPLIER:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Metering::Multiplier under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_metering_multiplier_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_METERING_DIVISOR:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Metering::Divisor under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_metering_divisor_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_METERING_SUMMATION_FORMATTING:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Metering::SummationFormatting under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_metering_summation_formatting_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_METERING_DEMAND_FORMATTING:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Metering::DemandFormatting under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_metering_demand_formatting_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_METERING_HISTORICAL_CONSUMPTION_FORMATTING:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Metering::HistoricalConsumptionFormatting under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_metering_historical_consumption_formatting_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_METERING_METERING_DEVICE_TYPE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Metering::MeteringDeviceType under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_metering_metering_device_type_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_UNIT_OF_MEASURE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Metering::EnergyCarrierUnitOfMeasure under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_metering_energy_carrier_unit_of_measure_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_SUMMATION_FORMATTING:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Metering::EnergyCarrierSummationFormatting under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_metering_energy_carrier_summation_formatting_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_DEMAND_FORMATTING:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Metering::EnergyCarrierDemandFormatting under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_metering_energy_carrier_demand_formatting_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_METERING_TEMPERATURE_UNIT_OF_MEASURE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Metering::TemperatureUnitOfMeasure under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_metering_temperature_unit_of_measure_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_METERING_TEMPERATURE_FORMATTING:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Metering::TemperatureFormatting under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_metering_temperature_formatting_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_SUMMATION_DELIVERED) {
          uic_mqtt_dotdot_metering_current_summation_delivered_publish(
            base_topic.c_str(),
            static_cast<uint64_t>(attr.reported<uint64_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_SUMMATION_RECEIVED) {
          uic_mqtt_dotdot_metering_current_summation_received_publish(
            base_topic.c_str(),
            static_cast<uint64_t>(attr.reported<uint64_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_DELIVERED) {
          uic_mqtt_dotdot_metering_current_max_demand_delivered_publish(
            base_topic.c_str(),
            static_cast<uint64_t>(attr.reported<uint64_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_RECEIVED) {
          uic_mqtt_dotdot_metering_current_max_demand_received_publish(
            base_topic.c_str(),
            static_cast<int8_t>(attr.reported<int8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_POWER_FACTOR) {
          uic_mqtt_dotdot_metering_power_factor_publish(
            base_topic.c_str(),
            static_cast<int8_t>(attr.reported<int8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_READING_SNAP_SHOT_TIME) {
          uic_mqtt_dotdot_metering_reading_snap_shot_time_publish(
            base_topic.c_str(),
            static_cast<UTC>(attr.reported<UTC>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_DELIVERED_TIME) {
          uic_mqtt_dotdot_metering_current_max_demand_delivered_time_publish(
            base_topic.c_str(),
            static_cast<UTC>(attr.reported<UTC>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_RECEIVED_TIME) {
          uic_mqtt_dotdot_metering_current_max_demand_received_time_publish(
            base_topic.c_str(),
            static_cast<UTC>(attr.reported<UTC>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_DEFAULT_UPDATE_PERIOD) {
          uic_mqtt_dotdot_metering_default_update_period_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_SUPPLY_STATUS) {
          uic_mqtt_dotdot_metering_supply_status_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_INLET_ENERGY_CARRIER_SUMMATION) {
          uic_mqtt_dotdot_metering_current_inlet_energy_carrier_summation_publish(
            base_topic.c_str(),
            static_cast<uint64_t>(attr.reported<uint64_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_OUTLET_ENERGY_CARRIER_SUMMATION) {
          uic_mqtt_dotdot_metering_current_outlet_energy_carrier_summation_publish(
            base_topic.c_str(),
            static_cast<uint64_t>(attr.reported<uint64_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_INLET_TEMPERATURE) {
          uic_mqtt_dotdot_metering_inlet_temperature_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_OUTLET_TEMPERATURE) {
          uic_mqtt_dotdot_metering_outlet_temperature_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_UNITOF_MEASURE) {
          uic_mqtt_dotdot_metering_unitof_measure_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_MULTIPLIER) {
          uic_mqtt_dotdot_metering_multiplier_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_DIVISOR) {
          uic_mqtt_dotdot_metering_divisor_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_SUMMATION_FORMATTING) {
          uic_mqtt_dotdot_metering_summation_formatting_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_DEMAND_FORMATTING) {
          uic_mqtt_dotdot_metering_demand_formatting_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_HISTORICAL_CONSUMPTION_FORMATTING) {
          uic_mqtt_dotdot_metering_historical_consumption_formatting_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_METERING_DEVICE_TYPE) {
          uic_mqtt_dotdot_metering_metering_device_type_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_UNIT_OF_MEASURE) {
          uic_mqtt_dotdot_metering_energy_carrier_unit_of_measure_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_SUMMATION_FORMATTING) {
          uic_mqtt_dotdot_metering_energy_carrier_summation_formatting_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_DEMAND_FORMATTING) {
          uic_mqtt_dotdot_metering_energy_carrier_demand_formatting_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_TEMPERATURE_UNIT_OF_MEASURE) {
          uic_mqtt_dotdot_metering_temperature_unit_of_measure_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_METERING_TEMPERATURE_FORMATTING) {
          uic_mqtt_dotdot_metering_temperature_formatting_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void metering_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/Metering/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_metering_publish_cluster_revision(base_topic.c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_metering_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/Metering";
      sl_log_debug(LOG_TAG, "No more attributes supported for Metering cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the ElectricalMeasurement cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void electrical_measurement_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASUREMENT_TYPE) {
          uic_mqtt_dotdot_electrical_measurement_measurement_type_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE) {
          uic_mqtt_dotdot_electrical_measurement_dc_voltage_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MIN) {
          uic_mqtt_dotdot_electrical_measurement_dc_voltage_min_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MAX) {
          uic_mqtt_dotdot_electrical_measurement_dc_voltage_max_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_dc_current_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MIN) {
          uic_mqtt_dotdot_electrical_measurement_dc_current_min_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MAX) {
          uic_mqtt_dotdot_electrical_measurement_dc_current_max_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER) {
          uic_mqtt_dotdot_electrical_measurement_dc_power_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MIN) {
          uic_mqtt_dotdot_electrical_measurement_dc_power_min_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MAX) {
          uic_mqtt_dotdot_electrical_measurement_dc_power_max_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MULTIPLIER) {
          uic_mqtt_dotdot_electrical_measurement_dc_voltage_multiplier_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_DIVISOR) {
          uic_mqtt_dotdot_electrical_measurement_dc_voltage_divisor_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MULTIPLIER) {
          uic_mqtt_dotdot_electrical_measurement_dc_current_multiplier_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_DIVISOR) {
          uic_mqtt_dotdot_electrical_measurement_dc_current_divisor_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MULTIPLIER) {
          uic_mqtt_dotdot_electrical_measurement_dc_power_multiplier_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_DIVISOR) {
          uic_mqtt_dotdot_electrical_measurement_dc_power_divisor_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY) {
          uic_mqtt_dotdot_electrical_measurement_ac_frequency_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MIN) {
          uic_mqtt_dotdot_electrical_measurement_ac_frequency_min_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MAX) {
          uic_mqtt_dotdot_electrical_measurement_ac_frequency_max_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_NEUTRAL_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_neutral_current_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_ACTIVE_POWER) {
          uic_mqtt_dotdot_electrical_measurement_total_active_power_publish(
            base_topic.c_str(),
            static_cast<int32_t>(attr.desired_or_reported<int32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_REACTIVE_POWER) {
          uic_mqtt_dotdot_electrical_measurement_total_reactive_power_publish(
            base_topic.c_str(),
            static_cast<int32_t>(attr.desired_or_reported<int32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_APPARENT_POWER) {
          uic_mqtt_dotdot_electrical_measurement_total_apparent_power_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED1ST_HARMONIC_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_measured1st_harmonic_current_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED3RD_HARMONIC_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_measured3rd_harmonic_current_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED5TH_HARMONIC_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_measured5th_harmonic_current_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED7TH_HARMONIC_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_measured7th_harmonic_current_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED9TH_HARMONIC_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_measured9th_harmonic_current_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED11TH_HARMONIC_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_measured11th_harmonic_current_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE1ST_HARMONIC_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_measured_phase1st_harmonic_current_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE3RD_HARMONIC_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_measured_phase3rd_harmonic_current_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE5TH_HARMONIC_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_measured_phase5th_harmonic_current_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE7TH_HARMONIC_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_measured_phase7th_harmonic_current_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE9TH_HARMONIC_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_measured_phase9th_harmonic_current_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE11TH_HARMONIC_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_measured_phase11th_harmonic_current_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MULTIPLIER) {
          uic_mqtt_dotdot_electrical_measurement_ac_frequency_multiplier_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_DIVISOR) {
          uic_mqtt_dotdot_electrical_measurement_ac_frequency_divisor_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_MULTIPLIER) {
          uic_mqtt_dotdot_electrical_measurement_power_multiplier_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_DIVISOR) {
          uic_mqtt_dotdot_electrical_measurement_power_divisor_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_HARMONIC_CURRENT_MULTIPLIER) {
          uic_mqtt_dotdot_electrical_measurement_harmonic_current_multiplier_publish(
            base_topic.c_str(),
            static_cast<int8_t>(attr.desired_or_reported<int8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_PHASE_HARMONIC_CURRENT_MULTIPLIER) {
          uic_mqtt_dotdot_electrical_measurement_phase_harmonic_current_multiplier_publish(
            base_topic.c_str(),
            static_cast<int8_t>(attr.desired_or_reported<int8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_line_current_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_active_current_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_reactive_current_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE) {
          uic_mqtt_dotdot_electrical_measurement_rms_voltage_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN) {
          uic_mqtt_dotdot_electrical_measurement_rms_voltage_min_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX) {
          uic_mqtt_dotdot_electrical_measurement_rms_voltage_max_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_rms_current_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN) {
          uic_mqtt_dotdot_electrical_measurement_rms_current_min_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX) {
          uic_mqtt_dotdot_electrical_measurement_rms_current_max_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER) {
          uic_mqtt_dotdot_electrical_measurement_active_power_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN) {
          uic_mqtt_dotdot_electrical_measurement_active_power_min_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX) {
          uic_mqtt_dotdot_electrical_measurement_active_power_max_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER) {
          uic_mqtt_dotdot_electrical_measurement_reactive_power_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER) {
          uic_mqtt_dotdot_electrical_measurement_apparent_power_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR) {
          uic_mqtt_dotdot_electrical_measurement_power_factor_publish(
            base_topic.c_str(),
            static_cast<int8_t>(attr.desired_or_reported<int8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_VOLTAGE_MEASUREMENT_PERIOD) {
          uic_mqtt_dotdot_electrical_measurement_average_rms_voltage_measurement_period_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_OVER_VOLTAGE_COUNTER) {
          uic_mqtt_dotdot_electrical_measurement_average_rms_over_voltage_counter_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_UNDER_VOLTAGE_COUNTER) {
          uic_mqtt_dotdot_electrical_measurement_average_rms_under_voltage_counter_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD) {
          uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_period_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD) {
          uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_period_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD) {
          uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_period_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD) {
          uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_period_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_MULTIPLIER) {
          uic_mqtt_dotdot_electrical_measurement_ac_voltage_multiplier_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_DIVISOR) {
          uic_mqtt_dotdot_electrical_measurement_ac_voltage_divisor_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_MULTIPLIER) {
          uic_mqtt_dotdot_electrical_measurement_ac_current_multiplier_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_DIVISOR) {
          uic_mqtt_dotdot_electrical_measurement_ac_current_divisor_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_POWER_MULTIPLIER) {
          uic_mqtt_dotdot_electrical_measurement_ac_power_multiplier_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_POWER_DIVISOR) {
          uic_mqtt_dotdot_electrical_measurement_ac_power_divisor_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_OVERLOAD_ALARMS_MASK) {
          uic_mqtt_dotdot_electrical_measurement_dc_overload_alarms_mask_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_OVERLOAD) {
          uic_mqtt_dotdot_electrical_measurement_dc_voltage_overload_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_OVERLOAD) {
          uic_mqtt_dotdot_electrical_measurement_dc_current_overload_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_ALARMS_MASK) {
          uic_mqtt_dotdot_electrical_measurement_ac_alarms_mask_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_OVERLOAD) {
          uic_mqtt_dotdot_electrical_measurement_ac_voltage_overload_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_OVERLOAD) {
          uic_mqtt_dotdot_electrical_measurement_ac_current_overload_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_ACTIVE_POWER_OVERLOAD) {
          uic_mqtt_dotdot_electrical_measurement_ac_active_power_overload_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_REACTIVE_POWER_OVERLOAD) {
          uic_mqtt_dotdot_electrical_measurement_ac_reactive_power_overload_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_OVER_VOLTAGE) {
          uic_mqtt_dotdot_electrical_measurement_average_rms_over_voltage_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_UNDER_VOLTAGE) {
          uic_mqtt_dotdot_electrical_measurement_average_rms_under_voltage_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE) {
          uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE) {
          uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG) {
          uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL) {
          uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT_PHB) {
          uic_mqtt_dotdot_electrical_measurement_line_current_phb_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT_PHB) {
          uic_mqtt_dotdot_electrical_measurement_active_current_phb_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT_PHB) {
          uic_mqtt_dotdot_electrical_measurement_reactive_current_phb_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_PHB) {
          uic_mqtt_dotdot_electrical_measurement_rms_voltage_phb_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN_PHB) {
          uic_mqtt_dotdot_electrical_measurement_rms_voltage_min_phb_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX_PHB) {
          uic_mqtt_dotdot_electrical_measurement_rms_voltage_max_phb_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_PHB) {
          uic_mqtt_dotdot_electrical_measurement_rms_current_phb_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN_PHB) {
          uic_mqtt_dotdot_electrical_measurement_rms_current_min_phb_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX_PHB) {
          uic_mqtt_dotdot_electrical_measurement_rms_current_max_phb_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_PHB) {
          uic_mqtt_dotdot_electrical_measurement_active_power_phb_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN_PHB) {
          uic_mqtt_dotdot_electrical_measurement_active_power_min_phb_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX_PHB) {
          uic_mqtt_dotdot_electrical_measurement_active_power_max_phb_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER_PHB) {
          uic_mqtt_dotdot_electrical_measurement_reactive_power_phb_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER_PHB) {
          uic_mqtt_dotdot_electrical_measurement_apparent_power_phb_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR_PHB) {
          uic_mqtt_dotdot_electrical_measurement_power_factor_phb_publish(
            base_topic.c_str(),
            static_cast<int8_t>(attr.desired_or_reported<int8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_VOLTAGE_MEASUREMENT_PERIOD_PHB) {
          uic_mqtt_dotdot_electrical_measurement_average_rms_voltage_measurement_period_phb_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_OVER_VOLTAGE_COUNTER_PHB) {
          uic_mqtt_dotdot_electrical_measurement_average_rms_over_voltage_counter_phb_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_UNDER_VOLTAGE_COUNTER_PHB) {
          uic_mqtt_dotdot_electrical_measurement_average_rms_under_voltage_counter_phb_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD_PHB) {
          uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_period_phb_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD_PHB) {
          uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_period_phb_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD_PHB) {
          uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_period_phb_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD_PHB) {
          uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_period_phb_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT_PHC) {
          uic_mqtt_dotdot_electrical_measurement_line_current_phc_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT_PHC) {
          uic_mqtt_dotdot_electrical_measurement_active_current_phc_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT_PHC) {
          uic_mqtt_dotdot_electrical_measurement_reactive_current_phc_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_PHC) {
          uic_mqtt_dotdot_electrical_measurement_rms_voltage_phc_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN_PHC) {
          uic_mqtt_dotdot_electrical_measurement_rms_voltage_min_phc_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX_PHC) {
          uic_mqtt_dotdot_electrical_measurement_rms_voltage_max_phc_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_PHC) {
          uic_mqtt_dotdot_electrical_measurement_rms_current_phc_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN_PHC) {
          uic_mqtt_dotdot_electrical_measurement_rms_current_min_phc_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX_PHC) {
          uic_mqtt_dotdot_electrical_measurement_rms_current_max_phc_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_PHC) {
          uic_mqtt_dotdot_electrical_measurement_active_power_phc_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN_PHC) {
          uic_mqtt_dotdot_electrical_measurement_active_power_min_phc_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX_PHC) {
          uic_mqtt_dotdot_electrical_measurement_active_power_max_phc_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER_PHC) {
          uic_mqtt_dotdot_electrical_measurement_reactive_power_phc_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER_PHC) {
          uic_mqtt_dotdot_electrical_measurement_apparent_power_phc_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR_PHC) {
          uic_mqtt_dotdot_electrical_measurement_power_factor_phc_publish(
            base_topic.c_str(),
            static_cast<int8_t>(attr.desired_or_reported<int8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_VOLTAGE_MEASUREMENT_PERIOD_PHC) {
          uic_mqtt_dotdot_electrical_measurement_average_rms_voltage_measurement_period_phc_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_OVER_VOLTAGE_COUNTER_PHC) {
          uic_mqtt_dotdot_electrical_measurement_average_rms_over_voltage_counter_phc_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_UNDER_VOLTAGE_COUNTER_PHC) {
          uic_mqtt_dotdot_electrical_measurement_average_rms_under_voltage_counter_phc_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD_PHC) {
          uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_period_phc_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD_PHC) {
          uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_period_phc_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD_PHC) {
          uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_period_phc_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD_PHC) {
          uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_period_phc_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the ElectricalMeasurement cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void electrical_measurement_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASUREMENT_TYPE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::MeasurementType under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_measurement_type_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::DCVoltage under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_dc_voltage_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MIN:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::DCVoltageMin under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_dc_voltage_min_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MAX:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::DCVoltageMax under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_dc_voltage_max_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::DCCurrent under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_dc_current_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MIN:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::DCCurrentMin under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_dc_current_min_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MAX:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::DCCurrentMax under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_dc_current_max_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::DCPower under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_dc_power_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MIN:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::DCPowerMin under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_dc_power_min_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MAX:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::DCPowerMax under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_dc_power_max_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MULTIPLIER:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::DCVoltageMultiplier under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_dc_voltage_multiplier_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_DIVISOR:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::DCVoltageDivisor under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_dc_voltage_divisor_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MULTIPLIER:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::DCCurrentMultiplier under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_dc_current_multiplier_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_DIVISOR:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::DCCurrentDivisor under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_dc_current_divisor_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MULTIPLIER:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::DCPowerMultiplier under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_dc_power_multiplier_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_DIVISOR:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::DCPowerDivisor under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_dc_power_divisor_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ACFrequency under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_ac_frequency_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MIN:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ACFrequencyMin under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_ac_frequency_min_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MAX:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ACFrequencyMax under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_ac_frequency_max_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_NEUTRAL_CURRENT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::NeutralCurrent under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_neutral_current_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_ACTIVE_POWER:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::TotalActivePower under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_total_active_power_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_REACTIVE_POWER:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::TotalReactivePower under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_total_reactive_power_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_APPARENT_POWER:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::TotalApparentPower under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_total_apparent_power_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED1ST_HARMONIC_CURRENT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::Measured1stHarmonicCurrent under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_measured1st_harmonic_current_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED3RD_HARMONIC_CURRENT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::Measured3rdHarmonicCurrent under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_measured3rd_harmonic_current_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED5TH_HARMONIC_CURRENT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::Measured5thHarmonicCurrent under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_measured5th_harmonic_current_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED7TH_HARMONIC_CURRENT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::Measured7thHarmonicCurrent under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_measured7th_harmonic_current_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED9TH_HARMONIC_CURRENT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::Measured9thHarmonicCurrent under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_measured9th_harmonic_current_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED11TH_HARMONIC_CURRENT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::Measured11thHarmonicCurrent under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_measured11th_harmonic_current_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE1ST_HARMONIC_CURRENT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::MeasuredPhase1stHarmonicCurrent under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_measured_phase1st_harmonic_current_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE3RD_HARMONIC_CURRENT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::MeasuredPhase3rdHarmonicCurrent under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_measured_phase3rd_harmonic_current_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE5TH_HARMONIC_CURRENT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::MeasuredPhase5thHarmonicCurrent under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_measured_phase5th_harmonic_current_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE7TH_HARMONIC_CURRENT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::MeasuredPhase7thHarmonicCurrent under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_measured_phase7th_harmonic_current_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE9TH_HARMONIC_CURRENT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::MeasuredPhase9thHarmonicCurrent under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_measured_phase9th_harmonic_current_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE11TH_HARMONIC_CURRENT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::MeasuredPhase11thHarmonicCurrent under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_measured_phase11th_harmonic_current_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MULTIPLIER:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ACFrequencyMultiplier under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_ac_frequency_multiplier_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_DIVISOR:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ACFrequencyDivisor under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_ac_frequency_divisor_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_MULTIPLIER:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::PowerMultiplier under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_power_multiplier_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_DIVISOR:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::PowerDivisor under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_power_divisor_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_HARMONIC_CURRENT_MULTIPLIER:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::HarmonicCurrentMultiplier under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_harmonic_current_multiplier_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_PHASE_HARMONIC_CURRENT_MULTIPLIER:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::PhaseHarmonicCurrentMultiplier under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_phase_harmonic_current_multiplier_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::LineCurrent under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_line_current_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ActiveCurrent under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_active_current_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ReactiveCurrent under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_reactive_current_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::RMSVoltage under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_rms_voltage_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::RMSVoltageMin under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_rms_voltage_min_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::RMSVoltageMax under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_rms_voltage_max_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::RMSCurrent under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_rms_current_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::RMSCurrentMin under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_rms_current_min_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::RMSCurrentMax under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_rms_current_max_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ActivePower under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_active_power_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ActivePowerMin under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_active_power_min_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ActivePowerMax under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_active_power_max_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ReactivePower under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_reactive_power_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ApparentPower under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_apparent_power_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::PowerFactor under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_power_factor_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_VOLTAGE_MEASUREMENT_PERIOD:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::AverageRMSVoltageMeasurementPeriod under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_average_rms_voltage_measurement_period_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_OVER_VOLTAGE_COUNTER:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::AverageRMSOverVoltageCounter under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_average_rms_over_voltage_counter_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_UNDER_VOLTAGE_COUNTER:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::AverageRMSUnderVoltageCounter under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_average_rms_under_voltage_counter_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::RMSExtremeOverVoltagePeriod under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_period_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::RMSExtremeUnderVoltagePeriod under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_period_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::RMSVoltageSagPeriod under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_period_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::RMSVoltageSwellPeriod under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_period_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_MULTIPLIER:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ACVoltageMultiplier under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_ac_voltage_multiplier_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_DIVISOR:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ACVoltageDivisor under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_ac_voltage_divisor_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_MULTIPLIER:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ACCurrentMultiplier under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_ac_current_multiplier_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_DIVISOR:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ACCurrentDivisor under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_ac_current_divisor_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_POWER_MULTIPLIER:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ACPowerMultiplier under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_ac_power_multiplier_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_POWER_DIVISOR:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ACPowerDivisor under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_ac_power_divisor_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_OVERLOAD_ALARMS_MASK:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::DCOverloadAlarmsMask under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_dc_overload_alarms_mask_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_OVERLOAD:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::DCVoltageOverload under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_dc_voltage_overload_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_OVERLOAD:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::DCCurrentOverload under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_dc_current_overload_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_ALARMS_MASK:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ACAlarmsMask under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_ac_alarms_mask_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_OVERLOAD:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ACVoltageOverload under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_ac_voltage_overload_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_OVERLOAD:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ACCurrentOverload under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_ac_current_overload_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_ACTIVE_POWER_OVERLOAD:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ACActivePowerOverload under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_ac_active_power_overload_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_REACTIVE_POWER_OVERLOAD:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ACReactivePowerOverload under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_ac_reactive_power_overload_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_OVER_VOLTAGE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::AverageRMSOverVoltage under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_average_rms_over_voltage_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_UNDER_VOLTAGE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::AverageRMSUnderVoltage under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_average_rms_under_voltage_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::RMSExtremeOverVoltage under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::RMSExtremeUnderVoltage under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::RMSVoltageSag under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::RMSVoltageSwell under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT_PHB:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::LineCurrentPhB under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_line_current_phb_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT_PHB:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ActiveCurrentPhB under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_active_current_phb_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT_PHB:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ReactiveCurrentPhB under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_reactive_current_phb_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_PHB:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::RMSVoltagePhB under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_rms_voltage_phb_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN_PHB:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::RMSVoltageMinPhB under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_rms_voltage_min_phb_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX_PHB:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::RMSVoltageMaxPhB under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_rms_voltage_max_phb_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_PHB:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::RMSCurrentPhB under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_rms_current_phb_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN_PHB:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::RMSCurrentMinPhB under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_rms_current_min_phb_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX_PHB:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::RMSCurrentMaxPhB under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_rms_current_max_phb_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_PHB:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ActivePowerPhB under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_active_power_phb_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN_PHB:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ActivePowerMinPhB under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_active_power_min_phb_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX_PHB:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ActivePowerMaxPhB under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_active_power_max_phb_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER_PHB:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ReactivePowerPhB under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_reactive_power_phb_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER_PHB:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ApparentPowerPhB under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_apparent_power_phb_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR_PHB:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::PowerFactorPhB under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_power_factor_phb_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_VOLTAGE_MEASUREMENT_PERIOD_PHB:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::AverageRMSVoltageMeasurementPeriodPhB under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_average_rms_voltage_measurement_period_phb_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_OVER_VOLTAGE_COUNTER_PHB:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::AverageRMSOverVoltageCounterPhB under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_average_rms_over_voltage_counter_phb_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_UNDER_VOLTAGE_COUNTER_PHB:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::AverageRMSUnderVoltageCounterPhB under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_average_rms_under_voltage_counter_phb_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD_PHB:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::RMSExtremeOverVoltagePeriodPhB under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_period_phb_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD_PHB:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::RMSExtremeUnderVoltagePeriodPhB under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_period_phb_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD_PHB:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::RMSVoltageSagPeriodPhB under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_period_phb_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD_PHB:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::RMSVoltageSwellPeriodPhB under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_period_phb_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT_PHC:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::LineCurrentPhC under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_line_current_phc_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT_PHC:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ActiveCurrentPhC under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_active_current_phc_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT_PHC:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ReactiveCurrentPhC under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_reactive_current_phc_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_PHC:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::RMSVoltagePhC under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_rms_voltage_phc_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN_PHC:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::RMSVoltageMinPhC under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_rms_voltage_min_phc_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX_PHC:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::RMSVoltageMaxPhC under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_rms_voltage_max_phc_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_PHC:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::RMSCurrentPhC under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_rms_current_phc_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN_PHC:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::RMSCurrentMinPhC under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_rms_current_min_phc_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX_PHC:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::RMSCurrentMaxPhC under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_rms_current_max_phc_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_PHC:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ActivePowerPhC under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_active_power_phc_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN_PHC:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ActivePowerMinPhC under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_active_power_min_phc_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX_PHC:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ActivePowerMaxPhC under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_active_power_max_phc_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER_PHC:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ReactivePowerPhC under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_reactive_power_phc_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER_PHC:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::ApparentPowerPhC under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_apparent_power_phc_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR_PHC:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::PowerFactorPhC under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_power_factor_phc_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_VOLTAGE_MEASUREMENT_PERIOD_PHC:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::AverageRMSVoltageMeasurementPeriodPhC under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_average_rms_voltage_measurement_period_phc_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_OVER_VOLTAGE_COUNTER_PHC:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::AverageRMSOverVoltageCounterPhC under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_average_rms_over_voltage_counter_phc_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_UNDER_VOLTAGE_COUNTER_PHC:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::AverageRMSUnderVoltageCounterPhC under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_average_rms_under_voltage_counter_phc_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD_PHC:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::RMSExtremeOverVoltagePeriodPhC under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_period_phc_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD_PHC:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::RMSExtremeUnderVoltagePeriodPhC under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_period_phc_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD_PHC:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::RMSVoltageSagPeriodPhC under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_period_phc_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD_PHC:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ElectricalMeasurement::RMSVoltageSwellPeriodPhC under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_period_phc_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASUREMENT_TYPE) {
          uic_mqtt_dotdot_electrical_measurement_measurement_type_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE) {
          uic_mqtt_dotdot_electrical_measurement_dc_voltage_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MIN) {
          uic_mqtt_dotdot_electrical_measurement_dc_voltage_min_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MAX) {
          uic_mqtt_dotdot_electrical_measurement_dc_voltage_max_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_dc_current_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MIN) {
          uic_mqtt_dotdot_electrical_measurement_dc_current_min_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MAX) {
          uic_mqtt_dotdot_electrical_measurement_dc_current_max_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER) {
          uic_mqtt_dotdot_electrical_measurement_dc_power_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MIN) {
          uic_mqtt_dotdot_electrical_measurement_dc_power_min_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MAX) {
          uic_mqtt_dotdot_electrical_measurement_dc_power_max_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MULTIPLIER) {
          uic_mqtt_dotdot_electrical_measurement_dc_voltage_multiplier_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_DIVISOR) {
          uic_mqtt_dotdot_electrical_measurement_dc_voltage_divisor_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MULTIPLIER) {
          uic_mqtt_dotdot_electrical_measurement_dc_current_multiplier_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_DIVISOR) {
          uic_mqtt_dotdot_electrical_measurement_dc_current_divisor_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MULTIPLIER) {
          uic_mqtt_dotdot_electrical_measurement_dc_power_multiplier_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_DIVISOR) {
          uic_mqtt_dotdot_electrical_measurement_dc_power_divisor_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY) {
          uic_mqtt_dotdot_electrical_measurement_ac_frequency_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MIN) {
          uic_mqtt_dotdot_electrical_measurement_ac_frequency_min_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MAX) {
          uic_mqtt_dotdot_electrical_measurement_ac_frequency_max_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_NEUTRAL_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_neutral_current_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_ACTIVE_POWER) {
          uic_mqtt_dotdot_electrical_measurement_total_active_power_publish(
            base_topic.c_str(),
            static_cast<int32_t>(attr.reported<int32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_REACTIVE_POWER) {
          uic_mqtt_dotdot_electrical_measurement_total_reactive_power_publish(
            base_topic.c_str(),
            static_cast<int32_t>(attr.reported<int32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_APPARENT_POWER) {
          uic_mqtt_dotdot_electrical_measurement_total_apparent_power_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED1ST_HARMONIC_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_measured1st_harmonic_current_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED3RD_HARMONIC_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_measured3rd_harmonic_current_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED5TH_HARMONIC_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_measured5th_harmonic_current_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED7TH_HARMONIC_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_measured7th_harmonic_current_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED9TH_HARMONIC_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_measured9th_harmonic_current_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED11TH_HARMONIC_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_measured11th_harmonic_current_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE1ST_HARMONIC_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_measured_phase1st_harmonic_current_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE3RD_HARMONIC_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_measured_phase3rd_harmonic_current_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE5TH_HARMONIC_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_measured_phase5th_harmonic_current_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE7TH_HARMONIC_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_measured_phase7th_harmonic_current_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE9TH_HARMONIC_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_measured_phase9th_harmonic_current_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE11TH_HARMONIC_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_measured_phase11th_harmonic_current_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MULTIPLIER) {
          uic_mqtt_dotdot_electrical_measurement_ac_frequency_multiplier_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_DIVISOR) {
          uic_mqtt_dotdot_electrical_measurement_ac_frequency_divisor_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_MULTIPLIER) {
          uic_mqtt_dotdot_electrical_measurement_power_multiplier_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_DIVISOR) {
          uic_mqtt_dotdot_electrical_measurement_power_divisor_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_HARMONIC_CURRENT_MULTIPLIER) {
          uic_mqtt_dotdot_electrical_measurement_harmonic_current_multiplier_publish(
            base_topic.c_str(),
            static_cast<int8_t>(attr.reported<int8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_PHASE_HARMONIC_CURRENT_MULTIPLIER) {
          uic_mqtt_dotdot_electrical_measurement_phase_harmonic_current_multiplier_publish(
            base_topic.c_str(),
            static_cast<int8_t>(attr.reported<int8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_line_current_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_active_current_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_reactive_current_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE) {
          uic_mqtt_dotdot_electrical_measurement_rms_voltage_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN) {
          uic_mqtt_dotdot_electrical_measurement_rms_voltage_min_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX) {
          uic_mqtt_dotdot_electrical_measurement_rms_voltage_max_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT) {
          uic_mqtt_dotdot_electrical_measurement_rms_current_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN) {
          uic_mqtt_dotdot_electrical_measurement_rms_current_min_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX) {
          uic_mqtt_dotdot_electrical_measurement_rms_current_max_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER) {
          uic_mqtt_dotdot_electrical_measurement_active_power_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN) {
          uic_mqtt_dotdot_electrical_measurement_active_power_min_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX) {
          uic_mqtt_dotdot_electrical_measurement_active_power_max_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER) {
          uic_mqtt_dotdot_electrical_measurement_reactive_power_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER) {
          uic_mqtt_dotdot_electrical_measurement_apparent_power_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR) {
          uic_mqtt_dotdot_electrical_measurement_power_factor_publish(
            base_topic.c_str(),
            static_cast<int8_t>(attr.reported<int8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_VOLTAGE_MEASUREMENT_PERIOD) {
          uic_mqtt_dotdot_electrical_measurement_average_rms_voltage_measurement_period_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_OVER_VOLTAGE_COUNTER) {
          uic_mqtt_dotdot_electrical_measurement_average_rms_over_voltage_counter_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_UNDER_VOLTAGE_COUNTER) {
          uic_mqtt_dotdot_electrical_measurement_average_rms_under_voltage_counter_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD) {
          uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_period_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD) {
          uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_period_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD) {
          uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_period_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD) {
          uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_period_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_MULTIPLIER) {
          uic_mqtt_dotdot_electrical_measurement_ac_voltage_multiplier_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_DIVISOR) {
          uic_mqtt_dotdot_electrical_measurement_ac_voltage_divisor_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_MULTIPLIER) {
          uic_mqtt_dotdot_electrical_measurement_ac_current_multiplier_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_DIVISOR) {
          uic_mqtt_dotdot_electrical_measurement_ac_current_divisor_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_POWER_MULTIPLIER) {
          uic_mqtt_dotdot_electrical_measurement_ac_power_multiplier_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_POWER_DIVISOR) {
          uic_mqtt_dotdot_electrical_measurement_ac_power_divisor_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_OVERLOAD_ALARMS_MASK) {
          uic_mqtt_dotdot_electrical_measurement_dc_overload_alarms_mask_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_OVERLOAD) {
          uic_mqtt_dotdot_electrical_measurement_dc_voltage_overload_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_OVERLOAD) {
          uic_mqtt_dotdot_electrical_measurement_dc_current_overload_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_ALARMS_MASK) {
          uic_mqtt_dotdot_electrical_measurement_ac_alarms_mask_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_OVERLOAD) {
          uic_mqtt_dotdot_electrical_measurement_ac_voltage_overload_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_OVERLOAD) {
          uic_mqtt_dotdot_electrical_measurement_ac_current_overload_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_ACTIVE_POWER_OVERLOAD) {
          uic_mqtt_dotdot_electrical_measurement_ac_active_power_overload_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_REACTIVE_POWER_OVERLOAD) {
          uic_mqtt_dotdot_electrical_measurement_ac_reactive_power_overload_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_OVER_VOLTAGE) {
          uic_mqtt_dotdot_electrical_measurement_average_rms_over_voltage_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_UNDER_VOLTAGE) {
          uic_mqtt_dotdot_electrical_measurement_average_rms_under_voltage_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE) {
          uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE) {
          uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG) {
          uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL) {
          uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT_PHB) {
          uic_mqtt_dotdot_electrical_measurement_line_current_phb_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT_PHB) {
          uic_mqtt_dotdot_electrical_measurement_active_current_phb_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT_PHB) {
          uic_mqtt_dotdot_electrical_measurement_reactive_current_phb_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_PHB) {
          uic_mqtt_dotdot_electrical_measurement_rms_voltage_phb_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN_PHB) {
          uic_mqtt_dotdot_electrical_measurement_rms_voltage_min_phb_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX_PHB) {
          uic_mqtt_dotdot_electrical_measurement_rms_voltage_max_phb_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_PHB) {
          uic_mqtt_dotdot_electrical_measurement_rms_current_phb_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN_PHB) {
          uic_mqtt_dotdot_electrical_measurement_rms_current_min_phb_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX_PHB) {
          uic_mqtt_dotdot_electrical_measurement_rms_current_max_phb_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_PHB) {
          uic_mqtt_dotdot_electrical_measurement_active_power_phb_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN_PHB) {
          uic_mqtt_dotdot_electrical_measurement_active_power_min_phb_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX_PHB) {
          uic_mqtt_dotdot_electrical_measurement_active_power_max_phb_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER_PHB) {
          uic_mqtt_dotdot_electrical_measurement_reactive_power_phb_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER_PHB) {
          uic_mqtt_dotdot_electrical_measurement_apparent_power_phb_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR_PHB) {
          uic_mqtt_dotdot_electrical_measurement_power_factor_phb_publish(
            base_topic.c_str(),
            static_cast<int8_t>(attr.reported<int8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_VOLTAGE_MEASUREMENT_PERIOD_PHB) {
          uic_mqtt_dotdot_electrical_measurement_average_rms_voltage_measurement_period_phb_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_OVER_VOLTAGE_COUNTER_PHB) {
          uic_mqtt_dotdot_electrical_measurement_average_rms_over_voltage_counter_phb_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_UNDER_VOLTAGE_COUNTER_PHB) {
          uic_mqtt_dotdot_electrical_measurement_average_rms_under_voltage_counter_phb_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD_PHB) {
          uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_period_phb_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD_PHB) {
          uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_period_phb_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD_PHB) {
          uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_period_phb_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD_PHB) {
          uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_period_phb_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT_PHC) {
          uic_mqtt_dotdot_electrical_measurement_line_current_phc_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT_PHC) {
          uic_mqtt_dotdot_electrical_measurement_active_current_phc_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT_PHC) {
          uic_mqtt_dotdot_electrical_measurement_reactive_current_phc_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_PHC) {
          uic_mqtt_dotdot_electrical_measurement_rms_voltage_phc_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN_PHC) {
          uic_mqtt_dotdot_electrical_measurement_rms_voltage_min_phc_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX_PHC) {
          uic_mqtt_dotdot_electrical_measurement_rms_voltage_max_phc_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_PHC) {
          uic_mqtt_dotdot_electrical_measurement_rms_current_phc_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN_PHC) {
          uic_mqtt_dotdot_electrical_measurement_rms_current_min_phc_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX_PHC) {
          uic_mqtt_dotdot_electrical_measurement_rms_current_max_phc_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_PHC) {
          uic_mqtt_dotdot_electrical_measurement_active_power_phc_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN_PHC) {
          uic_mqtt_dotdot_electrical_measurement_active_power_min_phc_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX_PHC) {
          uic_mqtt_dotdot_electrical_measurement_active_power_max_phc_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER_PHC) {
          uic_mqtt_dotdot_electrical_measurement_reactive_power_phc_publish(
            base_topic.c_str(),
            static_cast<int16_t>(attr.reported<int16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER_PHC) {
          uic_mqtt_dotdot_electrical_measurement_apparent_power_phc_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR_PHC) {
          uic_mqtt_dotdot_electrical_measurement_power_factor_phc_publish(
            base_topic.c_str(),
            static_cast<int8_t>(attr.reported<int8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_VOLTAGE_MEASUREMENT_PERIOD_PHC) {
          uic_mqtt_dotdot_electrical_measurement_average_rms_voltage_measurement_period_phc_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_OVER_VOLTAGE_COUNTER_PHC) {
          uic_mqtt_dotdot_electrical_measurement_average_rms_over_voltage_counter_phc_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_UNDER_VOLTAGE_COUNTER_PHC) {
          uic_mqtt_dotdot_electrical_measurement_average_rms_under_voltage_counter_phc_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD_PHC) {
          uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_period_phc_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD_PHC) {
          uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_period_phc_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD_PHC) {
          uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_period_phc_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD_PHC) {
          uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_period_phc_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void electrical_measurement_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/ElectricalMeasurement/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_electrical_measurement_publish_cluster_revision(base_topic.c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_electrical_measurement_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/ElectricalMeasurement";
      sl_log_debug(LOG_TAG, "No more attributes supported for ElectricalMeasurement cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the Diagnostics cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void diagnostics_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NUMBER_OF_RESETS) {
          uic_mqtt_dotdot_diagnostics_number_of_resets_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PERSISTENT_MEMORY_WRITES) {
          uic_mqtt_dotdot_diagnostics_persistent_memory_writes_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_RX_BCAST) {
          uic_mqtt_dotdot_diagnostics_mac_rx_bcast_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_BCAST) {
          uic_mqtt_dotdot_diagnostics_mac_tx_bcast_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_RX_UCAST) {
          uic_mqtt_dotdot_diagnostics_mac_rx_ucast_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST) {
          uic_mqtt_dotdot_diagnostics_mac_tx_ucast_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST_RETRY) {
          uic_mqtt_dotdot_diagnostics_mac_tx_ucast_retry_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST_FAIL) {
          uic_mqtt_dotdot_diagnostics_mac_tx_ucast_fail_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_RX_BCAST) {
          uic_mqtt_dotdot_diagnostics_aps_rx_bcast_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_BCAST) {
          uic_mqtt_dotdot_diagnostics_aps_tx_bcast_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_RX_UCAST) {
          uic_mqtt_dotdot_diagnostics_aps_rx_ucast_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_SUCCESS) {
          uic_mqtt_dotdot_diagnostics_aps_tx_ucast_success_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_RETRY) {
          uic_mqtt_dotdot_diagnostics_aps_tx_ucast_retry_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_FAIL) {
          uic_mqtt_dotdot_diagnostics_aps_tx_ucast_fail_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_ROUTE_DISC_INITIATED) {
          uic_mqtt_dotdot_diagnostics_route_disc_initiated_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_ADDED) {
          uic_mqtt_dotdot_diagnostics_neighbor_added_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_REMOVED) {
          uic_mqtt_dotdot_diagnostics_neighbor_removed_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_STALE) {
          uic_mqtt_dotdot_diagnostics_neighbor_stale_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_JOIN_INDICATION) {
          uic_mqtt_dotdot_diagnostics_join_indication_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_CHILD_MOVED) {
          uic_mqtt_dotdot_diagnostics_child_moved_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NWKFC_FAILURE) {
          uic_mqtt_dotdot_diagnostics_nwkfc_failure_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APSFC_FAILURE) {
          uic_mqtt_dotdot_diagnostics_apsfc_failure_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_UNAUTHORIZED_KEY) {
          uic_mqtt_dotdot_diagnostics_aps_unauthorized_key_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NWK_DECRYPT_FAILURES) {
          uic_mqtt_dotdot_diagnostics_nwk_decrypt_failures_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_DECRYPT_FAILURES) {
          uic_mqtt_dotdot_diagnostics_aps_decrypt_failures_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PACKET_BUFFER_ALLOCATE_FAILURES) {
          uic_mqtt_dotdot_diagnostics_packet_buffer_allocate_failures_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_RELAYED_UCAST) {
          uic_mqtt_dotdot_diagnostics_relayed_ucast_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PHY_TO_MAC_QUEUE_LIMIT_REACHED) {
          uic_mqtt_dotdot_diagnostics_phy_to_mac_queue_limit_reached_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PACKET_VALIDATE_DROP_COUNT) {
          uic_mqtt_dotdot_diagnostics_packet_validate_drop_count_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_AVERAGE_MAC_RETRY_PER_APS_MESSAGE_SENT) {
          uic_mqtt_dotdot_diagnostics_average_mac_retry_per_aps_message_sent_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_LAST_MESSAGELQI) {
          uic_mqtt_dotdot_diagnostics_last_messagelqi_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_LAST_MESSAGERSSI) {
          uic_mqtt_dotdot_diagnostics_last_messagerssi_publish(
            base_topic.c_str(),
            static_cast<int8_t>(attr.desired_or_reported<int8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the Diagnostics cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void diagnostics_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NUMBER_OF_RESETS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Diagnostics::NumberOfResets under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_diagnostics_number_of_resets_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PERSISTENT_MEMORY_WRITES:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Diagnostics::PersistentMemoryWrites under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_diagnostics_persistent_memory_writes_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_RX_BCAST:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Diagnostics::MacRxBcast under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_diagnostics_mac_rx_bcast_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_BCAST:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Diagnostics::MacTxBcast under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_diagnostics_mac_tx_bcast_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_RX_UCAST:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Diagnostics::MacRxUcast under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_diagnostics_mac_rx_ucast_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Diagnostics::MacTxUcast under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_diagnostics_mac_tx_ucast_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST_RETRY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Diagnostics::MacTxUcastRetry under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_diagnostics_mac_tx_ucast_retry_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST_FAIL:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Diagnostics::MacTxUcastFail under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_diagnostics_mac_tx_ucast_fail_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_RX_BCAST:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Diagnostics::APSRxBcast under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_diagnostics_aps_rx_bcast_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_BCAST:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Diagnostics::APSTxBcast under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_diagnostics_aps_tx_bcast_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_RX_UCAST:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Diagnostics::APSRxUcast under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_diagnostics_aps_rx_ucast_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_SUCCESS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Diagnostics::APSTxUcastSuccess under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_diagnostics_aps_tx_ucast_success_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_RETRY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Diagnostics::APSTxUcastRetry under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_diagnostics_aps_tx_ucast_retry_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_FAIL:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Diagnostics::APSTxUcastFail under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_diagnostics_aps_tx_ucast_fail_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_ROUTE_DISC_INITIATED:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Diagnostics::RouteDiscInitiated under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_diagnostics_route_disc_initiated_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_ADDED:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Diagnostics::NeighborAdded under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_diagnostics_neighbor_added_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_REMOVED:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Diagnostics::NeighborRemoved under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_diagnostics_neighbor_removed_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_STALE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Diagnostics::NeighborStale under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_diagnostics_neighbor_stale_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_JOIN_INDICATION:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Diagnostics::JoinIndication under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_diagnostics_join_indication_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_CHILD_MOVED:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Diagnostics::ChildMoved under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_diagnostics_child_moved_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NWKFC_FAILURE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Diagnostics::NWKFCFailure under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_diagnostics_nwkfc_failure_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APSFC_FAILURE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Diagnostics::APSFCFailure under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_diagnostics_apsfc_failure_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_UNAUTHORIZED_KEY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Diagnostics::APSUnauthorizedKey under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_diagnostics_aps_unauthorized_key_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NWK_DECRYPT_FAILURES:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Diagnostics::NWKDecryptFailures under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_diagnostics_nwk_decrypt_failures_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_DECRYPT_FAILURES:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Diagnostics::APSDecryptFailures under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_diagnostics_aps_decrypt_failures_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PACKET_BUFFER_ALLOCATE_FAILURES:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Diagnostics::PacketBufferAllocateFailures under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_diagnostics_packet_buffer_allocate_failures_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_RELAYED_UCAST:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Diagnostics::RelayedUcast under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_diagnostics_relayed_ucast_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PHY_TO_MAC_QUEUE_LIMIT_REACHED:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Diagnostics::PHYToMACQueueLimitReached under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_diagnostics_phy_to_mac_queue_limit_reached_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PACKET_VALIDATE_DROP_COUNT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Diagnostics::PacketValidateDropCount under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_diagnostics_packet_validate_drop_count_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_AVERAGE_MAC_RETRY_PER_APS_MESSAGE_SENT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Diagnostics::AverageMACRetryPerAPSMessageSent under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_diagnostics_average_mac_retry_per_aps_message_sent_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_LAST_MESSAGELQI:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Diagnostics::LastMessageLQI under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_diagnostics_last_messagelqi_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_LAST_MESSAGERSSI:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Diagnostics::LastMessageRSSI under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_diagnostics_last_messagerssi_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NUMBER_OF_RESETS) {
          uic_mqtt_dotdot_diagnostics_number_of_resets_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PERSISTENT_MEMORY_WRITES) {
          uic_mqtt_dotdot_diagnostics_persistent_memory_writes_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_RX_BCAST) {
          uic_mqtt_dotdot_diagnostics_mac_rx_bcast_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_BCAST) {
          uic_mqtt_dotdot_diagnostics_mac_tx_bcast_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_RX_UCAST) {
          uic_mqtt_dotdot_diagnostics_mac_rx_ucast_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST) {
          uic_mqtt_dotdot_diagnostics_mac_tx_ucast_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST_RETRY) {
          uic_mqtt_dotdot_diagnostics_mac_tx_ucast_retry_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST_FAIL) {
          uic_mqtt_dotdot_diagnostics_mac_tx_ucast_fail_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_RX_BCAST) {
          uic_mqtt_dotdot_diagnostics_aps_rx_bcast_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_BCAST) {
          uic_mqtt_dotdot_diagnostics_aps_tx_bcast_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_RX_UCAST) {
          uic_mqtt_dotdot_diagnostics_aps_rx_ucast_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_SUCCESS) {
          uic_mqtt_dotdot_diagnostics_aps_tx_ucast_success_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_RETRY) {
          uic_mqtt_dotdot_diagnostics_aps_tx_ucast_retry_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_FAIL) {
          uic_mqtt_dotdot_diagnostics_aps_tx_ucast_fail_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_ROUTE_DISC_INITIATED) {
          uic_mqtt_dotdot_diagnostics_route_disc_initiated_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_ADDED) {
          uic_mqtt_dotdot_diagnostics_neighbor_added_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_REMOVED) {
          uic_mqtt_dotdot_diagnostics_neighbor_removed_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_STALE) {
          uic_mqtt_dotdot_diagnostics_neighbor_stale_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_JOIN_INDICATION) {
          uic_mqtt_dotdot_diagnostics_join_indication_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_CHILD_MOVED) {
          uic_mqtt_dotdot_diagnostics_child_moved_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NWKFC_FAILURE) {
          uic_mqtt_dotdot_diagnostics_nwkfc_failure_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APSFC_FAILURE) {
          uic_mqtt_dotdot_diagnostics_apsfc_failure_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_UNAUTHORIZED_KEY) {
          uic_mqtt_dotdot_diagnostics_aps_unauthorized_key_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NWK_DECRYPT_FAILURES) {
          uic_mqtt_dotdot_diagnostics_nwk_decrypt_failures_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_DECRYPT_FAILURES) {
          uic_mqtt_dotdot_diagnostics_aps_decrypt_failures_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PACKET_BUFFER_ALLOCATE_FAILURES) {
          uic_mqtt_dotdot_diagnostics_packet_buffer_allocate_failures_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_RELAYED_UCAST) {
          uic_mqtt_dotdot_diagnostics_relayed_ucast_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PHY_TO_MAC_QUEUE_LIMIT_REACHED) {
          uic_mqtt_dotdot_diagnostics_phy_to_mac_queue_limit_reached_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PACKET_VALIDATE_DROP_COUNT) {
          uic_mqtt_dotdot_diagnostics_packet_validate_drop_count_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_AVERAGE_MAC_RETRY_PER_APS_MESSAGE_SENT) {
          uic_mqtt_dotdot_diagnostics_average_mac_retry_per_aps_message_sent_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_LAST_MESSAGELQI) {
          uic_mqtt_dotdot_diagnostics_last_messagelqi_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_LAST_MESSAGERSSI) {
          uic_mqtt_dotdot_diagnostics_last_messagerssi_publish(
            base_topic.c_str(),
            static_cast<int8_t>(attr.reported<int8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void diagnostics_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/Diagnostics/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_diagnostics_publish_cluster_revision(base_topic.c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_diagnostics_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/Diagnostics";
      sl_log_debug(LOG_TAG, "No more attributes supported for Diagnostics cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the ProtocolController-RFTelemetry cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void protocol_controller_rf_telemetry_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK != unify_dotdot_attributes_get_unid()(updated_node, unid)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_RF_TELEMETRY_TX_REPORT_ENABLED) {
          uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_enabled_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.desired_or_reported<bool>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_RF_TELEMETRY_PTI_ENABLED) {
          uic_mqtt_dotdot_protocol_controller_rf_telemetry_pti_enabled_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.desired_or_reported<bool>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the ProtocolController-RFTelemetry cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void protocol_controller_rf_telemetry_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK != unify_dotdot_attributes_get_unid()(updated_node, unid)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_RF_TELEMETRY_TX_REPORT_ENABLED:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ProtocolController-RFTelemetry::TxReportEnabled under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_enabled_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_RF_TELEMETRY_PTI_ENABLED:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ProtocolController-RFTelemetry::PTIEnabled under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_protocol_controller_rf_telemetry_pti_enabled_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_RF_TELEMETRY_TX_REPORT_ENABLED) {
          uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_enabled_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.reported<bool>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_RF_TELEMETRY_PTI_ENABLED) {
          uic_mqtt_dotdot_protocol_controller_rf_telemetry_pti_enabled_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.reported<bool>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void protocol_controller_rf_telemetry_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK != unify_dotdot_attributes_get_unid()(updated_node, unid)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/ProtocolController/RFTelemetry/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_protocol_controller_rf_telemetry_publish_cluster_revision(base_topic.c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_protocol_controller_rf_telemetry_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/ProtocolController/RFTelemetry";
      sl_log_debug(LOG_TAG, "No more attributes supported for ProtocolController-RFTelemetry cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the State cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void state_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK != unify_dotdot_attributes_get_unid()(updated_node, unid)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
    // Skip attribute EndpointIdList because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish desired value for attribute State EndpointIdList. Arrays are not supported");
      if (type == DOTDOT_ATTRIBUTE_ID_STATE_NETWORK_STATUS) {
          uic_mqtt_dotdot_state_network_status_publish(
            base_topic.c_str(),
            static_cast<NodeStateNetworkStatus>(attr.desired_or_reported<NodeStateNetworkStatus>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_STATE_SECURITY) {
          uic_mqtt_dotdot_state_security_publish(
            base_topic.c_str(),
            static_cast<NodeStateSecurity>(attr.desired_or_reported<NodeStateSecurity>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_STATE_MAXIMUM_COMMAND_DELAY) {
          uic_mqtt_dotdot_state_maximum_command_delay_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
        // Skip attribute NetworkList because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish desired value for attribute State NetworkList. Arrays are not supported");
  } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the State cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void state_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK != unify_dotdot_attributes_get_unid()(updated_node, unid)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_STATE_ENDPOINT_ID_LIST:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining State::EndpointIdList under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_state_endpoint_id_list_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_STATE_NETWORK_STATUS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining State::NetworkStatus under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_state_network_status_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_STATE_SECURITY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining State::Security under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_state_security_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_STATE_MAXIMUM_COMMAND_DELAY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining State::MaximumCommandDelay under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_state_maximum_command_delay_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_STATE_NETWORK_LIST:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining State::NetworkList under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_state_network_list_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
    // Skip attribute EndpointIdList because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish reported value for attribute State EndpointIdList. Arrays are not supported");
      if (type == DOTDOT_ATTRIBUTE_ID_STATE_NETWORK_STATUS) {
          uic_mqtt_dotdot_state_network_status_publish(
            base_topic.c_str(),
            static_cast<NodeStateNetworkStatus>(attr.reported<NodeStateNetworkStatus>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_STATE_SECURITY) {
          uic_mqtt_dotdot_state_security_publish(
            base_topic.c_str(),
            static_cast<NodeStateSecurity>(attr.reported<NodeStateSecurity>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_STATE_MAXIMUM_COMMAND_DELAY) {
          uic_mqtt_dotdot_state_maximum_command_delay_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
        // Skip attribute NetworkList because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish reported value for attribute State NetworkList. Arrays are not supported");
  } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void state_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK != unify_dotdot_attributes_get_unid()(updated_node, unid)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/State/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_state_publish_cluster_revision(base_topic.c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_state_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/State";
      sl_log_debug(LOG_TAG, "No more attributes supported for State cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the Binding cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void binding_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_BINDING_BINDING_TABLE_FULL) {
          uic_mqtt_dotdot_binding_binding_table_full_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.desired_or_reported<bool>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
        // Skip attribute BindableClusterList because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish desired value for attribute Binding BindableClusterList. Arrays are not supported");
    // Skip attribute BindingTable because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish desired value for attribute Binding BindingTable. Arrays are not supported");
  } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the Binding cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void binding_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_BINDING_BINDING_TABLE_FULL:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Binding::BindingTableFull under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_binding_binding_table_full_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BINDING_BINDABLE_CLUSTER_LIST:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Binding::BindableClusterList under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_binding_bindable_cluster_list_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_BINDING_BINDING_TABLE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Binding::BindingTable under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_binding_binding_table_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_BINDING_BINDING_TABLE_FULL) {
          uic_mqtt_dotdot_binding_binding_table_full_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.reported<bool>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
        // Skip attribute BindableClusterList because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish reported value for attribute Binding BindableClusterList. Arrays are not supported");
    // Skip attribute BindingTable because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish reported value for attribute Binding BindingTable. Arrays are not supported");
  } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void binding_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/Binding/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_binding_publish_cluster_revision(base_topic.c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_binding_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/Binding";
      sl_log_debug(LOG_TAG, "No more attributes supported for Binding cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the SystemMetrics cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void system_metrics_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK != unify_dotdot_attributes_get_unid()(updated_node, unid)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_REPORTING_INTERVAL_SECONDS) {
          uic_mqtt_dotdot_system_metrics_reporting_interval_seconds_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
        // Skip attribute CPUUsagePercent because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish desired value for attribute SystemMetrics CPUUsagePercent. Arrays are not supported");
    // Skip attribute CPUFrequencyMHz because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish desired value for attribute SystemMetrics CPUFrequencyMHz. Arrays are not supported");
    // Skip attribute CPUAverageUsagePercent because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish desired value for attribute SystemMetrics CPUAverageUsagePercent. Arrays are not supported");
    // Skip attribute CPUMinUsagePercent because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish desired value for attribute SystemMetrics CPUMinUsagePercent. Arrays are not supported");
    // Skip attribute CPUMaxUsagePercent because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish desired value for attribute SystemMetrics CPUMaxUsagePercent. Arrays are not supported");
      if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_TOTALMB) {
          uic_mqtt_dotdot_system_metrics_ram_totalmb_publish(
            base_topic.c_str(),
            static_cast<double>(attr.desired_or_reported<double>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_FREEMB) {
          uic_mqtt_dotdot_system_metrics_ram_freemb_publish(
            base_topic.c_str(),
            static_cast<double>(attr.desired_or_reported<double>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_AVAILABLEMB) {
          uic_mqtt_dotdot_system_metrics_ram_availablemb_publish(
            base_topic.c_str(),
            static_cast<double>(attr.desired_or_reported<double>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SWAP_MEMORY_TOTALMB) {
          uic_mqtt_dotdot_system_metrics_swap_memory_totalmb_publish(
            base_topic.c_str(),
            static_cast<double>(attr.desired_or_reported<double>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SWAP_MEMORY_USEDMB) {
          uic_mqtt_dotdot_system_metrics_swap_memory_usedmb_publish(
            base_topic.c_str(),
            static_cast<double>(attr.desired_or_reported<double>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_VIRTUAL_MEMORY_TOTALMB) {
          uic_mqtt_dotdot_system_metrics_virtual_memory_totalmb_publish(
            base_topic.c_str(),
            static_cast<double>(attr.desired_or_reported<double>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_VIRTUAL_MEMORY_USEDMB) {
          uic_mqtt_dotdot_system_metrics_virtual_memory_usedmb_publish(
            base_topic.c_str(),
            static_cast<double>(attr.desired_or_reported<double>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
        // Skip attribute DisksUsage because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish desired value for attribute SystemMetrics DisksUsage. Arrays are not supported");
    // Skip attribute DisksCounters because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish desired value for attribute SystemMetrics DisksCounters. Arrays are not supported");
    // Skip attribute NetworkInterfacesData because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish desired value for attribute SystemMetrics NetworkInterfacesData. Arrays are not supported");
    // Skip attribute WirelessNetworkInterfacesData because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish desired value for attribute SystemMetrics WirelessNetworkInterfacesData. Arrays are not supported");
      if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_HOSTNAME) {
          std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
          uic_mqtt_dotdot_system_metrics_hostname_publish(
            base_topic.c_str(),
            static_cast<const char*>(str_desired.data()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_FQDN) {
          std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
          uic_mqtt_dotdot_system_metrics_fqdn_publish(
            base_topic.c_str(),
            static_cast<const char*>(str_desired.data()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_UPTIME_MINUTES) {
          uic_mqtt_dotdot_system_metrics_uptime_minutes_publish(
            base_topic.c_str(),
            static_cast<uint64_t>(attr.desired_or_reported<uint64_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CURRENT_TEMPERATURE_CELCIUS) {
          uic_mqtt_dotdot_system_metrics_current_temperature_celcius_publish(
            base_topic.c_str(),
            static_cast<double>(attr.desired_or_reported<double>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_AVERAGE_TEMPERATURE_CELCIUS) {
          uic_mqtt_dotdot_system_metrics_average_temperature_celcius_publish(
            base_topic.c_str(),
            static_cast<double>(attr.desired_or_reported<double>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_MIN_TEMPERATURE_CELCIUS) {
          uic_mqtt_dotdot_system_metrics_min_temperature_celcius_publish(
            base_topic.c_str(),
            static_cast<double>(attr.desired_or_reported<double>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_MAX_TEMPERATURE_CELCIUS) {
          uic_mqtt_dotdot_system_metrics_max_temperature_celcius_publish(
            base_topic.c_str(),
            static_cast<double>(attr.desired_or_reported<double>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_POWER_PLUGGED) {
          uic_mqtt_dotdot_system_metrics_power_plugged_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.desired_or_reported<bool>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_BATTERY_PERCENTAGE) {
          uic_mqtt_dotdot_system_metrics_battery_percentage_publish(
            base_topic.c_str(),
            static_cast<double>(attr.desired_or_reported<double>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SYSTEM_INTERRUPTS) {
          uic_mqtt_dotdot_system_metrics_system_interrupts_publish(
            base_topic.c_str(),
            static_cast<uint64_t>(attr.desired_or_reported<uint64_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the SystemMetrics cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void system_metrics_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK != unify_dotdot_attributes_get_unid()(updated_node, unid)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_REPORTING_INTERVAL_SECONDS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining SystemMetrics::ReportingIntervalSeconds under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_system_metrics_reporting_interval_seconds_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_USAGE_PERCENT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining SystemMetrics::CPUUsagePercent under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_system_metrics_cpu_usage_percent_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_FREQUENCYM_HZ:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining SystemMetrics::CPUFrequencyMHz under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_system_metrics_cpu_frequencym_hz_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_AVERAGE_USAGE_PERCENT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining SystemMetrics::CPUAverageUsagePercent under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_system_metrics_cpu_average_usage_percent_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_MIN_USAGE_PERCENT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining SystemMetrics::CPUMinUsagePercent under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_system_metrics_cpu_min_usage_percent_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_MAX_USAGE_PERCENT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining SystemMetrics::CPUMaxUsagePercent under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_system_metrics_cpu_max_usage_percent_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_TOTALMB:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining SystemMetrics::RAMTotalMB under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_system_metrics_ram_totalmb_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_FREEMB:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining SystemMetrics::RAMFreeMB under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_system_metrics_ram_freemb_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_AVAILABLEMB:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining SystemMetrics::RAMAvailableMB under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_system_metrics_ram_availablemb_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SWAP_MEMORY_TOTALMB:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining SystemMetrics::SWAPMemoryTotalMB under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_system_metrics_swap_memory_totalmb_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SWAP_MEMORY_USEDMB:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining SystemMetrics::SWAPMemoryUsedMB under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_system_metrics_swap_memory_usedmb_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_VIRTUAL_MEMORY_TOTALMB:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining SystemMetrics::VirtualMemoryTotalMB under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_system_metrics_virtual_memory_totalmb_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_VIRTUAL_MEMORY_USEDMB:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining SystemMetrics::VirtualMemoryUsedMB under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_system_metrics_virtual_memory_usedmb_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_DISKS_USAGE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining SystemMetrics::DisksUsage under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_system_metrics_disks_usage_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_DISKS_COUNTERS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining SystemMetrics::DisksCounters under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_system_metrics_disks_counters_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_NETWORK_INTERFACES_DATA:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining SystemMetrics::NetworkInterfacesData under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_system_metrics_network_interfaces_data_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_WIRELESS_NETWORK_INTERFACES_DATA:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining SystemMetrics::WirelessNetworkInterfacesData under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_system_metrics_wireless_network_interfaces_data_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_HOSTNAME:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining SystemMetrics::Hostname under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_system_metrics_hostname_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_FQDN:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining SystemMetrics::FQDN under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_system_metrics_fqdn_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_UPTIME_MINUTES:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining SystemMetrics::UptimeMinutes under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_system_metrics_uptime_minutes_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CURRENT_TEMPERATURE_CELCIUS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining SystemMetrics::CurrentTemperatureCelcius under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_system_metrics_current_temperature_celcius_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_AVERAGE_TEMPERATURE_CELCIUS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining SystemMetrics::AverageTemperatureCelcius under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_system_metrics_average_temperature_celcius_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_MIN_TEMPERATURE_CELCIUS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining SystemMetrics::MinTemperatureCelcius under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_system_metrics_min_temperature_celcius_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_MAX_TEMPERATURE_CELCIUS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining SystemMetrics::MaxTemperatureCelcius under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_system_metrics_max_temperature_celcius_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_POWER_PLUGGED:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining SystemMetrics::PowerPlugged under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_system_metrics_power_plugged_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_BATTERY_PERCENTAGE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining SystemMetrics::BatteryPercentage under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_system_metrics_battery_percentage_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SYSTEM_INTERRUPTS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining SystemMetrics::SystemInterrupts under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_system_metrics_system_interrupts_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_REPORTING_INTERVAL_SECONDS) {
          uic_mqtt_dotdot_system_metrics_reporting_interval_seconds_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
        // Skip attribute CPUUsagePercent because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish reported value for attribute SystemMetrics CPUUsagePercent. Arrays are not supported");
    // Skip attribute CPUFrequencyMHz because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish reported value for attribute SystemMetrics CPUFrequencyMHz. Arrays are not supported");
    // Skip attribute CPUAverageUsagePercent because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish reported value for attribute SystemMetrics CPUAverageUsagePercent. Arrays are not supported");
    // Skip attribute CPUMinUsagePercent because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish reported value for attribute SystemMetrics CPUMinUsagePercent. Arrays are not supported");
    // Skip attribute CPUMaxUsagePercent because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish reported value for attribute SystemMetrics CPUMaxUsagePercent. Arrays are not supported");
      if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_TOTALMB) {
          uic_mqtt_dotdot_system_metrics_ram_totalmb_publish(
            base_topic.c_str(),
            static_cast<double>(attr.reported<double>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_FREEMB) {
          uic_mqtt_dotdot_system_metrics_ram_freemb_publish(
            base_topic.c_str(),
            static_cast<double>(attr.reported<double>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_AVAILABLEMB) {
          uic_mqtt_dotdot_system_metrics_ram_availablemb_publish(
            base_topic.c_str(),
            static_cast<double>(attr.reported<double>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SWAP_MEMORY_TOTALMB) {
          uic_mqtt_dotdot_system_metrics_swap_memory_totalmb_publish(
            base_topic.c_str(),
            static_cast<double>(attr.reported<double>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SWAP_MEMORY_USEDMB) {
          uic_mqtt_dotdot_system_metrics_swap_memory_usedmb_publish(
            base_topic.c_str(),
            static_cast<double>(attr.reported<double>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_VIRTUAL_MEMORY_TOTALMB) {
          uic_mqtt_dotdot_system_metrics_virtual_memory_totalmb_publish(
            base_topic.c_str(),
            static_cast<double>(attr.reported<double>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_VIRTUAL_MEMORY_USEDMB) {
          uic_mqtt_dotdot_system_metrics_virtual_memory_usedmb_publish(
            base_topic.c_str(),
            static_cast<double>(attr.reported<double>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
        // Skip attribute DisksUsage because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish reported value for attribute SystemMetrics DisksUsage. Arrays are not supported");
    // Skip attribute DisksCounters because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish reported value for attribute SystemMetrics DisksCounters. Arrays are not supported");
    // Skip attribute NetworkInterfacesData because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish reported value for attribute SystemMetrics NetworkInterfacesData. Arrays are not supported");
    // Skip attribute WirelessNetworkInterfacesData because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish reported value for attribute SystemMetrics WirelessNetworkInterfacesData. Arrays are not supported");
      if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_HOSTNAME) {
          std::vector<char> str_desired = attr.reported<std::vector<char>>();
          uic_mqtt_dotdot_system_metrics_hostname_publish(
            base_topic.c_str(),
            static_cast<const char*>( str_desired.data() ),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_FQDN) {
          std::vector<char> str_desired = attr.reported<std::vector<char>>();
          uic_mqtt_dotdot_system_metrics_fqdn_publish(
            base_topic.c_str(),
            static_cast<const char*>( str_desired.data() ),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_UPTIME_MINUTES) {
          uic_mqtt_dotdot_system_metrics_uptime_minutes_publish(
            base_topic.c_str(),
            static_cast<uint64_t>(attr.reported<uint64_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CURRENT_TEMPERATURE_CELCIUS) {
          uic_mqtt_dotdot_system_metrics_current_temperature_celcius_publish(
            base_topic.c_str(),
            static_cast<double>(attr.reported<double>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_AVERAGE_TEMPERATURE_CELCIUS) {
          uic_mqtt_dotdot_system_metrics_average_temperature_celcius_publish(
            base_topic.c_str(),
            static_cast<double>(attr.reported<double>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_MIN_TEMPERATURE_CELCIUS) {
          uic_mqtt_dotdot_system_metrics_min_temperature_celcius_publish(
            base_topic.c_str(),
            static_cast<double>(attr.reported<double>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_MAX_TEMPERATURE_CELCIUS) {
          uic_mqtt_dotdot_system_metrics_max_temperature_celcius_publish(
            base_topic.c_str(),
            static_cast<double>(attr.reported<double>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_POWER_PLUGGED) {
          uic_mqtt_dotdot_system_metrics_power_plugged_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.reported<bool>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_BATTERY_PERCENTAGE) {
          uic_mqtt_dotdot_system_metrics_battery_percentage_publish(
            base_topic.c_str(),
            static_cast<double>(attr.reported<double>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SYSTEM_INTERRUPTS) {
          uic_mqtt_dotdot_system_metrics_system_interrupts_publish(
            base_topic.c_str(),
            static_cast<uint64_t>(attr.reported<uint64_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void system_metrics_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK != unify_dotdot_attributes_get_unid()(updated_node, unid)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/SystemMetrics/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_system_metrics_publish_cluster_revision(base_topic.c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_system_metrics_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/SystemMetrics";
      sl_log_debug(LOG_TAG, "No more attributes supported for SystemMetrics cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the ApplicationMonitoring cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void application_monitoring_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK != unify_dotdot_attributes_get_unid()(updated_node, unid)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_NAME) {
          std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
          uic_mqtt_dotdot_application_monitoring_application_name_publish(
            base_topic.c_str(),
            static_cast<const char*>(str_desired.data()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_VERSION) {
          std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
          uic_mqtt_dotdot_application_monitoring_application_version_publish(
            base_topic.c_str(),
            static_cast<const char*>(str_desired.data()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CONNECTED) {
          uic_mqtt_dotdot_application_monitoring_application_connected_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.desired_or_reported<bool>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
        // Skip attribute ApplicationMQTTTopics because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish desired value for attribute ApplicationMonitoring ApplicationMQTTTopics. Arrays are not supported");
      if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_UPTIME_MINUTES) {
          uic_mqtt_dotdot_application_monitoring_uptime_minutes_publish(
            base_topic.c_str(),
            static_cast<uint64_t>(attr.desired_or_reported<uint64_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_PROCESS_ID) {
          uic_mqtt_dotdot_application_monitoring_process_id_publish(
            base_topic.c_str(),
            static_cast<uint64_t>(attr.desired_or_reported<uint64_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_HOSTNAME) {
          std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
          uic_mqtt_dotdot_application_monitoring_hostname_publish(
            base_topic.c_str(),
            static_cast<const char*>(str_desired.data()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_FQDN) {
          std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
          uic_mqtt_dotdot_application_monitoring_fqdn_publish(
            base_topic.c_str(),
            static_cast<const char*>(str_desired.data()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_LOGGING_ENABLED) {
          uic_mqtt_dotdot_application_monitoring_mqtt_logging_enabled_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.desired_or_reported<bool>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_LOGGING_LEVEL) {
          uic_mqtt_dotdot_application_monitoring_mqtt_logging_level_publish(
            base_topic.c_str(),
            static_cast<LoggingLevelEnum>(attr.desired_or_reported<LoggingLevelEnum>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_STATISTICS_REPORTING_INTERVAL_SECONDS) {
          uic_mqtt_dotdot_application_monitoring_mqtt_statistics_reporting_interval_seconds_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MESSAGES_SENT) {
          uic_mqtt_dotdot_application_monitoring_mqtt_messages_sent_publish(
            base_topic.c_str(),
            static_cast<uint64_t>(attr.desired_or_reported<uint64_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MESSAGES_RECEIVED) {
          uic_mqtt_dotdot_application_monitoring_mqtt_messages_received_publish(
            base_topic.c_str(),
            static_cast<uint64_t>(attr.desired_or_reported<uint64_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_SUBSCRIPTION_COUNT) {
          uic_mqtt_dotdot_application_monitoring_mqtt_subscription_count_publish(
            base_topic.c_str(),
            static_cast<uint64_t>(attr.desired_or_reported<uint64_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_AVERAGE_DELIVERY_TIME_SECONDS) {
          uic_mqtt_dotdot_application_monitoring_mqtt_average_delivery_time_seconds_publish(
            base_topic.c_str(),
            static_cast<double>(attr.desired_or_reported<double>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MIN_DELIVERY_TIME_SECONDS) {
          uic_mqtt_dotdot_application_monitoring_mqtt_min_delivery_time_seconds_publish(
            base_topic.c_str(),
            static_cast<double>(attr.desired_or_reported<double>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MAX_DELIVERY_TIME_SECONDS) {
          uic_mqtt_dotdot_application_monitoring_mqtt_max_delivery_time_seconds_publish(
            base_topic.c_str(),
            static_cast<double>(attr.desired_or_reported<double>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_STATISTICS_REPORTING_INTERVAL_SECONDS) {
          uic_mqtt_dotdot_application_monitoring_application_statistics_reporting_interval_seconds_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CPU_USAGE_PERCENT) {
          uic_mqtt_dotdot_application_monitoring_application_cpu_usage_percent_publish(
            base_topic.c_str(),
            static_cast<double>(attr.desired_or_reported<double>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CPU_AVERAGE_USAGE_PERCENT) {
          uic_mqtt_dotdot_application_monitoring_application_cpu_average_usage_percent_publish(
            base_topic.c_str(),
            static_cast<double>(attr.desired_or_reported<double>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CPU_MIN_USAGE_PERCENT) {
          uic_mqtt_dotdot_application_monitoring_application_cpu_min_usage_percent_publish(
            base_topic.c_str(),
            static_cast<double>(attr.desired_or_reported<double>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CPU_MAX_USAGE_PERCENT) {
          uic_mqtt_dotdot_application_monitoring_application_cpu_max_usage_percent_publish(
            base_topic.c_str(),
            static_cast<double>(attr.desired_or_reported<double>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_RAM_USAGEMB) {
          uic_mqtt_dotdot_application_monitoring_application_ram_usagemb_publish(
            base_topic.c_str(),
            static_cast<double>(attr.desired_or_reported<double>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the ApplicationMonitoring cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void application_monitoring_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK != unify_dotdot_attributes_get_unid()(updated_node, unid)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_NAME:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ApplicationMonitoring::ApplicationName under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_application_monitoring_application_name_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_VERSION:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ApplicationMonitoring::ApplicationVersion under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_application_monitoring_application_version_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CONNECTED:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ApplicationMonitoring::ApplicationConnected under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_application_monitoring_application_connected_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_MQTT_TOPICS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ApplicationMonitoring::ApplicationMQTTTopics under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_application_monitoring_application_mqtt_topics_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_UPTIME_MINUTES:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ApplicationMonitoring::UptimeMinutes under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_application_monitoring_uptime_minutes_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_PROCESS_ID:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ApplicationMonitoring::ProcessId under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_application_monitoring_process_id_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_HOSTNAME:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ApplicationMonitoring::Hostname under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_application_monitoring_hostname_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_FQDN:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ApplicationMonitoring::FQDN under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_application_monitoring_fqdn_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_LOGGING_ENABLED:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ApplicationMonitoring::MQTTLoggingEnabled under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_application_monitoring_mqtt_logging_enabled_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_LOGGING_LEVEL:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ApplicationMonitoring::MQTTLoggingLevel under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_application_monitoring_mqtt_logging_level_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_STATISTICS_REPORTING_INTERVAL_SECONDS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ApplicationMonitoring::MQTTStatisticsReportingIntervalSeconds under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_application_monitoring_mqtt_statistics_reporting_interval_seconds_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MESSAGES_SENT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ApplicationMonitoring::MQTTMessagesSent under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_application_monitoring_mqtt_messages_sent_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MESSAGES_RECEIVED:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ApplicationMonitoring::MQTTMessagesReceived under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_application_monitoring_mqtt_messages_received_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_SUBSCRIPTION_COUNT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ApplicationMonitoring::MQTTSubscriptionCount under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_application_monitoring_mqtt_subscription_count_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_AVERAGE_DELIVERY_TIME_SECONDS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ApplicationMonitoring::MQTTAverageDeliveryTimeSeconds under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_application_monitoring_mqtt_average_delivery_time_seconds_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MIN_DELIVERY_TIME_SECONDS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ApplicationMonitoring::MQTTMinDeliveryTimeSeconds under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_application_monitoring_mqtt_min_delivery_time_seconds_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MAX_DELIVERY_TIME_SECONDS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ApplicationMonitoring::MQTTMaxDeliveryTimeSeconds under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_application_monitoring_mqtt_max_delivery_time_seconds_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_STATISTICS_REPORTING_INTERVAL_SECONDS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ApplicationMonitoring::ApplicationStatisticsReportingIntervalSeconds under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_application_monitoring_application_statistics_reporting_interval_seconds_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CPU_USAGE_PERCENT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ApplicationMonitoring::ApplicationCPUUsagePercent under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_application_monitoring_application_cpu_usage_percent_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CPU_AVERAGE_USAGE_PERCENT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ApplicationMonitoring::ApplicationCPUAverageUsagePercent under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_application_monitoring_application_cpu_average_usage_percent_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CPU_MIN_USAGE_PERCENT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ApplicationMonitoring::ApplicationCPUMinUsagePercent under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_application_monitoring_application_cpu_min_usage_percent_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CPU_MAX_USAGE_PERCENT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ApplicationMonitoring::ApplicationCPUMaxUsagePercent under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_application_monitoring_application_cpu_max_usage_percent_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_RAM_USAGEMB:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ApplicationMonitoring::ApplicationRAMUsageMB under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_application_monitoring_application_ram_usagemb_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_NAME) {
          std::vector<char> str_desired = attr.reported<std::vector<char>>();
          uic_mqtt_dotdot_application_monitoring_application_name_publish(
            base_topic.c_str(),
            static_cast<const char*>( str_desired.data() ),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_VERSION) {
          std::vector<char> str_desired = attr.reported<std::vector<char>>();
          uic_mqtt_dotdot_application_monitoring_application_version_publish(
            base_topic.c_str(),
            static_cast<const char*>( str_desired.data() ),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CONNECTED) {
          uic_mqtt_dotdot_application_monitoring_application_connected_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.reported<bool>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
        // Skip attribute ApplicationMQTTTopics because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish reported value for attribute ApplicationMonitoring ApplicationMQTTTopics. Arrays are not supported");
      if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_UPTIME_MINUTES) {
          uic_mqtt_dotdot_application_monitoring_uptime_minutes_publish(
            base_topic.c_str(),
            static_cast<uint64_t>(attr.reported<uint64_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_PROCESS_ID) {
          uic_mqtt_dotdot_application_monitoring_process_id_publish(
            base_topic.c_str(),
            static_cast<uint64_t>(attr.reported<uint64_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_HOSTNAME) {
          std::vector<char> str_desired = attr.reported<std::vector<char>>();
          uic_mqtt_dotdot_application_monitoring_hostname_publish(
            base_topic.c_str(),
            static_cast<const char*>( str_desired.data() ),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_FQDN) {
          std::vector<char> str_desired = attr.reported<std::vector<char>>();
          uic_mqtt_dotdot_application_monitoring_fqdn_publish(
            base_topic.c_str(),
            static_cast<const char*>( str_desired.data() ),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_LOGGING_ENABLED) {
          uic_mqtt_dotdot_application_monitoring_mqtt_logging_enabled_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.reported<bool>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_LOGGING_LEVEL) {
          uic_mqtt_dotdot_application_monitoring_mqtt_logging_level_publish(
            base_topic.c_str(),
            static_cast<LoggingLevelEnum>(attr.reported<LoggingLevelEnum>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_STATISTICS_REPORTING_INTERVAL_SECONDS) {
          uic_mqtt_dotdot_application_monitoring_mqtt_statistics_reporting_interval_seconds_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MESSAGES_SENT) {
          uic_mqtt_dotdot_application_monitoring_mqtt_messages_sent_publish(
            base_topic.c_str(),
            static_cast<uint64_t>(attr.reported<uint64_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MESSAGES_RECEIVED) {
          uic_mqtt_dotdot_application_monitoring_mqtt_messages_received_publish(
            base_topic.c_str(),
            static_cast<uint64_t>(attr.reported<uint64_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_SUBSCRIPTION_COUNT) {
          uic_mqtt_dotdot_application_monitoring_mqtt_subscription_count_publish(
            base_topic.c_str(),
            static_cast<uint64_t>(attr.reported<uint64_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_AVERAGE_DELIVERY_TIME_SECONDS) {
          uic_mqtt_dotdot_application_monitoring_mqtt_average_delivery_time_seconds_publish(
            base_topic.c_str(),
            static_cast<double>(attr.reported<double>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MIN_DELIVERY_TIME_SECONDS) {
          uic_mqtt_dotdot_application_monitoring_mqtt_min_delivery_time_seconds_publish(
            base_topic.c_str(),
            static_cast<double>(attr.reported<double>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MAX_DELIVERY_TIME_SECONDS) {
          uic_mqtt_dotdot_application_monitoring_mqtt_max_delivery_time_seconds_publish(
            base_topic.c_str(),
            static_cast<double>(attr.reported<double>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_STATISTICS_REPORTING_INTERVAL_SECONDS) {
          uic_mqtt_dotdot_application_monitoring_application_statistics_reporting_interval_seconds_publish(
            base_topic.c_str(),
            static_cast<uint32_t>(attr.reported<uint32_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CPU_USAGE_PERCENT) {
          uic_mqtt_dotdot_application_monitoring_application_cpu_usage_percent_publish(
            base_topic.c_str(),
            static_cast<double>(attr.reported<double>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CPU_AVERAGE_USAGE_PERCENT) {
          uic_mqtt_dotdot_application_monitoring_application_cpu_average_usage_percent_publish(
            base_topic.c_str(),
            static_cast<double>(attr.reported<double>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CPU_MIN_USAGE_PERCENT) {
          uic_mqtt_dotdot_application_monitoring_application_cpu_min_usage_percent_publish(
            base_topic.c_str(),
            static_cast<double>(attr.reported<double>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CPU_MAX_USAGE_PERCENT) {
          uic_mqtt_dotdot_application_monitoring_application_cpu_max_usage_percent_publish(
            base_topic.c_str(),
            static_cast<double>(attr.reported<double>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_RAM_USAGEMB) {
          uic_mqtt_dotdot_application_monitoring_application_ram_usagemb_publish(
            base_topic.c_str(),
            static_cast<double>(attr.reported<double>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void application_monitoring_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK != unify_dotdot_attributes_get_unid()(updated_node, unid)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/ApplicationMonitoring/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_application_monitoring_publish_cluster_revision(base_topic.c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_application_monitoring_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/ApplicationMonitoring";
      sl_log_debug(LOG_TAG, "No more attributes supported for ApplicationMonitoring cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the NameAndLocation cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void name_and_location_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_NAME_AND_LOCATION_NAME) {
          std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
          uic_mqtt_dotdot_name_and_location_name_publish(
            base_topic.c_str(),
            static_cast<const char*>(str_desired.data()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_NAME_AND_LOCATION_LOCATION) {
          std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
          uic_mqtt_dotdot_name_and_location_location_publish(
            base_topic.c_str(),
            static_cast<const char*>(str_desired.data()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the NameAndLocation cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void name_and_location_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_NAME_AND_LOCATION_NAME:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining NameAndLocation::Name under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_name_and_location_name_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_NAME_AND_LOCATION_LOCATION:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining NameAndLocation::Location under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_name_and_location_location_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_NAME_AND_LOCATION_NAME) {
          std::vector<char> str_desired = attr.reported<std::vector<char>>();
          uic_mqtt_dotdot_name_and_location_name_publish(
            base_topic.c_str(),
            static_cast<const char*>( str_desired.data() ),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_NAME_AND_LOCATION_LOCATION) {
          std::vector<char> str_desired = attr.reported<std::vector<char>>();
          uic_mqtt_dotdot_name_and_location_location_publish(
            base_topic.c_str(),
            static_cast<const char*>( str_desired.data() ),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void name_and_location_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/NameAndLocation/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_name_and_location_publish_cluster_revision(base_topic.c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_name_and_location_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/NameAndLocation";
      sl_log_debug(LOG_TAG, "No more attributes supported for NameAndLocation cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the ConfigurationParameters cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void configuration_parameters_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
    // Skip attribute ConfigurationParameters because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish desired value for attribute ConfigurationParameters ConfigurationParameters. Arrays are not supported");
  } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the ConfigurationParameters cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void configuration_parameters_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_CONFIGURATION_PARAMETERS_CONFIGURATION_PARAMETERS:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ConfigurationParameters::ConfigurationParameters under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_configuration_parameters_configuration_parameters_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
    // Skip attribute ConfigurationParameters because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish reported value for attribute ConfigurationParameters ConfigurationParameters. Arrays are not supported");
  } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void configuration_parameters_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/ConfigurationParameters/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_configuration_parameters_publish_cluster_revision(base_topic.c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_configuration_parameters_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/ConfigurationParameters";
      sl_log_debug(LOG_TAG, "No more attributes supported for ConfigurationParameters cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the AoXLocator cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void aox_locator_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_REPORTING_MODE) {
          uic_mqtt_dotdot_aox_locator_reporting_mode_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_POSITION_AND_ORIENTATION_VALID) {
          uic_mqtt_dotdot_aox_locator_position_and_orientation_valid_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.desired_or_reported<bool>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
        // Skip attribute PositionAndOrientation because it is a struct,
    // we typically don't save them as structs in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish desired value for attribute AoXLocator PositionAndOrientation. Structs are not supported");
    // Skip attribute AzimuthMask because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish desired value for attribute AoXLocator AzimuthMask. Arrays are not supported");
    // Skip attribute ElevationMask because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish desired value for attribute AoXLocator ElevationMask. Arrays are not supported");
    // Skip attribute AllowList because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish desired value for attribute AoXLocator AllowList. Arrays are not supported");
      if (type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AOX_MODE) {
          uic_mqtt_dotdot_aox_locator_aox_mode_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_MODE) {
          uic_mqtt_dotdot_aox_locator_antenna_mode_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
        // Skip attribute AntennaArray because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish desired value for attribute AoXLocator AntennaArray. Arrays are not supported");
      if (type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_PERIOD_SAMPLES) {
          uic_mqtt_dotdot_aox_locator_period_samples_publish(
            base_topic.c_str(),
            static_cast<int8_t>(attr.desired_or_reported<int8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING) {
          uic_mqtt_dotdot_aox_locator_angle_filtering_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.desired_or_reported<bool>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING_WEIGHT) {
          uic_mqtt_dotdot_aox_locator_angle_filtering_weight_publish(
            base_topic.c_str(),
            static_cast<double>(attr.desired_or_reported<double>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_TIMEOUT) {
          uic_mqtt_dotdot_aox_locator_angle_correction_timeout_publish(
            base_topic.c_str(),
            static_cast<int8_t>(attr.desired_or_reported<int8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_DELAY) {
          uic_mqtt_dotdot_aox_locator_angle_correction_delay_publish(
            base_topic.c_str(),
            static_cast<int8_t>(attr.desired_or_reported<int8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_MODE) {
          uic_mqtt_dotdot_aox_locator_cte_mode_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_SAMPLING_INTERVAL) {
          uic_mqtt_dotdot_aox_locator_cte_sampling_interval_publish(
            base_topic.c_str(),
            static_cast<int8_t>(attr.desired_or_reported<int8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_LENGTH) {
          uic_mqtt_dotdot_aox_locator_cte_length_publish(
            base_topic.c_str(),
            static_cast<int8_t>(attr.desired_or_reported<int8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_SLOT_DURATION) {
          uic_mqtt_dotdot_aox_locator_slot_duration_publish(
            base_topic.c_str(),
            static_cast<int8_t>(attr.desired_or_reported<int8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the AoXLocator cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void aox_locator_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_REPORTING_MODE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining AoXLocator::ReportingMode under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_aox_locator_reporting_mode_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_POSITION_AND_ORIENTATION_VALID:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining AoXLocator::PositionAndOrientationValid under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_aox_locator_position_and_orientation_valid_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_POSITION_AND_ORIENTATION:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining AoXLocator::PositionAndOrientation under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_aox_locator_position_and_orientation_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AZIMUTH_MASK:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining AoXLocator::AzimuthMask under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_aox_locator_azimuth_mask_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ELEVATION_MASK:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining AoXLocator::ElevationMask under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_aox_locator_elevation_mask_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ALLOW_LIST:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining AoXLocator::AllowList under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_aox_locator_allow_list_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AOX_MODE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining AoXLocator::AoXMode under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_aox_locator_aox_mode_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_MODE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining AoXLocator::AntennaMode under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_aox_locator_antenna_mode_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_ARRAY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining AoXLocator::AntennaArray under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_aox_locator_antenna_array_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_PERIOD_SAMPLES:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining AoXLocator::PeriodSamples under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_aox_locator_period_samples_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining AoXLocator::AngleFiltering under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_aox_locator_angle_filtering_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING_WEIGHT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining AoXLocator::AngleFilteringWeight under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_aox_locator_angle_filtering_weight_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_TIMEOUT:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining AoXLocator::AngleCorrectionTimeout under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_aox_locator_angle_correction_timeout_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_DELAY:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining AoXLocator::AngleCorrectionDelay under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_aox_locator_angle_correction_delay_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_MODE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining AoXLocator::CTEMode under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_aox_locator_cte_mode_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_SAMPLING_INTERVAL:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining AoXLocator::CTESamplingInterval under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_aox_locator_cte_sampling_interval_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_LENGTH:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining AoXLocator::CTELength under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_aox_locator_cte_length_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_SLOT_DURATION:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining AoXLocator::SlotDuration under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_aox_locator_slot_duration_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_REPORTING_MODE) {
          uic_mqtt_dotdot_aox_locator_reporting_mode_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_POSITION_AND_ORIENTATION_VALID) {
          uic_mqtt_dotdot_aox_locator_position_and_orientation_valid_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.reported<bool>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
        // Skip attribute PositionAndOrientation because it is a struct,
    // we typically don't save them as structs in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish reported value for attribute AoXLocator PositionAndOrientation. Structs are not supported");
    // Skip attribute AzimuthMask because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish reported value for attribute AoXLocator AzimuthMask. Arrays are not supported");
    // Skip attribute ElevationMask because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish reported value for attribute AoXLocator ElevationMask. Arrays are not supported");
    // Skip attribute AllowList because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish reported value for attribute AoXLocator AllowList. Arrays are not supported");
      if (type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AOX_MODE) {
          uic_mqtt_dotdot_aox_locator_aox_mode_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_MODE) {
          uic_mqtt_dotdot_aox_locator_antenna_mode_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
        // Skip attribute AntennaArray because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish reported value for attribute AoXLocator AntennaArray. Arrays are not supported");
      if (type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_PERIOD_SAMPLES) {
          uic_mqtt_dotdot_aox_locator_period_samples_publish(
            base_topic.c_str(),
            static_cast<int8_t>(attr.reported<int8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING) {
          uic_mqtt_dotdot_aox_locator_angle_filtering_publish(
            base_topic.c_str(),
            static_cast<bool>(attr.reported<bool>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING_WEIGHT) {
          uic_mqtt_dotdot_aox_locator_angle_filtering_weight_publish(
            base_topic.c_str(),
            static_cast<double>(attr.reported<double>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_TIMEOUT) {
          uic_mqtt_dotdot_aox_locator_angle_correction_timeout_publish(
            base_topic.c_str(),
            static_cast<int8_t>(attr.reported<int8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_DELAY) {
          uic_mqtt_dotdot_aox_locator_angle_correction_delay_publish(
            base_topic.c_str(),
            static_cast<int8_t>(attr.reported<int8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_MODE) {
          uic_mqtt_dotdot_aox_locator_cte_mode_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_SAMPLING_INTERVAL) {
          uic_mqtt_dotdot_aox_locator_cte_sampling_interval_publish(
            base_topic.c_str(),
            static_cast<int8_t>(attr.reported<int8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_LENGTH) {
          uic_mqtt_dotdot_aox_locator_cte_length_publish(
            base_topic.c_str(),
            static_cast<int8_t>(attr.reported<int8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_SLOT_DURATION) {
          uic_mqtt_dotdot_aox_locator_slot_duration_publish(
            base_topic.c_str(),
            static_cast<int8_t>(attr.reported<int8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void aox_locator_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/AoXLocator/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_aox_locator_publish_cluster_revision(base_topic.c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_aox_locator_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/AoXLocator";
      sl_log_debug(LOG_TAG, "No more attributes supported for AoXLocator cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the AoXPositionEstimation cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void aox_position_estimation_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
    // Skip attribute Position because it is a struct,
    // we typically don't save them as structs in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish desired value for attribute AoXPositionEstimation Position. Structs are not supported");
  } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the AoXPositionEstimation cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void aox_position_estimation_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_AOX_POSITION_ESTIMATION_POSITION:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining AoXPositionEstimation::Position under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_aox_position_estimation_position_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
    // Skip attribute Position because it is a struct,
    // we typically don't save them as structs in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish reported value for attribute AoXPositionEstimation Position. Structs are not supported");
  } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void aox_position_estimation_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/AoXPositionEstimation/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_aox_position_estimation_publish_cluster_revision(base_topic.c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_aox_position_estimation_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/AoXPositionEstimation";
      sl_log_debug(LOG_TAG, "No more attributes supported for AoXPositionEstimation cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the ProtocolController-NetworkManagement cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void protocol_controller_network_management_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK != unify_dotdot_attributes_get_unid()(updated_node, unid)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
    // Skip attribute NetworkManagementState because it is a struct,
    // we typically don't save them as structs in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish desired value for attribute ProtocolController-NetworkManagement NetworkManagementState. Structs are not supported");
  } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the ProtocolController-NetworkManagement cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void protocol_controller_network_management_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK != unify_dotdot_attributes_get_unid()(updated_node, unid)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_NETWORK_MANAGEMENT_NETWORK_MANAGEMENT_STATE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining ProtocolController-NetworkManagement::NetworkManagementState under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_protocol_controller_network_management_network_management_state_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
    // Skip attribute NetworkManagementState because it is a struct,
    // we typically don't save them as structs in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish reported value for attribute ProtocolController-NetworkManagement NetworkManagementState. Structs are not supported");
  } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void protocol_controller_network_management_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK != unify_dotdot_attributes_get_unid()(updated_node, unid)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/ProtocolController/NetworkManagement/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_protocol_controller_network_management_publish_cluster_revision(base_topic.c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_protocol_controller_network_management_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/ProtocolController/NetworkManagement";
      sl_log_debug(LOG_TAG, "No more attributes supported for ProtocolController-NetworkManagement cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the Descriptor cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void descriptor_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
    // Skip attribute DeviceTypeList because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish desired value for attribute Descriptor DeviceTypeList. Arrays are not supported");
  } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the Descriptor cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void descriptor_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_DESCRIPTOR_DEVICE_TYPE_LIST:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining Descriptor::DeviceTypeList under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_descriptor_device_type_list_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
    // Skip attribute DeviceTypeList because it is an array,
    // we typically don't save them as array in the attribute store.
    sl_log_debug(LOG_TAG,"Warning: Cannot publish reported value for attribute Descriptor DeviceTypeList. Arrays are not supported");
  } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void descriptor_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/Descriptor/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_descriptor_publish_cluster_revision(base_topic.c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_descriptor_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/Descriptor";
      sl_log_debug(LOG_TAG, "No more attributes supported for Descriptor cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}


/**
 * @brief Publishes the desired value of an updated attribute store node for
 * the UnifyThermostat cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void unify_thermostat_cluster_publish_desired_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // If the value got updated but both Reported and Desired undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)
      && false == attribute_store_is_desired_defined(updated_node)) {
    sl_log_debug(LOG_TAG,
                 "Reported/Desired values are undefined. "
                 "Skipping publication");
    return;
  }

  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_THERMOSTAT_THERMOSTAT_MODE) {
          uic_mqtt_dotdot_unify_thermostat_thermostat_mode_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_THERMOSTAT_SUPPORTED_THERMOSTAT_MODE) {
          uic_mqtt_dotdot_unify_thermostat_supported_thermostat_mode_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
            UCL_MQTT_PUBLISH_TYPE_DESIRED);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
  }
}

/**
 * @brief Publishes the reported value of an updated attribute store node for
 * the UnifyThermostat cluster.
 * @param updated_node Updated attribute store node
 * @param change       Type of change applied
 */
static void unify_thermostat_cluster_publish_reported_value_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }
  if (change == ATTRIBUTE_CREATED) {
    return;
  }
  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
  if (ATTRIBUTE_STORE_INVALID_NODE
      != attribute_store_get_first_parent_with_type(
        updated_node,
        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  // clang-format off
  // clang-format on
  dotdot_endpoint_id_t endpoint_id = 0;
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);
  // clang-format on

  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    sl_log_debug(LOG_TAG,
                 "Warning: Invalid type for Attribute ID %d, "
                 "this should not happen.",
                 updated_node);
    return;
  }

  // Deletion case:
  if (change == ATTRIBUTE_DELETED) {
    // clang-format off
    switch(type) {
     case DOTDOT_ATTRIBUTE_ID_UNIFY_THERMOSTAT_THERMOSTAT_MODE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining UnifyThermostat::ThermostatMode under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_unify_thermostat_thermostat_mode_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
     case DOTDOT_ATTRIBUTE_ID_UNIFY_THERMOSTAT_SUPPORTED_THERMOSTAT_MODE:
        // clang-format on
        sl_log_debug(LOG_TAG,
                     "Unretaining UnifyThermostat::SupportedThermostatMode under topic %s",
                     base_topic.c_str());
        // clang-format off
      uic_mqtt_dotdot_unify_thermostat_supported_thermostat_mode_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
      break;
    default:
    break;
    }
    // clang-format on
    return;
  }

  // If the value got updated but undefined, we skip publication
  if (false == attribute_store_is_reported_defined(updated_node)) {
    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
    return;
  }

  // Else we assume update case:
  // clang-format off
  try {
    attribute_store::attribute attr(updated_node);
      if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_THERMOSTAT_THERMOSTAT_MODE) {
          uic_mqtt_dotdot_unify_thermostat_thermostat_mode_publish(
            base_topic.c_str(),
            static_cast<uint8_t>(attr.reported<uint8_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
          if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_THERMOSTAT_SUPPORTED_THERMOSTAT_MODE) {
          uic_mqtt_dotdot_unify_thermostat_supported_thermostat_mode_publish(
            base_topic.c_str(),
            static_cast<uint16_t>(attr.reported<uint16_t>()),
            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
        return;
      }
      } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
  }
}

static void unify_thermostat_cluster_cluster_revision_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // clang-format on
  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
    return;
  }

  // Get the UNID and EndPoint, and prepare the basic topic
  char unid[MAXIMUM_UNID_SIZE]     = {};
  dotdot_endpoint_id_t endpoint_id = 0;
  // clang-format off
  // clang-format on
  if (SL_STATUS_OK
      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
                                                     unid,
                                                     &endpoint_id)) {
    return;
  }
  // clang-format off
  // clang-format on

  std::string base_topic = "ucl/by-unid/" + std::string(unid);
  // clang-format off
  base_topic += "/ep" + std::to_string(endpoint_id);

  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
    // On attribute creation, make sure to publish the attribute revision for the first time
    std::string cluster_revision_topic = base_topic + "/UnifyThermostat/Attributes/ClusterRevision";
    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
      uic_mqtt_dotdot_unify_thermostat_publish_cluster_revision(base_topic.c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // Check if we just erased the last attribute under a cluster, if yes, unretain
    // the Cluster revision too.
    if (false == dotdot_is_any_unify_thermostat_attribute_supported(unid, endpoint_id)) {
      base_topic +=  "/UnifyThermostat";
      sl_log_debug(LOG_TAG, "No more attributes supported for UnifyThermostat cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
      uic_mqtt_unretain(base_topic.c_str());
    }
  }
}



// Initialization of the component.
sl_status_t unify_dotdot_attribute_store_attribute_publisher_init()
{
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_ZCL_VERSION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_ZCL_VERSION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_ZCL_VERSION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_APPLICATION_VERSION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_APPLICATION_VERSION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_APPLICATION_VERSION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_STACK_VERSION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_STACK_VERSION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_STACK_VERSION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_HW_VERSION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_HW_VERSION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_HW_VERSION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_MANUFACTURER_NAME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_MANUFACTURER_NAME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_MANUFACTURER_NAME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_MODEL_IDENTIFIER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_MODEL_IDENTIFIER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_MODEL_IDENTIFIER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_DATE_CODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_DATE_CODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_DATE_CODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_POWER_SOURCE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_POWER_SOURCE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_POWER_SOURCE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_GENERIC_DEVICE_CLASS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_GENERIC_DEVICE_CLASS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_GENERIC_DEVICE_CLASS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_GENERIC_DEVICE_TYPE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_GENERIC_DEVICE_TYPE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_GENERIC_DEVICE_TYPE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCT_CODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCT_CODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCT_CODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCTURL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCTURL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCTURL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_MANUFACTURER_VERSION_DETAILS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_MANUFACTURER_VERSION_DETAILS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_MANUFACTURER_VERSION_DETAILS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_SERIAL_NUMBER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_SERIAL_NUMBER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_SERIAL_NUMBER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCT_LABEL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCT_LABEL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCT_LABEL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_LOCATION_DESCRIPTION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_LOCATION_DESCRIPTION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_LOCATION_DESCRIPTION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_PHYSICAL_ENVIRONMENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_PHYSICAL_ENVIRONMENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_PHYSICAL_ENVIRONMENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_DEVICE_ENABLED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_DEVICE_ENABLED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_DEVICE_ENABLED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_ALARM_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_ALARM_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_ALARM_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_DISABLE_LOCAL_CONFIG,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_DISABLE_LOCAL_CONFIG,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_DISABLE_LOCAL_CONFIG);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_SW_BUILDID,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_SW_BUILDID,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_SW_BUILDID);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_FREQUENCY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_FREQUENCY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_FREQUENCY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_ALARM_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_ALARM_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_ALARM_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_MIN_THRESHOLD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_MIN_THRESHOLD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_MIN_THRESHOLD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_MAX_THRESHOLD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_MAX_THRESHOLD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_MAX_THRESHOLD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_DWELL_TRIP_POINT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_DWELL_TRIP_POINT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_DWELL_TRIP_POINT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_REMAINING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_REMAINING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_REMAINING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_MANUFACTURER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_MANUFACTURER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_MANUFACTURER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_SIZE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_SIZE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_SIZE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERYA_HR_RATING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERYA_HR_RATING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERYA_HR_RATING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_QUANTITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_QUANTITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_QUANTITY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_RATED_VOLTAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_RATED_VOLTAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_RATED_VOLTAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_ALARM_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_ALARM_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_ALARM_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_MIN_THRESHOLD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_MIN_THRESHOLD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_MIN_THRESHOLD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD1,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD1,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD1);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD2,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD2,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD2);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD3,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD3,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD3);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_MIN_THRESHOLD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_MIN_THRESHOLD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_MIN_THRESHOLD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD1,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD1,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD1);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD2,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD2,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD2);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD3,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD3,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD3);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_ALARM_STATE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_ALARM_STATE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_ALARM_STATE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_REMAINING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_REMAINING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_REMAINING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_MANUFACTURER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_MANUFACTURER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_MANUFACTURER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_SIZE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_SIZE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_SIZE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2A_HR_RATING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2A_HR_RATING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2A_HR_RATING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_QUANTITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_QUANTITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_QUANTITY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_RATED_VOLTAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_RATED_VOLTAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_RATED_VOLTAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_ALARM_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_ALARM_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_ALARM_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_MIN_THRESHOLD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_MIN_THRESHOLD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_MIN_THRESHOLD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD1,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD1,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD1);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD2,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD2,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD2);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD3,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD3,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD3);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_MIN_THRESHOLD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_MIN_THRESHOLD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_MIN_THRESHOLD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD1,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD1,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD1);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD2,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD2,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD2);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD3,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD3,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD3);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_ALARM_STATE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_ALARM_STATE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_ALARM_STATE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_REMAINING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_REMAINING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_REMAINING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_MANUFACTURER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_MANUFACTURER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_MANUFACTURER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_SIZE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_SIZE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_SIZE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3A_HR_RATING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3A_HR_RATING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3A_HR_RATING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_QUANTITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_QUANTITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_QUANTITY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_RATED_VOLTAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_RATED_VOLTAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_RATED_VOLTAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_ALARM_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_ALARM_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_ALARM_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_MIN_THRESHOLD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_MIN_THRESHOLD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_MIN_THRESHOLD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD1,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD1,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD1);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD2,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD2,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD2);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD3,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD3,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD3);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_MIN_THRESHOLD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_MIN_THRESHOLD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_MIN_THRESHOLD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD1,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD1,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD1);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD2,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD2,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD2);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD3,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD3,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD3);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_ALARM_STATE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_ALARM_STATE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_ALARM_STATE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_CURRENT_TEMPERATURE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_CURRENT_TEMPERATURE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      device_temperature_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_CURRENT_TEMPERATURE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_MIN_TEMP_EXPERIENCED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_MIN_TEMP_EXPERIENCED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      device_temperature_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_MIN_TEMP_EXPERIENCED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_MAX_TEMP_EXPERIENCED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_MAX_TEMP_EXPERIENCED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      device_temperature_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_MAX_TEMP_EXPERIENCED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_OVER_TEMP_TOTAL_DWELL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_OVER_TEMP_TOTAL_DWELL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      device_temperature_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_OVER_TEMP_TOTAL_DWELL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_DEVICE_TEMP_ALARM_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_DEVICE_TEMP_ALARM_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      device_temperature_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_DEVICE_TEMP_ALARM_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_LOW_TEMP_THRESHOLD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_LOW_TEMP_THRESHOLD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      device_temperature_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_LOW_TEMP_THRESHOLD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_HIGH_TEMP_THRESHOLD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_HIGH_TEMP_THRESHOLD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      device_temperature_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_HIGH_TEMP_THRESHOLD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_LOW_TEMP_DWELL_TRIP_POINT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_LOW_TEMP_DWELL_TRIP_POINT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      device_temperature_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_LOW_TEMP_DWELL_TRIP_POINT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_HIGH_TEMP_DWELL_TRIP_POINT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_HIGH_TEMP_DWELL_TRIP_POINT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      device_temperature_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_HIGH_TEMP_DWELL_TRIP_POINT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      identify_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_IDENTIFY_IDENTIFY_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      identify_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_IDENTIFY_IDENTIFY_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      identify_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_IDENTIFY_IDENTIFY_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      groups_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_GROUPS_NAME_SUPPORT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      groups_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_GROUPS_NAME_SUPPORT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      groups_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_GROUPS_NAME_SUPPORT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      scenes_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_COUNT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      scenes_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_COUNT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      scenes_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_COUNT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      scenes_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_CURRENT_SCENE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      scenes_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_CURRENT_SCENE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      scenes_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_CURRENT_SCENE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      scenes_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_CURRENT_GROUP,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      scenes_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_CURRENT_GROUP,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      scenes_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_CURRENT_GROUP);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      scenes_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_VALID,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      scenes_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_VALID,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      scenes_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_VALID);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      scenes_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_NAME_SUPPORT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      scenes_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_NAME_SUPPORT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      scenes_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_NAME_SUPPORT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      scenes_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_LAST_CONFIGURED_BY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      scenes_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_LAST_CONFIGURED_BY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      scenes_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_LAST_CONFIGURED_BY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      scenes_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      scenes_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      scenes_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      on_off_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ON_OFF_ON_OFF,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      on_off_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ON_OFF_ON_OFF,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      on_off_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ON_OFF_ON_OFF);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      on_off_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ON_OFF_GLOBAL_SCENE_CONTROL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      on_off_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ON_OFF_GLOBAL_SCENE_CONTROL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      on_off_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ON_OFF_GLOBAL_SCENE_CONTROL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      on_off_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ON_OFF_ON_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      on_off_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ON_OFF_ON_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      on_off_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ON_OFF_ON_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      on_off_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ON_OFF_OFF_WAIT_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      on_off_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ON_OFF_OFF_WAIT_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      on_off_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ON_OFF_OFF_WAIT_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      on_off_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ON_OFF_START_UP_ON_OFF,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      on_off_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ON_OFF_START_UP_ON_OFF,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      on_off_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ON_OFF_START_UP_ON_OFF);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_CURRENT_LEVEL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_CURRENT_LEVEL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      level_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_CURRENT_LEVEL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_REMAINING_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_REMAINING_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      level_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_REMAINING_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_MIN_LEVEL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_MIN_LEVEL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      level_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_MIN_LEVEL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_MAX_LEVEL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_MAX_LEVEL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      level_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_MAX_LEVEL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_CURRENT_FREQUENCY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_CURRENT_FREQUENCY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      level_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_CURRENT_FREQUENCY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_MIN_FREQUENCY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_MIN_FREQUENCY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      level_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_MIN_FREQUENCY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_MAX_FREQUENCY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_MAX_FREQUENCY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      level_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_MAX_FREQUENCY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_OPTIONS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_OPTIONS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      level_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_OPTIONS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_ON_OFF_TRANSITION_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_ON_OFF_TRANSITION_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      level_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_ON_OFF_TRANSITION_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_ON_LEVEL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_ON_LEVEL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      level_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_ON_LEVEL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_ON_TRANSITION_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_ON_TRANSITION_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      level_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_ON_TRANSITION_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_OFF_TRANSITION_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_OFF_TRANSITION_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      level_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_OFF_TRANSITION_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_DEFAULT_MOVE_RATE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_DEFAULT_MOVE_RATE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      level_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_DEFAULT_MOVE_RATE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_START_UP_CURRENT_LEVEL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_START_UP_CURRENT_LEVEL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      level_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_START_UP_CURRENT_LEVEL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      alarms_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ALARMS_ALARM_COUNT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      alarms_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ALARMS_ALARM_COUNT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      alarms_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ALARMS_ALARM_COUNT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      time_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_TIME_STATUS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_TIME_STATUS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      time_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_TIME_STATUS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_TIME_ZONE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_TIME_ZONE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      time_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_TIME_ZONE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_DST_START,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_DST_START,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      time_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_DST_START);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_DST_END,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_DST_END,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      time_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_DST_END);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_DST_SHIFT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_DST_SHIFT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      time_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_DST_SHIFT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_STANDARD_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_STANDARD_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      time_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_STANDARD_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_LOCAL_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_LOCAL_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      time_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_LOCAL_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_LAST_SET_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_LAST_SET_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      time_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_LAST_SET_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_VALID_UNTIL_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_VALID_UNTIL_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      time_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_VALID_UNTIL_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      poll_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_CHECK_IN_INTERVAL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      poll_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_CHECK_IN_INTERVAL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      poll_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_CHECK_IN_INTERVAL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      poll_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_LONG_POLL_INTERVAL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      poll_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_LONG_POLL_INTERVAL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      poll_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_LONG_POLL_INTERVAL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      poll_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_SHORT_POLL_INTERVAL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      poll_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_SHORT_POLL_INTERVAL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      poll_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_SHORT_POLL_INTERVAL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      poll_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_FAST_POLL_TIMEOUT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      poll_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_FAST_POLL_TIMEOUT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      poll_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_FAST_POLL_TIMEOUT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      poll_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_CHECK_IN_INTERVAL_MIN,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      poll_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_CHECK_IN_INTERVAL_MIN,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      poll_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_CHECK_IN_INTERVAL_MIN);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      poll_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_LONG_POLL_INTERVAL_MIN,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      poll_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_LONG_POLL_INTERVAL_MIN,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      poll_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_LONG_POLL_INTERVAL_MIN);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      poll_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_FAST_POLL_TIMEOUT_MAX,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      poll_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_FAST_POLL_TIMEOUT_MAX,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      poll_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_FAST_POLL_TIMEOUT_MAX);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      shade_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_PHYSICAL_CLOSED_LIMIT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      shade_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_PHYSICAL_CLOSED_LIMIT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      shade_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_PHYSICAL_CLOSED_LIMIT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      shade_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_MOTOR_STEP_SIZE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      shade_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_MOTOR_STEP_SIZE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      shade_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_MOTOR_STEP_SIZE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      shade_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_STATUS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      shade_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_STATUS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      shade_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_STATUS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      shade_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_CLOSED_LIMIT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      shade_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_CLOSED_LIMIT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      shade_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_CLOSED_LIMIT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      shade_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      shade_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      shade_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LOCK_STATE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LOCK_STATE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LOCK_STATE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LOCK_TYPE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LOCK_TYPE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LOCK_TYPE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ACTUATOR_ENABLED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ACTUATOR_ENABLED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ACTUATOR_ENABLED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_STATE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_STATE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_STATE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_OPEN_EVENTS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_OPEN_EVENTS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_OPEN_EVENTS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_CLOSED_EVENTS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_CLOSED_EVENTS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_CLOSED_EVENTS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_OPEN_PERIOD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_OPEN_PERIOD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_OPEN_PERIOD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_LOG_RECORDS_SUPPORTED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_LOG_RECORDS_SUPPORTED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_LOG_RECORDS_SUPPORTED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_TOTAL_USERS_SUPPORTED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_TOTAL_USERS_SUPPORTED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_TOTAL_USERS_SUPPORTED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_PIN_USERS_SUPPORTED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_PIN_USERS_SUPPORTED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_PIN_USERS_SUPPORTED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_RFID_USERS_SUPPORTED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_RFID_USERS_SUPPORTED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_RFID_USERS_SUPPORTED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_WEEK_DAY_SCHEDULES_SUPPORTED_PER_USER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_WEEK_DAY_SCHEDULES_SUPPORTED_PER_USER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_WEEK_DAY_SCHEDULES_SUPPORTED_PER_USER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_YEAR_DAY_SCHEDULES_SUPPORTED_PER_USER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_YEAR_DAY_SCHEDULES_SUPPORTED_PER_USER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_YEAR_DAY_SCHEDULES_SUPPORTED_PER_USER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_HOLIDAY_SCHEDULES_SUPPORTED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_HOLIDAY_SCHEDULES_SUPPORTED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_HOLIDAY_SCHEDULES_SUPPORTED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MAX_PIN_CODE_LENGTH,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MAX_PIN_CODE_LENGTH,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MAX_PIN_CODE_LENGTH);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MIN_PIN_CODE_LENGTH,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MIN_PIN_CODE_LENGTH,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MIN_PIN_CODE_LENGTH);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MAX_RFID_CODE_LENGTH,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MAX_RFID_CODE_LENGTH,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MAX_RFID_CODE_LENGTH);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MIN_RFID_CODE_LENGTH,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MIN_RFID_CODE_LENGTH,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MIN_RFID_CODE_LENGTH);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_CREDENTIAL_RULES_SUPPORT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_CREDENTIAL_RULES_SUPPORT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_CREDENTIAL_RULES_SUPPORT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_CREDENTIALS_SUPPORTED_PER_USER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_CREDENTIALS_SUPPORTED_PER_USER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_CREDENTIALS_SUPPORTED_PER_USER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_LOGGING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_LOGGING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_LOGGING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LANGUAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LANGUAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LANGUAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LED_SETTINGS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LED_SETTINGS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LED_SETTINGS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_AUTO_RELOCK_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_AUTO_RELOCK_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_AUTO_RELOCK_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SOUND_VOLUME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SOUND_VOLUME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SOUND_VOLUME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_OPERATING_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_OPERATING_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_OPERATING_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SUPPORTED_OPERATING_MODES,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SUPPORTED_OPERATING_MODES,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SUPPORTED_OPERATING_MODES);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DEFAULT_CONFIGURATION_REGISTER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DEFAULT_CONFIGURATION_REGISTER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DEFAULT_CONFIGURATION_REGISTER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_LOCAL_PROGRAMMING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_LOCAL_PROGRAMMING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_LOCAL_PROGRAMMING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_ONE_TOUCH_LOCKING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_ONE_TOUCH_LOCKING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_ONE_TOUCH_LOCKING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_INSIDE_STATUSLED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_INSIDE_STATUSLED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_INSIDE_STATUSLED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_PRIVACY_MODE_BUTTON,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_PRIVACY_MODE_BUTTON,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_PRIVACY_MODE_BUTTON);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LOCAL_PROGRAMMING_FEATURES,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LOCAL_PROGRAMMING_FEATURES,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LOCAL_PROGRAMMING_FEATURES);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_WRONG_CODE_ENTRY_LIMIT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_WRONG_CODE_ENTRY_LIMIT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_WRONG_CODE_ENTRY_LIMIT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_USER_CODE_TEMPORARY_DISABLE_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_USER_CODE_TEMPORARY_DISABLE_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_USER_CODE_TEMPORARY_DISABLE_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SEND_PIN_OVER_THE_AIR,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SEND_PIN_OVER_THE_AIR,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SEND_PIN_OVER_THE_AIR);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_REQUIRE_PI_NFOR_RF_OPERATION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_REQUIRE_PI_NFOR_RF_OPERATION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_REQUIRE_PI_NFOR_RF_OPERATION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SECURITY_LEVEL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SECURITY_LEVEL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SECURITY_LEVEL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_EXPIRING_USER_TIMEOUT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_EXPIRING_USER_TIMEOUT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_EXPIRING_USER_TIMEOUT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ALARM_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ALARM_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ALARM_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_KEYPAD_OPERATION_EVENT_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_KEYPAD_OPERATION_EVENT_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_KEYPAD_OPERATION_EVENT_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RF_OPERATION_EVENT_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RF_OPERATION_EVENT_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RF_OPERATION_EVENT_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MANUAL_OPERATION_EVENT_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MANUAL_OPERATION_EVENT_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MANUAL_OPERATION_EVENT_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RFID_OPERATION_EVENT_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RFID_OPERATION_EVENT_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RFID_OPERATION_EVENT_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_KEYPAD_PROGRAMMING_EVENT_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_KEYPAD_PROGRAMMING_EVENT_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_KEYPAD_PROGRAMMING_EVENT_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RF_PROGRAMMING_EVENT_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RF_PROGRAMMING_EVENT_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RF_PROGRAMMING_EVENT_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RFID_PROGRAMMING_EVENT_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RFID_PROGRAMMING_EVENT_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RFID_PROGRAMMING_EVENT_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_FEATURE_MAP,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_FEATURE_MAP,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_FEATURE_MAP);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_WINDOW_COVERING_TYPE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_WINDOW_COVERING_TYPE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_WINDOW_COVERING_TYPE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_PHYSICAL_CLOSED_LIMIT_LIFT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_PHYSICAL_CLOSED_LIMIT_LIFT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_PHYSICAL_CLOSED_LIMIT_LIFT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_PHYSICAL_CLOSED_LIMIT_TILT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_PHYSICAL_CLOSED_LIMIT_TILT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_PHYSICAL_CLOSED_LIMIT_TILT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_LIFT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_LIFT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_LIFT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_TILT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_TILT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_TILT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_NUMBER_OF_ACTUATIONS_LIFT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_NUMBER_OF_ACTUATIONS_LIFT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_NUMBER_OF_ACTUATIONS_LIFT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_NUMBER_OF_ACTUATIONS_TILT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_NUMBER_OF_ACTUATIONS_TILT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_NUMBER_OF_ACTUATIONS_TILT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CONFIG_OR_STATUS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CONFIG_OR_STATUS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CONFIG_OR_STATUS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_LIFT_PERCENTAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_LIFT_PERCENTAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_LIFT_PERCENTAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_TILT_PERCENTAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_TILT_PERCENTAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_TILT_PERCENTAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_OPEN_LIMIT_LIFT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_OPEN_LIMIT_LIFT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_OPEN_LIMIT_LIFT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_CLOSED_LIMIT_LIFT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_CLOSED_LIMIT_LIFT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_CLOSED_LIMIT_LIFT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_OPEN_LIMIT_TILT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_OPEN_LIMIT_TILT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_OPEN_LIMIT_TILT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_CLOSED_LIMIT_TILT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_CLOSED_LIMIT_TILT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_CLOSED_LIMIT_TILT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_VELOCITY_LIFT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_VELOCITY_LIFT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_VELOCITY_LIFT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_ACCELERATION_TIME_LIFT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_ACCELERATION_TIME_LIFT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_ACCELERATION_TIME_LIFT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_DECELERATION_TIME_LIFT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_DECELERATION_TIME_LIFT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_DECELERATION_TIME_LIFT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INTERMEDIATE_SETPOINTS_LIFT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INTERMEDIATE_SETPOINTS_LIFT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INTERMEDIATE_SETPOINTS_LIFT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INTERMEDIATE_SETPOINTS_TILT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INTERMEDIATE_SETPOINTS_TILT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INTERMEDIATE_SETPOINTS_TILT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_MOVING_STATE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_MOVING_STATE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      barrier_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_MOVING_STATE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_SAFETY_STATUS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_SAFETY_STATUS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      barrier_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_SAFETY_STATUS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CAPABILITIES,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CAPABILITIES,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      barrier_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CAPABILITIES);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_OPEN_EVENTS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_OPEN_EVENTS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      barrier_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_OPEN_EVENTS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CLOSE_EVENTS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CLOSE_EVENTS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      barrier_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CLOSE_EVENTS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_COMMAND_OPEN_EVENTS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_COMMAND_OPEN_EVENTS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      barrier_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_COMMAND_OPEN_EVENTS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_COMMAND_CLOSE_EVENTS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_COMMAND_CLOSE_EVENTS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      barrier_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_COMMAND_CLOSE_EVENTS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_OPEN_PERIOD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_OPEN_PERIOD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      barrier_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_OPEN_PERIOD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CLOSE_PERIOD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CLOSE_PERIOD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      barrier_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CLOSE_PERIOD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_BARRIER_POSITION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_BARRIER_POSITION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      barrier_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_BARRIER_POSITION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_PRESSURE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_PRESSURE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_PRESSURE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_SPEED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_SPEED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_SPEED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_FLOW,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_FLOW,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_FLOW);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_PRESSURE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_PRESSURE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_PRESSURE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_PRESSURE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_PRESSURE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_PRESSURE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_COMP_PRESSURE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_COMP_PRESSURE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_COMP_PRESSURE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_COMP_PRESSURE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_COMP_PRESSURE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_COMP_PRESSURE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_SPEED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_SPEED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_SPEED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_SPEED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_SPEED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_SPEED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_FLOW,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_FLOW,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_FLOW);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_FLOW,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_FLOW,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_FLOW);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_TEMP,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_TEMP,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_TEMP);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_TEMP,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_TEMP,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_TEMP);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_PUMP_STATUS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_PUMP_STATUS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_PUMP_STATUS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_EFFECTIVE_OPERATION_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_EFFECTIVE_OPERATION_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_EFFECTIVE_OPERATION_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_EFFECTIVE_CONTROL_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_EFFECTIVE_CONTROL_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_EFFECTIVE_CONTROL_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_CAPACITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_CAPACITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_CAPACITY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_SPEED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_SPEED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_SPEED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_LIFETIME_RUNNING_HOURS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_LIFETIME_RUNNING_HOURS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_LIFETIME_RUNNING_HOURS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_POWER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_POWER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_POWER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_LIFETIME_ENERGY_CONSUMED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_LIFETIME_ENERGY_CONSUMED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_LIFETIME_ENERGY_CONSUMED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_OPERATION_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_OPERATION_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_OPERATION_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_CONTROL_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_CONTROL_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_CONTROL_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_ALARM_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_ALARM_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_ALARM_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_LOCAL_TEMPERATURE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_LOCAL_TEMPERATURE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_LOCAL_TEMPERATURE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OUTDOOR_TEMPERATURE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OUTDOOR_TEMPERATURE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OUTDOOR_TEMPERATURE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPANCY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPANCY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPANCY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MIN_HEAT_SETPOINT_LIMIT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MIN_HEAT_SETPOINT_LIMIT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MIN_HEAT_SETPOINT_LIMIT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MAX_HEAT_SETPOINT_LIMIT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MAX_HEAT_SETPOINT_LIMIT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MAX_HEAT_SETPOINT_LIMIT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MIN_COOL_SETPOINT_LIMIT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MIN_COOL_SETPOINT_LIMIT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MIN_COOL_SETPOINT_LIMIT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MAX_COOL_SETPOINT_LIMIT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MAX_COOL_SETPOINT_LIMIT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MAX_COOL_SETPOINT_LIMIT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_PI_COOLING_DEMAND,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_PI_COOLING_DEMAND,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_PI_COOLING_DEMAND);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_PI_HEATING_DEMAND,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_PI_HEATING_DEMAND,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_PI_HEATING_DEMAND);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_HVAC_SYSTEM_TYPE_CONFIGURATION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_HVAC_SYSTEM_TYPE_CONFIGURATION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_HVAC_SYSTEM_TYPE_CONFIGURATION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_LOCAL_TEMPERATURE_CALIBRATION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_LOCAL_TEMPERATURE_CALIBRATION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_LOCAL_TEMPERATURE_CALIBRATION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_COOLING_SETPOINT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_COOLING_SETPOINT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_COOLING_SETPOINT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_HEATING_SETPOINT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_HEATING_SETPOINT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_HEATING_SETPOINT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_COOLING_SETPOINT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_COOLING_SETPOINT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_COOLING_SETPOINT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_HEATING_SETPOINT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_HEATING_SETPOINT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_HEATING_SETPOINT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_HEAT_SETPOINT_LIMIT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_HEAT_SETPOINT_LIMIT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_HEAT_SETPOINT_LIMIT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MAX_HEAT_SETPOINT_LIMIT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MAX_HEAT_SETPOINT_LIMIT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MAX_HEAT_SETPOINT_LIMIT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_COOL_SETPOINT_LIMIT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_COOL_SETPOINT_LIMIT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_COOL_SETPOINT_LIMIT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MAX_COOL_SETPOINT_LIMIT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MAX_COOL_SETPOINT_LIMIT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MAX_COOL_SETPOINT_LIMIT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_SETPOINT_DEAD_BAND,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_SETPOINT_DEAD_BAND,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_SETPOINT_DEAD_BAND);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_REMOTE_SENSING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_REMOTE_SENSING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_REMOTE_SENSING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_CONTROL_SEQUENCE_OF_OPERATION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_CONTROL_SEQUENCE_OF_OPERATION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_CONTROL_SEQUENCE_OF_OPERATION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SYSTEM_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SYSTEM_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SYSTEM_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ALARM_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ALARM_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ALARM_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_RUNNING_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_RUNNING_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_RUNNING_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_START_OF_WEEK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_START_OF_WEEK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_START_OF_WEEK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_NUMBER_OF_WEEKLY_TRANSITIONS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_NUMBER_OF_WEEKLY_TRANSITIONS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_NUMBER_OF_WEEKLY_TRANSITIONS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_NUMBER_OF_DAILY_TRANSITIONS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_NUMBER_OF_DAILY_TRANSITIONS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_NUMBER_OF_DAILY_TRANSITIONS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_TEMPERATURE_SETPOINT_HOLD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_TEMPERATURE_SETPOINT_HOLD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_TEMPERATURE_SETPOINT_HOLD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_TEMPERATURE_SETPOINT_HOLD_DURATION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_TEMPERATURE_SETPOINT_HOLD_DURATION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_TEMPERATURE_SETPOINT_HOLD_DURATION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_PROGRAMMING_OPERATION_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_PROGRAMMING_OPERATION_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_PROGRAMMING_OPERATION_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_RUNNING_STATE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_RUNNING_STATE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_RUNNING_STATE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_SOURCE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_SOURCE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_SOURCE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_AMOUNT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_AMOUNT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_AMOUNT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_SOURCE_TIMESTAMP,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_SOURCE_TIMESTAMP,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_SOURCE_TIMESTAMP);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK_MIN,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK_MIN,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK_MIN);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK_MAX,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK_MAX,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK_MAX);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK_MIN,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK_MIN,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK_MIN);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK_MAX,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK_MAX,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK_MAX);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_EMERGENCY_HEAT_DELTA,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_EMERGENCY_HEAT_DELTA,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_EMERGENCY_HEAT_DELTA);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_TYPE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_TYPE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_TYPE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_CAPACITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_CAPACITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_CAPACITY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_REFRIGERANT_TYPE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_REFRIGERANT_TYPE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_REFRIGERANT_TYPE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_COMPRESSOR_TYPE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_COMPRESSOR_TYPE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_COMPRESSOR_TYPE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_ERROR_CODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_ERROR_CODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_ERROR_CODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_LOUVER_POSITION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_LOUVER_POSITION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_LOUVER_POSITION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_COIL_TEMPERATURE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_COIL_TEMPERATURE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_COIL_TEMPERATURE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_CAPACITY_FORMAT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_CAPACITY_FORMAT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_CAPACITY_FORMAT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      fan_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_FAN_CONTROL_FAN_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      fan_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_FAN_CONTROL_FAN_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      fan_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_FAN_CONTROL_FAN_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      fan_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_FAN_CONTROL_FAN_MODE_SEQUENCE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      fan_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_FAN_CONTROL_FAN_MODE_SEQUENCE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      fan_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_FAN_CONTROL_FAN_MODE_SEQUENCE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      dehumidification_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      dehumidification_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      dehumidification_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      dehumidification_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_COOLING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      dehumidification_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_COOLING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      dehumidification_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_COOLING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      dehumidification_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RH_DEHUMIDIFICATION_SETPOINT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      dehumidification_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RH_DEHUMIDIFICATION_SETPOINT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      dehumidification_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RH_DEHUMIDIFICATION_SETPOINT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      dehumidification_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      dehumidification_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      dehumidification_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      dehumidification_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_LOCKOUT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      dehumidification_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_LOCKOUT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      dehumidification_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_LOCKOUT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      dehumidification_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_HYSTERESIS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      dehumidification_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_HYSTERESIS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      dehumidification_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_HYSTERESIS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      dehumidification_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_MAX_COOL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      dehumidification_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_MAX_COOL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      dehumidification_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_MAX_COOL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      dehumidification_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_DISPLAY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      dehumidification_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_DISPLAY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      dehumidification_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_DISPLAY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_user_interface_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_TEMPERATURE_DISPLAY_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_user_interface_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_TEMPERATURE_DISPLAY_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_user_interface_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_TEMPERATURE_DISPLAY_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_user_interface_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_KEYPAD_LOCKOUT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_user_interface_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_KEYPAD_LOCKOUT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_user_interface_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_KEYPAD_LOCKOUT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_user_interface_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_SCHEDULE_PROGRAMMING_VISIBILITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_user_interface_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_SCHEDULE_PROGRAMMING_VISIBILITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_user_interface_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_SCHEDULE_PROGRAMMING_VISIBILITY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENT_HUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENT_HUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENT_HUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENT_SATURATION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENT_SATURATION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENT_SATURATION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_REMAINING_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_REMAINING_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_REMAINING_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENTX,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENTX,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENTX);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENTY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENTY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENTY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_DRIFT_COMPENSATION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_DRIFT_COMPENSATION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_DRIFT_COMPENSATION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COMPENSATION_TEXT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COMPENSATION_TEXT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COMPENSATION_TEXT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMPERATURE_MIREDS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMPERATURE_MIREDS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMPERATURE_MIREDS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_OPTIONS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_OPTIONS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_OPTIONS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_NUMBER_OF_PRIMARIES,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_NUMBER_OF_PRIMARIES,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_NUMBER_OF_PRIMARIES);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1X,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1X,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1X);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1Y,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1Y,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1Y);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1_INTENSITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1_INTENSITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1_INTENSITY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2X,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2X,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2X);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2Y,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2Y,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2Y);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2_INTENSITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2_INTENSITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2_INTENSITY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3X,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3X,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3X);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3Y,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3Y,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3Y);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3_INTENSITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3_INTENSITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3_INTENSITY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4X,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4X,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4X);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4Y,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4Y,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4Y);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4_INTENSITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4_INTENSITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4_INTENSITY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5X,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5X,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5X);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5Y,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5Y,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5Y);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5_INTENSITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5_INTENSITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5_INTENSITY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6X,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6X,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6X);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6Y,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6Y,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6Y);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6_INTENSITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6_INTENSITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6_INTENSITY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_WHITE_POINTX,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_WHITE_POINTX,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_WHITE_POINTX);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_WHITE_POINTY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_WHITE_POINTY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_WHITE_POINTY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTRX,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTRX,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTRX);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTRY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTRY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTRY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTR_INTENSITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTR_INTENSITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTR_INTENSITY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTGX,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTGX,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTGX);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTGY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTGY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTGY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTG_INTENSITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTG_INTENSITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTG_INTENSITY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTBX,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTBX,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTBX);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTBY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTBY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTBY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTB_INTENSITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTB_INTENSITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTB_INTENSITY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_ENHANCED_CURRENT_HUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_ENHANCED_CURRENT_HUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_ENHANCED_CURRENT_HUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_ENHANCED_COLOR_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_ENHANCED_COLOR_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_ENHANCED_COLOR_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_ACTIVE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_ACTIVE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_ACTIVE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_DIRECTION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_DIRECTION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_DIRECTION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_START_ENHANCED_HUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_START_ENHANCED_HUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_START_ENHANCED_HUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_STORED_ENHANCED_HUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_STORED_ENHANCED_HUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_STORED_ENHANCED_HUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_CAPABILITIES,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_CAPABILITIES,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_CAPABILITIES);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMP_PHYSICAL_MIN_MIREDS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMP_PHYSICAL_MIN_MIREDS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMP_PHYSICAL_MIN_MIREDS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMP_PHYSICAL_MAX_MIREDS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMP_PHYSICAL_MAX_MIREDS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMP_PHYSICAL_MAX_MIREDS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COUPLE_COLOR_TEMP_TO_LEVEL_MIN_MIREDS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COUPLE_COLOR_TEMP_TO_LEVEL_MIN_MIREDS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COUPLE_COLOR_TEMP_TO_LEVEL_MIN_MIREDS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_START_UP_COLOR_TEMPERATURE_MIREDS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_START_UP_COLOR_TEMPERATURE_MIREDS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_START_UP_COLOR_TEMPERATURE_MIREDS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_PHYSICAL_MIN_LEVEL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_PHYSICAL_MIN_LEVEL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ballast_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_PHYSICAL_MIN_LEVEL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_PHYSICAL_MAX_LEVEL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_PHYSICAL_MAX_LEVEL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ballast_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_PHYSICAL_MAX_LEVEL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_BALLAST_STATUS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_BALLAST_STATUS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ballast_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_BALLAST_STATUS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_MIN_LEVEL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_MIN_LEVEL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ballast_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_MIN_LEVEL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_MAX_LEVEL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_MAX_LEVEL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ballast_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_MAX_LEVEL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_POWER_ON_LEVEL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_POWER_ON_LEVEL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ballast_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_POWER_ON_LEVEL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_POWER_ON_FADE_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_POWER_ON_FADE_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ballast_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_POWER_ON_FADE_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_INTRINSIC_BALLAST_FACTOR,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_INTRINSIC_BALLAST_FACTOR,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ballast_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_INTRINSIC_BALLAST_FACTOR);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_BALLAST_FACTOR_ADJUSTMENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_BALLAST_FACTOR_ADJUSTMENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ballast_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_BALLAST_FACTOR_ADJUSTMENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_QUANTITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_QUANTITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ballast_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_QUANTITY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_TYPE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_TYPE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ballast_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_TYPE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_MANUFACTURER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_MANUFACTURER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ballast_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_MANUFACTURER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_RATED_HOURS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_RATED_HOURS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ballast_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_RATED_HOURS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_BURN_HOURS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_BURN_HOURS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ballast_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_BURN_HOURS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_ALARM_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_ALARM_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ballast_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_ALARM_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_BURN_HOURS_TRIP_POINT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_BURN_HOURS_TRIP_POINT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ballast_configuration_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_BURN_HOURS_TRIP_POINT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      illuminance_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      illuminance_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      illuminance_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      illuminance_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MIN_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      illuminance_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MIN_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      illuminance_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MIN_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      illuminance_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MAX_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      illuminance_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MAX_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      illuminance_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MAX_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      illuminance_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_TOLERANCE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      illuminance_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_TOLERANCE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      illuminance_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_TOLERANCE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      illuminance_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_LIGHT_SENSOR_TYPE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      illuminance_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_LIGHT_SENSOR_TYPE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      illuminance_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_LIGHT_SENSOR_TYPE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      illuminance_level_sensing_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_LEVEL_STATUS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      illuminance_level_sensing_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_LEVEL_STATUS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      illuminance_level_sensing_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_LEVEL_STATUS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      illuminance_level_sensing_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_LIGHT_SENSOR_TYPE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      illuminance_level_sensing_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_LIGHT_SENSOR_TYPE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      illuminance_level_sensing_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_LIGHT_SENSOR_TYPE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      illuminance_level_sensing_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_ILLUMINANCE_TARGET_LEVEL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      illuminance_level_sensing_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_ILLUMINANCE_TARGET_LEVEL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      illuminance_level_sensing_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_ILLUMINANCE_TARGET_LEVEL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      temperature_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      temperature_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      temperature_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      temperature_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MIN_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      temperature_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MIN_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      temperature_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MIN_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      temperature_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MAX_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      temperature_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MAX_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      temperature_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MAX_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      temperature_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_TOLERANCE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      temperature_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_TOLERANCE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      temperature_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_TOLERANCE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pressure_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MIN_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MIN_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pressure_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MIN_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MAX_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MAX_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pressure_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MAX_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_TOLERANCE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_TOLERANCE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pressure_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_TOLERANCE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pressure_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MIN_SCALED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MIN_SCALED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pressure_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MIN_SCALED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MAX_SCALED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MAX_SCALED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pressure_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MAX_SCALED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALED_TOLERANCE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALED_TOLERANCE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pressure_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALED_TOLERANCE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pressure_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      flow_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      flow_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      flow_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      flow_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MIN_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      flow_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MIN_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      flow_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MIN_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      flow_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MAX_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      flow_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MAX_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      flow_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MAX_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      flow_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_TOLERANCE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      flow_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_TOLERANCE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      flow_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_TOLERANCE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      relativity_humidity_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      relativity_humidity_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      relativity_humidity_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      relativity_humidity_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MIN_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      relativity_humidity_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MIN_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      relativity_humidity_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MIN_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      relativity_humidity_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MAX_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      relativity_humidity_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MAX_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      relativity_humidity_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MAX_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      relativity_humidity_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_TOLERANCE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      relativity_humidity_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_TOLERANCE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      relativity_humidity_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_TOLERANCE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      occupancy_sensing_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY_SENSOR_TYPE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY_SENSOR_TYPE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      occupancy_sensing_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY_SENSOR_TYPE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY_SENSOR_TYPE_BITMAP,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY_SENSOR_TYPE_BITMAP,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      occupancy_sensing_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY_SENSOR_TYPE_BITMAP);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_OCCUPIED_TO_UNOCCUPIED_DELAY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_OCCUPIED_TO_UNOCCUPIED_DELAY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      occupancy_sensing_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_OCCUPIED_TO_UNOCCUPIED_DELAY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_UNOCCUPIED_TO_OCCUPIED_DELAY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_UNOCCUPIED_TO_OCCUPIED_DELAY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      occupancy_sensing_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_UNOCCUPIED_TO_OCCUPIED_DELAY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_UNOCCUPIED_TO_OCCUPIED_THRESHOLD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_UNOCCUPIED_TO_OCCUPIED_THRESHOLD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      occupancy_sensing_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_UNOCCUPIED_TO_OCCUPIED_THRESHOLD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_OCCUPIED_TO_UNOCCUPIED_DELAY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_OCCUPIED_TO_UNOCCUPIED_DELAY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      occupancy_sensing_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_OCCUPIED_TO_UNOCCUPIED_DELAY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_DELAY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_DELAY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      occupancy_sensing_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_DELAY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_THRESHOLD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_THRESHOLD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      occupancy_sensing_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_THRESHOLD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_OCCUPIED_TO_UNOCCUPIED_DELAY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_OCCUPIED_TO_UNOCCUPIED_DELAY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      occupancy_sensing_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_OCCUPIED_TO_UNOCCUPIED_DELAY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_DELAY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_DELAY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      occupancy_sensing_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_DELAY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_THRESHOLD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_THRESHOLD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      occupancy_sensing_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_THRESHOLD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      soil_moisture_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SOIL_MOISTURE_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      soil_moisture_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SOIL_MOISTURE_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      soil_moisture_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SOIL_MOISTURE_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      soil_moisture_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SOIL_MOISTURE_MIN_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      soil_moisture_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SOIL_MOISTURE_MIN_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      soil_moisture_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SOIL_MOISTURE_MIN_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      soil_moisture_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SOIL_MOISTURE_MAX_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      soil_moisture_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SOIL_MOISTURE_MAX_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      soil_moisture_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SOIL_MOISTURE_MAX_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      soil_moisture_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SOIL_MOISTURE_TOLERANCE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      soil_moisture_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SOIL_MOISTURE_TOLERANCE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      soil_moisture_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SOIL_MOISTURE_TOLERANCE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ph_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ph_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ph_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ph_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MIN_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ph_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MIN_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ph_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MIN_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ph_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MAX_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ph_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MAX_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ph_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MAX_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ph_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_TOLERANCE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ph_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_TOLERANCE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ph_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_TOLERANCE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_conductivity_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_conductivity_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_conductivity_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_conductivity_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MIN_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_conductivity_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MIN_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_conductivity_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MIN_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_conductivity_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MAX_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_conductivity_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MAX_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_conductivity_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MAX_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_conductivity_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_TOLERANCE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_conductivity_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_TOLERANCE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_conductivity_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_TOLERANCE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      wind_speed_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      wind_speed_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      wind_speed_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      wind_speed_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MIN_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      wind_speed_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MIN_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      wind_speed_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MIN_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      wind_speed_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MAX_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      wind_speed_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MAX_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      wind_speed_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MAX_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      wind_speed_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_TOLERANCE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      wind_speed_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_TOLERANCE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      wind_speed_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_TOLERANCE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      carbon_monoxide_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      carbon_monoxide_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      carbon_monoxide_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      carbon_monoxide_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MIN_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      carbon_monoxide_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MIN_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      carbon_monoxide_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MIN_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      carbon_monoxide_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MAX_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      carbon_monoxide_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MAX_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      carbon_monoxide_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MAX_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      carbon_monoxide_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_TOLERANCE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      carbon_monoxide_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_TOLERANCE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      carbon_monoxide_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_TOLERANCE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      carbon_dioxide_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_DIOXIDE_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      carbon_dioxide_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_DIOXIDE_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      carbon_dioxide_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_DIOXIDE_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      carbon_dioxide_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_DIOXIDE_MIN_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      carbon_dioxide_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_DIOXIDE_MIN_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      carbon_dioxide_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_DIOXIDE_MIN_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      carbon_dioxide_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_DIOXIDE_MAX_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      carbon_dioxide_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_DIOXIDE_MAX_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      carbon_dioxide_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_DIOXIDE_MAX_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      carbon_dioxide_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_DIOXIDE_TOLERANCE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      carbon_dioxide_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_DIOXIDE_TOLERANCE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      carbon_dioxide_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_DIOXIDE_TOLERANCE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pm25_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PM25_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pm25_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PM25_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pm25_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PM25_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pm25_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PM25_MIN_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pm25_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PM25_MIN_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pm25_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PM25_MIN_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pm25_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PM25_MAX_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pm25_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PM25_MAX_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pm25_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PM25_MAX_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pm25_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PM25_TOLERANCE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pm25_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PM25_TOLERANCE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pm25_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PM25_TOLERANCE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ias_zone_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_STATE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ias_zone_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_STATE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ias_zone_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_STATE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ias_zone_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_TYPE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ias_zone_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_TYPE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ias_zone_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_TYPE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ias_zone_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_STATUS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ias_zone_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_STATUS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ias_zone_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_STATUS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ias_zone_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_IASCIE_ADDRESS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ias_zone_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_IASCIE_ADDRESS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ias_zone_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_IASCIE_ADDRESS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ias_zone_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONEID,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ias_zone_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONEID,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ias_zone_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONEID);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ias_zone_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_NUMBER_OF_ZONE_SENSITIVITY_LEVELS_SUPPORTED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ias_zone_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_NUMBER_OF_ZONE_SENSITIVITY_LEVELS_SUPPORTED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ias_zone_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_NUMBER_OF_ZONE_SENSITIVITY_LEVELS_SUPPORTED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ias_zone_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_CURRENT_ZONE_SENSITIVITY_LEVEL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ias_zone_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_CURRENT_ZONE_SENSITIVITY_LEVEL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ias_zone_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_CURRENT_ZONE_SENSITIVITY_LEVEL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      iaswd_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_IASWD_MAX_DURATION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      iaswd_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_IASWD_MAX_DURATION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      iaswd_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_IASWD_MAX_DURATION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_SUMMATION_DELIVERED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_SUMMATION_DELIVERED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_SUMMATION_DELIVERED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_SUMMATION_RECEIVED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_SUMMATION_RECEIVED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_SUMMATION_RECEIVED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_DELIVERED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_DELIVERED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_DELIVERED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_RECEIVED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_RECEIVED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_RECEIVED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_POWER_FACTOR,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_POWER_FACTOR,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_POWER_FACTOR);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_READING_SNAP_SHOT_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_READING_SNAP_SHOT_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_READING_SNAP_SHOT_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_DELIVERED_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_DELIVERED_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_DELIVERED_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_RECEIVED_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_RECEIVED_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_RECEIVED_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_DEFAULT_UPDATE_PERIOD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_DEFAULT_UPDATE_PERIOD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_DEFAULT_UPDATE_PERIOD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_SUPPLY_STATUS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_SUPPLY_STATUS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_SUPPLY_STATUS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_INLET_ENERGY_CARRIER_SUMMATION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_INLET_ENERGY_CARRIER_SUMMATION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_INLET_ENERGY_CARRIER_SUMMATION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_OUTLET_ENERGY_CARRIER_SUMMATION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_OUTLET_ENERGY_CARRIER_SUMMATION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_OUTLET_ENERGY_CARRIER_SUMMATION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_INLET_TEMPERATURE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_INLET_TEMPERATURE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_INLET_TEMPERATURE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_OUTLET_TEMPERATURE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_OUTLET_TEMPERATURE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_OUTLET_TEMPERATURE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_UNITOF_MEASURE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_UNITOF_MEASURE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_UNITOF_MEASURE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_MULTIPLIER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_MULTIPLIER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_MULTIPLIER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_DIVISOR,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_DIVISOR,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_DIVISOR);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_SUMMATION_FORMATTING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_SUMMATION_FORMATTING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_SUMMATION_FORMATTING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_DEMAND_FORMATTING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_DEMAND_FORMATTING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_DEMAND_FORMATTING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_HISTORICAL_CONSUMPTION_FORMATTING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_HISTORICAL_CONSUMPTION_FORMATTING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_HISTORICAL_CONSUMPTION_FORMATTING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_METERING_DEVICE_TYPE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_METERING_DEVICE_TYPE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_METERING_DEVICE_TYPE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_UNIT_OF_MEASURE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_UNIT_OF_MEASURE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_UNIT_OF_MEASURE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_SUMMATION_FORMATTING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_SUMMATION_FORMATTING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_SUMMATION_FORMATTING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_DEMAND_FORMATTING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_DEMAND_FORMATTING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_DEMAND_FORMATTING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_TEMPERATURE_UNIT_OF_MEASURE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_TEMPERATURE_UNIT_OF_MEASURE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_TEMPERATURE_UNIT_OF_MEASURE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_TEMPERATURE_FORMATTING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_TEMPERATURE_FORMATTING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_TEMPERATURE_FORMATTING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASUREMENT_TYPE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASUREMENT_TYPE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASUREMENT_TYPE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MIN,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MIN,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MIN);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MAX,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MAX,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MAX);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MIN,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MIN,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MIN);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MAX,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MAX,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MAX);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MIN,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MIN,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MIN);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MAX,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MAX,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MAX);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MULTIPLIER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MULTIPLIER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MULTIPLIER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_DIVISOR,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_DIVISOR,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_DIVISOR);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MULTIPLIER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MULTIPLIER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MULTIPLIER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_DIVISOR,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_DIVISOR,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_DIVISOR);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MULTIPLIER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MULTIPLIER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MULTIPLIER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_DIVISOR,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_DIVISOR,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_DIVISOR);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MIN,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MIN,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MIN);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MAX,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MAX,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MAX);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_NEUTRAL_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_NEUTRAL_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_NEUTRAL_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_ACTIVE_POWER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_ACTIVE_POWER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_ACTIVE_POWER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_REACTIVE_POWER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_REACTIVE_POWER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_REACTIVE_POWER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_APPARENT_POWER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_APPARENT_POWER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_APPARENT_POWER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED1ST_HARMONIC_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED1ST_HARMONIC_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED1ST_HARMONIC_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED3RD_HARMONIC_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED3RD_HARMONIC_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED3RD_HARMONIC_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED5TH_HARMONIC_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED5TH_HARMONIC_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED5TH_HARMONIC_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED7TH_HARMONIC_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED7TH_HARMONIC_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED7TH_HARMONIC_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED9TH_HARMONIC_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED9TH_HARMONIC_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED9TH_HARMONIC_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED11TH_HARMONIC_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED11TH_HARMONIC_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED11TH_HARMONIC_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE1ST_HARMONIC_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE1ST_HARMONIC_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE1ST_HARMONIC_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE3RD_HARMONIC_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE3RD_HARMONIC_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE3RD_HARMONIC_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE5TH_HARMONIC_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE5TH_HARMONIC_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE5TH_HARMONIC_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE7TH_HARMONIC_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE7TH_HARMONIC_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE7TH_HARMONIC_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE9TH_HARMONIC_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE9TH_HARMONIC_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE9TH_HARMONIC_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE11TH_HARMONIC_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE11TH_HARMONIC_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE11TH_HARMONIC_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MULTIPLIER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MULTIPLIER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MULTIPLIER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_DIVISOR,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_DIVISOR,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_DIVISOR);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_MULTIPLIER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_MULTIPLIER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_MULTIPLIER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_DIVISOR,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_DIVISOR,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_DIVISOR);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_HARMONIC_CURRENT_MULTIPLIER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_HARMONIC_CURRENT_MULTIPLIER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_HARMONIC_CURRENT_MULTIPLIER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_PHASE_HARMONIC_CURRENT_MULTIPLIER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_PHASE_HARMONIC_CURRENT_MULTIPLIER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_PHASE_HARMONIC_CURRENT_MULTIPLIER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_VOLTAGE_MEASUREMENT_PERIOD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_VOLTAGE_MEASUREMENT_PERIOD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_VOLTAGE_MEASUREMENT_PERIOD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_OVER_VOLTAGE_COUNTER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_OVER_VOLTAGE_COUNTER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_OVER_VOLTAGE_COUNTER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_UNDER_VOLTAGE_COUNTER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_UNDER_VOLTAGE_COUNTER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_UNDER_VOLTAGE_COUNTER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_MULTIPLIER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_MULTIPLIER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_MULTIPLIER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_DIVISOR,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_DIVISOR,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_DIVISOR);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_MULTIPLIER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_MULTIPLIER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_MULTIPLIER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_DIVISOR,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_DIVISOR,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_DIVISOR);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_POWER_MULTIPLIER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_POWER_MULTIPLIER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_POWER_MULTIPLIER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_POWER_DIVISOR,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_POWER_DIVISOR,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_POWER_DIVISOR);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_OVERLOAD_ALARMS_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_OVERLOAD_ALARMS_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_OVERLOAD_ALARMS_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_OVERLOAD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_OVERLOAD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_OVERLOAD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_OVERLOAD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_OVERLOAD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_OVERLOAD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_ALARMS_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_ALARMS_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_ALARMS_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_OVERLOAD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_OVERLOAD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_OVERLOAD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_OVERLOAD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_OVERLOAD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_OVERLOAD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_ACTIVE_POWER_OVERLOAD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_ACTIVE_POWER_OVERLOAD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_ACTIVE_POWER_OVERLOAD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_REACTIVE_POWER_OVERLOAD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_REACTIVE_POWER_OVERLOAD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_REACTIVE_POWER_OVERLOAD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_OVER_VOLTAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_OVER_VOLTAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_OVER_VOLTAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_UNDER_VOLTAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_UNDER_VOLTAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_UNDER_VOLTAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_VOLTAGE_MEASUREMENT_PERIOD_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_VOLTAGE_MEASUREMENT_PERIOD_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_VOLTAGE_MEASUREMENT_PERIOD_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_OVER_VOLTAGE_COUNTER_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_OVER_VOLTAGE_COUNTER_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_OVER_VOLTAGE_COUNTER_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_UNDER_VOLTAGE_COUNTER_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_UNDER_VOLTAGE_COUNTER_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_UNDER_VOLTAGE_COUNTER_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_VOLTAGE_MEASUREMENT_PERIOD_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_VOLTAGE_MEASUREMENT_PERIOD_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_VOLTAGE_MEASUREMENT_PERIOD_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_OVER_VOLTAGE_COUNTER_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_OVER_VOLTAGE_COUNTER_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_OVER_VOLTAGE_COUNTER_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_UNDER_VOLTAGE_COUNTER_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_UNDER_VOLTAGE_COUNTER_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGE_RMS_UNDER_VOLTAGE_COUNTER_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NUMBER_OF_RESETS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NUMBER_OF_RESETS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NUMBER_OF_RESETS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PERSISTENT_MEMORY_WRITES,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PERSISTENT_MEMORY_WRITES,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PERSISTENT_MEMORY_WRITES);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_RX_BCAST,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_RX_BCAST,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_RX_BCAST);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_BCAST,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_BCAST,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_BCAST);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_RX_UCAST,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_RX_UCAST,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_RX_UCAST);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST_RETRY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST_RETRY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST_RETRY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST_FAIL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST_FAIL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST_FAIL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_RX_BCAST,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_RX_BCAST,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_RX_BCAST);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_BCAST,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_BCAST,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_BCAST);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_RX_UCAST,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_RX_UCAST,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_RX_UCAST);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_SUCCESS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_SUCCESS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_SUCCESS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_RETRY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_RETRY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_RETRY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_FAIL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_FAIL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_FAIL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_ROUTE_DISC_INITIATED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_ROUTE_DISC_INITIATED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_ROUTE_DISC_INITIATED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_ADDED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_ADDED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_ADDED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_REMOVED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_REMOVED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_REMOVED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_STALE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_STALE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_STALE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_JOIN_INDICATION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_JOIN_INDICATION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_JOIN_INDICATION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_CHILD_MOVED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_CHILD_MOVED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_CHILD_MOVED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NWKFC_FAILURE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NWKFC_FAILURE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NWKFC_FAILURE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APSFC_FAILURE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APSFC_FAILURE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APSFC_FAILURE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_UNAUTHORIZED_KEY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_UNAUTHORIZED_KEY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_UNAUTHORIZED_KEY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NWK_DECRYPT_FAILURES,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NWK_DECRYPT_FAILURES,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NWK_DECRYPT_FAILURES);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_DECRYPT_FAILURES,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_DECRYPT_FAILURES,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_DECRYPT_FAILURES);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PACKET_BUFFER_ALLOCATE_FAILURES,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PACKET_BUFFER_ALLOCATE_FAILURES,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PACKET_BUFFER_ALLOCATE_FAILURES);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_RELAYED_UCAST,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_RELAYED_UCAST,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_RELAYED_UCAST);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PHY_TO_MAC_QUEUE_LIMIT_REACHED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PHY_TO_MAC_QUEUE_LIMIT_REACHED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PHY_TO_MAC_QUEUE_LIMIT_REACHED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PACKET_VALIDATE_DROP_COUNT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PACKET_VALIDATE_DROP_COUNT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PACKET_VALIDATE_DROP_COUNT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_AVERAGE_MAC_RETRY_PER_APS_MESSAGE_SENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_AVERAGE_MAC_RETRY_PER_APS_MESSAGE_SENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_AVERAGE_MAC_RETRY_PER_APS_MESSAGE_SENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_LAST_MESSAGELQI,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_LAST_MESSAGELQI,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_LAST_MESSAGELQI);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_LAST_MESSAGERSSI,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_LAST_MESSAGERSSI,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_LAST_MESSAGERSSI);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      protocol_controller_rf_telemetry_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_RF_TELEMETRY_TX_REPORT_ENABLED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      protocol_controller_rf_telemetry_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_RF_TELEMETRY_TX_REPORT_ENABLED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      protocol_controller_rf_telemetry_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_RF_TELEMETRY_TX_REPORT_ENABLED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      protocol_controller_rf_telemetry_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_RF_TELEMETRY_PTI_ENABLED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      protocol_controller_rf_telemetry_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_RF_TELEMETRY_PTI_ENABLED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      protocol_controller_rf_telemetry_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_RF_TELEMETRY_PTI_ENABLED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      state_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_STATE_ENDPOINT_ID_LIST,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      state_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_STATE_ENDPOINT_ID_LIST,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      state_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_STATE_ENDPOINT_ID_LIST);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      state_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_STATE_NETWORK_STATUS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      state_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_STATE_NETWORK_STATUS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      state_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_STATE_NETWORK_STATUS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      state_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_STATE_SECURITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      state_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_STATE_SECURITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      state_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_STATE_SECURITY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      state_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_STATE_MAXIMUM_COMMAND_DELAY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      state_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_STATE_MAXIMUM_COMMAND_DELAY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      state_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_STATE_MAXIMUM_COMMAND_DELAY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      state_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_STATE_NETWORK_LIST,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      state_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_STATE_NETWORK_LIST,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      state_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_STATE_NETWORK_LIST);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      binding_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BINDING_BINDING_TABLE_FULL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      binding_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BINDING_BINDING_TABLE_FULL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      binding_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BINDING_BINDING_TABLE_FULL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      binding_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BINDING_BINDABLE_CLUSTER_LIST,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      binding_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BINDING_BINDABLE_CLUSTER_LIST,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      binding_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BINDING_BINDABLE_CLUSTER_LIST);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      binding_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_BINDING_BINDING_TABLE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      binding_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_BINDING_BINDING_TABLE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      binding_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_BINDING_BINDING_TABLE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_REPORTING_INTERVAL_SECONDS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_REPORTING_INTERVAL_SECONDS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_REPORTING_INTERVAL_SECONDS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_USAGE_PERCENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_USAGE_PERCENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_USAGE_PERCENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_FREQUENCYM_HZ,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_FREQUENCYM_HZ,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_FREQUENCYM_HZ);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_AVERAGE_USAGE_PERCENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_AVERAGE_USAGE_PERCENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_AVERAGE_USAGE_PERCENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_MIN_USAGE_PERCENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_MIN_USAGE_PERCENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_MIN_USAGE_PERCENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_MAX_USAGE_PERCENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_MAX_USAGE_PERCENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_MAX_USAGE_PERCENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_TOTALMB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_TOTALMB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_TOTALMB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_FREEMB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_FREEMB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_FREEMB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_AVAILABLEMB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_AVAILABLEMB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_AVAILABLEMB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SWAP_MEMORY_TOTALMB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SWAP_MEMORY_TOTALMB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SWAP_MEMORY_TOTALMB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SWAP_MEMORY_USEDMB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SWAP_MEMORY_USEDMB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SWAP_MEMORY_USEDMB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_VIRTUAL_MEMORY_TOTALMB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_VIRTUAL_MEMORY_TOTALMB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_VIRTUAL_MEMORY_TOTALMB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_VIRTUAL_MEMORY_USEDMB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_VIRTUAL_MEMORY_USEDMB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_VIRTUAL_MEMORY_USEDMB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_DISKS_USAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_DISKS_USAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_DISKS_USAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_DISKS_COUNTERS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_DISKS_COUNTERS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_DISKS_COUNTERS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_NETWORK_INTERFACES_DATA,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_NETWORK_INTERFACES_DATA,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_NETWORK_INTERFACES_DATA);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_WIRELESS_NETWORK_INTERFACES_DATA,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_WIRELESS_NETWORK_INTERFACES_DATA,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_WIRELESS_NETWORK_INTERFACES_DATA);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_HOSTNAME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_HOSTNAME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_HOSTNAME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_FQDN,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_FQDN,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_FQDN);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_UPTIME_MINUTES,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_UPTIME_MINUTES,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_UPTIME_MINUTES);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CURRENT_TEMPERATURE_CELCIUS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CURRENT_TEMPERATURE_CELCIUS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CURRENT_TEMPERATURE_CELCIUS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_AVERAGE_TEMPERATURE_CELCIUS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_AVERAGE_TEMPERATURE_CELCIUS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_AVERAGE_TEMPERATURE_CELCIUS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_MIN_TEMPERATURE_CELCIUS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_MIN_TEMPERATURE_CELCIUS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_MIN_TEMPERATURE_CELCIUS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_MAX_TEMPERATURE_CELCIUS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_MAX_TEMPERATURE_CELCIUS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_MAX_TEMPERATURE_CELCIUS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_POWER_PLUGGED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_POWER_PLUGGED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_POWER_PLUGGED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_BATTERY_PERCENTAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_BATTERY_PERCENTAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_BATTERY_PERCENTAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SYSTEM_INTERRUPTS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SYSTEM_INTERRUPTS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SYSTEM_INTERRUPTS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_NAME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_NAME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_NAME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_VERSION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_VERSION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_VERSION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CONNECTED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CONNECTED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CONNECTED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_MQTT_TOPICS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_MQTT_TOPICS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_MQTT_TOPICS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_UPTIME_MINUTES,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_UPTIME_MINUTES,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_UPTIME_MINUTES);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_PROCESS_ID,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_PROCESS_ID,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_PROCESS_ID);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_HOSTNAME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_HOSTNAME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_HOSTNAME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_FQDN,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_FQDN,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_FQDN);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_LOGGING_ENABLED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_LOGGING_ENABLED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_LOGGING_ENABLED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_LOGGING_LEVEL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_LOGGING_LEVEL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_LOGGING_LEVEL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_STATISTICS_REPORTING_INTERVAL_SECONDS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_STATISTICS_REPORTING_INTERVAL_SECONDS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_STATISTICS_REPORTING_INTERVAL_SECONDS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MESSAGES_SENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MESSAGES_SENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MESSAGES_SENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MESSAGES_RECEIVED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MESSAGES_RECEIVED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MESSAGES_RECEIVED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_SUBSCRIPTION_COUNT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_SUBSCRIPTION_COUNT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_SUBSCRIPTION_COUNT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_AVERAGE_DELIVERY_TIME_SECONDS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_AVERAGE_DELIVERY_TIME_SECONDS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_AVERAGE_DELIVERY_TIME_SECONDS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MIN_DELIVERY_TIME_SECONDS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MIN_DELIVERY_TIME_SECONDS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MIN_DELIVERY_TIME_SECONDS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MAX_DELIVERY_TIME_SECONDS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MAX_DELIVERY_TIME_SECONDS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MAX_DELIVERY_TIME_SECONDS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_STATISTICS_REPORTING_INTERVAL_SECONDS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_STATISTICS_REPORTING_INTERVAL_SECONDS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_STATISTICS_REPORTING_INTERVAL_SECONDS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CPU_USAGE_PERCENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CPU_USAGE_PERCENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CPU_USAGE_PERCENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CPU_AVERAGE_USAGE_PERCENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CPU_AVERAGE_USAGE_PERCENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CPU_AVERAGE_USAGE_PERCENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CPU_MIN_USAGE_PERCENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CPU_MIN_USAGE_PERCENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CPU_MIN_USAGE_PERCENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CPU_MAX_USAGE_PERCENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CPU_MAX_USAGE_PERCENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CPU_MAX_USAGE_PERCENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_RAM_USAGEMB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_RAM_USAGEMB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_RAM_USAGEMB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      name_and_location_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_NAME_AND_LOCATION_NAME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      name_and_location_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_NAME_AND_LOCATION_NAME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      name_and_location_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_NAME_AND_LOCATION_NAME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      name_and_location_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_NAME_AND_LOCATION_LOCATION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      name_and_location_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_NAME_AND_LOCATION_LOCATION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      name_and_location_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_NAME_AND_LOCATION_LOCATION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      configuration_parameters_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_CONFIGURATION_PARAMETERS_CONFIGURATION_PARAMETERS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      configuration_parameters_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_CONFIGURATION_PARAMETERS_CONFIGURATION_PARAMETERS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      configuration_parameters_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_CONFIGURATION_PARAMETERS_CONFIGURATION_PARAMETERS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_REPORTING_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_REPORTING_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_REPORTING_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_POSITION_AND_ORIENTATION_VALID,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_POSITION_AND_ORIENTATION_VALID,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_POSITION_AND_ORIENTATION_VALID);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_POSITION_AND_ORIENTATION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_POSITION_AND_ORIENTATION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_POSITION_AND_ORIENTATION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AZIMUTH_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AZIMUTH_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AZIMUTH_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ELEVATION_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ELEVATION_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ELEVATION_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ALLOW_LIST,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ALLOW_LIST,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ALLOW_LIST);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AOX_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AOX_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AOX_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_ARRAY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_ARRAY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_ARRAY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_PERIOD_SAMPLES,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_PERIOD_SAMPLES,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_PERIOD_SAMPLES);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING_WEIGHT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING_WEIGHT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING_WEIGHT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_TIMEOUT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_TIMEOUT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_TIMEOUT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_DELAY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_DELAY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_DELAY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_SAMPLING_INTERVAL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_SAMPLING_INTERVAL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_SAMPLING_INTERVAL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_LENGTH,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_LENGTH,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_LENGTH);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_SLOT_DURATION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_SLOT_DURATION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_SLOT_DURATION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_position_estimation_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_POSITION_ESTIMATION_POSITION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_position_estimation_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_POSITION_ESTIMATION_POSITION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_position_estimation_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_POSITION_ESTIMATION_POSITION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      protocol_controller_network_management_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_NETWORK_MANAGEMENT_NETWORK_MANAGEMENT_STATE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      protocol_controller_network_management_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_NETWORK_MANAGEMENT_NETWORK_MANAGEMENT_STATE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      protocol_controller_network_management_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_NETWORK_MANAGEMENT_NETWORK_MANAGEMENT_STATE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      descriptor_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_DESCRIPTOR_DEVICE_TYPE_LIST,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      descriptor_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_DESCRIPTOR_DEVICE_TYPE_LIST,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      descriptor_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_DESCRIPTOR_DEVICE_TYPE_LIST);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      unify_thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_UNIFY_THERMOSTAT_THERMOSTAT_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      unify_thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_UNIFY_THERMOSTAT_THERMOSTAT_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      unify_thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_UNIFY_THERMOSTAT_THERMOSTAT_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      unify_thermostat_cluster_publish_desired_value_callback,
      DOTDOT_ATTRIBUTE_ID_UNIFY_THERMOSTAT_SUPPORTED_THERMOSTAT_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      unify_thermostat_cluster_publish_reported_value_callback,
      DOTDOT_ATTRIBUTE_ID_UNIFY_THERMOSTAT_SUPPORTED_THERMOSTAT_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      unify_thermostat_cluster_cluster_revision_callback,
      DOTDOT_ATTRIBUTE_ID_UNIFY_THERMOSTAT_SUPPORTED_THERMOSTAT_MODE);

  return SL_STATUS_OK;
}
