/******************************************************************************
 * # License
 * <b>Copyright 2022 Silicon Laboratories Inc. www.silabs.com</b>
 ******************************************************************************
 * The licensor of this software is Silicon Laboratories Inc. Your use of this
 * software is governed by the terms of Silicon Labs Master Software License
 * Agreement (MSLA) available at
 * www.silabs.com/about-us/legal/master-software-license-agreement. This
 * software is distributed to you in Source Code format and is governed by the
 * sections of the MSLA applicable to Source Code.
 *
 *****************************************************************************/

// This file is generated by ZCL Advanced Platform generator. Please don't edit manually.

// Includes from this component
#include "dotdot_mqtt_supported_generated_commands.h"

// Unify includes
#include "uic_mqtt.h"

// Generic includes
#include <string>
#include <vector>
#include <nlohmann/json.hpp>


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the Basic cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Basic/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_basic_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_basic_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/Basic/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->reset_to_factory_defaults == true) {
    command_vector.emplace_back("ResetToFactoryDefaults");
  }
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the PowerConfiguration cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/PowerConfiguration/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_power_configuration_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_power_configuration_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/PowerConfiguration/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the DeviceTemperatureConfiguration cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DeviceTemperatureConfiguration/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_device_temperature_configuration_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_device_temperature_configuration_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/DeviceTemperatureConfiguration/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the Identify cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Identify/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_identify_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_identify_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/Identify/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->identify == true) {
    command_vector.emplace_back("Identify");
  }
  if (command_list->identify_query_response == true) {
    command_vector.emplace_back("IdentifyQueryResponse");
  }
  if (command_list->identify_query == true) {
    command_vector.emplace_back("IdentifyQuery");
  }
  if (command_list->trigger_effect == true) {
    command_vector.emplace_back("TriggerEffect");
  }
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the Groups cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_groups_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_groups_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/Groups/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->add_group == true) {
    command_vector.emplace_back("AddGroup");
  }
  if (command_list->add_group_response == true) {
    command_vector.emplace_back("AddGroupResponse");
  }
  if (command_list->view_group == true) {
    command_vector.emplace_back("ViewGroup");
  }
  if (command_list->view_group_response == true) {
    command_vector.emplace_back("ViewGroupResponse");
  }
  if (command_list->get_group_membership == true) {
    command_vector.emplace_back("GetGroupMembership");
  }
  if (command_list->get_group_membership_response == true) {
    command_vector.emplace_back("GetGroupMembershipResponse");
  }
  if (command_list->remove_group == true) {
    command_vector.emplace_back("RemoveGroup");
  }
  if (command_list->remove_group_response == true) {
    command_vector.emplace_back("RemoveGroupResponse");
  }
  if (command_list->remove_all_groups == true) {
    command_vector.emplace_back("RemoveAllGroups");
  }
  if (command_list->add_group_if_identifying == true) {
    command_vector.emplace_back("AddGroupIfIdentifying");
  }
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the Scenes cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_scenes_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/Scenes/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->add_scene == true) {
    command_vector.emplace_back("AddScene");
  }
  if (command_list->add_scene_response == true) {
    command_vector.emplace_back("AddSceneResponse");
  }
  if (command_list->view_scene == true) {
    command_vector.emplace_back("ViewScene");
  }
  if (command_list->view_scene_response == true) {
    command_vector.emplace_back("ViewSceneResponse");
  }
  if (command_list->remove_scene == true) {
    command_vector.emplace_back("RemoveScene");
  }
  if (command_list->remove_scene_response == true) {
    command_vector.emplace_back("RemoveSceneResponse");
  }
  if (command_list->remove_all_scenes == true) {
    command_vector.emplace_back("RemoveAllScenes");
  }
  if (command_list->remove_all_scenes_response == true) {
    command_vector.emplace_back("RemoveAllScenesResponse");
  }
  if (command_list->store_scene == true) {
    command_vector.emplace_back("StoreScene");
  }
  if (command_list->store_scene_response == true) {
    command_vector.emplace_back("StoreSceneResponse");
  }
  if (command_list->recall_scene == true) {
    command_vector.emplace_back("RecallScene");
  }
  if (command_list->get_scene_membership == true) {
    command_vector.emplace_back("GetSceneMembership");
  }
  if (command_list->get_scene_membership_response == true) {
    command_vector.emplace_back("GetSceneMembershipResponse");
  }
  if (command_list->enhanced_add_scene == true) {
    command_vector.emplace_back("EnhancedAddScene");
  }
  if (command_list->enhanced_add_scene_response == true) {
    command_vector.emplace_back("EnhancedAddSceneResponse");
  }
  if (command_list->enhanced_view_scene == true) {
    command_vector.emplace_back("EnhancedViewScene");
  }
  if (command_list->enhanced_view_scene_response == true) {
    command_vector.emplace_back("EnhancedViewSceneResponse");
  }
  if (command_list->copy_scene == true) {
    command_vector.emplace_back("CopyScene");
  }
  if (command_list->copy_scene_response == true) {
    command_vector.emplace_back("CopySceneResponse");
  }
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the OnOff cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OnOff/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_on_off_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_on_off_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/OnOff/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->off == true) {
    command_vector.emplace_back("Off");
  }
  if (command_list->on == true) {
    command_vector.emplace_back("On");
  }
  if (command_list->toggle == true) {
    command_vector.emplace_back("Toggle");
  }
  if (command_list->off_with_effect == true) {
    command_vector.emplace_back("OffWithEffect");
  }
  if (command_list->on_with_recall_global_scene == true) {
    command_vector.emplace_back("OnWithRecallGlobalScene");
  }
  if (command_list->on_with_timed_off == true) {
    command_vector.emplace_back("OnWithTimedOff");
  }
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the Level cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_level_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_level_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/Level/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->move_to_level == true) {
    command_vector.emplace_back("MoveToLevel");
  }
  if (command_list->move == true) {
    command_vector.emplace_back("Move");
  }
  if (command_list->step == true) {
    command_vector.emplace_back("Step");
  }
  if (command_list->stop == true) {
    command_vector.emplace_back("Stop");
  }
  if (command_list->move_to_level_with_on_off == true) {
    command_vector.emplace_back("MoveToLevelWithOnOff");
  }
  if (command_list->move_with_on_off == true) {
    command_vector.emplace_back("MoveWithOnOff");
  }
  if (command_list->step_with_on_off == true) {
    command_vector.emplace_back("StepWithOnOff");
  }
  if (command_list->stop_with_on_off == true) {
    command_vector.emplace_back("StopWithOnOff");
  }
  if (command_list->move_to_closest_frequency == true) {
    command_vector.emplace_back("MoveToClosestFrequency");
  }
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the Alarms cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Alarms/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_alarms_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_alarms_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/Alarms/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->reset_alarm == true) {
    command_vector.emplace_back("ResetAlarm");
  }
  if (command_list->alarm == true) {
    command_vector.emplace_back("Alarm");
  }
  if (command_list->reset_all_alarms == true) {
    command_vector.emplace_back("ResetAllAlarms");
  }
  if (command_list->get_alarm_response == true) {
    command_vector.emplace_back("GetAlarmResponse");
  }
  if (command_list->get_alarm == true) {
    command_vector.emplace_back("GetAlarm");
  }
  if (command_list->reset_alarm_log == true) {
    command_vector.emplace_back("ResetAlarmLog");
  }
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the Time cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Time/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_time_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_time_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/Time/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the PollControl cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/PollControl/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_poll_control_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_poll_control_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/PollControl/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->check_in == true) {
    command_vector.emplace_back("CheckIn");
  }
  if (command_list->check_in_response == true) {
    command_vector.emplace_back("CheckInResponse");
  }
  if (command_list->fast_poll_stop == true) {
    command_vector.emplace_back("FastPollStop");
  }
  if (command_list->set_long_poll_interval == true) {
    command_vector.emplace_back("SetLongPollInterval");
  }
  if (command_list->set_short_poll_interval == true) {
    command_vector.emplace_back("SetShortPollInterval");
  }
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the ShadeConfiguration cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ShadeConfiguration/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_shade_configuration_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_shade_configuration_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/ShadeConfiguration/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the DoorLock cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_door_lock_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/DoorLock/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->lock_door == true) {
    command_vector.emplace_back("LockDoor");
  }
  if (command_list->lock_door_response == true) {
    command_vector.emplace_back("LockDoorResponse");
  }
  if (command_list->unlock_door == true) {
    command_vector.emplace_back("UnlockDoor");
  }
  if (command_list->unlock_door_response == true) {
    command_vector.emplace_back("UnlockDoorResponse");
  }
  if (command_list->toggle == true) {
    command_vector.emplace_back("Toggle");
  }
  if (command_list->toggle_response == true) {
    command_vector.emplace_back("ToggleResponse");
  }
  if (command_list->unlock_with_timeout == true) {
    command_vector.emplace_back("UnlockWithTimeout");
  }
  if (command_list->unlock_with_timeout_response == true) {
    command_vector.emplace_back("UnlockWithTimeoutResponse");
  }
  if (command_list->get_log_record == true) {
    command_vector.emplace_back("GetLogRecord");
  }
  if (command_list->get_log_record_response == true) {
    command_vector.emplace_back("GetLogRecordResponse");
  }
  if (command_list->setpin_code == true) {
    command_vector.emplace_back("SetPINCode");
  }
  if (command_list->setpin_code_response == true) {
    command_vector.emplace_back("SetPINCodeResponse");
  }
  if (command_list->getpin_code == true) {
    command_vector.emplace_back("GetPINCode");
  }
  if (command_list->getpin_code_response == true) {
    command_vector.emplace_back("GetPINCodeResponse");
  }
  if (command_list->clearpin_code == true) {
    command_vector.emplace_back("ClearPINCode");
  }
  if (command_list->clearpin_code_response == true) {
    command_vector.emplace_back("ClearPINCodeResponse");
  }
  if (command_list->clear_allpin_codes == true) {
    command_vector.emplace_back("ClearAllPINCodes");
  }
  if (command_list->clear_allpin_codes_response == true) {
    command_vector.emplace_back("ClearAllPINCodesResponse");
  }
  if (command_list->set_user_status == true) {
    command_vector.emplace_back("SetUserStatus");
  }
  if (command_list->set_user_status_response == true) {
    command_vector.emplace_back("SetUserStatusResponse");
  }
  if (command_list->get_user_status == true) {
    command_vector.emplace_back("GetUserStatus");
  }
  if (command_list->get_user_status_response == true) {
    command_vector.emplace_back("GetUserStatusResponse");
  }
  if (command_list->set_weekday_schedule == true) {
    command_vector.emplace_back("SetWeekdaySchedule");
  }
  if (command_list->set_weekday_schedule_response == true) {
    command_vector.emplace_back("SetWeekdayScheduleResponse");
  }
  if (command_list->get_weekday_schedule == true) {
    command_vector.emplace_back("GetWeekdaySchedule");
  }
  if (command_list->get_weekday_schedule_response == true) {
    command_vector.emplace_back("GetWeekdayScheduleResponse");
  }
  if (command_list->clear_weekday_schedule == true) {
    command_vector.emplace_back("ClearWeekdaySchedule");
  }
  if (command_list->clear_weekday_schedule_response == true) {
    command_vector.emplace_back("ClearWeekdayScheduleResponse");
  }
  if (command_list->set_year_day_schedule == true) {
    command_vector.emplace_back("SetYearDaySchedule");
  }
  if (command_list->set_year_day_schedule_response == true) {
    command_vector.emplace_back("SetYearDayScheduleResponse");
  }
  if (command_list->get_year_day_schedule == true) {
    command_vector.emplace_back("GetYearDaySchedule");
  }
  if (command_list->get_year_day_schedule_response == true) {
    command_vector.emplace_back("GetYearDayScheduleResponse");
  }
  if (command_list->clear_year_day_schedule == true) {
    command_vector.emplace_back("ClearYearDaySchedule");
  }
  if (command_list->clear_year_day_schedule_response == true) {
    command_vector.emplace_back("ClearYearDayScheduleResponse");
  }
  if (command_list->set_holiday_schedule == true) {
    command_vector.emplace_back("SetHolidaySchedule");
  }
  if (command_list->set_holiday_schedule_response == true) {
    command_vector.emplace_back("SetHolidayScheduleResponse");
  }
  if (command_list->get_holiday_schedule == true) {
    command_vector.emplace_back("GetHolidaySchedule");
  }
  if (command_list->get_holiday_schedule_response == true) {
    command_vector.emplace_back("GetHolidayScheduleResponse");
  }
  if (command_list->clear_holiday_schedule == true) {
    command_vector.emplace_back("ClearHolidaySchedule");
  }
  if (command_list->clear_holiday_schedule_response == true) {
    command_vector.emplace_back("ClearHolidayScheduleResponse");
  }
  if (command_list->set_user_type == true) {
    command_vector.emplace_back("SetUserType");
  }
  if (command_list->set_user_type_response == true) {
    command_vector.emplace_back("SetUserTypeResponse");
  }
  if (command_list->get_user_type == true) {
    command_vector.emplace_back("GetUserType");
  }
  if (command_list->get_user_type_response == true) {
    command_vector.emplace_back("GetUserTypeResponse");
  }
  if (command_list->setrfid_code == true) {
    command_vector.emplace_back("SetRFIDCode");
  }
  if (command_list->setrfid_code_response == true) {
    command_vector.emplace_back("SetRFIDCodeResponse");
  }
  if (command_list->getrfid_code == true) {
    command_vector.emplace_back("GetRFIDCode");
  }
  if (command_list->getrfid_code_response == true) {
    command_vector.emplace_back("GetRFIDCodeResponse");
  }
  if (command_list->clearrfid_code == true) {
    command_vector.emplace_back("ClearRFIDCode");
  }
  if (command_list->clearrfid_code_response == true) {
    command_vector.emplace_back("ClearRFIDCodeResponse");
  }
  if (command_list->clear_allrfid_codes == true) {
    command_vector.emplace_back("ClearAllRFIDCodes");
  }
  if (command_list->clear_allrfid_codes_response == true) {
    command_vector.emplace_back("ClearAllRFIDCodesResponse");
  }
  if (command_list->operating_event_notification == true) {
    command_vector.emplace_back("OperatingEventNotification");
  }
  if (command_list->programming_event_notification == true) {
    command_vector.emplace_back("ProgrammingEventNotification");
  }
  if (command_list->get_allpin_codes == true) {
    command_vector.emplace_back("GetAllPINCodes");
  }
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the WindowCovering cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/WindowCovering/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_window_covering_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_window_covering_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/WindowCovering/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->up_or_open == true) {
    command_vector.emplace_back("UpOrOpen");
  }
  if (command_list->down_or_close == true) {
    command_vector.emplace_back("DownOrClose");
  }
  if (command_list->stop == true) {
    command_vector.emplace_back("Stop");
  }
  if (command_list->go_to_lift_value == true) {
    command_vector.emplace_back("GoToLiftValue");
  }
  if (command_list->go_to_lift_percentage == true) {
    command_vector.emplace_back("GoToLiftPercentage");
  }
  if (command_list->go_to_tilt_value == true) {
    command_vector.emplace_back("GoToTiltValue");
  }
  if (command_list->go_to_tilt_percentage == true) {
    command_vector.emplace_back("GoToTiltPercentage");
  }
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the BarrierControl cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/BarrierControl/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_barrier_control_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_barrier_control_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/BarrierControl/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->go_to_percent == true) {
    command_vector.emplace_back("GoToPercent");
  }
  if (command_list->stop == true) {
    command_vector.emplace_back("Stop");
  }
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the PumpConfigurationAndControl cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/PumpConfigurationAndControl/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_pump_configuration_and_control_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_pump_configuration_and_control_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/PumpConfigurationAndControl/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the Thermostat cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Thermostat/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_thermostat_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_thermostat_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/Thermostat/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->setpoint_raise_or_lower == true) {
    command_vector.emplace_back("SetpointRaiseOrLower");
  }
  if (command_list->get_weekly_schedule_response == true) {
    command_vector.emplace_back("GetWeeklyScheduleResponse");
  }
  if (command_list->set_weekly_schedule == true) {
    command_vector.emplace_back("SetWeeklySchedule");
  }
  if (command_list->get_relay_status_log_response == true) {
    command_vector.emplace_back("GetRelayStatusLogResponse");
  }
  if (command_list->get_weekly_schedule == true) {
    command_vector.emplace_back("GetWeeklySchedule");
  }
  if (command_list->clear_weekly_schedule == true) {
    command_vector.emplace_back("ClearWeeklySchedule");
  }
  if (command_list->get_relay_status_log == true) {
    command_vector.emplace_back("GetRelayStatusLog");
  }
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the FanControl cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/FanControl/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_fan_control_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_fan_control_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/FanControl/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the DehumidificationControl cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DehumidificationControl/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_dehumidification_control_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_dehumidification_control_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/DehumidificationControl/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the ThermostatUserInterfaceConfiguration cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ThermostatUserInterfaceConfiguration/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_thermostat_user_interface_configuration_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_thermostat_user_interface_configuration_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/ThermostatUserInterfaceConfiguration/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the ColorControl cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_color_control_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/ColorControl/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->move_to_hue == true) {
    command_vector.emplace_back("MoveToHue");
  }
  if (command_list->move_hue == true) {
    command_vector.emplace_back("MoveHue");
  }
  if (command_list->step_hue == true) {
    command_vector.emplace_back("StepHue");
  }
  if (command_list->move_to_saturation == true) {
    command_vector.emplace_back("MoveToSaturation");
  }
  if (command_list->move_saturation == true) {
    command_vector.emplace_back("MoveSaturation");
  }
  if (command_list->step_saturation == true) {
    command_vector.emplace_back("StepSaturation");
  }
  if (command_list->move_to_hue_and_saturation == true) {
    command_vector.emplace_back("MoveToHueAndSaturation");
  }
  if (command_list->move_to_color == true) {
    command_vector.emplace_back("MoveToColor");
  }
  if (command_list->move_color == true) {
    command_vector.emplace_back("MoveColor");
  }
  if (command_list->step_color == true) {
    command_vector.emplace_back("StepColor");
  }
  if (command_list->move_to_color_temperature == true) {
    command_vector.emplace_back("MoveToColorTemperature");
  }
  if (command_list->enhanced_move_to_hue == true) {
    command_vector.emplace_back("EnhancedMoveToHue");
  }
  if (command_list->enhanced_move_hue == true) {
    command_vector.emplace_back("EnhancedMoveHue");
  }
  if (command_list->enhanced_step_hue == true) {
    command_vector.emplace_back("EnhancedStepHue");
  }
  if (command_list->enhanced_move_to_hue_and_saturation == true) {
    command_vector.emplace_back("EnhancedMoveToHueAndSaturation");
  }
  if (command_list->color_loop_set == true) {
    command_vector.emplace_back("ColorLoopSet");
  }
  if (command_list->stop_move_step == true) {
    command_vector.emplace_back("StopMoveStep");
  }
  if (command_list->move_color_temperature == true) {
    command_vector.emplace_back("MoveColorTemperature");
  }
  if (command_list->step_color_temperature == true) {
    command_vector.emplace_back("StepColorTemperature");
  }
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the BallastConfiguration cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/BallastConfiguration/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_ballast_configuration_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_ballast_configuration_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/BallastConfiguration/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the IlluminanceMeasurement cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IlluminanceMeasurement/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_illuminance_measurement_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_illuminance_measurement_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/IlluminanceMeasurement/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the IlluminanceLevelSensing cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IlluminanceLevelSensing/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_illuminance_level_sensing_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_illuminance_level_sensing_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/IlluminanceLevelSensing/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the TemperatureMeasurement cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/TemperatureMeasurement/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_temperature_measurement_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_temperature_measurement_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/TemperatureMeasurement/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the PressureMeasurement cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/PressureMeasurement/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_pressure_measurement_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_pressure_measurement_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/PressureMeasurement/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the FlowMeasurement cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/FlowMeasurement/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_flow_measurement_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_flow_measurement_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/FlowMeasurement/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the RelativityHumidity cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/RelativityHumidity/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_relativity_humidity_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_relativity_humidity_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/RelativityHumidity/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the OccupancySensing cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OccupancySensing/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_occupancy_sensing_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_occupancy_sensing_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/OccupancySensing/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the SoilMoisture cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/SoilMoisture/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_soil_moisture_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_soil_moisture_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/SoilMoisture/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the PhMeasurement cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/PhMeasurement/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_ph_measurement_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_ph_measurement_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/PhMeasurement/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the ElectricalConductivityMeasurement cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ElectricalConductivityMeasurement/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_electrical_conductivity_measurement_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_electrical_conductivity_measurement_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/ElectricalConductivityMeasurement/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the WindSpeedMeasurement cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/WindSpeedMeasurement/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_wind_speed_measurement_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_wind_speed_measurement_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/WindSpeedMeasurement/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the CarbonMonoxide cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/CarbonMonoxide/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_carbon_monoxide_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_carbon_monoxide_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/CarbonMonoxide/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the CarbonDioxide cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/CarbonDioxide/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_carbon_dioxide_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_carbon_dioxide_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/CarbonDioxide/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the PM25 cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/PM25/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_pm25_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_pm25_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/PM25/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the IASZone cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IASZone/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_ias_zone_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_ias_zone_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/IASZone/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->zone_enroll_response == true) {
    command_vector.emplace_back("ZoneEnrollResponse");
  }
  if (command_list->zone_status_change_notification == true) {
    command_vector.emplace_back("ZoneStatusChangeNotification");
  }
  if (command_list->initiate_normal_operation_mode == true) {
    command_vector.emplace_back("InitiateNormalOperationMode");
  }
  if (command_list->zone_enroll_request == true) {
    command_vector.emplace_back("ZoneEnrollRequest");
  }
  if (command_list->initiate_test_mode == true) {
    command_vector.emplace_back("InitiateTestMode");
  }
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the IASWD cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IASWD/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_iaswd_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_iaswd_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/IASWD/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->start_warning == true) {
    command_vector.emplace_back("StartWarning");
  }
  if (command_list->squawk == true) {
    command_vector.emplace_back("Squawk");
  }
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the Metering cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Metering/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_metering_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_metering_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/Metering/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the ElectricalMeasurement cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ElectricalMeasurement/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_electrical_measurement_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_electrical_measurement_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/ElectricalMeasurement/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->get_profile_info_response == true) {
    command_vector.emplace_back("GetProfileInfoResponse");
  }
  if (command_list->get_profile_info == true) {
    command_vector.emplace_back("GetProfileInfo");
  }
  if (command_list->get_measurement_profile_response == true) {
    command_vector.emplace_back("GetMeasurementProfileResponse");
  }
  if (command_list->get_measurement_profile == true) {
    command_vector.emplace_back("GetMeasurementProfile");
  }
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the Diagnostics cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Diagnostics/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_diagnostics_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_diagnostics_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/Diagnostics/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the ProtocolController-RFTelemetry cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/ProtocolController/RFTelemetry/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_protocol_controller_rf_telemetry_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const uic_mqtt_dotdot_protocol_controller_rf_telemetry_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  // No endpoint for this topic
  topic +=  "/ProtocolController/RFTelemetry/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->tx_report == true) {
    command_vector.emplace_back("TxReport");
  }
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the State cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/State/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_state_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const uic_mqtt_dotdot_state_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  // No endpoint for this topic
  topic +=  "/State/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->remove == true) {
    command_vector.emplace_back("Remove");
  }
  if (command_list->remove_offline == true) {
    command_vector.emplace_back("RemoveOffline");
  }
  if (command_list->discover_neighbors == true) {
    command_vector.emplace_back("DiscoverNeighbors");
  }
  if (command_list->interview == true) {
    command_vector.emplace_back("Interview");
  }
  if (command_list->discover_security == true) {
    command_vector.emplace_back("DiscoverSecurity");
  }
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the Binding cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Binding/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_binding_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_binding_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/Binding/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->bind == true) {
    command_vector.emplace_back("Bind");
  }
  if (command_list->unbind == true) {
    command_vector.emplace_back("Unbind");
  }
  if (command_list->bind_to_protocol_controller == true) {
    command_vector.emplace_back("BindToProtocolController");
  }
  if (command_list->unbind_from_protocol_controller == true) {
    command_vector.emplace_back("UnbindFromProtocolController");
  }
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the SystemMetrics cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/SystemMetrics/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_system_metrics_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const uic_mqtt_dotdot_system_metrics_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  // No endpoint for this topic
  topic +=  "/SystemMetrics/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the ApplicationMonitoring cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/ApplicationMonitoring/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_application_monitoring_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const uic_mqtt_dotdot_application_monitoring_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  // No endpoint for this topic
  topic +=  "/ApplicationMonitoring/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->log_entry == true) {
    command_vector.emplace_back("LogEntry");
  }
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the NameAndLocation cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/NameAndLocation/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_name_and_location_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_name_and_location_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/NameAndLocation/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the ConfigurationParameters cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ConfigurationParameters/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_configuration_parameters_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_configuration_parameters_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/ConfigurationParameters/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->discover_parameter == true) {
    command_vector.emplace_back("DiscoverParameter");
  }
  if (command_list->default_reset_all_parameters == true) {
    command_vector.emplace_back("DefaultResetAllParameters");
  }
  if (command_list->set_parameter == true) {
    command_vector.emplace_back("SetParameter");
  }
  if (command_list->discover_parameter_range == true) {
    command_vector.emplace_back("DiscoverParameterRange");
  }
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the AoXLocator cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/AoXLocator/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_aox_locator_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_aox_locator_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/AoXLocator/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->iq_report == true) {
    command_vector.emplace_back("IQReport");
  }
  if (command_list->angle_report == true) {
    command_vector.emplace_back("AngleReport");
  }
  if (command_list->angle_correction == true) {
    command_vector.emplace_back("AngleCorrection");
  }
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the AoXPositionEstimation cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/AoXPositionEstimation/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_aox_position_estimation_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_aox_position_estimation_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint);
  topic +=  "/AoXPositionEstimation/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}


/**
 * @brief Sends/Publishes a the SupportedGenerated commands for
 * the ProtocolController-NetworkManagement cluster for a UNID/Endpoint
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/ProtocolController/NetworkManagement/SupportedGeneratedCommands
 *
 * @param unid      The UNID of the node on behalf of which the advertisment is made
 * 
 * @param command_list      Struct pointer with the fields value indicating if
 *                          individual commands can be generated.
 */
void uic_mqtt_dotdot_protocol_controller_network_management_publish_supported_generated_commands(
  const dotdot_unid_t unid,
  const uic_mqtt_dotdot_protocol_controller_network_management_supported_commands_t *command_list)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  // No endpoint for this topic
  topic +=  "/ProtocolController/NetworkManagement/SupportedGeneratedCommands";

  // Assemble of vector of strings for the Supported Commands:
  std::vector<std::string> command_vector;
  if (command_list->write == true) {
    command_vector.emplace_back("Write");
  }
  if (command_list->write_attributes == true) {
    command_vector.emplace_back("WriteAttributes");
  }

  // JSONify, then Stringify
  nlohmann::json json_payload;
  json_payload["value"] = command_vector;
  std::string string_payload = json_payload.dump();

  // Publish to MQTT
  uic_mqtt_publish(topic.c_str(),
                   string_payload.c_str(),
                   string_payload.length(),
                   true);

}

