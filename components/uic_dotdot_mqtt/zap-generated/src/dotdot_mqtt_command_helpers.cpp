/******************************************************************************
 * # License
 * <b>Copyright 2022 Silicon Laboratories Inc. www.silabs.com</b>
 ******************************************************************************
 * The licensor of this software is Silicon Laboratories Inc. Your use of this
 * software is governed by the terms of Silicon Labs Master Software License
 * Agreement (MSLA) available at
 * www.silabs.com/about-us/legal/master-software-license-agreement. This
 * software is distributed to you in Source Code format and is governed by the
 * sections of the MSLA applicable to Source Code.
 *
 *****************************************************************************/

// This file is generated by ZCL Advanced Platform generator. Please don't edit manually.

#include <string>
#include <vector>
#include <inttypes.h>

#include <boost/algorithm/string.hpp>
#include <nlohmann/json.hpp>

#include "uic_mqtt.h"
#include "sl_log.h"
#include "sl_status.h"

#include "dotdot_bitmap.hpp"
#include "json_helpers.hpp"
#include "dotdot_mqtt.h"
#include "dotdot_mqtt.hpp"
#include "dotdot_mqtt_command_helpers.hpp"
#include "dotdot_mqtt_parsing_helpers.hpp"
#include "dotdot_mqtt_translators.h"

static constexpr char LOG_TAG[] = "dotdot_mqtt";

template<typename Type>
Type get_enum_decimal_value(const std::string &key, nlohmann::json &jsn)
{
  if (jsn[key].is_number_integer()) {
    return jsn[key].get<Type>();
  } else if (jsn[key].is_string()) {
    try {
      std::string payload_value = jsn[key].get<std::string>();
      boost::replace_all(payload_value, "\"", "");
      Type value = static_cast<Type>(std::stoi(payload_value, nullptr, 0));
      sl_log_debug(LOG_TAG,
                     "Accepted a decimal value '%s' as enum argument.",
                     payload_value.c_str());
      return value;
    } catch (std::invalid_argument &e) {
      return std::numeric_limits<Type>::max();
    }
  } else {
    sl_log_debug(LOG_TAG, "Failed to parse JSON message, invalid Json value");
    return std::numeric_limits<Type>::max();
  }
}

////////////////////////////////////////////////////////////////////////////////
// Command fields parsing functions
////////////////////////////////////////////////////////////////////////////////

std::string get_json_payload_for_basic_reset_to_factory_defaults_command(
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}




/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_basic_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_basic_state_t &new_state,
  uic_mqtt_dotdot_basic_updated_state_t &new_updated_state
) {


  if (jsn.find("LocationDescription") != jsn.end()) {

    new_state.location_description = jsn.at("LocationDescription").get_ptr<const std::string*>()->c_str();
  
    new_updated_state.location_description = true;
  }

  if (jsn.find("PhysicalEnvironment") != jsn.end()) {

    uint32_t tmp = get_enum_decimal_value<BasicPhysicalEnvironment>("PhysicalEnvironment", jsn);
    if (tmp == std::numeric_limits<BasicPhysicalEnvironment>::max()) {
      #ifdef BASIC_PHYSICAL_ENVIRONMENT_ENUM_NAME_AVAILABLE
      tmp = basic_physical_environment_get_enum_value_number(jsn.at("PhysicalEnvironment").get<std::string>());
      #elif defined(PHYSICAL_ENVIRONMENT_ENUM_NAME_AVAILABLE)
      tmp = physical_environment_get_enum_value_number(jsn.at("PhysicalEnvironment").get<std::string>());
      #endif
    }
    new_state.physical_environment = tmp;
  
    new_updated_state.physical_environment = true;
  }

  if (jsn.find("DeviceEnabled") != jsn.end()) {

    new_state.device_enabled = get_bool_from_json(jsn, "DeviceEnabled");
  
    new_updated_state.device_enabled = true;
  }

  if (jsn.find("AlarmMask") != jsn.end()) {

    new_state.alarm_mask = uic_dotdot_mqtt::get_bitmap_decimal_value("AlarmMask", jsn, BasicAlarmMask);
  
    new_updated_state.alarm_mask = true;
  }

  if (jsn.find("DisableLocalConfig") != jsn.end()) {

    new_state.disable_local_config = uic_dotdot_mqtt::get_bitmap_decimal_value("DisableLocalConfig", jsn, BasicDisableLocalConfig);
  
    new_updated_state.disable_local_config = true;
  }


}


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_power_configuration_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_power_configuration_state_t &new_state,
  uic_mqtt_dotdot_power_configuration_updated_state_t &new_updated_state
) {


  if (jsn.find("MainsAlarmMask") != jsn.end()) {

    new_state.mains_alarm_mask = uic_dotdot_mqtt::get_bitmap_decimal_value("MainsAlarmMask", jsn, PowerConfigurationMainsAlarmMask);
  
    new_updated_state.mains_alarm_mask = true;
  }

  if (jsn.find("MainsVoltageMinThreshold") != jsn.end()) {

    new_state.mains_voltage_min_threshold = jsn.at("MainsVoltageMinThreshold").get<uint16_t>();
        
    new_updated_state.mains_voltage_min_threshold = true;
  }

  if (jsn.find("MainsVoltageMaxThreshold") != jsn.end()) {

    new_state.mains_voltage_max_threshold = jsn.at("MainsVoltageMaxThreshold").get<uint16_t>();
        
    new_updated_state.mains_voltage_max_threshold = true;
  }

  if (jsn.find("MainsVoltageDwellTripPoint") != jsn.end()) {

    new_state.mains_voltage_dwell_trip_point = jsn.at("MainsVoltageDwellTripPoint").get<uint16_t>();
        
    new_updated_state.mains_voltage_dwell_trip_point = true;
  }

  if (jsn.find("BatteryManufacturer") != jsn.end()) {

    new_state.battery_manufacturer = jsn.at("BatteryManufacturer").get_ptr<const std::string*>()->c_str();
  
    new_updated_state.battery_manufacturer = true;
  }

  if (jsn.find("BatterySize") != jsn.end()) {

    uint32_t tmp = get_enum_decimal_value<BatterySize>("BatterySize", jsn);
    if (tmp == std::numeric_limits<BatterySize>::max()) {
      #ifdef POWER_CONFIGURATION_BATTERY_SIZE_ENUM_NAME_AVAILABLE
      tmp = power_configuration_battery_size_get_enum_value_number(jsn.at("BatterySize").get<std::string>());
      #elif defined(BATTERY_SIZE_ENUM_NAME_AVAILABLE)
      tmp = battery_size_get_enum_value_number(jsn.at("BatterySize").get<std::string>());
      #endif
    }
    new_state.battery_size = tmp;
  
    new_updated_state.battery_size = true;
  }

  if (jsn.find("BatteryAHrRating") != jsn.end()) {

    new_state.batterya_hr_rating = jsn.at("BatteryAHrRating").get<uint16_t>();
        
    new_updated_state.batterya_hr_rating = true;
  }

  if (jsn.find("BatteryQuantity") != jsn.end()) {

    new_state.battery_quantity = jsn.at("BatteryQuantity").get<uint8_t>();
        
    new_updated_state.battery_quantity = true;
  }

  if (jsn.find("BatteryRatedVoltage") != jsn.end()) {

    new_state.battery_rated_voltage = jsn.at("BatteryRatedVoltage").get<uint8_t>();
        
    new_updated_state.battery_rated_voltage = true;
  }

  if (jsn.find("BatteryAlarmMask") != jsn.end()) {

    new_state.battery_alarm_mask = uic_dotdot_mqtt::get_bitmap_decimal_value("BatteryAlarmMask", jsn, BatteryAlarmMask);
  
    new_updated_state.battery_alarm_mask = true;
  }

  if (jsn.find("BatteryVoltageMinThreshold") != jsn.end()) {

    new_state.battery_voltage_min_threshold = jsn.at("BatteryVoltageMinThreshold").get<uint8_t>();
        
    new_updated_state.battery_voltage_min_threshold = true;
  }

  if (jsn.find("BatteryVoltageThreshold1") != jsn.end()) {

    new_state.battery_voltage_threshold1 = jsn.at("BatteryVoltageThreshold1").get<uint8_t>();
        
    new_updated_state.battery_voltage_threshold1 = true;
  }

  if (jsn.find("BatteryVoltageThreshold2") != jsn.end()) {

    new_state.battery_voltage_threshold2 = jsn.at("BatteryVoltageThreshold2").get<uint8_t>();
        
    new_updated_state.battery_voltage_threshold2 = true;
  }

  if (jsn.find("BatteryVoltageThreshold3") != jsn.end()) {

    new_state.battery_voltage_threshold3 = jsn.at("BatteryVoltageThreshold3").get<uint8_t>();
        
    new_updated_state.battery_voltage_threshold3 = true;
  }

  if (jsn.find("BatteryPercentageMinThreshold") != jsn.end()) {

    new_state.battery_percentage_min_threshold = jsn.at("BatteryPercentageMinThreshold").get<uint8_t>();
        
    new_updated_state.battery_percentage_min_threshold = true;
  }

  if (jsn.find("BatteryPercentageThreshold1") != jsn.end()) {

    new_state.battery_percentage_threshold1 = jsn.at("BatteryPercentageThreshold1").get<uint8_t>();
        
    new_updated_state.battery_percentage_threshold1 = true;
  }

  if (jsn.find("BatteryPercentageThreshold2") != jsn.end()) {

    new_state.battery_percentage_threshold2 = jsn.at("BatteryPercentageThreshold2").get<uint8_t>();
        
    new_updated_state.battery_percentage_threshold2 = true;
  }

  if (jsn.find("BatteryPercentageThreshold3") != jsn.end()) {

    new_state.battery_percentage_threshold3 = jsn.at("BatteryPercentageThreshold3").get<uint8_t>();
        
    new_updated_state.battery_percentage_threshold3 = true;
  }

  if (jsn.find("Battery2Manufacturer") != jsn.end()) {

    new_state.battery2_manufacturer = jsn.at("Battery2Manufacturer").get_ptr<const std::string*>()->c_str();
  
    new_updated_state.battery2_manufacturer = true;
  }

  if (jsn.find("Battery2Size") != jsn.end()) {

    uint32_t tmp = get_enum_decimal_value<BatterySize>("Battery2Size", jsn);
    if (tmp == std::numeric_limits<BatterySize>::max()) {
      #ifdef POWER_CONFIGURATION_BATTERY2_SIZE_ENUM_NAME_AVAILABLE
      tmp = power_configuration_battery2_size_get_enum_value_number(jsn.at("Battery2Size").get<std::string>());
      #elif defined(BATTERY2_SIZE_ENUM_NAME_AVAILABLE)
      tmp = battery2_size_get_enum_value_number(jsn.at("Battery2Size").get<std::string>());
      #endif
    }
    new_state.battery2_size = tmp;
  
    new_updated_state.battery2_size = true;
  }

  if (jsn.find("Battery2AHrRating") != jsn.end()) {

    new_state.battery2a_hr_rating = jsn.at("Battery2AHrRating").get<uint16_t>();
        
    new_updated_state.battery2a_hr_rating = true;
  }

  if (jsn.find("Battery2Quantity") != jsn.end()) {

    new_state.battery2_quantity = jsn.at("Battery2Quantity").get<uint8_t>();
        
    new_updated_state.battery2_quantity = true;
  }

  if (jsn.find("Battery2RatedVoltage") != jsn.end()) {

    new_state.battery2_rated_voltage = jsn.at("Battery2RatedVoltage").get<uint8_t>();
        
    new_updated_state.battery2_rated_voltage = true;
  }

  if (jsn.find("Battery2AlarmMask") != jsn.end()) {

    new_state.battery2_alarm_mask = uic_dotdot_mqtt::get_bitmap_decimal_value("Battery2AlarmMask", jsn, BatteryAlarmMask);
  
    new_updated_state.battery2_alarm_mask = true;
  }

  if (jsn.find("Battery2VoltageMinThreshold") != jsn.end()) {

    new_state.battery2_voltage_min_threshold = jsn.at("Battery2VoltageMinThreshold").get<uint8_t>();
        
    new_updated_state.battery2_voltage_min_threshold = true;
  }

  if (jsn.find("Battery2VoltageThreshold1") != jsn.end()) {

    new_state.battery2_voltage_threshold1 = jsn.at("Battery2VoltageThreshold1").get<uint8_t>();
        
    new_updated_state.battery2_voltage_threshold1 = true;
  }

  if (jsn.find("Battery2VoltageThreshold2") != jsn.end()) {

    new_state.battery2_voltage_threshold2 = jsn.at("Battery2VoltageThreshold2").get<uint8_t>();
        
    new_updated_state.battery2_voltage_threshold2 = true;
  }

  if (jsn.find("Battery2VoltageThreshold3") != jsn.end()) {

    new_state.battery2_voltage_threshold3 = jsn.at("Battery2VoltageThreshold3").get<uint8_t>();
        
    new_updated_state.battery2_voltage_threshold3 = true;
  }

  if (jsn.find("Battery2PercentageMinThreshold") != jsn.end()) {

    new_state.battery2_percentage_min_threshold = jsn.at("Battery2PercentageMinThreshold").get<uint8_t>();
        
    new_updated_state.battery2_percentage_min_threshold = true;
  }

  if (jsn.find("Battery2PercentageThreshold1") != jsn.end()) {

    new_state.battery2_percentage_threshold1 = jsn.at("Battery2PercentageThreshold1").get<uint8_t>();
        
    new_updated_state.battery2_percentage_threshold1 = true;
  }

  if (jsn.find("Battery2PercentageThreshold2") != jsn.end()) {

    new_state.battery2_percentage_threshold2 = jsn.at("Battery2PercentageThreshold2").get<uint8_t>();
        
    new_updated_state.battery2_percentage_threshold2 = true;
  }

  if (jsn.find("Battery2PercentageThreshold3") != jsn.end()) {

    new_state.battery2_percentage_threshold3 = jsn.at("Battery2PercentageThreshold3").get<uint8_t>();
        
    new_updated_state.battery2_percentage_threshold3 = true;
  }

  if (jsn.find("Battery3Manufacturer") != jsn.end()) {

    new_state.battery3_manufacturer = jsn.at("Battery3Manufacturer").get_ptr<const std::string*>()->c_str();
  
    new_updated_state.battery3_manufacturer = true;
  }

  if (jsn.find("Battery3Size") != jsn.end()) {

    uint32_t tmp = get_enum_decimal_value<BatterySize>("Battery3Size", jsn);
    if (tmp == std::numeric_limits<BatterySize>::max()) {
      #ifdef POWER_CONFIGURATION_BATTERY3_SIZE_ENUM_NAME_AVAILABLE
      tmp = power_configuration_battery3_size_get_enum_value_number(jsn.at("Battery3Size").get<std::string>());
      #elif defined(BATTERY3_SIZE_ENUM_NAME_AVAILABLE)
      tmp = battery3_size_get_enum_value_number(jsn.at("Battery3Size").get<std::string>());
      #endif
    }
    new_state.battery3_size = tmp;
  
    new_updated_state.battery3_size = true;
  }

  if (jsn.find("Battery3AHrRating") != jsn.end()) {

    new_state.battery3a_hr_rating = jsn.at("Battery3AHrRating").get<uint16_t>();
        
    new_updated_state.battery3a_hr_rating = true;
  }

  if (jsn.find("Battery3Quantity") != jsn.end()) {

    new_state.battery3_quantity = jsn.at("Battery3Quantity").get<uint8_t>();
        
    new_updated_state.battery3_quantity = true;
  }

  if (jsn.find("Battery3RatedVoltage") != jsn.end()) {

    new_state.battery3_rated_voltage = jsn.at("Battery3RatedVoltage").get<uint8_t>();
        
    new_updated_state.battery3_rated_voltage = true;
  }

  if (jsn.find("Battery3AlarmMask") != jsn.end()) {

    new_state.battery3_alarm_mask = uic_dotdot_mqtt::get_bitmap_decimal_value("Battery3AlarmMask", jsn, BatteryAlarmMask);
  
    new_updated_state.battery3_alarm_mask = true;
  }

  if (jsn.find("Battery3VoltageMinThreshold") != jsn.end()) {

    new_state.battery3_voltage_min_threshold = jsn.at("Battery3VoltageMinThreshold").get<uint8_t>();
        
    new_updated_state.battery3_voltage_min_threshold = true;
  }

  if (jsn.find("Battery3VoltageThreshold1") != jsn.end()) {

    new_state.battery3_voltage_threshold1 = jsn.at("Battery3VoltageThreshold1").get<uint8_t>();
        
    new_updated_state.battery3_voltage_threshold1 = true;
  }

  if (jsn.find("Battery3VoltageThreshold2") != jsn.end()) {

    new_state.battery3_voltage_threshold2 = jsn.at("Battery3VoltageThreshold2").get<uint8_t>();
        
    new_updated_state.battery3_voltage_threshold2 = true;
  }

  if (jsn.find("Battery3VoltageThreshold3") != jsn.end()) {

    new_state.battery3_voltage_threshold3 = jsn.at("Battery3VoltageThreshold3").get<uint8_t>();
        
    new_updated_state.battery3_voltage_threshold3 = true;
  }

  if (jsn.find("Battery3PercentageMinThreshold") != jsn.end()) {

    new_state.battery3_percentage_min_threshold = jsn.at("Battery3PercentageMinThreshold").get<uint8_t>();
        
    new_updated_state.battery3_percentage_min_threshold = true;
  }

  if (jsn.find("Battery3PercentageThreshold1") != jsn.end()) {

    new_state.battery3_percentage_threshold1 = jsn.at("Battery3PercentageThreshold1").get<uint8_t>();
        
    new_updated_state.battery3_percentage_threshold1 = true;
  }

  if (jsn.find("Battery3PercentageThreshold2") != jsn.end()) {

    new_state.battery3_percentage_threshold2 = jsn.at("Battery3PercentageThreshold2").get<uint8_t>();
        
    new_updated_state.battery3_percentage_threshold2 = true;
  }

  if (jsn.find("Battery3PercentageThreshold3") != jsn.end()) {

    new_state.battery3_percentage_threshold3 = jsn.at("Battery3PercentageThreshold3").get<uint8_t>();
        
    new_updated_state.battery3_percentage_threshold3 = true;
  }


}


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_device_temperature_configuration_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_device_temperature_configuration_state_t &new_state,
  uic_mqtt_dotdot_device_temperature_configuration_updated_state_t &new_updated_state
) {


  if (jsn.find("DeviceTempAlarmMask") != jsn.end()) {

    new_state.device_temp_alarm_mask = uic_dotdot_mqtt::get_bitmap_decimal_value("DeviceTempAlarmMask", jsn, DeviceTemperatureConfigurationDeviceTempAlarmMask);
  
    new_updated_state.device_temp_alarm_mask = true;
  }

  if (jsn.find("LowTempThreshold") != jsn.end()) {

    new_state.low_temp_threshold = jsn.at("LowTempThreshold").get<int16_t>();
        
    new_updated_state.low_temp_threshold = true;
  }

  if (jsn.find("HighTempThreshold") != jsn.end()) {

    new_state.high_temp_threshold = jsn.at("HighTempThreshold").get<int16_t>();
        
    new_updated_state.high_temp_threshold = true;
  }

  if (jsn.find("LowTempDwellTripPoint") != jsn.end()) {

    new_state.low_temp_dwell_trip_point = jsn.at("LowTempDwellTripPoint").get<uint32_t>();
        
    new_updated_state.low_temp_dwell_trip_point = true;
  }

  if (jsn.find("HighTempDwellTripPoint") != jsn.end()) {

    new_state.high_temp_dwell_trip_point = jsn.at("HighTempDwellTripPoint").get<uint32_t>();
        
    new_updated_state.high_temp_dwell_trip_point = true;
  }


}


std::string get_json_payload_for_identify_identify_command(
  
  const uic_mqtt_dotdot_identify_command_identify_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["IdentifyTime"] = nlohmann::json(fields->identify_time);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_identify_identify(
  nlohmann::json &jsn,
  uint16_t &identify_time
  
) {

  if (jsn.at("IdentifyTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  identify_time = jsn.at("IdentifyTime").get< uint16_t >();
    }


std::string get_json_payload_for_identify_identify_query_response_command(
  
  const uic_mqtt_dotdot_identify_command_identify_query_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Timeout"] = nlohmann::json(fields->timeout);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_identify_identify_query_response(
  nlohmann::json &jsn,
  uint16_t &timeout
  
) {

  if (jsn.at("Timeout").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  timeout = jsn.at("Timeout").get< uint16_t >();
    }


std::string get_json_payload_for_identify_identify_query_command(
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}




std::string get_json_payload_for_identify_trigger_effect_command(
  
  const uic_mqtt_dotdot_identify_command_trigger_effect_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum TriggerEffect / EffectIdentifier
  #ifdef TRIGGER_EFFECT_EFFECT_IDENTIFIER_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["EffectIdentifier"] =
    trigger_effect_effect_identifier_get_enum_value_name(
      (uint32_t)fields->effect_identifier);
  #elif defined(TRIGGER_EFFECT_EFFECT_IDENTIFIER_ENUM_NAME_AVAILABLE)
  json_payload["EffectIdentifier"] =
    trigger_effect_effect_identifier_get_enum_value_name((uint32_t)fields->effect_identifier);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["EffectIdentifier"] = fields->effect_identifier;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Enum TriggerEffect / EffectVariant
  #ifdef TRIGGER_EFFECT_EFFECT_VARIANT_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["EffectVariant"] =
    trigger_effect_effect_variant_get_enum_value_name(
      (uint32_t)fields->effect_variant);
  #elif defined(TRIGGER_EFFECT_EFFECT_VARIANT_ENUM_NAME_AVAILABLE)
  json_payload["EffectVariant"] =
    trigger_effect_effect_variant_get_enum_value_name((uint32_t)fields->effect_variant);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["EffectVariant"] = fields->effect_variant;
  #endif

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_identify_trigger_effect(
  nlohmann::json &jsn,
  TriggerEffectEffectIdentifier &effect_identifier,
  
  TriggerEffectEffectVariant &effect_variant
  
) {

  uint32_t EffectIdentifier_enum_val = get_enum_decimal_value<TriggerEffectEffectIdentifier>("EffectIdentifier", jsn);
  if (EffectIdentifier_enum_val == std::numeric_limits<TriggerEffectEffectIdentifier>::max()) {
    #ifdef TRIGGER_EFFECT_EFFECT_IDENTIFIER_ENUM_NAME_AVAILABLE
    EffectIdentifier_enum_val = trigger_effect_effect_identifier_get_enum_value_number(jsn.at("EffectIdentifier").get<std::string>());
    #endif
  }
  uint32_t EffectVariant_enum_val = get_enum_decimal_value<TriggerEffectEffectVariant>("EffectVariant", jsn);
  if (EffectVariant_enum_val == std::numeric_limits<TriggerEffectEffectVariant>::max()) {
    #ifdef TRIGGER_EFFECT_EFFECT_VARIANT_ENUM_NAME_AVAILABLE
    EffectVariant_enum_val = trigger_effect_effect_variant_get_enum_value_number(jsn.at("EffectVariant").get<std::string>());
    #endif
  }
  if (jsn.at("EffectIdentifier").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  effect_identifier = static_cast<TriggerEffectEffectIdentifier>(EffectIdentifier_enum_val);
  if (jsn.at("EffectVariant").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  effect_variant = static_cast<TriggerEffectEffectVariant>(EffectVariant_enum_val);
}


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_identify_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_identify_state_t &new_state,
  uic_mqtt_dotdot_identify_updated_state_t &new_updated_state
) {


  if (jsn.find("IdentifyTime") != jsn.end()) {

    new_state.identify_time = jsn.at("IdentifyTime").get<uint16_t>();
        
    new_updated_state.identify_time = true;
  }


}


std::string get_json_payload_for_groups_add_group_command(
  
  const uic_mqtt_dotdot_groups_command_add_group_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["GroupId"] = nlohmann::json(fields->group_id);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["GroupName"] = nlohmann::json(fields->group_name);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_groups_add_group(
  nlohmann::json &jsn,
  uint16_t &group_id,
  
  std::string &group_name
  
) {

  if (jsn.at("GroupId").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  group_id = jsn.at("GroupId").get< uint16_t >();
      if (jsn.at("GroupName").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  group_name = jsn.at("GroupName").get<std::string>();
          }


std::string get_json_payload_for_groups_add_group_response_command(
  
  const uic_mqtt_dotdot_groups_command_add_group_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum AddGroupResponse / Status
  #ifdef ADD_GROUP_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    add_group_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    enum8_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["GroupId"] = nlohmann::json(fields->group_id);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_groups_add_group_response(
  nlohmann::json &jsn,
  uint8_t &status,
  
  uint16_t &group_id
  
) {

  uint32_t Status_enum_val = get_enum_decimal_value<uint8_t>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<uint8_t>::max()) {
    #ifdef ENUM8_ENUM_NAME_AVAILABLE
    Status_enum_val = enum8_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<uint8_t>(Status_enum_val);
  if (jsn.at("GroupId").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  group_id = jsn.at("GroupId").get< uint16_t >();
    }


std::string get_json_payload_for_groups_view_group_command(
  
  const uic_mqtt_dotdot_groups_command_view_group_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["GroupId"] = nlohmann::json(fields->group_id);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_groups_view_group(
  nlohmann::json &jsn,
  uint16_t &group_id
  
) {

  if (jsn.at("GroupId").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  group_id = jsn.at("GroupId").get< uint16_t >();
    }


std::string get_json_payload_for_groups_view_group_response_command(
  
  const uic_mqtt_dotdot_groups_command_view_group_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum ViewGroupResponse / Status
  #ifdef VIEW_GROUP_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    view_group_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    enum8_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["GroupId"] = nlohmann::json(fields->group_id);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["GroupName"] = nlohmann::json(fields->group_name);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_groups_view_group_response(
  nlohmann::json &jsn,
  uint8_t &status,
  
  uint16_t &group_id,
  
  std::string &group_name
  
) {

  uint32_t Status_enum_val = get_enum_decimal_value<uint8_t>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<uint8_t>::max()) {
    #ifdef ENUM8_ENUM_NAME_AVAILABLE
    Status_enum_val = enum8_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<uint8_t>(Status_enum_val);
  if (jsn.at("GroupId").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  group_id = jsn.at("GroupId").get< uint16_t >();
      if (jsn.at("GroupName").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  group_name = jsn.at("GroupName").get<std::string>();
          }


std::string get_json_payload_for_groups_get_group_membership_command(
  
  const uic_mqtt_dotdot_groups_command_get_group_membership_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // We assume arrays are Non-enum and non-bitmask (struct, string or scalar)
  json_payload["GroupList"] = std::vector< uint16_t >(
    fields->group_list,
    fields->group_list + fields->group_list_count);


  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_groups_get_group_membership(
  nlohmann::json &jsn,
  std::vector<uint16_t> &group_list

) {

  if (jsn.at("GroupList").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  group_list = jsn.at("GroupList").get< std::vector< uint16_t >>();
      }


std::string get_json_payload_for_groups_get_group_membership_response_command(
  
  const uic_mqtt_dotdot_groups_command_get_group_membership_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Capacity"] = nlohmann::json(fields->capacity);
  command_with_no_fields = false;
  // We assume arrays are Non-enum and non-bitmask (struct, string or scalar)
  json_payload["GroupList"] = std::vector< uint16_t >(
    fields->group_list,
    fields->group_list + fields->group_list_count);


  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_groups_get_group_membership_response(
  nlohmann::json &jsn,
  uint8_t &capacity,
  
  std::vector<uint16_t> &group_list

) {

  if (jsn.at("Capacity").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  capacity = jsn.at("Capacity").get< uint8_t >();
      if (jsn.at("GroupList").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  group_list = jsn.at("GroupList").get< std::vector< uint16_t >>();
      }


std::string get_json_payload_for_groups_remove_group_command(
  
  const uic_mqtt_dotdot_groups_command_remove_group_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["GroupId"] = nlohmann::json(fields->group_id);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_groups_remove_group(
  nlohmann::json &jsn,
  uint16_t &group_id
  
) {

  if (jsn.at("GroupId").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  group_id = jsn.at("GroupId").get< uint16_t >();
    }


std::string get_json_payload_for_groups_remove_group_response_command(
  
  const uic_mqtt_dotdot_groups_command_remove_group_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum RemoveGroupResponse / Status
  #ifdef REMOVE_GROUP_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    remove_group_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    enum8_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["GroupId"] = nlohmann::json(fields->group_id);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_groups_remove_group_response(
  nlohmann::json &jsn,
  uint8_t &status,
  
  uint16_t &group_id
  
) {

  uint32_t Status_enum_val = get_enum_decimal_value<uint8_t>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<uint8_t>::max()) {
    #ifdef ENUM8_ENUM_NAME_AVAILABLE
    Status_enum_val = enum8_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<uint8_t>(Status_enum_val);
  if (jsn.at("GroupId").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  group_id = jsn.at("GroupId").get< uint16_t >();
    }


std::string get_json_payload_for_groups_remove_all_groups_command(
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}




std::string get_json_payload_for_groups_add_group_if_identifying_command(
  
  const uic_mqtt_dotdot_groups_command_add_group_if_identifying_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["GroupId"] = nlohmann::json(fields->group_id);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["GroupName"] = nlohmann::json(fields->group_name);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_groups_add_group_if_identifying(
  nlohmann::json &jsn,
  uint16_t &group_id,
  
  std::string &group_name
  
) {

  if (jsn.at("GroupId").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  group_id = jsn.at("GroupId").get< uint16_t >();
      if (jsn.at("GroupName").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  group_name = jsn.at("GroupName").get<std::string>();
          }


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_groups_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_groups_state_t &new_state,
  uic_mqtt_dotdot_groups_updated_state_t &new_updated_state
) {



}


std::string get_json_payload_for_scenes_add_scene_command(
  
  const uic_mqtt_dotdot_scenes_command_add_scene_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["GroupID"] = nlohmann::json(fields->groupid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["SceneID"] = nlohmann::json(fields->sceneid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["TransitionTime"] = nlohmann::json(fields->transition_time);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["SceneName"] = nlohmann::json(fields->scene_name);
  command_with_no_fields = false;
  // We assume arrays are Non-enum and non-bitmask (struct, string or scalar)
  json_payload["ExtensionFieldSets"] = std::vector< SExtensionFieldSetList >(
    fields->extension_field_sets,
    fields->extension_field_sets + fields->extension_field_sets_count);

  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["TransitionTime100ms"] = nlohmann::json(fields->transition_time100ms);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_scenes_add_scene(
  nlohmann::json &jsn,
  SGroupId &groupid,
  
  uint8_t &sceneid,
  
  uint16_t &transition_time,
  
  std::string &scene_name,
  
  std::vector<SExtensionFieldSetList> &extension_field_sets,

  uint8_t &transition_time100ms
  
) {

  if (jsn.at("GroupID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  groupid = jsn.at("GroupID").get< SGroupId >();
      if (jsn.at("SceneID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  sceneid = jsn.at("SceneID").get< uint8_t >();
      if (jsn.at("TransitionTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  transition_time = jsn.at("TransitionTime").get< uint16_t >();
      if (jsn.at("SceneName").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  scene_name = jsn.at("SceneName").get<std::string>();
            if (jsn.at("ExtensionFieldSets").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  // SExtensionFieldSetList is a struct
  for (auto &ExtensionFieldSets_el : jsn.at("ExtensionFieldSets")) {

    SExtensionFieldSetList item = {};
     if (ExtensionFieldSets_el.at("ClusterId").is_null()) {
      continue;
     }
    item.ClusterId = ExtensionFieldSets_el.at("ClusterId");
     if (ExtensionFieldSets_el.at("ExtensionFieldSet").is_null()) {
      continue;
     }
    sl_log_warning(LOG_TAG,"Parsing limit reached. Too many nested special types");
    //item.ExtensionFieldSet = ExtensionFieldSet_el.at("ExtensionFieldSet").get<const std::string*>();
    extension_field_sets.push_back(item);
  }
        if (jsn.at("TransitionTime100ms").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  transition_time100ms = jsn.at("TransitionTime100ms").get< uint8_t >();
    }


std::string get_json_payload_for_scenes_add_scene_response_command(
  
  const uic_mqtt_dotdot_scenes_command_add_scene_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum AddSceneResponse / Status
  #ifdef ADD_SCENE_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    add_scene_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(ZCL_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    zcl_status_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["GroupID"] = nlohmann::json(fields->groupid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["SceneID"] = nlohmann::json(fields->sceneid);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_scenes_add_scene_response(
  nlohmann::json &jsn,
  zclStatus &status,
  
  SGroupId &groupid,
  
  uint8_t &sceneid
  
) {

  uint32_t Status_enum_val = get_enum_decimal_value<zclStatus>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<zclStatus>::max()) {
    #ifdef ZCL_STATUS_ENUM_NAME_AVAILABLE
    Status_enum_val = zcl_status_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<zclStatus>(Status_enum_val);
  if (jsn.at("GroupID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  groupid = jsn.at("GroupID").get< SGroupId >();
      if (jsn.at("SceneID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  sceneid = jsn.at("SceneID").get< uint8_t >();
    }


std::string get_json_payload_for_scenes_view_scene_command(
  
  const uic_mqtt_dotdot_scenes_command_view_scene_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["GroupID"] = nlohmann::json(fields->groupid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["SceneID"] = nlohmann::json(fields->sceneid);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_scenes_view_scene(
  nlohmann::json &jsn,
  SGroupId &groupid,
  
  uint8_t &sceneid
  
) {

  if (jsn.at("GroupID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  groupid = jsn.at("GroupID").get< SGroupId >();
      if (jsn.at("SceneID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  sceneid = jsn.at("SceneID").get< uint8_t >();
    }


std::string get_json_payload_for_scenes_view_scene_response_command(
  
  const uic_mqtt_dotdot_scenes_command_view_scene_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum ViewSceneResponse / Status
  #ifdef VIEW_SCENE_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    view_scene_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(ZCL_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    zcl_status_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["GroupID"] = nlohmann::json(fields->groupid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["SceneID"] = nlohmann::json(fields->sceneid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["TransitionTime"] = nlohmann::json(fields->transition_time);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["SceneName"] = nlohmann::json(fields->scene_name);
  command_with_no_fields = false;
  // We assume arrays are Non-enum and non-bitmask (struct, string or scalar)
  json_payload["ExtensionFieldSets"] = std::vector< SExtensionFieldSetList >(
    fields->extension_field_sets,
    fields->extension_field_sets + fields->extension_field_sets_count);


  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_scenes_view_scene_response(
  nlohmann::json &jsn,
  zclStatus &status,
  
  SGroupId &groupid,
  
  uint8_t &sceneid,
  
  uint16_t &transition_time,
  
  std::string &scene_name,
  
  std::vector<SExtensionFieldSetList> &extension_field_sets

) {

  uint32_t Status_enum_val = get_enum_decimal_value<zclStatus>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<zclStatus>::max()) {
    #ifdef ZCL_STATUS_ENUM_NAME_AVAILABLE
    Status_enum_val = zcl_status_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<zclStatus>(Status_enum_val);
  if (jsn.at("GroupID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  groupid = jsn.at("GroupID").get< SGroupId >();
      if (jsn.at("SceneID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  sceneid = jsn.at("SceneID").get< uint8_t >();
      if (jsn.at("TransitionTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  transition_time = jsn.at("TransitionTime").get< uint16_t >();
      if (jsn.at("SceneName").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  scene_name = jsn.at("SceneName").get<std::string>();
            if (jsn.at("ExtensionFieldSets").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  // SExtensionFieldSetList is a struct
  for (auto &ExtensionFieldSets_el : jsn.at("ExtensionFieldSets")) {

    SExtensionFieldSetList item = {};
     if (ExtensionFieldSets_el.at("ClusterId").is_null()) {
      continue;
     }
    item.ClusterId = ExtensionFieldSets_el.at("ClusterId");
     if (ExtensionFieldSets_el.at("ExtensionFieldSet").is_null()) {
      continue;
     }
    sl_log_warning(LOG_TAG,"Parsing limit reached. Too many nested special types");
    //item.ExtensionFieldSet = ExtensionFieldSet_el.at("ExtensionFieldSet").get<const std::string*>();
    extension_field_sets.push_back(item);
  }
      }


std::string get_json_payload_for_scenes_remove_scene_command(
  
  const uic_mqtt_dotdot_scenes_command_remove_scene_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["GroupID"] = nlohmann::json(fields->groupid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["SceneID"] = nlohmann::json(fields->sceneid);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_scenes_remove_scene(
  nlohmann::json &jsn,
  SGroupId &groupid,
  
  uint8_t &sceneid
  
) {

  if (jsn.at("GroupID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  groupid = jsn.at("GroupID").get< SGroupId >();
      if (jsn.at("SceneID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  sceneid = jsn.at("SceneID").get< uint8_t >();
    }


std::string get_json_payload_for_scenes_remove_scene_response_command(
  
  const uic_mqtt_dotdot_scenes_command_remove_scene_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum RemoveSceneResponse / Status
  #ifdef REMOVE_SCENE_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    remove_scene_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(ZCL_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    zcl_status_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["GroupID"] = nlohmann::json(fields->groupid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["SceneID"] = nlohmann::json(fields->sceneid);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_scenes_remove_scene_response(
  nlohmann::json &jsn,
  zclStatus &status,
  
  SGroupId &groupid,
  
  uint8_t &sceneid
  
) {

  uint32_t Status_enum_val = get_enum_decimal_value<zclStatus>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<zclStatus>::max()) {
    #ifdef ZCL_STATUS_ENUM_NAME_AVAILABLE
    Status_enum_val = zcl_status_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<zclStatus>(Status_enum_val);
  if (jsn.at("GroupID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  groupid = jsn.at("GroupID").get< SGroupId >();
      if (jsn.at("SceneID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  sceneid = jsn.at("SceneID").get< uint8_t >();
    }


std::string get_json_payload_for_scenes_remove_all_scenes_command(
  
  const uic_mqtt_dotdot_scenes_command_remove_all_scenes_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["GroupID"] = nlohmann::json(fields->groupid);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_scenes_remove_all_scenes(
  nlohmann::json &jsn,
  SGroupId &groupid
  
) {

  if (jsn.at("GroupID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  groupid = jsn.at("GroupID").get< SGroupId >();
    }


std::string get_json_payload_for_scenes_remove_all_scenes_response_command(
  
  const uic_mqtt_dotdot_scenes_command_remove_all_scenes_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum RemoveAllScenesResponse / Status
  #ifdef REMOVE_ALL_SCENES_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    remove_all_scenes_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(ZCL_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    zcl_status_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["GroupID"] = nlohmann::json(fields->groupid);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_scenes_remove_all_scenes_response(
  nlohmann::json &jsn,
  zclStatus &status,
  
  SGroupId &groupid
  
) {

  uint32_t Status_enum_val = get_enum_decimal_value<zclStatus>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<zclStatus>::max()) {
    #ifdef ZCL_STATUS_ENUM_NAME_AVAILABLE
    Status_enum_val = zcl_status_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<zclStatus>(Status_enum_val);
  if (jsn.at("GroupID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  groupid = jsn.at("GroupID").get< SGroupId >();
    }


std::string get_json_payload_for_scenes_store_scene_command(
  
  const uic_mqtt_dotdot_scenes_command_store_scene_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["GroupID"] = nlohmann::json(fields->groupid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["SceneID"] = nlohmann::json(fields->sceneid);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_scenes_store_scene(
  nlohmann::json &jsn,
  SGroupId &groupid,
  
  uint8_t &sceneid
  
) {

  if (jsn.at("GroupID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  groupid = jsn.at("GroupID").get< SGroupId >();
      if (jsn.at("SceneID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  sceneid = jsn.at("SceneID").get< uint8_t >();
    }


std::string get_json_payload_for_scenes_store_scene_response_command(
  
  const uic_mqtt_dotdot_scenes_command_store_scene_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum StoreSceneResponse / Status
  #ifdef STORE_SCENE_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    store_scene_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(ZCL_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    zcl_status_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["GroupID"] = nlohmann::json(fields->groupid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["SceneID"] = nlohmann::json(fields->sceneid);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_scenes_store_scene_response(
  nlohmann::json &jsn,
  zclStatus &status,
  
  SGroupId &groupid,
  
  uint8_t &sceneid
  
) {

  uint32_t Status_enum_val = get_enum_decimal_value<zclStatus>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<zclStatus>::max()) {
    #ifdef ZCL_STATUS_ENUM_NAME_AVAILABLE
    Status_enum_val = zcl_status_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<zclStatus>(Status_enum_val);
  if (jsn.at("GroupID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  groupid = jsn.at("GroupID").get< SGroupId >();
      if (jsn.at("SceneID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  sceneid = jsn.at("SceneID").get< uint8_t >();
    }


std::string get_json_payload_for_scenes_recall_scene_command(
  
  const uic_mqtt_dotdot_scenes_command_recall_scene_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["GroupID"] = nlohmann::json(fields->groupid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["SceneID"] = nlohmann::json(fields->sceneid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["TransitionTime"] = nlohmann::json(fields->transition_time);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_scenes_recall_scene(
  nlohmann::json &jsn,
  SGroupId &groupid,
  
  uint8_t &sceneid,
  
  uint16_t &transition_time
  
) {

  if (jsn.at("GroupID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  groupid = jsn.at("GroupID").get< SGroupId >();
      if (jsn.at("SceneID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  sceneid = jsn.at("SceneID").get< uint8_t >();
      if (jsn.at("TransitionTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  transition_time = jsn.at("TransitionTime").get< uint16_t >();
    }


std::string get_json_payload_for_scenes_get_scene_membership_command(
  
  const uic_mqtt_dotdot_scenes_command_get_scene_membership_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["GroupID"] = nlohmann::json(fields->groupid);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_scenes_get_scene_membership(
  nlohmann::json &jsn,
  SGroupId &groupid
  
) {

  if (jsn.at("GroupID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  groupid = jsn.at("GroupID").get< SGroupId >();
    }


std::string get_json_payload_for_scenes_get_scene_membership_response_command(
  
  const uic_mqtt_dotdot_scenes_command_get_scene_membership_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum GetSceneMembershipResponse / Status
  #ifdef GET_SCENE_MEMBERSHIP_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    get_scene_membership_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(ZCL_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    zcl_status_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Capacity"] = nlohmann::json(fields->capacity);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["GroupID"] = nlohmann::json(fields->groupid);
  command_with_no_fields = false;
  // We assume arrays are Non-enum and non-bitmask (struct, string or scalar)
  json_payload["SceneList"] = std::vector< uint8_t >(
    fields->scene_list,
    fields->scene_list + fields->scene_list_count);


  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_scenes_get_scene_membership_response(
  nlohmann::json &jsn,
  zclStatus &status,
  
  uint8_t &capacity,
  
  SGroupId &groupid,
  
  std::vector<uint8_t> &scene_list

) {

  uint32_t Status_enum_val = get_enum_decimal_value<zclStatus>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<zclStatus>::max()) {
    #ifdef ZCL_STATUS_ENUM_NAME_AVAILABLE
    Status_enum_val = zcl_status_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<zclStatus>(Status_enum_val);
  if (jsn.at("Capacity").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  capacity = jsn.at("Capacity").get< uint8_t >();
      if (jsn.at("GroupID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  groupid = jsn.at("GroupID").get< SGroupId >();
      if (jsn.at("SceneList").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  scene_list = jsn.at("SceneList").get< std::vector< uint8_t >>();
      }


std::string get_json_payload_for_scenes_enhanced_add_scene_command(
  
  const uic_mqtt_dotdot_scenes_command_enhanced_add_scene_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["GroupID"] = nlohmann::json(fields->groupid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["SceneID"] = nlohmann::json(fields->sceneid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["TransitionTime"] = nlohmann::json(fields->transition_time);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["SceneName"] = nlohmann::json(fields->scene_name);
  command_with_no_fields = false;
  // We assume arrays are Non-enum and non-bitmask (struct, string or scalar)
  json_payload["ExtensionFieldSets"] = std::vector< SExtensionFieldSetList >(
    fields->extension_field_sets,
    fields->extension_field_sets + fields->extension_field_sets_count);


  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_scenes_enhanced_add_scene(
  nlohmann::json &jsn,
  SGroupId &groupid,
  
  uint8_t &sceneid,
  
  uint16_t &transition_time,
  
  std::string &scene_name,
  
  std::vector<SExtensionFieldSetList> &extension_field_sets

) {

  if (jsn.at("GroupID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  groupid = jsn.at("GroupID").get< SGroupId >();
      if (jsn.at("SceneID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  sceneid = jsn.at("SceneID").get< uint8_t >();
      if (jsn.at("TransitionTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  transition_time = jsn.at("TransitionTime").get< uint16_t >();
      if (jsn.at("SceneName").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  scene_name = jsn.at("SceneName").get<std::string>();
            if (jsn.at("ExtensionFieldSets").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  // SExtensionFieldSetList is a struct
  for (auto &ExtensionFieldSets_el : jsn.at("ExtensionFieldSets")) {

    SExtensionFieldSetList item = {};
     if (ExtensionFieldSets_el.at("ClusterId").is_null()) {
      continue;
     }
    item.ClusterId = ExtensionFieldSets_el.at("ClusterId");
     if (ExtensionFieldSets_el.at("ExtensionFieldSet").is_null()) {
      continue;
     }
    sl_log_warning(LOG_TAG,"Parsing limit reached. Too many nested special types");
    //item.ExtensionFieldSet = ExtensionFieldSet_el.at("ExtensionFieldSet").get<const std::string*>();
    extension_field_sets.push_back(item);
  }
      }


std::string get_json_payload_for_scenes_enhanced_add_scene_response_command(
  
  const uic_mqtt_dotdot_scenes_command_enhanced_add_scene_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum EnhancedAddSceneResponse / Status
  #ifdef ENHANCED_ADD_SCENE_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    enhanced_add_scene_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(ZCL_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    zcl_status_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["GroupID"] = nlohmann::json(fields->groupid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["SceneID"] = nlohmann::json(fields->sceneid);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_scenes_enhanced_add_scene_response(
  nlohmann::json &jsn,
  zclStatus &status,
  
  SGroupId &groupid,
  
  uint8_t &sceneid
  
) {

  uint32_t Status_enum_val = get_enum_decimal_value<zclStatus>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<zclStatus>::max()) {
    #ifdef ZCL_STATUS_ENUM_NAME_AVAILABLE
    Status_enum_val = zcl_status_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<zclStatus>(Status_enum_val);
  if (jsn.at("GroupID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  groupid = jsn.at("GroupID").get< SGroupId >();
      if (jsn.at("SceneID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  sceneid = jsn.at("SceneID").get< uint8_t >();
    }


std::string get_json_payload_for_scenes_enhanced_view_scene_command(
  
  const uic_mqtt_dotdot_scenes_command_enhanced_view_scene_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["GroupID"] = nlohmann::json(fields->groupid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["SceneID"] = nlohmann::json(fields->sceneid);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_scenes_enhanced_view_scene(
  nlohmann::json &jsn,
  SGroupId &groupid,
  
  uint8_t &sceneid
  
) {

  if (jsn.at("GroupID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  groupid = jsn.at("GroupID").get< SGroupId >();
      if (jsn.at("SceneID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  sceneid = jsn.at("SceneID").get< uint8_t >();
    }


std::string get_json_payload_for_scenes_enhanced_view_scene_response_command(
  
  const uic_mqtt_dotdot_scenes_command_enhanced_view_scene_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum EnhancedViewSceneResponse / Status
  #ifdef ENHANCED_VIEW_SCENE_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    enhanced_view_scene_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(ZCL_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    zcl_status_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["GroupID"] = nlohmann::json(fields->groupid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["SceneID"] = nlohmann::json(fields->sceneid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["TransitionTime"] = nlohmann::json(fields->transition_time);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["SceneName"] = nlohmann::json(fields->scene_name);
  command_with_no_fields = false;
  // We assume arrays are Non-enum and non-bitmask (struct, string or scalar)
  json_payload["ExtensionFieldSets"] = std::vector< SExtensionFieldSetList >(
    fields->extension_field_sets,
    fields->extension_field_sets + fields->extension_field_sets_count);


  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_scenes_enhanced_view_scene_response(
  nlohmann::json &jsn,
  zclStatus &status,
  
  SGroupId &groupid,
  
  uint8_t &sceneid,
  
  uint16_t &transition_time,
  
  std::string &scene_name,
  
  std::vector<SExtensionFieldSetList> &extension_field_sets

) {

  uint32_t Status_enum_val = get_enum_decimal_value<zclStatus>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<zclStatus>::max()) {
    #ifdef ZCL_STATUS_ENUM_NAME_AVAILABLE
    Status_enum_val = zcl_status_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<zclStatus>(Status_enum_val);
  if (jsn.at("GroupID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  groupid = jsn.at("GroupID").get< SGroupId >();
      if (jsn.at("SceneID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  sceneid = jsn.at("SceneID").get< uint8_t >();
      if (jsn.at("TransitionTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  transition_time = jsn.at("TransitionTime").get< uint16_t >();
      if (jsn.at("SceneName").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  scene_name = jsn.at("SceneName").get<std::string>();
            if (jsn.at("ExtensionFieldSets").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  // SExtensionFieldSetList is a struct
  for (auto &ExtensionFieldSets_el : jsn.at("ExtensionFieldSets")) {

    SExtensionFieldSetList item = {};
     if (ExtensionFieldSets_el.at("ClusterId").is_null()) {
      continue;
     }
    item.ClusterId = ExtensionFieldSets_el.at("ClusterId");
     if (ExtensionFieldSets_el.at("ExtensionFieldSet").is_null()) {
      continue;
     }
    sl_log_warning(LOG_TAG,"Parsing limit reached. Too many nested special types");
    //item.ExtensionFieldSet = ExtensionFieldSet_el.at("ExtensionFieldSet").get<const std::string*>();
    extension_field_sets.push_back(item);
  }
      }


std::string get_json_payload_for_scenes_copy_scene_command(
  
  const uic_mqtt_dotdot_scenes_command_copy_scene_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["Mode"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->mode,
                                CopySceneMode);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["GroupIdentifierFrom"] = nlohmann::json(fields->group_identifier_from);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["SceneIdentifierFrom"] = nlohmann::json(fields->scene_identifier_from);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["GroupIdentifierTo"] = nlohmann::json(fields->group_identifier_to);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["SceneIdentifierTo"] = nlohmann::json(fields->scene_identifier_to);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_scenes_copy_scene(
  nlohmann::json &jsn,
  uint8_t &mode,
  
  SGroupId &group_identifier_from,
  
  uint8_t &scene_identifier_from,
  
  SGroupId &group_identifier_to,
  
  uint8_t &scene_identifier_to
  
) {

  if (jsn.at("Mode").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  mode = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("Mode", jsn, CopySceneMode);
  if (jsn.at("GroupIdentifierFrom").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  group_identifier_from = jsn.at("GroupIdentifierFrom").get< SGroupId >();
      if (jsn.at("SceneIdentifierFrom").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  scene_identifier_from = jsn.at("SceneIdentifierFrom").get< uint8_t >();
      if (jsn.at("GroupIdentifierTo").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  group_identifier_to = jsn.at("GroupIdentifierTo").get< SGroupId >();
      if (jsn.at("SceneIdentifierTo").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  scene_identifier_to = jsn.at("SceneIdentifierTo").get< uint8_t >();
    }


std::string get_json_payload_for_scenes_copy_scene_response_command(
  
  const uic_mqtt_dotdot_scenes_command_copy_scene_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum CopySceneResponse / Status
  #ifdef COPY_SCENE_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    copy_scene_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(ZCL_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    zcl_status_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["GroupIdentifierFrom"] = nlohmann::json(fields->group_identifier_from);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["SceneIdentifierFrom"] = nlohmann::json(fields->scene_identifier_from);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_scenes_copy_scene_response(
  nlohmann::json &jsn,
  zclStatus &status,
  
  SGroupId &group_identifier_from,
  
  uint8_t &scene_identifier_from
  
) {

  uint32_t Status_enum_val = get_enum_decimal_value<zclStatus>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<zclStatus>::max()) {
    #ifdef ZCL_STATUS_ENUM_NAME_AVAILABLE
    Status_enum_val = zcl_status_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<zclStatus>(Status_enum_val);
  if (jsn.at("GroupIdentifierFrom").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  group_identifier_from = jsn.at("GroupIdentifierFrom").get< SGroupId >();
      if (jsn.at("SceneIdentifierFrom").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  scene_identifier_from = jsn.at("SceneIdentifierFrom").get< uint8_t >();
    }


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_scenes_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_scenes_state_t &new_state,
  uic_mqtt_dotdot_scenes_updated_state_t &new_updated_state
) {



}


std::string get_json_payload_for_on_off_off_command(
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}




std::string get_json_payload_for_on_off_on_command(
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}




std::string get_json_payload_for_on_off_toggle_command(
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}




std::string get_json_payload_for_on_off_off_with_effect_command(
  
  const uic_mqtt_dotdot_on_off_command_off_with_effect_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum OffWithEffect / EffectIdentifier
  #ifdef OFF_WITH_EFFECT_EFFECT_IDENTIFIER_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["EffectIdentifier"] =
    off_with_effect_effect_identifier_get_enum_value_name(
      (uint32_t)fields->effect_identifier);
  #elif defined(OFF_WITH_EFFECT_EFFECT_IDENTIFIER_ENUM_NAME_AVAILABLE)
  json_payload["EffectIdentifier"] =
    off_with_effect_effect_identifier_get_enum_value_name((uint32_t)fields->effect_identifier);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["EffectIdentifier"] = fields->effect_identifier;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["EffectVariant"] = nlohmann::json(fields->effect_variant);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_on_off_off_with_effect(
  nlohmann::json &jsn,
  OffWithEffectEffectIdentifier &effect_identifier,
  
  uint8_t &effect_variant
  
) {

  uint32_t EffectIdentifier_enum_val = get_enum_decimal_value<OffWithEffectEffectIdentifier>("EffectIdentifier", jsn);
  if (EffectIdentifier_enum_val == std::numeric_limits<OffWithEffectEffectIdentifier>::max()) {
    #ifdef OFF_WITH_EFFECT_EFFECT_IDENTIFIER_ENUM_NAME_AVAILABLE
    EffectIdentifier_enum_val = off_with_effect_effect_identifier_get_enum_value_number(jsn.at("EffectIdentifier").get<std::string>());
    #endif
  }
  if (jsn.at("EffectIdentifier").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  effect_identifier = static_cast<OffWithEffectEffectIdentifier>(EffectIdentifier_enum_val);
  if (jsn.at("EffectVariant").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  effect_variant = jsn.at("EffectVariant").get< uint8_t >();
    }


std::string get_json_payload_for_on_off_on_with_recall_global_scene_command(
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}




std::string get_json_payload_for_on_off_on_with_timed_off_command(
  
  const uic_mqtt_dotdot_on_off_command_on_with_timed_off_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OnOffControl"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->on_off_control,
                                OnWithTimedOffOnOffControl);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["OnTime"] = nlohmann::json(fields->on_time);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["OffWaitTime"] = nlohmann::json(fields->off_wait_time);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_on_off_on_with_timed_off(
  nlohmann::json &jsn,
  uint8_t &on_off_control,
  
  uint16_t &on_time,
  
  uint16_t &off_wait_time
  
) {

  if (jsn.at("OnOffControl").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  on_off_control = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OnOffControl", jsn, OnWithTimedOffOnOffControl);
  if (jsn.at("OnTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  on_time = jsn.at("OnTime").get< uint16_t >();
      if (jsn.at("OffWaitTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  off_wait_time = jsn.at("OffWaitTime").get< uint16_t >();
    }


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_on_off_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_on_off_state_t &new_state,
  uic_mqtt_dotdot_on_off_updated_state_t &new_updated_state
) {


  if (jsn.find("OnTime") != jsn.end()) {

    new_state.on_time = jsn.at("OnTime").get<uint16_t>();
        
    new_updated_state.on_time = true;
  }

  if (jsn.find("OffWaitTime") != jsn.end()) {

    new_state.off_wait_time = jsn.at("OffWaitTime").get<uint16_t>();
        
    new_updated_state.off_wait_time = true;
  }

  if (jsn.find("StartUpOnOff") != jsn.end()) {

    uint32_t tmp = get_enum_decimal_value<OnOffStartUpOnOff>("StartUpOnOff", jsn);
    if (tmp == std::numeric_limits<OnOffStartUpOnOff>::max()) {
      #ifdef ON_OFF_START_UP_ON_OFF_ENUM_NAME_AVAILABLE
      tmp = on_off_start_up_on_off_get_enum_value_number(jsn.at("StartUpOnOff").get<std::string>());
      #elif defined(START_UP_ON_OFF_ENUM_NAME_AVAILABLE)
      tmp = start_up_on_off_get_enum_value_number(jsn.at("StartUpOnOff").get<std::string>());
      #endif
    }
    new_state.start_up_on_off = tmp;
  
    new_updated_state.start_up_on_off = true;
  }


}


std::string get_json_payload_for_level_move_to_level_command(
  
  const uic_mqtt_dotdot_level_command_move_to_level_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Level"] = nlohmann::json(fields->level);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["TransitionTime"] = nlohmann::json(fields->transition_time);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsMask"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_mask,
                                LevelOptions);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsOverride"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_override,
                                LevelOptions);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_level_move_to_level(
  nlohmann::json &jsn,
  uint8_t &level,
  
  uint16_t &transition_time,
  
  uint8_t &options_mask,
  
  uint8_t &options_override
  
) {

  if (jsn.at("Level").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  level = jsn.at("Level").get< uint8_t >();
      if (jsn.at("TransitionTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  transition_time = jsn.at("TransitionTime").get< uint16_t >();
      if (jsn.at("OptionsMask").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_mask = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsMask", jsn, LevelOptions);
  if (jsn.at("OptionsOverride").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_override = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsOverride", jsn, LevelOptions);
}


std::string get_json_payload_for_level_move_command(
  
  const uic_mqtt_dotdot_level_command_move_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum Move / MoveMode
  #ifdef MOVE_MOVE_MODE_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["MoveMode"] =
    move_move_mode_get_enum_value_name(
      (uint32_t)fields->move_mode);
  #elif defined(MOVE_STEP_MODE_ENUM_NAME_AVAILABLE)
  json_payload["MoveMode"] =
    move_step_mode_get_enum_value_name((uint32_t)fields->move_mode);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["MoveMode"] = fields->move_mode;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Rate"] = nlohmann::json(fields->rate);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsMask"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_mask,
                                LevelOptions);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsOverride"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_override,
                                LevelOptions);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_level_move(
  nlohmann::json &jsn,
  MoveStepMode &move_mode,
  
  uint8_t &rate,
  
  uint8_t &options_mask,
  
  uint8_t &options_override
  
) {

  uint32_t MoveMode_enum_val = get_enum_decimal_value<MoveStepMode>("MoveMode", jsn);
  if (MoveMode_enum_val == std::numeric_limits<MoveStepMode>::max()) {
    #ifdef MOVE_STEP_MODE_ENUM_NAME_AVAILABLE
    MoveMode_enum_val = move_step_mode_get_enum_value_number(jsn.at("MoveMode").get<std::string>());
    #endif
  }
  if (jsn.at("MoveMode").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  move_mode = static_cast<MoveStepMode>(MoveMode_enum_val);
  if (jsn.at("Rate").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  rate = jsn.at("Rate").get< uint8_t >();
      if (jsn.at("OptionsMask").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_mask = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsMask", jsn, LevelOptions);
  if (jsn.at("OptionsOverride").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_override = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsOverride", jsn, LevelOptions);
}


std::string get_json_payload_for_level_step_command(
  
  const uic_mqtt_dotdot_level_command_step_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum Step / StepMode
  #ifdef STEP_STEP_MODE_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["StepMode"] =
    step_step_mode_get_enum_value_name(
      (uint32_t)fields->step_mode);
  #elif defined(MOVE_STEP_MODE_ENUM_NAME_AVAILABLE)
  json_payload["StepMode"] =
    move_step_mode_get_enum_value_name((uint32_t)fields->step_mode);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["StepMode"] = fields->step_mode;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["StepSize"] = nlohmann::json(fields->step_size);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["TransitionTime"] = nlohmann::json(fields->transition_time);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsMask"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_mask,
                                LevelOptions);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsOverride"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_override,
                                LevelOptions);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_level_step(
  nlohmann::json &jsn,
  MoveStepMode &step_mode,
  
  uint8_t &step_size,
  
  uint16_t &transition_time,
  
  uint8_t &options_mask,
  
  uint8_t &options_override
  
) {

  uint32_t StepMode_enum_val = get_enum_decimal_value<MoveStepMode>("StepMode", jsn);
  if (StepMode_enum_val == std::numeric_limits<MoveStepMode>::max()) {
    #ifdef MOVE_STEP_MODE_ENUM_NAME_AVAILABLE
    StepMode_enum_val = move_step_mode_get_enum_value_number(jsn.at("StepMode").get<std::string>());
    #endif
  }
  if (jsn.at("StepMode").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  step_mode = static_cast<MoveStepMode>(StepMode_enum_val);
  if (jsn.at("StepSize").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  step_size = jsn.at("StepSize").get< uint8_t >();
      if (jsn.at("TransitionTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  transition_time = jsn.at("TransitionTime").get< uint16_t >();
      if (jsn.at("OptionsMask").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_mask = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsMask", jsn, LevelOptions);
  if (jsn.at("OptionsOverride").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_override = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsOverride", jsn, LevelOptions);
}


std::string get_json_payload_for_level_stop_command(
  
  const uic_mqtt_dotdot_level_command_stop_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsMask"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_mask,
                                LevelOptions);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsOverride"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_override,
                                LevelOptions);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_level_stop(
  nlohmann::json &jsn,
  uint8_t &options_mask,
  
  uint8_t &options_override
  
) {

  if (jsn.at("OptionsMask").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_mask = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsMask", jsn, LevelOptions);
  if (jsn.at("OptionsOverride").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_override = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsOverride", jsn, LevelOptions);
}


std::string get_json_payload_for_level_move_to_level_with_on_off_command(
  
  const uic_mqtt_dotdot_level_command_move_to_level_with_on_off_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Level"] = nlohmann::json(fields->level);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["TransitionTime"] = nlohmann::json(fields->transition_time);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsMask"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_mask,
                                LevelOptions);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsOverride"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_override,
                                LevelOptions);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_level_move_to_level_with_on_off(
  nlohmann::json &jsn,
  uint8_t &level,
  
  uint16_t &transition_time,
  
  uint8_t &options_mask,
  
  uint8_t &options_override
  
) {

  if (jsn.at("Level").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  level = jsn.at("Level").get< uint8_t >();
      if (jsn.at("TransitionTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  transition_time = jsn.at("TransitionTime").get< uint16_t >();
      if (jsn.at("OptionsMask").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_mask = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsMask", jsn, LevelOptions);
  if (jsn.at("OptionsOverride").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_override = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsOverride", jsn, LevelOptions);
}


std::string get_json_payload_for_level_move_with_on_off_command(
  
  const uic_mqtt_dotdot_level_command_move_with_on_off_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum MoveWithOnOff / MoveMode
  #ifdef MOVE_WITH_ON_OFF_MOVE_MODE_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["MoveMode"] =
    move_with_on_off_move_mode_get_enum_value_name(
      (uint32_t)fields->move_mode);
  #elif defined(MOVE_STEP_MODE_ENUM_NAME_AVAILABLE)
  json_payload["MoveMode"] =
    move_step_mode_get_enum_value_name((uint32_t)fields->move_mode);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["MoveMode"] = fields->move_mode;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Rate"] = nlohmann::json(fields->rate);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsMask"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_mask,
                                LevelOptions);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsOverride"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_override,
                                LevelOptions);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_level_move_with_on_off(
  nlohmann::json &jsn,
  MoveStepMode &move_mode,
  
  uint8_t &rate,
  
  uint8_t &options_mask,
  
  uint8_t &options_override
  
) {

  uint32_t MoveMode_enum_val = get_enum_decimal_value<MoveStepMode>("MoveMode", jsn);
  if (MoveMode_enum_val == std::numeric_limits<MoveStepMode>::max()) {
    #ifdef MOVE_STEP_MODE_ENUM_NAME_AVAILABLE
    MoveMode_enum_val = move_step_mode_get_enum_value_number(jsn.at("MoveMode").get<std::string>());
    #endif
  }
  if (jsn.at("MoveMode").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  move_mode = static_cast<MoveStepMode>(MoveMode_enum_val);
  if (jsn.at("Rate").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  rate = jsn.at("Rate").get< uint8_t >();
      if (jsn.at("OptionsMask").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_mask = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsMask", jsn, LevelOptions);
  if (jsn.at("OptionsOverride").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_override = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsOverride", jsn, LevelOptions);
}


std::string get_json_payload_for_level_step_with_on_off_command(
  
  const uic_mqtt_dotdot_level_command_step_with_on_off_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum StepWithOnOff / StepMode
  #ifdef STEP_WITH_ON_OFF_STEP_MODE_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["StepMode"] =
    step_with_on_off_step_mode_get_enum_value_name(
      (uint32_t)fields->step_mode);
  #elif defined(MOVE_STEP_MODE_ENUM_NAME_AVAILABLE)
  json_payload["StepMode"] =
    move_step_mode_get_enum_value_name((uint32_t)fields->step_mode);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["StepMode"] = fields->step_mode;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["StepSize"] = nlohmann::json(fields->step_size);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["TransitionTime"] = nlohmann::json(fields->transition_time);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsMask"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_mask,
                                LevelOptions);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsOverride"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_override,
                                LevelOptions);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_level_step_with_on_off(
  nlohmann::json &jsn,
  MoveStepMode &step_mode,
  
  uint8_t &step_size,
  
  uint16_t &transition_time,
  
  uint8_t &options_mask,
  
  uint8_t &options_override
  
) {

  uint32_t StepMode_enum_val = get_enum_decimal_value<MoveStepMode>("StepMode", jsn);
  if (StepMode_enum_val == std::numeric_limits<MoveStepMode>::max()) {
    #ifdef MOVE_STEP_MODE_ENUM_NAME_AVAILABLE
    StepMode_enum_val = move_step_mode_get_enum_value_number(jsn.at("StepMode").get<std::string>());
    #endif
  }
  if (jsn.at("StepMode").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  step_mode = static_cast<MoveStepMode>(StepMode_enum_val);
  if (jsn.at("StepSize").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  step_size = jsn.at("StepSize").get< uint8_t >();
      if (jsn.at("TransitionTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  transition_time = jsn.at("TransitionTime").get< uint16_t >();
      if (jsn.at("OptionsMask").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_mask = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsMask", jsn, LevelOptions);
  if (jsn.at("OptionsOverride").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_override = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsOverride", jsn, LevelOptions);
}


std::string get_json_payload_for_level_stop_with_on_off_command(
  
  const uic_mqtt_dotdot_level_command_stop_with_on_off_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsMask"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_mask,
                                LevelOptions);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsOverride"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_override,
                                LevelOptions);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_level_stop_with_on_off(
  nlohmann::json &jsn,
  uint8_t &options_mask,
  
  uint8_t &options_override
  
) {

  if (jsn.at("OptionsMask").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_mask = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsMask", jsn, LevelOptions);
  if (jsn.at("OptionsOverride").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_override = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsOverride", jsn, LevelOptions);
}


std::string get_json_payload_for_level_move_to_closest_frequency_command(
  
  const uic_mqtt_dotdot_level_command_move_to_closest_frequency_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Frequency"] = nlohmann::json(fields->frequency);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_level_move_to_closest_frequency(
  nlohmann::json &jsn,
  uint16_t &frequency
  
) {

  if (jsn.at("Frequency").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  frequency = jsn.at("Frequency").get< uint16_t >();
    }


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_level_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_level_state_t &new_state,
  uic_mqtt_dotdot_level_updated_state_t &new_updated_state
) {


  if (jsn.find("Options") != jsn.end()) {

    new_state.options = uic_dotdot_mqtt::get_bitmap_decimal_value("Options", jsn, LevelOptions);
  
    new_updated_state.options = true;
  }

  if (jsn.find("OnOffTransitionTime") != jsn.end()) {

    new_state.on_off_transition_time = jsn.at("OnOffTransitionTime").get<uint16_t>();
        
    new_updated_state.on_off_transition_time = true;
  }

  if (jsn.find("OnLevel") != jsn.end()) {

    new_state.on_level = jsn.at("OnLevel").get<uint8_t>();
        
    new_updated_state.on_level = true;
  }

  if (jsn.find("OnTransitionTime") != jsn.end()) {

    new_state.on_transition_time = jsn.at("OnTransitionTime").get<uint16_t>();
        
    new_updated_state.on_transition_time = true;
  }

  if (jsn.find("OffTransitionTime") != jsn.end()) {

    new_state.off_transition_time = jsn.at("OffTransitionTime").get<uint16_t>();
        
    new_updated_state.off_transition_time = true;
  }

  if (jsn.find("DefaultMoveRate") != jsn.end()) {

    new_state.default_move_rate = jsn.at("DefaultMoveRate").get<uint16_t>();
        
    new_updated_state.default_move_rate = true;
  }

  if (jsn.find("StartUpCurrentLevel") != jsn.end()) {

    new_state.start_up_current_level = jsn.at("StartUpCurrentLevel").get<uint8_t>();
        
    new_updated_state.start_up_current_level = true;
  }


}


std::string get_json_payload_for_alarms_reset_alarm_command(
  
  const uic_mqtt_dotdot_alarms_command_reset_alarm_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum ResetAlarm / AlarmCode
  #ifdef RESET_ALARM_ALARM_CODE_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["AlarmCode"] =
    reset_alarm_alarm_code_get_enum_value_name(
      (uint32_t)fields->alarm_code);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  json_payload["AlarmCode"] =
    enum8_get_enum_value_name((uint32_t)fields->alarm_code);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["AlarmCode"] = fields->alarm_code;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["ClusterIdentifier"] = nlohmann::json(fields->cluster_identifier);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_alarms_reset_alarm(
  nlohmann::json &jsn,
  uint8_t &alarm_code,
  
  clusterId &cluster_identifier
  
) {

  uint32_t AlarmCode_enum_val = get_enum_decimal_value<uint8_t>("AlarmCode", jsn);
  if (AlarmCode_enum_val == std::numeric_limits<uint8_t>::max()) {
    #ifdef ENUM8_ENUM_NAME_AVAILABLE
    AlarmCode_enum_val = enum8_get_enum_value_number(jsn.at("AlarmCode").get<std::string>());
    #endif
  }
  if (jsn.at("AlarmCode").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  alarm_code = static_cast<uint8_t>(AlarmCode_enum_val);
  if (jsn.at("ClusterIdentifier").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  cluster_identifier = jsn.at("ClusterIdentifier").get< clusterId >();
    }


std::string get_json_payload_for_alarms_alarm_command(
  
  const uic_mqtt_dotdot_alarms_command_alarm_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum Alarm / AlarmCode
  #ifdef ALARM_ALARM_CODE_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["AlarmCode"] =
    alarm_alarm_code_get_enum_value_name(
      (uint32_t)fields->alarm_code);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  json_payload["AlarmCode"] =
    enum8_get_enum_value_name((uint32_t)fields->alarm_code);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["AlarmCode"] = fields->alarm_code;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["ClusterIdentifier"] = nlohmann::json(fields->cluster_identifier);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_alarms_alarm(
  nlohmann::json &jsn,
  uint8_t &alarm_code,
  
  clusterId &cluster_identifier
  
) {

  uint32_t AlarmCode_enum_val = get_enum_decimal_value<uint8_t>("AlarmCode", jsn);
  if (AlarmCode_enum_val == std::numeric_limits<uint8_t>::max()) {
    #ifdef ENUM8_ENUM_NAME_AVAILABLE
    AlarmCode_enum_val = enum8_get_enum_value_number(jsn.at("AlarmCode").get<std::string>());
    #endif
  }
  if (jsn.at("AlarmCode").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  alarm_code = static_cast<uint8_t>(AlarmCode_enum_val);
  if (jsn.at("ClusterIdentifier").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  cluster_identifier = jsn.at("ClusterIdentifier").get< clusterId >();
    }


std::string get_json_payload_for_alarms_reset_all_alarms_command(
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}




std::string get_json_payload_for_alarms_get_alarm_response_command(
  
  const uic_mqtt_dotdot_alarms_command_get_alarm_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum GetAlarmResponse / Status
  #ifdef GET_ALARM_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    get_alarm_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(ZCL_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    zcl_status_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Enum GetAlarmResponse / AlarmCode
  #ifdef GET_ALARM_RESPONSE_ALARM_CODE_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["AlarmCode"] =
    get_alarm_response_alarm_code_get_enum_value_name(
      (uint32_t)fields->alarm_code);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  json_payload["AlarmCode"] =
    enum8_get_enum_value_name((uint32_t)fields->alarm_code);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["AlarmCode"] = fields->alarm_code;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["ClusterIdentifier"] = nlohmann::json(fields->cluster_identifier);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["TimeStamp"] = nlohmann::json(fields->time_stamp);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_alarms_get_alarm_response(
  nlohmann::json &jsn,
  zclStatus &status,
  
  uint8_t &alarm_code,
  
  clusterId &cluster_identifier,
  
  uint32_t &time_stamp
  
) {

  uint32_t Status_enum_val = get_enum_decimal_value<zclStatus>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<zclStatus>::max()) {
    #ifdef ZCL_STATUS_ENUM_NAME_AVAILABLE
    Status_enum_val = zcl_status_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  uint32_t AlarmCode_enum_val = get_enum_decimal_value<uint8_t>("AlarmCode", jsn);
  if (AlarmCode_enum_val == std::numeric_limits<uint8_t>::max()) {
    #ifdef ENUM8_ENUM_NAME_AVAILABLE
    AlarmCode_enum_val = enum8_get_enum_value_number(jsn.at("AlarmCode").get<std::string>());
    #endif
  }
  if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<zclStatus>(Status_enum_val);
  if (jsn.at("AlarmCode").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  alarm_code = static_cast<uint8_t>(AlarmCode_enum_val);
  if (jsn.at("ClusterIdentifier").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  cluster_identifier = jsn.at("ClusterIdentifier").get< clusterId >();
      if (jsn.at("TimeStamp").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  time_stamp = jsn.at("TimeStamp").get< uint32_t >();
    }


std::string get_json_payload_for_alarms_get_alarm_command(
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}




std::string get_json_payload_for_alarms_reset_alarm_log_command(
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}




/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_alarms_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_alarms_state_t &new_state,
  uic_mqtt_dotdot_alarms_updated_state_t &new_updated_state
) {



}


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_time_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_time_state_t &new_state,
  uic_mqtt_dotdot_time_updated_state_t &new_updated_state
) {


  if (jsn.find("Time") != jsn.end()) {

    new_state.time = jsn.at("Time").get<UTC>();
        
    new_updated_state.time = true;
  }

  if (jsn.find("TimeStatus") != jsn.end()) {

    new_state.time_status = uic_dotdot_mqtt::get_bitmap_decimal_value("TimeStatus", jsn, TimeTimeStatus);
  
    new_updated_state.time_status = true;
  }

  if (jsn.find("TimeZone") != jsn.end()) {

    new_state.time_zone = jsn.at("TimeZone").get<int32_t>();
        
    new_updated_state.time_zone = true;
  }

  if (jsn.find("DstStart") != jsn.end()) {

    new_state.dst_start = jsn.at("DstStart").get<uint32_t>();
        
    new_updated_state.dst_start = true;
  }

  if (jsn.find("DstEnd") != jsn.end()) {

    new_state.dst_end = jsn.at("DstEnd").get<uint32_t>();
        
    new_updated_state.dst_end = true;
  }

  if (jsn.find("DstShift") != jsn.end()) {

    new_state.dst_shift = jsn.at("DstShift").get<int32_t>();
        
    new_updated_state.dst_shift = true;
  }

  if (jsn.find("ValidUntilTime") != jsn.end()) {

    new_state.valid_until_time = jsn.at("ValidUntilTime").get<UTC>();
        
    new_updated_state.valid_until_time = true;
  }


}


std::string get_json_payload_for_poll_control_check_in_command(
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}




std::string get_json_payload_for_poll_control_check_in_response_command(
  
  const uic_mqtt_dotdot_poll_control_command_check_in_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["StartFastPolling"] = nlohmann::json(fields->start_fast_polling);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["FastPollTimeout"] = nlohmann::json(fields->fast_poll_timeout);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_poll_control_check_in_response(
  nlohmann::json &jsn,
  bool &start_fast_polling,
  
  uint16_t &fast_poll_timeout
  
) {

  if (jsn.at("StartFastPolling").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  start_fast_polling = jsn.at("StartFastPolling").get< bool >();
      if (jsn.at("FastPollTimeout").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  fast_poll_timeout = jsn.at("FastPollTimeout").get< uint16_t >();
    }


std::string get_json_payload_for_poll_control_fast_poll_stop_command(
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}




std::string get_json_payload_for_poll_control_set_long_poll_interval_command(
  
  const uic_mqtt_dotdot_poll_control_command_set_long_poll_interval_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["NewLongPollInterval"] = nlohmann::json(fields->new_long_poll_interval);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_poll_control_set_long_poll_interval(
  nlohmann::json &jsn,
  uint32_t &new_long_poll_interval
  
) {

  if (jsn.at("NewLongPollInterval").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  new_long_poll_interval = jsn.at("NewLongPollInterval").get< uint32_t >();
    }


std::string get_json_payload_for_poll_control_set_short_poll_interval_command(
  
  const uic_mqtt_dotdot_poll_control_command_set_short_poll_interval_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["NewShortPollInterval"] = nlohmann::json(fields->new_short_poll_interval);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_poll_control_set_short_poll_interval(
  nlohmann::json &jsn,
  uint16_t &new_short_poll_interval
  
) {

  if (jsn.at("NewShortPollInterval").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  new_short_poll_interval = jsn.at("NewShortPollInterval").get< uint16_t >();
    }


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_poll_control_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_poll_control_state_t &new_state,
  uic_mqtt_dotdot_poll_control_updated_state_t &new_updated_state
) {


  if (jsn.find("CheckInInterval") != jsn.end()) {

    new_state.check_in_interval = jsn.at("CheckInInterval").get<uint32_t>();
        
    new_updated_state.check_in_interval = true;
  }

  if (jsn.find("FastPollTimeout") != jsn.end()) {

    new_state.fast_poll_timeout = jsn.at("FastPollTimeout").get<uint16_t>();
        
    new_updated_state.fast_poll_timeout = true;
  }


}


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_shade_configuration_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_shade_configuration_state_t &new_state,
  uic_mqtt_dotdot_shade_configuration_updated_state_t &new_updated_state
) {


  if (jsn.find("Status") != jsn.end()) {

    new_state.status = uic_dotdot_mqtt::get_bitmap_decimal_value("Status", jsn, ShadeConfigurationStatus);
  
    new_updated_state.status = true;
  }

  if (jsn.find("ClosedLimit") != jsn.end()) {

    new_state.closed_limit = jsn.at("ClosedLimit").get<uint16_t>();
        
    new_updated_state.closed_limit = true;
  }

  if (jsn.find("Mode") != jsn.end()) {

    uint32_t tmp = get_enum_decimal_value<ShadeConfigurationMode>("Mode", jsn);
    if (tmp == std::numeric_limits<ShadeConfigurationMode>::max()) {
      #ifdef SHADE_CONFIGURATION_MODE_ENUM_NAME_AVAILABLE
      tmp = shade_configuration_mode_get_enum_value_number(jsn.at("Mode").get<std::string>());
      #elif defined(MODE_ENUM_NAME_AVAILABLE)
      tmp = mode_get_enum_value_number(jsn.at("Mode").get<std::string>());
      #endif
    }
    new_state.mode = tmp;
  
    new_updated_state.mode = true;
  }


}


std::string get_json_payload_for_door_lock_lock_door_command(
  
  const uic_mqtt_dotdot_door_lock_command_lock_door_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["PINOrRFIDCode"] = nlohmann::json(fields->pin_orrfid_code);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_lock_door(
  nlohmann::json &jsn,
  std::string &pin_orrfid_code
  
) {

  if (jsn.at("PINOrRFIDCode").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  pin_orrfid_code = jsn.at("PINOrRFIDCode").get<std::string>();
          }


std::string get_json_payload_for_door_lock_lock_door_response_command(
  
  const uic_mqtt_dotdot_door_lock_command_lock_door_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum LockDoorResponse / Status
  #ifdef LOCK_DOOR_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    lock_door_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(ZCL_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    zcl_status_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_lock_door_response(
  nlohmann::json &jsn,
  zclStatus &status
  
) {

  uint32_t Status_enum_val = get_enum_decimal_value<zclStatus>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<zclStatus>::max()) {
    #ifdef ZCL_STATUS_ENUM_NAME_AVAILABLE
    Status_enum_val = zcl_status_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<zclStatus>(Status_enum_val);
}


std::string get_json_payload_for_door_lock_unlock_door_command(
  
  const uic_mqtt_dotdot_door_lock_command_unlock_door_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["PINOrRFIDCode"] = nlohmann::json(fields->pin_orrfid_code);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_unlock_door(
  nlohmann::json &jsn,
  std::string &pin_orrfid_code
  
) {

  if (jsn.at("PINOrRFIDCode").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  pin_orrfid_code = jsn.at("PINOrRFIDCode").get<std::string>();
          }


std::string get_json_payload_for_door_lock_unlock_door_response_command(
  
  const uic_mqtt_dotdot_door_lock_command_unlock_door_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum UnlockDoorResponse / Status
  #ifdef UNLOCK_DOOR_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    unlock_door_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(ZCL_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    zcl_status_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_unlock_door_response(
  nlohmann::json &jsn,
  zclStatus &status
  
) {

  uint32_t Status_enum_val = get_enum_decimal_value<zclStatus>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<zclStatus>::max()) {
    #ifdef ZCL_STATUS_ENUM_NAME_AVAILABLE
    Status_enum_val = zcl_status_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<zclStatus>(Status_enum_val);
}


std::string get_json_payload_for_door_lock_toggle_command(
  
  const uic_mqtt_dotdot_door_lock_command_toggle_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["PINOrRFIDCode"] = nlohmann::json(fields->pin_orrfid_code);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_toggle(
  nlohmann::json &jsn,
  std::string &pin_orrfid_code
  
) {

  if (jsn.at("PINOrRFIDCode").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  pin_orrfid_code = jsn.at("PINOrRFIDCode").get<std::string>();
          }


std::string get_json_payload_for_door_lock_toggle_response_command(
  
  const uic_mqtt_dotdot_door_lock_command_toggle_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum ToggleResponse / Status
  #ifdef TOGGLE_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    toggle_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(ZCL_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    zcl_status_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_toggle_response(
  nlohmann::json &jsn,
  zclStatus &status
  
) {

  uint32_t Status_enum_val = get_enum_decimal_value<zclStatus>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<zclStatus>::max()) {
    #ifdef ZCL_STATUS_ENUM_NAME_AVAILABLE
    Status_enum_val = zcl_status_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<zclStatus>(Status_enum_val);
}


std::string get_json_payload_for_door_lock_unlock_with_timeout_command(
  
  const uic_mqtt_dotdot_door_lock_command_unlock_with_timeout_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["TimeoutInSeconds"] = nlohmann::json(fields->timeout_in_seconds);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["PINOrRFIDCode"] = nlohmann::json(fields->pin_orrfid_code);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_unlock_with_timeout(
  nlohmann::json &jsn,
  uint16_t &timeout_in_seconds,
  
  std::string &pin_orrfid_code
  
) {

  if (jsn.at("TimeoutInSeconds").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  timeout_in_seconds = jsn.at("TimeoutInSeconds").get< uint16_t >();
      if (jsn.at("PINOrRFIDCode").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  pin_orrfid_code = jsn.at("PINOrRFIDCode").get<std::string>();
          }


std::string get_json_payload_for_door_lock_unlock_with_timeout_response_command(
  
  const uic_mqtt_dotdot_door_lock_command_unlock_with_timeout_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum UnlockWithTimeoutResponse / Status
  #ifdef UNLOCK_WITH_TIMEOUT_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    unlock_with_timeout_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(ZCL_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    zcl_status_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_unlock_with_timeout_response(
  nlohmann::json &jsn,
  zclStatus &status
  
) {

  uint32_t Status_enum_val = get_enum_decimal_value<zclStatus>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<zclStatus>::max()) {
    #ifdef ZCL_STATUS_ENUM_NAME_AVAILABLE
    Status_enum_val = zcl_status_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<zclStatus>(Status_enum_val);
}


std::string get_json_payload_for_door_lock_get_log_record_command(
  
  const uic_mqtt_dotdot_door_lock_command_get_log_record_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["LogIndex"] = nlohmann::json(fields->log_index);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_get_log_record(
  nlohmann::json &jsn,
  uint16_t &log_index
  
) {

  if (jsn.at("LogIndex").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  log_index = jsn.at("LogIndex").get< uint16_t >();
    }


std::string get_json_payload_for_door_lock_get_log_record_response_command(
  
  const uic_mqtt_dotdot_door_lock_command_get_log_record_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["LogEntryID"] = nlohmann::json(fields->log_entryid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Timestamp"] = nlohmann::json(fields->timestamp);
  command_with_no_fields = false;
  // Single Value
  // Enum GetLogRecordResponse / EventType
  #ifdef GET_LOG_RECORD_RESPONSE_EVENT_TYPE_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["EventType"] =
    get_log_record_response_event_type_get_enum_value_name(
      (uint32_t)fields->event_type);
  #elif defined(GET_LOG_RECORD_RESPONSE_EVENT_TYPE_ENUM_NAME_AVAILABLE)
  json_payload["EventType"] =
    get_log_record_response_event_type_get_enum_value_name((uint32_t)fields->event_type);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["EventType"] = fields->event_type;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Enum GetLogRecordResponse / SourceOperationEvent
  #ifdef GET_LOG_RECORD_RESPONSE_SOURCE_OPERATION_EVENT_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["SourceOperationEvent"] =
    get_log_record_response_source_operation_event_get_enum_value_name(
      (uint32_t)fields->source_operation_event);
  #elif defined(DRLK_OPER_EVENT_SOURCE_ENUM_NAME_AVAILABLE)
  json_payload["SourceOperationEvent"] =
    drlk_oper_event_source_get_enum_value_name((uint32_t)fields->source_operation_event);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["SourceOperationEvent"] = fields->source_operation_event;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["EventIDOrAlarmCode"] = nlohmann::json(fields->eventid_or_alarm_code);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["UserID"] = nlohmann::json(fields->userid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["PIN"] = nlohmann::json(fields->pin);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_get_log_record_response(
  nlohmann::json &jsn,
  uint16_t &log_entryid,
  
  uint32_t &timestamp,
  
  GetLogRecordResponseEventType &event_type,
  
  DrlkOperEventSource &source_operation_event,
  
  uint8_t &eventid_or_alarm_code,
  
  uint16_t &userid,
  
  std::string &pin
  
) {

  uint32_t EventType_enum_val = get_enum_decimal_value<GetLogRecordResponseEventType>("EventType", jsn);
  if (EventType_enum_val == std::numeric_limits<GetLogRecordResponseEventType>::max()) {
    #ifdef GET_LOG_RECORD_RESPONSE_EVENT_TYPE_ENUM_NAME_AVAILABLE
    EventType_enum_val = get_log_record_response_event_type_get_enum_value_number(jsn.at("EventType").get<std::string>());
    #endif
  }
  uint32_t SourceOperationEvent_enum_val = get_enum_decimal_value<DrlkOperEventSource>("SourceOperationEvent", jsn);
  if (SourceOperationEvent_enum_val == std::numeric_limits<DrlkOperEventSource>::max()) {
    #ifdef DRLK_OPER_EVENT_SOURCE_ENUM_NAME_AVAILABLE
    SourceOperationEvent_enum_val = drlk_oper_event_source_get_enum_value_number(jsn.at("SourceOperationEvent").get<std::string>());
    #endif
  }
  if (jsn.at("LogEntryID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  log_entryid = jsn.at("LogEntryID").get< uint16_t >();
      if (jsn.at("Timestamp").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  timestamp = jsn.at("Timestamp").get< uint32_t >();
      if (jsn.at("EventType").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  event_type = static_cast<GetLogRecordResponseEventType>(EventType_enum_val);
  if (jsn.at("SourceOperationEvent").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  source_operation_event = static_cast<DrlkOperEventSource>(SourceOperationEvent_enum_val);
  if (jsn.at("EventIDOrAlarmCode").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  eventid_or_alarm_code = jsn.at("EventIDOrAlarmCode").get< uint8_t >();
      if (jsn.at("UserID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  userid = jsn.at("UserID").get< uint16_t >();
      if (jsn.at("PIN").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  pin = jsn.at("PIN").get<std::string>();
          }


std::string get_json_payload_for_door_lock_setpin_code_command(
  
  const uic_mqtt_dotdot_door_lock_command_setpin_code_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["UserID"] = nlohmann::json(fields->userid);
  command_with_no_fields = false;
  // Single Value
  // Enum SetPINCode / UserStatus
  #ifdef SETPIN_CODE_USER_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["UserStatus"] =
    setpin_code_user_status_get_enum_value_name(
      (uint32_t)fields->user_status);
  #elif defined(DRLK_SETTABLE_USER_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["UserStatus"] =
    drlk_settable_user_status_get_enum_value_name((uint32_t)fields->user_status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["UserStatus"] = fields->user_status;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Enum SetPINCode / UserType
  #ifdef SETPIN_CODE_USER_TYPE_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["UserType"] =
    setpin_code_user_type_get_enum_value_name(
      (uint32_t)fields->user_type);
  #elif defined(DRLK_USER_TYPE_ENUM_NAME_AVAILABLE)
  json_payload["UserType"] =
    drlk_user_type_get_enum_value_name((uint32_t)fields->user_type);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["UserType"] = fields->user_type;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["PIN"] = nlohmann::json(fields->pin);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_setpin_code(
  nlohmann::json &jsn,
  DrlkPINUserID &userid,
  
  DrlkSettableUserStatus &user_status,
  
  DrlkUserType &user_type,
  
  std::string &pin
  
) {

  uint32_t UserStatus_enum_val = get_enum_decimal_value<DrlkSettableUserStatus>("UserStatus", jsn);
  if (UserStatus_enum_val == std::numeric_limits<DrlkSettableUserStatus>::max()) {
    #ifdef DRLK_SETTABLE_USER_STATUS_ENUM_NAME_AVAILABLE
    UserStatus_enum_val = drlk_settable_user_status_get_enum_value_number(jsn.at("UserStatus").get<std::string>());
    #endif
  }
  uint32_t UserType_enum_val = get_enum_decimal_value<DrlkUserType>("UserType", jsn);
  if (UserType_enum_val == std::numeric_limits<DrlkUserType>::max()) {
    #ifdef DRLK_USER_TYPE_ENUM_NAME_AVAILABLE
    UserType_enum_val = drlk_user_type_get_enum_value_number(jsn.at("UserType").get<std::string>());
    #endif
  }
  if (jsn.at("UserID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  userid = jsn.at("UserID").get< DrlkPINUserID >();
      if (jsn.at("UserStatus").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  user_status = static_cast<DrlkSettableUserStatus>(UserStatus_enum_val);
  if (jsn.at("UserType").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  user_type = static_cast<DrlkUserType>(UserType_enum_val);
  if (jsn.at("PIN").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  pin = jsn.at("PIN").get<std::string>();
          }


std::string get_json_payload_for_door_lock_setpin_code_response_command(
  
  const uic_mqtt_dotdot_door_lock_command_setpin_code_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum SetPINCodeResponse / Status
  #ifdef SETPIN_CODE_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    setpin_code_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(DRLK_SET_CODE_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    drlk_set_code_status_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_setpin_code_response(
  nlohmann::json &jsn,
  DrlkSetCodeStatus &status
  
) {

  uint32_t Status_enum_val = get_enum_decimal_value<DrlkSetCodeStatus>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<DrlkSetCodeStatus>::max()) {
    #ifdef DRLK_SET_CODE_STATUS_ENUM_NAME_AVAILABLE
    Status_enum_val = drlk_set_code_status_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<DrlkSetCodeStatus>(Status_enum_val);
}


std::string get_json_payload_for_door_lock_getpin_code_command(
  
  const uic_mqtt_dotdot_door_lock_command_getpin_code_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["UserID"] = nlohmann::json(fields->userid);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_getpin_code(
  nlohmann::json &jsn,
  DrlkPINUserID &userid
  
) {

  if (jsn.at("UserID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  userid = jsn.at("UserID").get< DrlkPINUserID >();
    }


std::string get_json_payload_for_door_lock_getpin_code_response_command(
  
  const uic_mqtt_dotdot_door_lock_command_getpin_code_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["UserID"] = nlohmann::json(fields->userid);
  command_with_no_fields = false;
  // Single Value
  // Enum GetPINCodeResponse / UserStatus
  #ifdef GETPIN_CODE_RESPONSE_USER_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["UserStatus"] =
    getpin_code_response_user_status_get_enum_value_name(
      (uint32_t)fields->user_status);
  #elif defined(DRLK_USER_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["UserStatus"] =
    drlk_user_status_get_enum_value_name((uint32_t)fields->user_status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["UserStatus"] = fields->user_status;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Enum GetPINCodeResponse / UserType
  #ifdef GETPIN_CODE_RESPONSE_USER_TYPE_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["UserType"] =
    getpin_code_response_user_type_get_enum_value_name(
      (uint32_t)fields->user_type);
  #elif defined(DRLK_USER_TYPE_ENUM_NAME_AVAILABLE)
  json_payload["UserType"] =
    drlk_user_type_get_enum_value_name((uint32_t)fields->user_type);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["UserType"] = fields->user_type;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Code"] = nlohmann::json(fields->code);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_getpin_code_response(
  nlohmann::json &jsn,
  uint16_t &userid,
  
  DrlkUserStatus &user_status,
  
  DrlkUserType &user_type,
  
  std::string &code
  
) {

  uint32_t UserStatus_enum_val = get_enum_decimal_value<DrlkUserStatus>("UserStatus", jsn);
  if (UserStatus_enum_val == std::numeric_limits<DrlkUserStatus>::max()) {
    #ifdef DRLK_USER_STATUS_ENUM_NAME_AVAILABLE
    UserStatus_enum_val = drlk_user_status_get_enum_value_number(jsn.at("UserStatus").get<std::string>());
    #endif
  }
  uint32_t UserType_enum_val = get_enum_decimal_value<DrlkUserType>("UserType", jsn);
  if (UserType_enum_val == std::numeric_limits<DrlkUserType>::max()) {
    #ifdef DRLK_USER_TYPE_ENUM_NAME_AVAILABLE
    UserType_enum_val = drlk_user_type_get_enum_value_number(jsn.at("UserType").get<std::string>());
    #endif
  }
  if (jsn.at("UserID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  userid = jsn.at("UserID").get< uint16_t >();
      if (jsn.at("UserStatus").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  user_status = static_cast<DrlkUserStatus>(UserStatus_enum_val);
  if (jsn.at("UserType").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  user_type = static_cast<DrlkUserType>(UserType_enum_val);
  if (jsn.at("Code").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  code = jsn.at("Code").get<std::string>();
          }


std::string get_json_payload_for_door_lock_clearpin_code_command(
  
  const uic_mqtt_dotdot_door_lock_command_clearpin_code_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["UserID"] = nlohmann::json(fields->userid);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_clearpin_code(
  nlohmann::json &jsn,
  DrlkPINUserID &userid
  
) {

  if (jsn.at("UserID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  userid = jsn.at("UserID").get< DrlkPINUserID >();
    }


std::string get_json_payload_for_door_lock_clearpin_code_response_command(
  
  const uic_mqtt_dotdot_door_lock_command_clearpin_code_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum ClearPINCodeResponse / Status
  #ifdef CLEARPIN_CODE_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    clearpin_code_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(DRLK_PASS_FAIL_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    drlk_pass_fail_status_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_clearpin_code_response(
  nlohmann::json &jsn,
  DrlkPassFailStatus &status
  
) {

  uint32_t Status_enum_val = get_enum_decimal_value<DrlkPassFailStatus>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<DrlkPassFailStatus>::max()) {
    #ifdef DRLK_PASS_FAIL_STATUS_ENUM_NAME_AVAILABLE
    Status_enum_val = drlk_pass_fail_status_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<DrlkPassFailStatus>(Status_enum_val);
}


std::string get_json_payload_for_door_lock_clear_allpin_codes_command(
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}




std::string get_json_payload_for_door_lock_clear_allpin_codes_response_command(
  
  const uic_mqtt_dotdot_door_lock_command_clear_allpin_codes_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum ClearAllPINCodesResponse / Status
  #ifdef CLEAR_ALLPIN_CODES_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    clear_allpin_codes_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(DRLK_PASS_FAIL_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    drlk_pass_fail_status_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_clear_allpin_codes_response(
  nlohmann::json &jsn,
  DrlkPassFailStatus &status
  
) {

  uint32_t Status_enum_val = get_enum_decimal_value<DrlkPassFailStatus>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<DrlkPassFailStatus>::max()) {
    #ifdef DRLK_PASS_FAIL_STATUS_ENUM_NAME_AVAILABLE
    Status_enum_val = drlk_pass_fail_status_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<DrlkPassFailStatus>(Status_enum_val);
}


std::string get_json_payload_for_door_lock_set_user_status_command(
  
  const uic_mqtt_dotdot_door_lock_command_set_user_status_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["UserID"] = nlohmann::json(fields->userid);
  command_with_no_fields = false;
  // Single Value
  // Enum SetUserStatus / UserStatus
  #ifdef SET_USER_STATUS_USER_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["UserStatus"] =
    set_user_status_user_status_get_enum_value_name(
      (uint32_t)fields->user_status);
  #elif defined(DRLK_SETTABLE_USER_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["UserStatus"] =
    drlk_settable_user_status_get_enum_value_name((uint32_t)fields->user_status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["UserStatus"] = fields->user_status;
  #endif

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_set_user_status(
  nlohmann::json &jsn,
  DrlkTotalUserID &userid,
  
  DrlkSettableUserStatus &user_status
  
) {

  uint32_t UserStatus_enum_val = get_enum_decimal_value<DrlkSettableUserStatus>("UserStatus", jsn);
  if (UserStatus_enum_val == std::numeric_limits<DrlkSettableUserStatus>::max()) {
    #ifdef DRLK_SETTABLE_USER_STATUS_ENUM_NAME_AVAILABLE
    UserStatus_enum_val = drlk_settable_user_status_get_enum_value_number(jsn.at("UserStatus").get<std::string>());
    #endif
  }
  if (jsn.at("UserID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  userid = jsn.at("UserID").get< DrlkTotalUserID >();
      if (jsn.at("UserStatus").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  user_status = static_cast<DrlkSettableUserStatus>(UserStatus_enum_val);
}


std::string get_json_payload_for_door_lock_set_user_status_response_command(
  
  const uic_mqtt_dotdot_door_lock_command_set_user_status_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum SetUserStatusResponse / Status
  #ifdef SET_USER_STATUS_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    set_user_status_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(DRLK_PASS_FAIL_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    drlk_pass_fail_status_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_set_user_status_response(
  nlohmann::json &jsn,
  DrlkPassFailStatus &status
  
) {

  uint32_t Status_enum_val = get_enum_decimal_value<DrlkPassFailStatus>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<DrlkPassFailStatus>::max()) {
    #ifdef DRLK_PASS_FAIL_STATUS_ENUM_NAME_AVAILABLE
    Status_enum_val = drlk_pass_fail_status_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<DrlkPassFailStatus>(Status_enum_val);
}


std::string get_json_payload_for_door_lock_get_user_status_command(
  
  const uic_mqtt_dotdot_door_lock_command_get_user_status_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["UserID"] = nlohmann::json(fields->userid);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_get_user_status(
  nlohmann::json &jsn,
  DrlkTotalUserID &userid
  
) {

  if (jsn.at("UserID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  userid = jsn.at("UserID").get< DrlkTotalUserID >();
    }


std::string get_json_payload_for_door_lock_get_user_status_response_command(
  
  const uic_mqtt_dotdot_door_lock_command_get_user_status_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["UserID"] = nlohmann::json(fields->userid);
  command_with_no_fields = false;
  // Single Value
  // Enum GetUserStatusResponse / UserStatus
  #ifdef GET_USER_STATUS_RESPONSE_USER_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["UserStatus"] =
    get_user_status_response_user_status_get_enum_value_name(
      (uint32_t)fields->user_status);
  #elif defined(DRLK_USER_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["UserStatus"] =
    drlk_user_status_get_enum_value_name((uint32_t)fields->user_status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["UserStatus"] = fields->user_status;
  #endif

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_get_user_status_response(
  nlohmann::json &jsn,
  uint16_t &userid,
  
  DrlkUserStatus &user_status
  
) {

  uint32_t UserStatus_enum_val = get_enum_decimal_value<DrlkUserStatus>("UserStatus", jsn);
  if (UserStatus_enum_val == std::numeric_limits<DrlkUserStatus>::max()) {
    #ifdef DRLK_USER_STATUS_ENUM_NAME_AVAILABLE
    UserStatus_enum_val = drlk_user_status_get_enum_value_number(jsn.at("UserStatus").get<std::string>());
    #endif
  }
  if (jsn.at("UserID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  userid = jsn.at("UserID").get< uint16_t >();
      if (jsn.at("UserStatus").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  user_status = static_cast<DrlkUserStatus>(UserStatus_enum_val);
}


std::string get_json_payload_for_door_lock_set_weekday_schedule_command(
  
  const uic_mqtt_dotdot_door_lock_command_set_weekday_schedule_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["ScheduleID"] = nlohmann::json(fields->scheduleid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["UserID"] = nlohmann::json(fields->userid);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["DaysMask"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->days_mask,
                                DrlkDaysMask);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["StartHour"] = nlohmann::json(fields->start_hour);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["StartMinute"] = nlohmann::json(fields->start_minute);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["EndHour"] = nlohmann::json(fields->end_hour);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["EndMinute"] = nlohmann::json(fields->end_minute);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_set_weekday_schedule(
  nlohmann::json &jsn,
  DrlkWeekDayScheduleID &scheduleid,
  
  DrlkTotalUserID &userid,
  
  uint8_t &days_mask,
  
  uint8_t &start_hour,
  
  uint8_t &start_minute,
  
  uint8_t &end_hour,
  
  uint8_t &end_minute
  
) {

  if (jsn.at("ScheduleID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  scheduleid = jsn.at("ScheduleID").get< DrlkWeekDayScheduleID >();
      if (jsn.at("UserID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  userid = jsn.at("UserID").get< DrlkTotalUserID >();
      if (jsn.at("DaysMask").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  days_mask = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("DaysMask", jsn, DrlkDaysMask);
  if (jsn.at("StartHour").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  start_hour = jsn.at("StartHour").get< uint8_t >();
      if (jsn.at("StartMinute").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  start_minute = jsn.at("StartMinute").get< uint8_t >();
      if (jsn.at("EndHour").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  end_hour = jsn.at("EndHour").get< uint8_t >();
      if (jsn.at("EndMinute").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  end_minute = jsn.at("EndMinute").get< uint8_t >();
    }


std::string get_json_payload_for_door_lock_set_weekday_schedule_response_command(
  
  const uic_mqtt_dotdot_door_lock_command_set_weekday_schedule_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum SetWeekdayScheduleResponse / Status
  #ifdef SET_WEEKDAY_SCHEDULE_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    set_weekday_schedule_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(DRLK_PASS_FAIL_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    drlk_pass_fail_status_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_set_weekday_schedule_response(
  nlohmann::json &jsn,
  DrlkPassFailStatus &status
  
) {

  uint32_t Status_enum_val = get_enum_decimal_value<DrlkPassFailStatus>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<DrlkPassFailStatus>::max()) {
    #ifdef DRLK_PASS_FAIL_STATUS_ENUM_NAME_AVAILABLE
    Status_enum_val = drlk_pass_fail_status_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<DrlkPassFailStatus>(Status_enum_val);
}


std::string get_json_payload_for_door_lock_get_weekday_schedule_command(
  
  const uic_mqtt_dotdot_door_lock_command_get_weekday_schedule_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["ScheduleID"] = nlohmann::json(fields->scheduleid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["UserID"] = nlohmann::json(fields->userid);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_get_weekday_schedule(
  nlohmann::json &jsn,
  DrlkWeekDayScheduleID &scheduleid,
  
  DrlkTotalUserID &userid
  
) {

  if (jsn.at("ScheduleID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  scheduleid = jsn.at("ScheduleID").get< DrlkWeekDayScheduleID >();
      if (jsn.at("UserID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  userid = jsn.at("UserID").get< DrlkTotalUserID >();
    }


std::string get_json_payload_for_door_lock_get_weekday_schedule_response_command(
  
  const uic_mqtt_dotdot_door_lock_command_get_weekday_schedule_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["ScheduleID"] = nlohmann::json(fields->scheduleid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["UserID"] = nlohmann::json(fields->userid);
  command_with_no_fields = false;
  // Single Value
  // Enum GetWeekdayScheduleResponse / Status
  #ifdef GET_WEEKDAY_SCHEDULE_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    get_weekday_schedule_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(ZCL_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    zcl_status_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["DaysMask"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->days_mask,
                                DrlkDaysMask);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["StartHour"] = nlohmann::json(fields->start_hour);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["StartMinute"] = nlohmann::json(fields->start_minute);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["EndHour"] = nlohmann::json(fields->end_hour);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["EndMinute"] = nlohmann::json(fields->end_minute);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_get_weekday_schedule_response(
  nlohmann::json &jsn,
  uint8_t &scheduleid,
  
  uint16_t &userid,
  
  zclStatus &status,
  
  uint8_t &days_mask,
  
  uint8_t &start_hour,
  
  uint8_t &start_minute,
  
  uint8_t &end_hour,
  
  uint8_t &end_minute
  
) {

  uint32_t Status_enum_val = get_enum_decimal_value<zclStatus>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<zclStatus>::max()) {
    #ifdef ZCL_STATUS_ENUM_NAME_AVAILABLE
    Status_enum_val = zcl_status_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  if (jsn.at("ScheduleID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  scheduleid = jsn.at("ScheduleID").get< uint8_t >();
      if (jsn.at("UserID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  userid = jsn.at("UserID").get< uint16_t >();
      if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<zclStatus>(Status_enum_val);
  if (jsn.at("DaysMask").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  days_mask = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("DaysMask", jsn, DrlkDaysMask);
  if (jsn.at("StartHour").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  start_hour = jsn.at("StartHour").get< uint8_t >();
      if (jsn.at("StartMinute").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  start_minute = jsn.at("StartMinute").get< uint8_t >();
      if (jsn.at("EndHour").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  end_hour = jsn.at("EndHour").get< uint8_t >();
      if (jsn.at("EndMinute").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  end_minute = jsn.at("EndMinute").get< uint8_t >();
    }


std::string get_json_payload_for_door_lock_clear_weekday_schedule_command(
  
  const uic_mqtt_dotdot_door_lock_command_clear_weekday_schedule_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["ScheduleID"] = nlohmann::json(fields->scheduleid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["UserID"] = nlohmann::json(fields->userid);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_clear_weekday_schedule(
  nlohmann::json &jsn,
  DrlkWeekDayScheduleID &scheduleid,
  
  DrlkTotalUserID &userid
  
) {

  if (jsn.at("ScheduleID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  scheduleid = jsn.at("ScheduleID").get< DrlkWeekDayScheduleID >();
      if (jsn.at("UserID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  userid = jsn.at("UserID").get< DrlkTotalUserID >();
    }


std::string get_json_payload_for_door_lock_clear_weekday_schedule_response_command(
  
  const uic_mqtt_dotdot_door_lock_command_clear_weekday_schedule_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum ClearWeekdayScheduleResponse / Status
  #ifdef CLEAR_WEEKDAY_SCHEDULE_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    clear_weekday_schedule_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(DRLK_PASS_FAIL_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    drlk_pass_fail_status_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_clear_weekday_schedule_response(
  nlohmann::json &jsn,
  DrlkPassFailStatus &status
  
) {

  uint32_t Status_enum_val = get_enum_decimal_value<DrlkPassFailStatus>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<DrlkPassFailStatus>::max()) {
    #ifdef DRLK_PASS_FAIL_STATUS_ENUM_NAME_AVAILABLE
    Status_enum_val = drlk_pass_fail_status_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<DrlkPassFailStatus>(Status_enum_val);
}


std::string get_json_payload_for_door_lock_set_year_day_schedule_command(
  
  const uic_mqtt_dotdot_door_lock_command_set_year_day_schedule_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["ScheduleID"] = nlohmann::json(fields->scheduleid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["UserID"] = nlohmann::json(fields->userid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["LocalStartTime"] = nlohmann::json(fields->local_start_time);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["LocalEndTime"] = nlohmann::json(fields->local_end_time);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_set_year_day_schedule(
  nlohmann::json &jsn,
  DrlkYearDayScheduleID &scheduleid,
  
  DrlkTotalUserID &userid,
  
  uint32_t &local_start_time,
  
  uint32_t &local_end_time
  
) {

  if (jsn.at("ScheduleID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  scheduleid = jsn.at("ScheduleID").get< DrlkYearDayScheduleID >();
      if (jsn.at("UserID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  userid = jsn.at("UserID").get< DrlkTotalUserID >();
      if (jsn.at("LocalStartTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  local_start_time = jsn.at("LocalStartTime").get< uint32_t >();
      if (jsn.at("LocalEndTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  local_end_time = jsn.at("LocalEndTime").get< uint32_t >();
    }


std::string get_json_payload_for_door_lock_set_year_day_schedule_response_command(
  
  const uic_mqtt_dotdot_door_lock_command_set_year_day_schedule_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum SetYearDayScheduleResponse / Status
  #ifdef SET_YEAR_DAY_SCHEDULE_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    set_year_day_schedule_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(DRLK_PASS_FAIL_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    drlk_pass_fail_status_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_set_year_day_schedule_response(
  nlohmann::json &jsn,
  DrlkPassFailStatus &status
  
) {

  uint32_t Status_enum_val = get_enum_decimal_value<DrlkPassFailStatus>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<DrlkPassFailStatus>::max()) {
    #ifdef DRLK_PASS_FAIL_STATUS_ENUM_NAME_AVAILABLE
    Status_enum_val = drlk_pass_fail_status_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<DrlkPassFailStatus>(Status_enum_val);
}


std::string get_json_payload_for_door_lock_get_year_day_schedule_command(
  
  const uic_mqtt_dotdot_door_lock_command_get_year_day_schedule_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["ScheduleID"] = nlohmann::json(fields->scheduleid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["UserID"] = nlohmann::json(fields->userid);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_get_year_day_schedule(
  nlohmann::json &jsn,
  DrlkYearDayScheduleID &scheduleid,
  
  DrlkTotalUserID &userid
  
) {

  if (jsn.at("ScheduleID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  scheduleid = jsn.at("ScheduleID").get< DrlkYearDayScheduleID >();
      if (jsn.at("UserID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  userid = jsn.at("UserID").get< DrlkTotalUserID >();
    }


std::string get_json_payload_for_door_lock_get_year_day_schedule_response_command(
  
  const uic_mqtt_dotdot_door_lock_command_get_year_day_schedule_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["ScheduleID"] = nlohmann::json(fields->scheduleid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["UserID"] = nlohmann::json(fields->userid);
  command_with_no_fields = false;
  // Single Value
  // Enum GetYearDayScheduleResponse / Status
  #ifdef GET_YEAR_DAY_SCHEDULE_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    get_year_day_schedule_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(ZCL_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    zcl_status_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["LocalStartTime"] = nlohmann::json(fields->local_start_time);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["LocalEndTime"] = nlohmann::json(fields->local_end_time);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_get_year_day_schedule_response(
  nlohmann::json &jsn,
  uint8_t &scheduleid,
  
  uint16_t &userid,
  
  zclStatus &status,
  
  uint32_t &local_start_time,
  
  uint32_t &local_end_time
  
) {

  uint32_t Status_enum_val = get_enum_decimal_value<zclStatus>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<zclStatus>::max()) {
    #ifdef ZCL_STATUS_ENUM_NAME_AVAILABLE
    Status_enum_val = zcl_status_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  if (jsn.at("ScheduleID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  scheduleid = jsn.at("ScheduleID").get< uint8_t >();
      if (jsn.at("UserID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  userid = jsn.at("UserID").get< uint16_t >();
      if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<zclStatus>(Status_enum_val);
  if (jsn.at("LocalStartTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  local_start_time = jsn.at("LocalStartTime").get< uint32_t >();
      if (jsn.at("LocalEndTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  local_end_time = jsn.at("LocalEndTime").get< uint32_t >();
    }


std::string get_json_payload_for_door_lock_clear_year_day_schedule_command(
  
  const uic_mqtt_dotdot_door_lock_command_clear_year_day_schedule_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["ScheduleID"] = nlohmann::json(fields->scheduleid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["UserID"] = nlohmann::json(fields->userid);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_clear_year_day_schedule(
  nlohmann::json &jsn,
  DrlkYearDayScheduleID &scheduleid,
  
  DrlkTotalUserID &userid
  
) {

  if (jsn.at("ScheduleID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  scheduleid = jsn.at("ScheduleID").get< DrlkYearDayScheduleID >();
      if (jsn.at("UserID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  userid = jsn.at("UserID").get< DrlkTotalUserID >();
    }


std::string get_json_payload_for_door_lock_clear_year_day_schedule_response_command(
  
  const uic_mqtt_dotdot_door_lock_command_clear_year_day_schedule_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum ClearYearDayScheduleResponse / Status
  #ifdef CLEAR_YEAR_DAY_SCHEDULE_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    clear_year_day_schedule_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(DRLK_PASS_FAIL_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    drlk_pass_fail_status_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_clear_year_day_schedule_response(
  nlohmann::json &jsn,
  DrlkPassFailStatus &status
  
) {

  uint32_t Status_enum_val = get_enum_decimal_value<DrlkPassFailStatus>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<DrlkPassFailStatus>::max()) {
    #ifdef DRLK_PASS_FAIL_STATUS_ENUM_NAME_AVAILABLE
    Status_enum_val = drlk_pass_fail_status_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<DrlkPassFailStatus>(Status_enum_val);
}


std::string get_json_payload_for_door_lock_set_holiday_schedule_command(
  
  const uic_mqtt_dotdot_door_lock_command_set_holiday_schedule_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["HolidayScheduleID"] = nlohmann::json(fields->holiday_scheduleid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["LocalStartTime"] = nlohmann::json(fields->local_start_time);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["LocalEndTime"] = nlohmann::json(fields->local_end_time);
  command_with_no_fields = false;
  // Single Value
  // Enum SetHolidaySchedule / OperatingModeDuringHoliday
  #ifdef SET_HOLIDAY_SCHEDULE_OPERATING_MODE_DURING_HOLIDAY_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["OperatingModeDuringHoliday"] =
    set_holiday_schedule_operating_mode_during_holiday_get_enum_value_name(
      (uint32_t)fields->operating_mode_during_holiday);
  #elif defined(DRLK_OPER_MODE_ENUM_NAME_AVAILABLE)
  json_payload["OperatingModeDuringHoliday"] =
    drlk_oper_mode_get_enum_value_name((uint32_t)fields->operating_mode_during_holiday);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["OperatingModeDuringHoliday"] = fields->operating_mode_during_holiday;
  #endif

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_set_holiday_schedule(
  nlohmann::json &jsn,
  DrlkHolidayScheduleID &holiday_scheduleid,
  
  uint32_t &local_start_time,
  
  uint32_t &local_end_time,
  
  DrlkOperMode &operating_mode_during_holiday
  
) {

  uint32_t OperatingModeDuringHoliday_enum_val = get_enum_decimal_value<DrlkOperMode>("OperatingModeDuringHoliday", jsn);
  if (OperatingModeDuringHoliday_enum_val == std::numeric_limits<DrlkOperMode>::max()) {
    #ifdef DRLK_OPER_MODE_ENUM_NAME_AVAILABLE
    OperatingModeDuringHoliday_enum_val = drlk_oper_mode_get_enum_value_number(jsn.at("OperatingModeDuringHoliday").get<std::string>());
    #endif
  }
  if (jsn.at("HolidayScheduleID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  holiday_scheduleid = jsn.at("HolidayScheduleID").get< DrlkHolidayScheduleID >();
      if (jsn.at("LocalStartTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  local_start_time = jsn.at("LocalStartTime").get< uint32_t >();
      if (jsn.at("LocalEndTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  local_end_time = jsn.at("LocalEndTime").get< uint32_t >();
      if (jsn.at("OperatingModeDuringHoliday").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  operating_mode_during_holiday = static_cast<DrlkOperMode>(OperatingModeDuringHoliday_enum_val);
}


std::string get_json_payload_for_door_lock_set_holiday_schedule_response_command(
  
  const uic_mqtt_dotdot_door_lock_command_set_holiday_schedule_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum SetHolidayScheduleResponse / Status
  #ifdef SET_HOLIDAY_SCHEDULE_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    set_holiday_schedule_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(DRLK_PASS_FAIL_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    drlk_pass_fail_status_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_set_holiday_schedule_response(
  nlohmann::json &jsn,
  DrlkPassFailStatus &status
  
) {

  uint32_t Status_enum_val = get_enum_decimal_value<DrlkPassFailStatus>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<DrlkPassFailStatus>::max()) {
    #ifdef DRLK_PASS_FAIL_STATUS_ENUM_NAME_AVAILABLE
    Status_enum_val = drlk_pass_fail_status_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<DrlkPassFailStatus>(Status_enum_val);
}


std::string get_json_payload_for_door_lock_get_holiday_schedule_command(
  
  const uic_mqtt_dotdot_door_lock_command_get_holiday_schedule_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["HolidayScheduleID"] = nlohmann::json(fields->holiday_scheduleid);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_get_holiday_schedule(
  nlohmann::json &jsn,
  DrlkHolidayScheduleID &holiday_scheduleid
  
) {

  if (jsn.at("HolidayScheduleID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  holiday_scheduleid = jsn.at("HolidayScheduleID").get< DrlkHolidayScheduleID >();
    }


std::string get_json_payload_for_door_lock_get_holiday_schedule_response_command(
  
  const uic_mqtt_dotdot_door_lock_command_get_holiday_schedule_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["HolidayScheduleID"] = nlohmann::json(fields->holiday_scheduleid);
  command_with_no_fields = false;
  // Single Value
  // Enum GetHolidayScheduleResponse / Status
  #ifdef GET_HOLIDAY_SCHEDULE_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    get_holiday_schedule_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(ZCL_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    zcl_status_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["LocalStartTime"] = nlohmann::json(fields->local_start_time);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["LocalEndTime"] = nlohmann::json(fields->local_end_time);
  command_with_no_fields = false;
  // Single Value
  // Enum GetHolidayScheduleResponse / OperatingModeDuringHoliday
  #ifdef GET_HOLIDAY_SCHEDULE_RESPONSE_OPERATING_MODE_DURING_HOLIDAY_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["OperatingModeDuringHoliday"] =
    get_holiday_schedule_response_operating_mode_during_holiday_get_enum_value_name(
      (uint32_t)fields->operating_mode_during_holiday);
  #elif defined(DRLK_OPER_MODE_ENUM_NAME_AVAILABLE)
  json_payload["OperatingModeDuringHoliday"] =
    drlk_oper_mode_get_enum_value_name((uint32_t)fields->operating_mode_during_holiday);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["OperatingModeDuringHoliday"] = fields->operating_mode_during_holiday;
  #endif

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_get_holiday_schedule_response(
  nlohmann::json &jsn,
  uint8_t &holiday_scheduleid,
  
  zclStatus &status,
  
  uint32_t &local_start_time,
  
  uint32_t &local_end_time,
  
  DrlkOperMode &operating_mode_during_holiday
  
) {

  uint32_t Status_enum_val = get_enum_decimal_value<zclStatus>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<zclStatus>::max()) {
    #ifdef ZCL_STATUS_ENUM_NAME_AVAILABLE
    Status_enum_val = zcl_status_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  uint32_t OperatingModeDuringHoliday_enum_val = get_enum_decimal_value<DrlkOperMode>("OperatingModeDuringHoliday", jsn);
  if (OperatingModeDuringHoliday_enum_val == std::numeric_limits<DrlkOperMode>::max()) {
    #ifdef DRLK_OPER_MODE_ENUM_NAME_AVAILABLE
    OperatingModeDuringHoliday_enum_val = drlk_oper_mode_get_enum_value_number(jsn.at("OperatingModeDuringHoliday").get<std::string>());
    #endif
  }
  if (jsn.at("HolidayScheduleID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  holiday_scheduleid = jsn.at("HolidayScheduleID").get< uint8_t >();
      if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<zclStatus>(Status_enum_val);
  if (jsn.at("LocalStartTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  local_start_time = jsn.at("LocalStartTime").get< uint32_t >();
      if (jsn.at("LocalEndTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  local_end_time = jsn.at("LocalEndTime").get< uint32_t >();
      if (jsn.at("OperatingModeDuringHoliday").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  operating_mode_during_holiday = static_cast<DrlkOperMode>(OperatingModeDuringHoliday_enum_val);
}


std::string get_json_payload_for_door_lock_clear_holiday_schedule_command(
  
  const uic_mqtt_dotdot_door_lock_command_clear_holiday_schedule_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["HolidayScheduleID"] = nlohmann::json(fields->holiday_scheduleid);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_clear_holiday_schedule(
  nlohmann::json &jsn,
  DrlkHolidayScheduleID &holiday_scheduleid
  
) {

  if (jsn.at("HolidayScheduleID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  holiday_scheduleid = jsn.at("HolidayScheduleID").get< DrlkHolidayScheduleID >();
    }


std::string get_json_payload_for_door_lock_clear_holiday_schedule_response_command(
  
  const uic_mqtt_dotdot_door_lock_command_clear_holiday_schedule_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum ClearHolidayScheduleResponse / Status
  #ifdef CLEAR_HOLIDAY_SCHEDULE_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    clear_holiday_schedule_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(DRLK_PASS_FAIL_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    drlk_pass_fail_status_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_clear_holiday_schedule_response(
  nlohmann::json &jsn,
  DrlkPassFailStatus &status
  
) {

  uint32_t Status_enum_val = get_enum_decimal_value<DrlkPassFailStatus>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<DrlkPassFailStatus>::max()) {
    #ifdef DRLK_PASS_FAIL_STATUS_ENUM_NAME_AVAILABLE
    Status_enum_val = drlk_pass_fail_status_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<DrlkPassFailStatus>(Status_enum_val);
}


std::string get_json_payload_for_door_lock_set_user_type_command(
  
  const uic_mqtt_dotdot_door_lock_command_set_user_type_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["UserID"] = nlohmann::json(fields->userid);
  command_with_no_fields = false;
  // Single Value
  // Enum SetUserType / UserType
  #ifdef SET_USER_TYPE_USER_TYPE_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["UserType"] =
    set_user_type_user_type_get_enum_value_name(
      (uint32_t)fields->user_type);
  #elif defined(DRLK_USER_TYPE_ENUM_NAME_AVAILABLE)
  json_payload["UserType"] =
    drlk_user_type_get_enum_value_name((uint32_t)fields->user_type);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["UserType"] = fields->user_type;
  #endif

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_set_user_type(
  nlohmann::json &jsn,
  DrlkTotalUserID &userid,
  
  DrlkUserType &user_type
  
) {

  uint32_t UserType_enum_val = get_enum_decimal_value<DrlkUserType>("UserType", jsn);
  if (UserType_enum_val == std::numeric_limits<DrlkUserType>::max()) {
    #ifdef DRLK_USER_TYPE_ENUM_NAME_AVAILABLE
    UserType_enum_val = drlk_user_type_get_enum_value_number(jsn.at("UserType").get<std::string>());
    #endif
  }
  if (jsn.at("UserID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  userid = jsn.at("UserID").get< DrlkTotalUserID >();
      if (jsn.at("UserType").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  user_type = static_cast<DrlkUserType>(UserType_enum_val);
}


std::string get_json_payload_for_door_lock_set_user_type_response_command(
  
  const uic_mqtt_dotdot_door_lock_command_set_user_type_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum SetUserTypeResponse / Status
  #ifdef SET_USER_TYPE_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    set_user_type_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(DRLK_PASS_FAIL_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    drlk_pass_fail_status_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_set_user_type_response(
  nlohmann::json &jsn,
  DrlkPassFailStatus &status
  
) {

  uint32_t Status_enum_val = get_enum_decimal_value<DrlkPassFailStatus>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<DrlkPassFailStatus>::max()) {
    #ifdef DRLK_PASS_FAIL_STATUS_ENUM_NAME_AVAILABLE
    Status_enum_val = drlk_pass_fail_status_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<DrlkPassFailStatus>(Status_enum_val);
}


std::string get_json_payload_for_door_lock_get_user_type_command(
  
  const uic_mqtt_dotdot_door_lock_command_get_user_type_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["UserID"] = nlohmann::json(fields->userid);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_get_user_type(
  nlohmann::json &jsn,
  DrlkTotalUserID &userid
  
) {

  if (jsn.at("UserID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  userid = jsn.at("UserID").get< DrlkTotalUserID >();
    }


std::string get_json_payload_for_door_lock_get_user_type_response_command(
  
  const uic_mqtt_dotdot_door_lock_command_get_user_type_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["UserID"] = nlohmann::json(fields->userid);
  command_with_no_fields = false;
  // Single Value
  // Enum GetUserTypeResponse / UserType
  #ifdef GET_USER_TYPE_RESPONSE_USER_TYPE_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["UserType"] =
    get_user_type_response_user_type_get_enum_value_name(
      (uint32_t)fields->user_type);
  #elif defined(DRLK_USER_TYPE_ENUM_NAME_AVAILABLE)
  json_payload["UserType"] =
    drlk_user_type_get_enum_value_name((uint32_t)fields->user_type);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["UserType"] = fields->user_type;
  #endif

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_get_user_type_response(
  nlohmann::json &jsn,
  uint16_t &userid,
  
  DrlkUserType &user_type
  
) {

  uint32_t UserType_enum_val = get_enum_decimal_value<DrlkUserType>("UserType", jsn);
  if (UserType_enum_val == std::numeric_limits<DrlkUserType>::max()) {
    #ifdef DRLK_USER_TYPE_ENUM_NAME_AVAILABLE
    UserType_enum_val = drlk_user_type_get_enum_value_number(jsn.at("UserType").get<std::string>());
    #endif
  }
  if (jsn.at("UserID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  userid = jsn.at("UserID").get< uint16_t >();
      if (jsn.at("UserType").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  user_type = static_cast<DrlkUserType>(UserType_enum_val);
}


std::string get_json_payload_for_door_lock_setrfid_code_command(
  
  const uic_mqtt_dotdot_door_lock_command_setrfid_code_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["UserID"] = nlohmann::json(fields->userid);
  command_with_no_fields = false;
  // Single Value
  // Enum SetRFIDCode / UserStatus
  #ifdef SETRFID_CODE_USER_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["UserStatus"] =
    setrfid_code_user_status_get_enum_value_name(
      (uint32_t)fields->user_status);
  #elif defined(DRLK_SETTABLE_USER_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["UserStatus"] =
    drlk_settable_user_status_get_enum_value_name((uint32_t)fields->user_status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["UserStatus"] = fields->user_status;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Enum SetRFIDCode / UserType
  #ifdef SETRFID_CODE_USER_TYPE_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["UserType"] =
    setrfid_code_user_type_get_enum_value_name(
      (uint32_t)fields->user_type);
  #elif defined(DRLK_USER_TYPE_ENUM_NAME_AVAILABLE)
  json_payload["UserType"] =
    drlk_user_type_get_enum_value_name((uint32_t)fields->user_type);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["UserType"] = fields->user_type;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["RFIDCode"] = nlohmann::json(fields->rfid_code);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_setrfid_code(
  nlohmann::json &jsn,
  DrlkRFIDUserID &userid,
  
  DrlkSettableUserStatus &user_status,
  
  DrlkUserType &user_type,
  
  std::string &rfid_code
  
) {

  uint32_t UserStatus_enum_val = get_enum_decimal_value<DrlkSettableUserStatus>("UserStatus", jsn);
  if (UserStatus_enum_val == std::numeric_limits<DrlkSettableUserStatus>::max()) {
    #ifdef DRLK_SETTABLE_USER_STATUS_ENUM_NAME_AVAILABLE
    UserStatus_enum_val = drlk_settable_user_status_get_enum_value_number(jsn.at("UserStatus").get<std::string>());
    #endif
  }
  uint32_t UserType_enum_val = get_enum_decimal_value<DrlkUserType>("UserType", jsn);
  if (UserType_enum_val == std::numeric_limits<DrlkUserType>::max()) {
    #ifdef DRLK_USER_TYPE_ENUM_NAME_AVAILABLE
    UserType_enum_val = drlk_user_type_get_enum_value_number(jsn.at("UserType").get<std::string>());
    #endif
  }
  if (jsn.at("UserID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  userid = jsn.at("UserID").get< DrlkRFIDUserID >();
      if (jsn.at("UserStatus").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  user_status = static_cast<DrlkSettableUserStatus>(UserStatus_enum_val);
  if (jsn.at("UserType").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  user_type = static_cast<DrlkUserType>(UserType_enum_val);
  if (jsn.at("RFIDCode").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  rfid_code = jsn.at("RFIDCode").get<std::string>();
          }


std::string get_json_payload_for_door_lock_setrfid_code_response_command(
  
  const uic_mqtt_dotdot_door_lock_command_setrfid_code_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum SetRFIDCodeResponse / Status
  #ifdef SETRFID_CODE_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    setrfid_code_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(DRLK_SET_CODE_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    drlk_set_code_status_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_setrfid_code_response(
  nlohmann::json &jsn,
  DrlkSetCodeStatus &status
  
) {

  uint32_t Status_enum_val = get_enum_decimal_value<DrlkSetCodeStatus>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<DrlkSetCodeStatus>::max()) {
    #ifdef DRLK_SET_CODE_STATUS_ENUM_NAME_AVAILABLE
    Status_enum_val = drlk_set_code_status_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<DrlkSetCodeStatus>(Status_enum_val);
}


std::string get_json_payload_for_door_lock_getrfid_code_command(
  
  const uic_mqtt_dotdot_door_lock_command_getrfid_code_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["UserID"] = nlohmann::json(fields->userid);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_getrfid_code(
  nlohmann::json &jsn,
  DrlkRFIDUserID &userid
  
) {

  if (jsn.at("UserID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  userid = jsn.at("UserID").get< DrlkRFIDUserID >();
    }


std::string get_json_payload_for_door_lock_getrfid_code_response_command(
  
  const uic_mqtt_dotdot_door_lock_command_getrfid_code_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["UserID"] = nlohmann::json(fields->userid);
  command_with_no_fields = false;
  // Single Value
  // Enum GetRFIDCodeResponse / UserStatus
  #ifdef GETRFID_CODE_RESPONSE_USER_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["UserStatus"] =
    getrfid_code_response_user_status_get_enum_value_name(
      (uint32_t)fields->user_status);
  #elif defined(DRLK_USER_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["UserStatus"] =
    drlk_user_status_get_enum_value_name((uint32_t)fields->user_status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["UserStatus"] = fields->user_status;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Enum GetRFIDCodeResponse / UserType
  #ifdef GETRFID_CODE_RESPONSE_USER_TYPE_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["UserType"] =
    getrfid_code_response_user_type_get_enum_value_name(
      (uint32_t)fields->user_type);
  #elif defined(DRLK_USER_TYPE_ENUM_NAME_AVAILABLE)
  json_payload["UserType"] =
    drlk_user_type_get_enum_value_name((uint32_t)fields->user_type);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["UserType"] = fields->user_type;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["RFIDCode"] = nlohmann::json(fields->rfid_code);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_getrfid_code_response(
  nlohmann::json &jsn,
  uint16_t &userid,
  
  DrlkUserStatus &user_status,
  
  DrlkUserType &user_type,
  
  std::string &rfid_code
  
) {

  uint32_t UserStatus_enum_val = get_enum_decimal_value<DrlkUserStatus>("UserStatus", jsn);
  if (UserStatus_enum_val == std::numeric_limits<DrlkUserStatus>::max()) {
    #ifdef DRLK_USER_STATUS_ENUM_NAME_AVAILABLE
    UserStatus_enum_val = drlk_user_status_get_enum_value_number(jsn.at("UserStatus").get<std::string>());
    #endif
  }
  uint32_t UserType_enum_val = get_enum_decimal_value<DrlkUserType>("UserType", jsn);
  if (UserType_enum_val == std::numeric_limits<DrlkUserType>::max()) {
    #ifdef DRLK_USER_TYPE_ENUM_NAME_AVAILABLE
    UserType_enum_val = drlk_user_type_get_enum_value_number(jsn.at("UserType").get<std::string>());
    #endif
  }
  if (jsn.at("UserID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  userid = jsn.at("UserID").get< uint16_t >();
      if (jsn.at("UserStatus").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  user_status = static_cast<DrlkUserStatus>(UserStatus_enum_val);
  if (jsn.at("UserType").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  user_type = static_cast<DrlkUserType>(UserType_enum_val);
  if (jsn.at("RFIDCode").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  rfid_code = jsn.at("RFIDCode").get<std::string>();
          }


std::string get_json_payload_for_door_lock_clearrfid_code_command(
  
  const uic_mqtt_dotdot_door_lock_command_clearrfid_code_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["UserID"] = nlohmann::json(fields->userid);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_clearrfid_code(
  nlohmann::json &jsn,
  DrlkRFIDUserID &userid
  
) {

  if (jsn.at("UserID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  userid = jsn.at("UserID").get< DrlkRFIDUserID >();
    }


std::string get_json_payload_for_door_lock_clearrfid_code_response_command(
  
  const uic_mqtt_dotdot_door_lock_command_clearrfid_code_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum ClearRFIDCodeResponse / Status
  #ifdef CLEARRFID_CODE_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    clearrfid_code_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(DRLK_PASS_FAIL_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    drlk_pass_fail_status_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_clearrfid_code_response(
  nlohmann::json &jsn,
  DrlkPassFailStatus &status
  
) {

  uint32_t Status_enum_val = get_enum_decimal_value<DrlkPassFailStatus>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<DrlkPassFailStatus>::max()) {
    #ifdef DRLK_PASS_FAIL_STATUS_ENUM_NAME_AVAILABLE
    Status_enum_val = drlk_pass_fail_status_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<DrlkPassFailStatus>(Status_enum_val);
}


std::string get_json_payload_for_door_lock_clear_allrfid_codes_command(
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}




std::string get_json_payload_for_door_lock_clear_allrfid_codes_response_command(
  
  const uic_mqtt_dotdot_door_lock_command_clear_allrfid_codes_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum ClearAllRFIDCodesResponse / Status
  #ifdef CLEAR_ALLRFID_CODES_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    clear_allrfid_codes_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(DRLK_PASS_FAIL_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    drlk_pass_fail_status_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_clear_allrfid_codes_response(
  nlohmann::json &jsn,
  DrlkPassFailStatus &status
  
) {

  uint32_t Status_enum_val = get_enum_decimal_value<DrlkPassFailStatus>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<DrlkPassFailStatus>::max()) {
    #ifdef DRLK_PASS_FAIL_STATUS_ENUM_NAME_AVAILABLE
    Status_enum_val = drlk_pass_fail_status_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<DrlkPassFailStatus>(Status_enum_val);
}


std::string get_json_payload_for_door_lock_operating_event_notification_command(
  
  const uic_mqtt_dotdot_door_lock_command_operating_event_notification_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum OperatingEventNotification / OperationEventSource
  #ifdef OPERATING_EVENT_NOTIFICATION_OPERATION_EVENT_SOURCE_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["OperationEventSource"] =
    operating_event_notification_operation_event_source_get_enum_value_name(
      (uint32_t)fields->operation_event_source);
  #elif defined(DRLK_OPER_EVENT_SOURCE_ENUM_NAME_AVAILABLE)
  json_payload["OperationEventSource"] =
    drlk_oper_event_source_get_enum_value_name((uint32_t)fields->operation_event_source);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["OperationEventSource"] = fields->operation_event_source;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Enum OperatingEventNotification / OperationEventCode
  #ifdef OPERATING_EVENT_NOTIFICATION_OPERATION_EVENT_CODE_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["OperationEventCode"] =
    operating_event_notification_operation_event_code_get_enum_value_name(
      (uint32_t)fields->operation_event_code);
  #elif defined(OPERATING_EVENT_NOTIFICATION_OPERATION_EVENT_CODE_ENUM_NAME_AVAILABLE)
  json_payload["OperationEventCode"] =
    operating_event_notification_operation_event_code_get_enum_value_name((uint32_t)fields->operation_event_code);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["OperationEventCode"] = fields->operation_event_code;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["UserID"] = nlohmann::json(fields->userid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["PIN"] = nlohmann::json(fields->pin);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["LocalTime"] = nlohmann::json(fields->local_time);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Data"] = nlohmann::json(fields->data);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_operating_event_notification(
  nlohmann::json &jsn,
  DrlkOperEventSource &operation_event_source,
  
  OperatingEventNotificationOperationEventCode &operation_event_code,
  
  uint16_t &userid,
  
  std::string &pin,
  
  uint32_t &local_time,
  
  std::string &data
  
) {

  uint32_t OperationEventSource_enum_val = get_enum_decimal_value<DrlkOperEventSource>("OperationEventSource", jsn);
  if (OperationEventSource_enum_val == std::numeric_limits<DrlkOperEventSource>::max()) {
    #ifdef DRLK_OPER_EVENT_SOURCE_ENUM_NAME_AVAILABLE
    OperationEventSource_enum_val = drlk_oper_event_source_get_enum_value_number(jsn.at("OperationEventSource").get<std::string>());
    #endif
  }
  uint32_t OperationEventCode_enum_val = get_enum_decimal_value<OperatingEventNotificationOperationEventCode>("OperationEventCode", jsn);
  if (OperationEventCode_enum_val == std::numeric_limits<OperatingEventNotificationOperationEventCode>::max()) {
    #ifdef OPERATING_EVENT_NOTIFICATION_OPERATION_EVENT_CODE_ENUM_NAME_AVAILABLE
    OperationEventCode_enum_val = operating_event_notification_operation_event_code_get_enum_value_number(jsn.at("OperationEventCode").get<std::string>());
    #endif
  }
  if (jsn.at("OperationEventSource").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  operation_event_source = static_cast<DrlkOperEventSource>(OperationEventSource_enum_val);
  if (jsn.at("OperationEventCode").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  operation_event_code = static_cast<OperatingEventNotificationOperationEventCode>(OperationEventCode_enum_val);
  if (jsn.at("UserID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  userid = jsn.at("UserID").get< uint16_t >();
      if (jsn.at("PIN").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  pin = jsn.at("PIN").get<std::string>();
            if (jsn.at("LocalTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  local_time = jsn.at("LocalTime").get< uint32_t >();
      if (jsn.at("Data").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  data = jsn.at("Data").get<std::string>();
          }


std::string get_json_payload_for_door_lock_programming_event_notification_command(
  
  const uic_mqtt_dotdot_door_lock_command_programming_event_notification_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum ProgrammingEventNotification / ProgramEventSource
  #ifdef PROGRAMMING_EVENT_NOTIFICATION_PROGRAM_EVENT_SOURCE_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["ProgramEventSource"] =
    programming_event_notification_program_event_source_get_enum_value_name(
      (uint32_t)fields->program_event_source);
  #elif defined(PROGRAMMING_EVENT_NOTIFICATION_PROGRAM_EVENT_SOURCE_ENUM_NAME_AVAILABLE)
  json_payload["ProgramEventSource"] =
    programming_event_notification_program_event_source_get_enum_value_name((uint32_t)fields->program_event_source);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["ProgramEventSource"] = fields->program_event_source;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Enum ProgrammingEventNotification / ProgramEventCode
  #ifdef PROGRAMMING_EVENT_NOTIFICATION_PROGRAM_EVENT_CODE_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["ProgramEventCode"] =
    programming_event_notification_program_event_code_get_enum_value_name(
      (uint32_t)fields->program_event_code);
  #elif defined(PROGRAMMING_EVENT_NOTIFICATION_PROGRAM_EVENT_CODE_ENUM_NAME_AVAILABLE)
  json_payload["ProgramEventCode"] =
    programming_event_notification_program_event_code_get_enum_value_name((uint32_t)fields->program_event_code);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["ProgramEventCode"] = fields->program_event_code;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["UserID"] = nlohmann::json(fields->userid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["PIN"] = nlohmann::json(fields->pin);
  command_with_no_fields = false;
  // Single Value
  // Enum ProgrammingEventNotification / UserType
  #ifdef PROGRAMMING_EVENT_NOTIFICATION_USER_TYPE_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["UserType"] =
    programming_event_notification_user_type_get_enum_value_name(
      (uint32_t)fields->user_type);
  #elif defined(DRLK_USER_TYPE_ENUM_NAME_AVAILABLE)
  json_payload["UserType"] =
    drlk_user_type_get_enum_value_name((uint32_t)fields->user_type);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["UserType"] = fields->user_type;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Enum ProgrammingEventNotification / UserStatus
  #ifdef PROGRAMMING_EVENT_NOTIFICATION_USER_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["UserStatus"] =
    programming_event_notification_user_status_get_enum_value_name(
      (uint32_t)fields->user_status);
  #elif defined(DRLK_USER_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["UserStatus"] =
    drlk_user_status_get_enum_value_name((uint32_t)fields->user_status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["UserStatus"] = fields->user_status;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["LocalTime"] = nlohmann::json(fields->local_time);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Data"] = nlohmann::json(fields->data);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_door_lock_programming_event_notification(
  nlohmann::json &jsn,
  ProgrammingEventNotificationProgramEventSource &program_event_source,
  
  ProgrammingEventNotificationProgramEventCode &program_event_code,
  
  uint16_t &userid,
  
  std::string &pin,
  
  DrlkUserType &user_type,
  
  DrlkUserStatus &user_status,
  
  uint32_t &local_time,
  
  std::string &data
  
) {

  uint32_t ProgramEventSource_enum_val = get_enum_decimal_value<ProgrammingEventNotificationProgramEventSource>("ProgramEventSource", jsn);
  if (ProgramEventSource_enum_val == std::numeric_limits<ProgrammingEventNotificationProgramEventSource>::max()) {
    #ifdef PROGRAMMING_EVENT_NOTIFICATION_PROGRAM_EVENT_SOURCE_ENUM_NAME_AVAILABLE
    ProgramEventSource_enum_val = programming_event_notification_program_event_source_get_enum_value_number(jsn.at("ProgramEventSource").get<std::string>());
    #endif
  }
  uint32_t ProgramEventCode_enum_val = get_enum_decimal_value<ProgrammingEventNotificationProgramEventCode>("ProgramEventCode", jsn);
  if (ProgramEventCode_enum_val == std::numeric_limits<ProgrammingEventNotificationProgramEventCode>::max()) {
    #ifdef PROGRAMMING_EVENT_NOTIFICATION_PROGRAM_EVENT_CODE_ENUM_NAME_AVAILABLE
    ProgramEventCode_enum_val = programming_event_notification_program_event_code_get_enum_value_number(jsn.at("ProgramEventCode").get<std::string>());
    #endif
  }
  uint32_t UserType_enum_val = get_enum_decimal_value<DrlkUserType>("UserType", jsn);
  if (UserType_enum_val == std::numeric_limits<DrlkUserType>::max()) {
    #ifdef DRLK_USER_TYPE_ENUM_NAME_AVAILABLE
    UserType_enum_val = drlk_user_type_get_enum_value_number(jsn.at("UserType").get<std::string>());
    #endif
  }
  uint32_t UserStatus_enum_val = get_enum_decimal_value<DrlkUserStatus>("UserStatus", jsn);
  if (UserStatus_enum_val == std::numeric_limits<DrlkUserStatus>::max()) {
    #ifdef DRLK_USER_STATUS_ENUM_NAME_AVAILABLE
    UserStatus_enum_val = drlk_user_status_get_enum_value_number(jsn.at("UserStatus").get<std::string>());
    #endif
  }
  if (jsn.at("ProgramEventSource").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  program_event_source = static_cast<ProgrammingEventNotificationProgramEventSource>(ProgramEventSource_enum_val);
  if (jsn.at("ProgramEventCode").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  program_event_code = static_cast<ProgrammingEventNotificationProgramEventCode>(ProgramEventCode_enum_val);
  if (jsn.at("UserID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  userid = jsn.at("UserID").get< uint16_t >();
      if (jsn.at("PIN").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  pin = jsn.at("PIN").get<std::string>();
            if (jsn.at("UserType").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  user_type = static_cast<DrlkUserType>(UserType_enum_val);
  if (jsn.at("UserStatus").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  user_status = static_cast<DrlkUserStatus>(UserStatus_enum_val);
  if (jsn.at("LocalTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  local_time = jsn.at("LocalTime").get< uint32_t >();
      if (jsn.at("Data").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  data = jsn.at("Data").get<std::string>();
          }


std::string get_json_payload_for_door_lock_get_allpin_codes_command(
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}




/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_door_lock_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_door_lock_state_t &new_state,
  uic_mqtt_dotdot_door_lock_updated_state_t &new_updated_state
) {


  if (jsn.find("DoorOpenEvents") != jsn.end()) {

    new_state.door_open_events = jsn.at("DoorOpenEvents").get<uint32_t>();
        
    new_updated_state.door_open_events = true;
  }

  if (jsn.find("DoorClosedEvents") != jsn.end()) {

    new_state.door_closed_events = jsn.at("DoorClosedEvents").get<uint32_t>();
        
    new_updated_state.door_closed_events = true;
  }

  if (jsn.find("OpenPeriod") != jsn.end()) {

    new_state.open_period = jsn.at("OpenPeriod").get<uint16_t>();
        
    new_updated_state.open_period = true;
  }

  if (jsn.find("EnableLogging") != jsn.end()) {

    new_state.enable_logging = get_bool_from_json(jsn, "EnableLogging");
  
    new_updated_state.enable_logging = true;
  }

  if (jsn.find("Language") != jsn.end()) {

    new_state.language = jsn.at("Language").get_ptr<const std::string*>()->c_str();
  
    new_updated_state.language = true;
  }

  if (jsn.find("LEDSettings") != jsn.end()) {

    new_state.led_settings = jsn.at("LEDSettings").get<uint8_t>();
        
    new_updated_state.led_settings = true;
  }

  if (jsn.find("AutoRelockTime") != jsn.end()) {

    new_state.auto_relock_time = jsn.at("AutoRelockTime").get<uint32_t>();
        
    new_updated_state.auto_relock_time = true;
  }

  if (jsn.find("SoundVolume") != jsn.end()) {

    new_state.sound_volume = jsn.at("SoundVolume").get<uint8_t>();
        
    new_updated_state.sound_volume = true;
  }

  if (jsn.find("OperatingMode") != jsn.end()) {

    uint32_t tmp = get_enum_decimal_value<DrlkOperMode>("OperatingMode", jsn);
    if (tmp == std::numeric_limits<DrlkOperMode>::max()) {
      #ifdef DOOR_LOCK_OPERATING_MODE_ENUM_NAME_AVAILABLE
      tmp = door_lock_operating_mode_get_enum_value_number(jsn.at("OperatingMode").get<std::string>());
      #elif defined(OPERATING_MODE_ENUM_NAME_AVAILABLE)
      tmp = operating_mode_get_enum_value_number(jsn.at("OperatingMode").get<std::string>());
      #endif
    }
    new_state.operating_mode = tmp;
  
    new_updated_state.operating_mode = true;
  }

  if (jsn.find("EnableLocalProgramming") != jsn.end()) {

    new_state.enable_local_programming = get_bool_from_json(jsn, "EnableLocalProgramming");
  
    new_updated_state.enable_local_programming = true;
  }

  if (jsn.find("EnableOneTouchLocking") != jsn.end()) {

    new_state.enable_one_touch_locking = get_bool_from_json(jsn, "EnableOneTouchLocking");
  
    new_updated_state.enable_one_touch_locking = true;
  }

  if (jsn.find("EnableInsideStatusLED") != jsn.end()) {

    new_state.enable_inside_statusled = get_bool_from_json(jsn, "EnableInsideStatusLED");
  
    new_updated_state.enable_inside_statusled = true;
  }

  if (jsn.find("EnablePrivacyModeButton") != jsn.end()) {

    new_state.enable_privacy_mode_button = get_bool_from_json(jsn, "EnablePrivacyModeButton");
  
    new_updated_state.enable_privacy_mode_button = true;
  }

  if (jsn.find("WrongCodeEntryLimit") != jsn.end()) {

    new_state.wrong_code_entry_limit = jsn.at("WrongCodeEntryLimit").get<uint8_t>();
        
    new_updated_state.wrong_code_entry_limit = true;
  }

  if (jsn.find("UserCodeTemporaryDisableTime") != jsn.end()) {

    new_state.user_code_temporary_disable_time = jsn.at("UserCodeTemporaryDisableTime").get<uint8_t>();
        
    new_updated_state.user_code_temporary_disable_time = true;
  }

  if (jsn.find("SendPINOverTheAir") != jsn.end()) {

    new_state.sendpin_over_the_air = get_bool_from_json(jsn, "SendPINOverTheAir");
  
    new_updated_state.sendpin_over_the_air = true;
  }

  if (jsn.find("RequirePINforRFOperation") != jsn.end()) {

    new_state.requirepi_nforrf_operation = get_bool_from_json(jsn, "RequirePINforRFOperation");
  
    new_updated_state.requirepi_nforrf_operation = true;
  }

  if (jsn.find("AlarmMask") != jsn.end()) {

    new_state.alarm_mask = uic_dotdot_mqtt::get_bitmap_decimal_value("AlarmMask", jsn, DoorLockAlarmMask);
  
    new_updated_state.alarm_mask = true;
  }

  if (jsn.find("KeypadOperationEventMask") != jsn.end()) {

    new_state.keypad_operation_event_mask = uic_dotdot_mqtt::get_bitmap_decimal_value("KeypadOperationEventMask", jsn, DoorLockKeypadOperationEventMask);
  
    new_updated_state.keypad_operation_event_mask = true;
  }

  if (jsn.find("RFOperationEventMask") != jsn.end()) {

    new_state.rf_operation_event_mask = uic_dotdot_mqtt::get_bitmap_decimal_value("RFOperationEventMask", jsn, DoorLockRFOperationEventMask);
  
    new_updated_state.rf_operation_event_mask = true;
  }

  if (jsn.find("ManualOperationEventMask") != jsn.end()) {

    new_state.manual_operation_event_mask = uic_dotdot_mqtt::get_bitmap_decimal_value("ManualOperationEventMask", jsn, DoorLockManualOperationEventMask);
  
    new_updated_state.manual_operation_event_mask = true;
  }

  if (jsn.find("RFIDOperationEventMask") != jsn.end()) {

    new_state.rfid_operation_event_mask = uic_dotdot_mqtt::get_bitmap_decimal_value("RFIDOperationEventMask", jsn, DoorLockRFIDOperationEventMask);
  
    new_updated_state.rfid_operation_event_mask = true;
  }

  if (jsn.find("KeypadProgrammingEventMask") != jsn.end()) {

    new_state.keypad_programming_event_mask = uic_dotdot_mqtt::get_bitmap_decimal_value("KeypadProgrammingEventMask", jsn, DoorLockKeypadProgrammingEventMask);
  
    new_updated_state.keypad_programming_event_mask = true;
  }

  if (jsn.find("RFProgrammingEventMask") != jsn.end()) {

    new_state.rf_programming_event_mask = uic_dotdot_mqtt::get_bitmap_decimal_value("RFProgrammingEventMask", jsn, DoorLockRFProgrammingEventMask);
  
    new_updated_state.rf_programming_event_mask = true;
  }

  if (jsn.find("RFIDProgrammingEventMask") != jsn.end()) {

    new_state.rfid_programming_event_mask = uic_dotdot_mqtt::get_bitmap_decimal_value("RFIDProgrammingEventMask", jsn, DoorLockRFIDProgrammingEventMask);
  
    new_updated_state.rfid_programming_event_mask = true;
  }


}


std::string get_json_payload_for_window_covering_up_or_open_command(
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}




std::string get_json_payload_for_window_covering_down_or_close_command(
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}




std::string get_json_payload_for_window_covering_stop_command(
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}




std::string get_json_payload_for_window_covering_go_to_lift_value_command(
  
  const uic_mqtt_dotdot_window_covering_command_go_to_lift_value_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["LiftValue"] = nlohmann::json(fields->lift_value);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_window_covering_go_to_lift_value(
  nlohmann::json &jsn,
  uint16_t &lift_value
  
) {

  if (jsn.at("LiftValue").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  lift_value = jsn.at("LiftValue").get< uint16_t >();
    }


std::string get_json_payload_for_window_covering_go_to_lift_percentage_command(
  
  const uic_mqtt_dotdot_window_covering_command_go_to_lift_percentage_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["PercentageLiftValue"] = nlohmann::json(fields->percentage_lift_value);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_window_covering_go_to_lift_percentage(
  nlohmann::json &jsn,
  uint8_t &percentage_lift_value
  
) {

  if (jsn.at("PercentageLiftValue").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  percentage_lift_value = jsn.at("PercentageLiftValue").get< uint8_t >();
    }


std::string get_json_payload_for_window_covering_go_to_tilt_value_command(
  
  const uic_mqtt_dotdot_window_covering_command_go_to_tilt_value_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["TiltValue"] = nlohmann::json(fields->tilt_value);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_window_covering_go_to_tilt_value(
  nlohmann::json &jsn,
  uint16_t &tilt_value
  
) {

  if (jsn.at("TiltValue").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  tilt_value = jsn.at("TiltValue").get< uint16_t >();
    }


std::string get_json_payload_for_window_covering_go_to_tilt_percentage_command(
  
  const uic_mqtt_dotdot_window_covering_command_go_to_tilt_percentage_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["PercentageTiltValue"] = nlohmann::json(fields->percentage_tilt_value);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_window_covering_go_to_tilt_percentage(
  nlohmann::json &jsn,
  uint8_t &percentage_tilt_value
  
) {

  if (jsn.at("PercentageTiltValue").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  percentage_tilt_value = jsn.at("PercentageTiltValue").get< uint8_t >();
    }


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_window_covering_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_window_covering_state_t &new_state,
  uic_mqtt_dotdot_window_covering_updated_state_t &new_updated_state
) {


  if (jsn.find("VelocityLift") != jsn.end()) {

    new_state.velocity_lift = jsn.at("VelocityLift").get<uint16_t>();
        
    new_updated_state.velocity_lift = true;
  }

  if (jsn.find("AccelerationTimeLift") != jsn.end()) {

    new_state.acceleration_time_lift = jsn.at("AccelerationTimeLift").get<uint16_t>();
        
    new_updated_state.acceleration_time_lift = true;
  }

  if (jsn.find("DecelerationTimeLift") != jsn.end()) {

    new_state.deceleration_time_lift = jsn.at("DecelerationTimeLift").get<uint16_t>();
        
    new_updated_state.deceleration_time_lift = true;
  }


}


std::string get_json_payload_for_barrier_control_go_to_percent_command(
  
  const uic_mqtt_dotdot_barrier_control_command_go_to_percent_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["PercentOpen"] = nlohmann::json(fields->percent_open);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_barrier_control_go_to_percent(
  nlohmann::json &jsn,
  uint8_t &percent_open
  
) {

  if (jsn.at("PercentOpen").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  percent_open = jsn.at("PercentOpen").get< uint8_t >();
    }


std::string get_json_payload_for_barrier_control_stop_command(
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}




/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_barrier_control_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_barrier_control_state_t &new_state,
  uic_mqtt_dotdot_barrier_control_updated_state_t &new_updated_state
) {


  if (jsn.find("OpenEvents") != jsn.end()) {

    new_state.open_events = jsn.at("OpenEvents").get<uint16_t>();
        
    new_updated_state.open_events = true;
  }

  if (jsn.find("CloseEvents") != jsn.end()) {

    new_state.close_events = jsn.at("CloseEvents").get<uint16_t>();
        
    new_updated_state.close_events = true;
  }

  if (jsn.find("CommandOpenEvents") != jsn.end()) {

    new_state.command_open_events = jsn.at("CommandOpenEvents").get<uint16_t>();
        
    new_updated_state.command_open_events = true;
  }

  if (jsn.find("CommandCloseEvents") != jsn.end()) {

    new_state.command_close_events = jsn.at("CommandCloseEvents").get<uint16_t>();
        
    new_updated_state.command_close_events = true;
  }

  if (jsn.find("OpenPeriod") != jsn.end()) {

    new_state.open_period = jsn.at("OpenPeriod").get<uint16_t>();
        
    new_updated_state.open_period = true;
  }

  if (jsn.find("ClosePeriod") != jsn.end()) {

    new_state.close_period = jsn.at("ClosePeriod").get<uint16_t>();
        
    new_updated_state.close_period = true;
  }


}


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_pump_configuration_and_control_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_pump_configuration_and_control_state_t &new_state,
  uic_mqtt_dotdot_pump_configuration_and_control_updated_state_t &new_updated_state
) {


  if (jsn.find("LifetimeRunningHours") != jsn.end()) {

    new_state.lifetime_running_hours = jsn.at("LifetimeRunningHours").get<uint32_t>();
        
    new_updated_state.lifetime_running_hours = true;
  }

  if (jsn.find("Power") != jsn.end()) {

    new_state.power = jsn.at("Power").get<uint32_t>();
        
    new_updated_state.power = true;
  }

  if (jsn.find("OperationMode") != jsn.end()) {

    uint32_t tmp = get_enum_decimal_value<PumpOperationMode>("OperationMode", jsn);
    if (tmp == std::numeric_limits<PumpOperationMode>::max()) {
      #ifdef PUMP_CONFIGURATION_AND_CONTROL_OPERATION_MODE_ENUM_NAME_AVAILABLE
      tmp = pump_configuration_and_control_operation_mode_get_enum_value_number(jsn.at("OperationMode").get<std::string>());
      #elif defined(OPERATION_MODE_ENUM_NAME_AVAILABLE)
      tmp = operation_mode_get_enum_value_number(jsn.at("OperationMode").get<std::string>());
      #endif
    }
    new_state.operation_mode = tmp;
  
    new_updated_state.operation_mode = true;
  }

  if (jsn.find("ControlMode") != jsn.end()) {

    uint32_t tmp = get_enum_decimal_value<PumpControlMode>("ControlMode", jsn);
    if (tmp == std::numeric_limits<PumpControlMode>::max()) {
      #ifdef PUMP_CONFIGURATION_AND_CONTROL_CONTROL_MODE_ENUM_NAME_AVAILABLE
      tmp = pump_configuration_and_control_control_mode_get_enum_value_number(jsn.at("ControlMode").get<std::string>());
      #elif defined(CONTROL_MODE_ENUM_NAME_AVAILABLE)
      tmp = control_mode_get_enum_value_number(jsn.at("ControlMode").get<std::string>());
      #endif
    }
    new_state.control_mode = tmp;
  
    new_updated_state.control_mode = true;
  }


}


std::string get_json_payload_for_thermostat_setpoint_raise_or_lower_command(
  
  const uic_mqtt_dotdot_thermostat_command_setpoint_raise_or_lower_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum SetpointRaiseOrLower / Mode
  #ifdef SETPOINT_RAISE_OR_LOWER_MODE_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Mode"] =
    setpoint_raise_or_lower_mode_get_enum_value_name(
      (uint32_t)fields->mode);
  #elif defined(SETPOINT_RAISE_OR_LOWER_MODE_ENUM_NAME_AVAILABLE)
  json_payload["Mode"] =
    setpoint_raise_or_lower_mode_get_enum_value_name((uint32_t)fields->mode);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Mode"] = fields->mode;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Amount"] = nlohmann::json(fields->amount);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_thermostat_setpoint_raise_or_lower(
  nlohmann::json &jsn,
  SetpointRaiseOrLowerMode &mode,
  
  int8_t &amount
  
) {

  uint32_t Mode_enum_val = get_enum_decimal_value<SetpointRaiseOrLowerMode>("Mode", jsn);
  if (Mode_enum_val == std::numeric_limits<SetpointRaiseOrLowerMode>::max()) {
    #ifdef SETPOINT_RAISE_OR_LOWER_MODE_ENUM_NAME_AVAILABLE
    Mode_enum_val = setpoint_raise_or_lower_mode_get_enum_value_number(jsn.at("Mode").get<std::string>());
    #endif
  }
  if (jsn.at("Mode").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  mode = static_cast<SetpointRaiseOrLowerMode>(Mode_enum_val);
  if (jsn.at("Amount").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  amount = jsn.at("Amount").get< int8_t >();
    }


std::string get_json_payload_for_thermostat_get_weekly_schedule_response_command(
  
  const uic_mqtt_dotdot_thermostat_command_get_weekly_schedule_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum GetWeeklyScheduleResponse / NumberOfTransitions
  #ifdef GET_WEEKLY_SCHEDULE_RESPONSE_NUMBER_OF_TRANSITIONS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["NumberOfTransitions"] =
    get_weekly_schedule_response_number_of_transitions_get_enum_value_name(
      (uint32_t)fields->number_of_transitions);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  json_payload["NumberOfTransitions"] =
    enum8_get_enum_value_name((uint32_t)fields->number_of_transitions);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["NumberOfTransitions"] = fields->number_of_transitions;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["DayOfWeek"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->day_of_week,
                                TstatScheduleDOW);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["Mode"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->mode,
                                TstatScheduleMode);
  command_with_no_fields = false;
  // We assume arrays are Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Transitions"] = std::vector< TransitionType >(
    fields->transitions,
    fields->transitions + fields->transitions_count);


  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_thermostat_get_weekly_schedule_response(
  nlohmann::json &jsn,
  uint8_t &number_of_transitions,
  
  uint8_t &day_of_week,
  
  uint8_t &mode,
  
  std::vector<TransitionType> &transitions

) {

  uint32_t NumberOfTransitions_enum_val = get_enum_decimal_value<uint8_t>("NumberOfTransitions", jsn);
  if (NumberOfTransitions_enum_val == std::numeric_limits<uint8_t>::max()) {
    #ifdef ENUM8_ENUM_NAME_AVAILABLE
    NumberOfTransitions_enum_val = enum8_get_enum_value_number(jsn.at("NumberOfTransitions").get<std::string>());
    #endif
  }
  if (jsn.at("NumberOfTransitions").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  number_of_transitions = static_cast<uint8_t>(NumberOfTransitions_enum_val);
  if (jsn.at("DayOfWeek").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  day_of_week = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("DayOfWeek", jsn, TstatScheduleDOW);
  if (jsn.at("Mode").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  mode = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("Mode", jsn, TstatScheduleMode);
  if (jsn.at("Transitions").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  // TransitionType is a struct
  for (auto &Transitions_el : jsn.at("Transitions")) {

    TransitionType item = {};
     if (Transitions_el.at("TransitionTime").is_null()) {
      continue;
     }
    item.TransitionTime = Transitions_el.at("TransitionTime");
     if (Transitions_el.at("HeatSetPoint").is_null()) {
      continue;
     }
    item.HeatSetPoint = Transitions_el.at("HeatSetPoint");
     if (Transitions_el.at("CoolSetPoint").is_null()) {
      continue;
     }
    item.CoolSetPoint = Transitions_el.at("CoolSetPoint");
    transitions.push_back(item);
  }
      }


std::string get_json_payload_for_thermostat_set_weekly_schedule_command(
  
  const uic_mqtt_dotdot_thermostat_command_set_weekly_schedule_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum SetWeeklySchedule / NumberOfTransitions
  #ifdef SET_WEEKLY_SCHEDULE_NUMBER_OF_TRANSITIONS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["NumberOfTransitions"] =
    set_weekly_schedule_number_of_transitions_get_enum_value_name(
      (uint32_t)fields->number_of_transitions);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  json_payload["NumberOfTransitions"] =
    enum8_get_enum_value_name((uint32_t)fields->number_of_transitions);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["NumberOfTransitions"] = fields->number_of_transitions;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["DayOfWeek"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->day_of_week,
                                TstatScheduleDOW);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["Mode"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->mode,
                                TstatScheduleMode);
  command_with_no_fields = false;
  // We assume arrays are Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Transitions"] = std::vector< TransitionType >(
    fields->transitions,
    fields->transitions + fields->transitions_count);


  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_thermostat_set_weekly_schedule(
  nlohmann::json &jsn,
  uint8_t &number_of_transitions,
  
  uint8_t &day_of_week,
  
  uint8_t &mode,
  
  std::vector<TransitionType> &transitions

) {

  uint32_t NumberOfTransitions_enum_val = get_enum_decimal_value<uint8_t>("NumberOfTransitions", jsn);
  if (NumberOfTransitions_enum_val == std::numeric_limits<uint8_t>::max()) {
    #ifdef ENUM8_ENUM_NAME_AVAILABLE
    NumberOfTransitions_enum_val = enum8_get_enum_value_number(jsn.at("NumberOfTransitions").get<std::string>());
    #endif
  }
  if (jsn.at("NumberOfTransitions").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  number_of_transitions = static_cast<uint8_t>(NumberOfTransitions_enum_val);
  if (jsn.at("DayOfWeek").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  day_of_week = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("DayOfWeek", jsn, TstatScheduleDOW);
  if (jsn.at("Mode").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  mode = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("Mode", jsn, TstatScheduleMode);
  if (jsn.at("Transitions").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  // TransitionType is a struct
  for (auto &Transitions_el : jsn.at("Transitions")) {

    TransitionType item = {};
     if (Transitions_el.at("TransitionTime").is_null()) {
      continue;
     }
    item.TransitionTime = Transitions_el.at("TransitionTime");
     if (Transitions_el.at("HeatSetPoint").is_null()) {
      continue;
     }
    item.HeatSetPoint = Transitions_el.at("HeatSetPoint");
     if (Transitions_el.at("CoolSetPoint").is_null()) {
      continue;
     }
    item.CoolSetPoint = Transitions_el.at("CoolSetPoint");
    transitions.push_back(item);
  }
      }


std::string get_json_payload_for_thermostat_get_relay_status_log_response_command(
  
  const uic_mqtt_dotdot_thermostat_command_get_relay_status_log_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["TimeOfDay"] = nlohmann::json(fields->time_of_day);
  command_with_no_fields = false;
  // Single Value
  // Unknown bitmask: we write the value directly.
  json_payload["RelayStatus"] = fields->relay_status;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["LocalTemperature"] = nlohmann::json(fields->local_temperature);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["HumidityPercentage"] = nlohmann::json(fields->humidity_percentage);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["SetPoint"] = nlohmann::json(fields->set_point);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["UnreadEntries"] = nlohmann::json(fields->unread_entries);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_thermostat_get_relay_status_log_response(
  nlohmann::json &jsn,
  uint16_t &time_of_day,
  
  uint8_t &relay_status,
  
  int16_t &local_temperature,
  
  uint8_t &humidity_percentage,
  
  int16_t &set_point,
  
  uint16_t &unread_entries
  
) {

  if (jsn.at("TimeOfDay").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  time_of_day = jsn.at("TimeOfDay").get< uint16_t >();
      if (jsn.at("RelayStatus").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  relay_status = jsn.at("RelayStatus").get<uint8_t>();
  if (jsn.at("LocalTemperature").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  local_temperature = jsn.at("LocalTemperature").get< int16_t >();
      if (jsn.at("HumidityPercentage").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  humidity_percentage = jsn.at("HumidityPercentage").get< uint8_t >();
      if (jsn.at("SetPoint").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  set_point = jsn.at("SetPoint").get< int16_t >();
      if (jsn.at("UnreadEntries").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  unread_entries = jsn.at("UnreadEntries").get< uint16_t >();
    }


std::string get_json_payload_for_thermostat_get_weekly_schedule_command(
  
  const uic_mqtt_dotdot_thermostat_command_get_weekly_schedule_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["DaysToReturn"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->days_to_return,
                                TstatScheduleDOW);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["ModeToReturn"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->mode_to_return,
                                TstatScheduleMode);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_thermostat_get_weekly_schedule(
  nlohmann::json &jsn,
  uint8_t &days_to_return,
  
  uint8_t &mode_to_return
  
) {

  if (jsn.at("DaysToReturn").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  days_to_return = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("DaysToReturn", jsn, TstatScheduleDOW);
  if (jsn.at("ModeToReturn").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  mode_to_return = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("ModeToReturn", jsn, TstatScheduleMode);
}


std::string get_json_payload_for_thermostat_clear_weekly_schedule_command(
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}




std::string get_json_payload_for_thermostat_get_relay_status_log_command(
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}




/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_thermostat_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_thermostat_state_t &new_state,
  uic_mqtt_dotdot_thermostat_updated_state_t &new_updated_state
) {


  if (jsn.find("HVACSystemTypeConfiguration") != jsn.end()) {

    new_state.hvac_system_type_configuration = uic_dotdot_mqtt::get_bitmap_decimal_value("HVACSystemTypeConfiguration", jsn, ThermostatHVACSystemTypeConfiguration);
  
    new_updated_state.hvac_system_type_configuration = true;
  }

  if (jsn.find("LocalTemperatureCalibration") != jsn.end()) {

    new_state.local_temperature_calibration = jsn.at("LocalTemperatureCalibration").get<int8_t>();
        
    new_updated_state.local_temperature_calibration = true;
  }

  if (jsn.find("OccupiedCoolingSetpoint") != jsn.end()) {

    new_state.occupied_cooling_setpoint = jsn.at("OccupiedCoolingSetpoint").get<int16_t>();
        
    new_updated_state.occupied_cooling_setpoint = true;
  }

  if (jsn.find("OccupiedHeatingSetpoint") != jsn.end()) {

    new_state.occupied_heating_setpoint = jsn.at("OccupiedHeatingSetpoint").get<int16_t>();
        
    new_updated_state.occupied_heating_setpoint = true;
  }

  if (jsn.find("UnoccupiedCoolingSetpoint") != jsn.end()) {

    new_state.unoccupied_cooling_setpoint = jsn.at("UnoccupiedCoolingSetpoint").get<int16_t>();
        
    new_updated_state.unoccupied_cooling_setpoint = true;
  }

  if (jsn.find("UnoccupiedHeatingSetpoint") != jsn.end()) {

    new_state.unoccupied_heating_setpoint = jsn.at("UnoccupiedHeatingSetpoint").get<int16_t>();
        
    new_updated_state.unoccupied_heating_setpoint = true;
  }

  if (jsn.find("MinHeatSetpointLimit") != jsn.end()) {

    new_state.min_heat_setpoint_limit = jsn.at("MinHeatSetpointLimit").get<int16_t>();
        
    new_updated_state.min_heat_setpoint_limit = true;
  }

  if (jsn.find("MaxHeatSetpointLimit") != jsn.end()) {

    new_state.max_heat_setpoint_limit = jsn.at("MaxHeatSetpointLimit").get<int16_t>();
        
    new_updated_state.max_heat_setpoint_limit = true;
  }

  if (jsn.find("MinCoolSetpointLimit") != jsn.end()) {

    new_state.min_cool_setpoint_limit = jsn.at("MinCoolSetpointLimit").get<int16_t>();
        
    new_updated_state.min_cool_setpoint_limit = true;
  }

  if (jsn.find("MaxCoolSetpointLimit") != jsn.end()) {

    new_state.max_cool_setpoint_limit = jsn.at("MaxCoolSetpointLimit").get<int16_t>();
        
    new_updated_state.max_cool_setpoint_limit = true;
  }

  if (jsn.find("MinSetpointDeadBand") != jsn.end()) {

    new_state.min_setpoint_dead_band = jsn.at("MinSetpointDeadBand").get<int8_t>();
        
    new_updated_state.min_setpoint_dead_band = true;
  }

  if (jsn.find("RemoteSensing") != jsn.end()) {

    new_state.remote_sensing = uic_dotdot_mqtt::get_bitmap_decimal_value("RemoteSensing", jsn, ThermostatRemoteSensing);
  
    new_updated_state.remote_sensing = true;
  }

  if (jsn.find("ControlSequenceOfOperation") != jsn.end()) {

    uint32_t tmp = get_enum_decimal_value<ThermostatControlSequenceOfOperation>("ControlSequenceOfOperation", jsn);
    if (tmp == std::numeric_limits<ThermostatControlSequenceOfOperation>::max()) {
      #ifdef THERMOSTAT_CONTROL_SEQUENCE_OF_OPERATION_ENUM_NAME_AVAILABLE
      tmp = thermostat_control_sequence_of_operation_get_enum_value_number(jsn.at("ControlSequenceOfOperation").get<std::string>());
      #elif defined(CONTROL_SEQUENCE_OF_OPERATION_ENUM_NAME_AVAILABLE)
      tmp = control_sequence_of_operation_get_enum_value_number(jsn.at("ControlSequenceOfOperation").get<std::string>());
      #endif
    }
    new_state.control_sequence_of_operation = tmp;
  
    new_updated_state.control_sequence_of_operation = true;
  }

  if (jsn.find("SystemMode") != jsn.end()) {

    uint32_t tmp = get_enum_decimal_value<ThermostatSystemMode>("SystemMode", jsn);
    if (tmp == std::numeric_limits<ThermostatSystemMode>::max()) {
      #ifdef THERMOSTAT_SYSTEM_MODE_ENUM_NAME_AVAILABLE
      tmp = thermostat_system_mode_get_enum_value_number(jsn.at("SystemMode").get<std::string>());
      #elif defined(SYSTEM_MODE_ENUM_NAME_AVAILABLE)
      tmp = system_mode_get_enum_value_number(jsn.at("SystemMode").get<std::string>());
      #endif
    }
    new_state.system_mode = tmp;
  
    new_updated_state.system_mode = true;
  }

  if (jsn.find("TemperatureSetpointHold") != jsn.end()) {

    uint32_t tmp = get_enum_decimal_value<ThermostatTemperatureSetpointHold>("TemperatureSetpointHold", jsn);
    if (tmp == std::numeric_limits<ThermostatTemperatureSetpointHold>::max()) {
      #ifdef THERMOSTAT_TEMPERATURE_SETPOINT_HOLD_ENUM_NAME_AVAILABLE
      tmp = thermostat_temperature_setpoint_hold_get_enum_value_number(jsn.at("TemperatureSetpointHold").get<std::string>());
      #elif defined(TEMPERATURE_SETPOINT_HOLD_ENUM_NAME_AVAILABLE)
      tmp = temperature_setpoint_hold_get_enum_value_number(jsn.at("TemperatureSetpointHold").get<std::string>());
      #endif
    }
    new_state.temperature_setpoint_hold = tmp;
  
    new_updated_state.temperature_setpoint_hold = true;
  }

  if (jsn.find("TemperatureSetpointHoldDuration") != jsn.end()) {

    new_state.temperature_setpoint_hold_duration = jsn.at("TemperatureSetpointHoldDuration").get<uint16_t>();
        
    new_updated_state.temperature_setpoint_hold_duration = true;
  }

  if (jsn.find("ThermostatProgrammingOperationMode") != jsn.end()) {

    new_state.thermostat_programming_operation_mode = uic_dotdot_mqtt::get_bitmap_decimal_value("ThermostatProgrammingOperationMode", jsn, ThermostatThermostatProgrammingOperationMode);
  
    new_updated_state.thermostat_programming_operation_mode = true;
  }

  if (jsn.find("OccupiedSetback") != jsn.end()) {

    new_state.occupied_setback = jsn.at("OccupiedSetback").get<uint8_t>();
        
    new_updated_state.occupied_setback = true;
  }

  if (jsn.find("UnoccupiedSetback") != jsn.end()) {

    new_state.unoccupied_setback = jsn.at("UnoccupiedSetback").get<uint8_t>();
        
    new_updated_state.unoccupied_setback = true;
  }

  if (jsn.find("EmergencyHeatDelta") != jsn.end()) {

    new_state.emergency_heat_delta = jsn.at("EmergencyHeatDelta").get<uint8_t>();
        
    new_updated_state.emergency_heat_delta = true;
  }

  if (jsn.find("ACType") != jsn.end()) {

    uint32_t tmp = get_enum_decimal_value<ThermostatACType>("ACType", jsn);
    if (tmp == std::numeric_limits<ThermostatACType>::max()) {
      #ifdef THERMOSTAT_AC_TYPE_ENUM_NAME_AVAILABLE
      tmp = thermostat_ac_type_get_enum_value_number(jsn.at("ACType").get<std::string>());
      #elif defined(AC_TYPE_ENUM_NAME_AVAILABLE)
      tmp = ac_type_get_enum_value_number(jsn.at("ACType").get<std::string>());
      #endif
    }
    new_state.ac_type = tmp;
  
    new_updated_state.ac_type = true;
  }

  if (jsn.find("ACCapacity") != jsn.end()) {

    new_state.ac_capacity = jsn.at("ACCapacity").get<uint16_t>();
        
    new_updated_state.ac_capacity = true;
  }

  if (jsn.find("ACRefrigerantType") != jsn.end()) {

    uint32_t tmp = get_enum_decimal_value<ThermostatACRefrigerantType>("ACRefrigerantType", jsn);
    if (tmp == std::numeric_limits<ThermostatACRefrigerantType>::max()) {
      #ifdef THERMOSTAT_AC_REFRIGERANT_TYPE_ENUM_NAME_AVAILABLE
      tmp = thermostat_ac_refrigerant_type_get_enum_value_number(jsn.at("ACRefrigerantType").get<std::string>());
      #elif defined(AC_REFRIGERANT_TYPE_ENUM_NAME_AVAILABLE)
      tmp = ac_refrigerant_type_get_enum_value_number(jsn.at("ACRefrigerantType").get<std::string>());
      #endif
    }
    new_state.ac_refrigerant_type = tmp;
  
    new_updated_state.ac_refrigerant_type = true;
  }

  if (jsn.find("ACCompressorType") != jsn.end()) {

    uint32_t tmp = get_enum_decimal_value<ThermostatACCompressorType>("ACCompressorType", jsn);
    if (tmp == std::numeric_limits<ThermostatACCompressorType>::max()) {
      #ifdef THERMOSTAT_AC_COMPRESSOR_TYPE_ENUM_NAME_AVAILABLE
      tmp = thermostat_ac_compressor_type_get_enum_value_number(jsn.at("ACCompressorType").get<std::string>());
      #elif defined(AC_COMPRESSOR_TYPE_ENUM_NAME_AVAILABLE)
      tmp = ac_compressor_type_get_enum_value_number(jsn.at("ACCompressorType").get<std::string>());
      #endif
    }
    new_state.ac_compressor_type = tmp;
  
    new_updated_state.ac_compressor_type = true;
  }

  if (jsn.find("ACErrorCode") != jsn.end()) {

    new_state.ac_error_code = uic_dotdot_mqtt::get_bitmap_decimal_value("ACErrorCode", jsn, ThermostatACErrorCode);
  
    new_updated_state.ac_error_code = true;
  }

  if (jsn.find("ACLouverPosition") != jsn.end()) {

    uint32_t tmp = get_enum_decimal_value<ThermostatACLouverPosition>("ACLouverPosition", jsn);
    if (tmp == std::numeric_limits<ThermostatACLouverPosition>::max()) {
      #ifdef THERMOSTAT_AC_LOUVER_POSITION_ENUM_NAME_AVAILABLE
      tmp = thermostat_ac_louver_position_get_enum_value_number(jsn.at("ACLouverPosition").get<std::string>());
      #elif defined(AC_LOUVER_POSITION_ENUM_NAME_AVAILABLE)
      tmp = ac_louver_position_get_enum_value_number(jsn.at("ACLouverPosition").get<std::string>());
      #endif
    }
    new_state.ac_louver_position = tmp;
  
    new_updated_state.ac_louver_position = true;
  }

  if (jsn.find("ACCapacityFormat") != jsn.end()) {

    uint32_t tmp = get_enum_decimal_value<ThermostatACCapacityFormat>("ACCapacityFormat", jsn);
    if (tmp == std::numeric_limits<ThermostatACCapacityFormat>::max()) {
      #ifdef THERMOSTAT_AC_CAPACITY_FORMAT_ENUM_NAME_AVAILABLE
      tmp = thermostat_ac_capacity_format_get_enum_value_number(jsn.at("ACCapacityFormat").get<std::string>());
      #elif defined(AC_CAPACITY_FORMAT_ENUM_NAME_AVAILABLE)
      tmp = ac_capacity_format_get_enum_value_number(jsn.at("ACCapacityFormat").get<std::string>());
      #endif
    }
    new_state.ac_capacity_format = tmp;
  
    new_updated_state.ac_capacity_format = true;
  }


}


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_fan_control_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_fan_control_state_t &new_state,
  uic_mqtt_dotdot_fan_control_updated_state_t &new_updated_state
) {


  if (jsn.find("FanMode") != jsn.end()) {

    uint32_t tmp = get_enum_decimal_value<FanControlFanMode>("FanMode", jsn);
    if (tmp == std::numeric_limits<FanControlFanMode>::max()) {
      #ifdef FAN_CONTROL_FAN_MODE_ENUM_NAME_AVAILABLE
      tmp = fan_control_fan_mode_get_enum_value_number(jsn.at("FanMode").get<std::string>());
      #elif defined(FAN_MODE_ENUM_NAME_AVAILABLE)
      tmp = fan_mode_get_enum_value_number(jsn.at("FanMode").get<std::string>());
      #endif
    }
    new_state.fan_mode = tmp;
  
    new_updated_state.fan_mode = true;
  }

  if (jsn.find("FanModeSequence") != jsn.end()) {

    uint32_t tmp = get_enum_decimal_value<FanControlFanModeSequence>("FanModeSequence", jsn);
    if (tmp == std::numeric_limits<FanControlFanModeSequence>::max()) {
      #ifdef FAN_CONTROL_FAN_MODE_SEQUENCE_ENUM_NAME_AVAILABLE
      tmp = fan_control_fan_mode_sequence_get_enum_value_number(jsn.at("FanModeSequence").get<std::string>());
      #elif defined(FAN_MODE_SEQUENCE_ENUM_NAME_AVAILABLE)
      tmp = fan_mode_sequence_get_enum_value_number(jsn.at("FanModeSequence").get<std::string>());
      #endif
    }
    new_state.fan_mode_sequence = tmp;
  
    new_updated_state.fan_mode_sequence = true;
  }


}


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_dehumidification_control_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_dehumidification_control_state_t &new_state,
  uic_mqtt_dotdot_dehumidification_control_updated_state_t &new_updated_state
) {


  if (jsn.find("RHDehumidificationSetpoint") != jsn.end()) {

    new_state.rh_dehumidification_setpoint = jsn.at("RHDehumidificationSetpoint").get<uint8_t>();
        
    new_updated_state.rh_dehumidification_setpoint = true;
  }

  if (jsn.find("RelativeHumidityMode") != jsn.end()) {

    uint32_t tmp = get_enum_decimal_value<DehumidificationControlRelativeHumidityMode>("RelativeHumidityMode", jsn);
    if (tmp == std::numeric_limits<DehumidificationControlRelativeHumidityMode>::max()) {
      #ifdef DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_MODE_ENUM_NAME_AVAILABLE
      tmp = dehumidification_control_relative_humidity_mode_get_enum_value_number(jsn.at("RelativeHumidityMode").get<std::string>());
      #elif defined(RELATIVE_HUMIDITY_MODE_ENUM_NAME_AVAILABLE)
      tmp = relative_humidity_mode_get_enum_value_number(jsn.at("RelativeHumidityMode").get<std::string>());
      #endif
    }
    new_state.relative_humidity_mode = tmp;
  
    new_updated_state.relative_humidity_mode = true;
  }

  if (jsn.find("DehumidificationLockout") != jsn.end()) {

    uint32_t tmp = get_enum_decimal_value<DehumidificationControlDehumidificationLockout>("DehumidificationLockout", jsn);
    if (tmp == std::numeric_limits<DehumidificationControlDehumidificationLockout>::max()) {
      #ifdef DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_LOCKOUT_ENUM_NAME_AVAILABLE
      tmp = dehumidification_control_dehumidification_lockout_get_enum_value_number(jsn.at("DehumidificationLockout").get<std::string>());
      #elif defined(DEHUMIDIFICATION_LOCKOUT_ENUM_NAME_AVAILABLE)
      tmp = dehumidification_lockout_get_enum_value_number(jsn.at("DehumidificationLockout").get<std::string>());
      #endif
    }
    new_state.dehumidification_lockout = tmp;
  
    new_updated_state.dehumidification_lockout = true;
  }

  if (jsn.find("DehumidificationHysteresis") != jsn.end()) {

    new_state.dehumidification_hysteresis = jsn.at("DehumidificationHysteresis").get<uint8_t>();
        
    new_updated_state.dehumidification_hysteresis = true;
  }

  if (jsn.find("DehumidificationMaxCool") != jsn.end()) {

    new_state.dehumidification_max_cool = jsn.at("DehumidificationMaxCool").get<uint8_t>();
        
    new_updated_state.dehumidification_max_cool = true;
  }

  if (jsn.find("RelativeHumidityDisplay") != jsn.end()) {

    uint32_t tmp = get_enum_decimal_value<DehumidificationControlRelativeHumidityDisplay>("RelativeHumidityDisplay", jsn);
    if (tmp == std::numeric_limits<DehumidificationControlRelativeHumidityDisplay>::max()) {
      #ifdef DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_DISPLAY_ENUM_NAME_AVAILABLE
      tmp = dehumidification_control_relative_humidity_display_get_enum_value_number(jsn.at("RelativeHumidityDisplay").get<std::string>());
      #elif defined(RELATIVE_HUMIDITY_DISPLAY_ENUM_NAME_AVAILABLE)
      tmp = relative_humidity_display_get_enum_value_number(jsn.at("RelativeHumidityDisplay").get<std::string>());
      #endif
    }
    new_state.relative_humidity_display = tmp;
  
    new_updated_state.relative_humidity_display = true;
  }


}


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_thermostat_user_interface_configuration_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_thermostat_user_interface_configuration_state_t &new_state,
  uic_mqtt_dotdot_thermostat_user_interface_configuration_updated_state_t &new_updated_state
) {


  if (jsn.find("TemperatureDisplayMode") != jsn.end()) {

    uint32_t tmp = get_enum_decimal_value<ThermostatUserInterfaceConfigurationTemperatureDisplayMode>("TemperatureDisplayMode", jsn);
    if (tmp == std::numeric_limits<ThermostatUserInterfaceConfigurationTemperatureDisplayMode>::max()) {
      #ifdef THERMOSTAT_USER_INTERFACE_CONFIGURATION_TEMPERATURE_DISPLAY_MODE_ENUM_NAME_AVAILABLE
      tmp = thermostat_user_interface_configuration_temperature_display_mode_get_enum_value_number(jsn.at("TemperatureDisplayMode").get<std::string>());
      #elif defined(TEMPERATURE_DISPLAY_MODE_ENUM_NAME_AVAILABLE)
      tmp = temperature_display_mode_get_enum_value_number(jsn.at("TemperatureDisplayMode").get<std::string>());
      #endif
    }
    new_state.temperature_display_mode = tmp;
  
    new_updated_state.temperature_display_mode = true;
  }

  if (jsn.find("KeypadLockout") != jsn.end()) {

    uint32_t tmp = get_enum_decimal_value<ThermostatUserInterfaceConfigurationKeypadLockout>("KeypadLockout", jsn);
    if (tmp == std::numeric_limits<ThermostatUserInterfaceConfigurationKeypadLockout>::max()) {
      #ifdef THERMOSTAT_USER_INTERFACE_CONFIGURATION_KEYPAD_LOCKOUT_ENUM_NAME_AVAILABLE
      tmp = thermostat_user_interface_configuration_keypad_lockout_get_enum_value_number(jsn.at("KeypadLockout").get<std::string>());
      #elif defined(KEYPAD_LOCKOUT_ENUM_NAME_AVAILABLE)
      tmp = keypad_lockout_get_enum_value_number(jsn.at("KeypadLockout").get<std::string>());
      #endif
    }
    new_state.keypad_lockout = tmp;
  
    new_updated_state.keypad_lockout = true;
  }

  if (jsn.find("ScheduleProgrammingVisibility") != jsn.end()) {

    uint32_t tmp = get_enum_decimal_value<ThermostatUserInterfaceConfigurationScheduleProgrammingVisibility>("ScheduleProgrammingVisibility", jsn);
    if (tmp == std::numeric_limits<ThermostatUserInterfaceConfigurationScheduleProgrammingVisibility>::max()) {
      #ifdef THERMOSTAT_USER_INTERFACE_CONFIGURATION_SCHEDULE_PROGRAMMING_VISIBILITY_ENUM_NAME_AVAILABLE
      tmp = thermostat_user_interface_configuration_schedule_programming_visibility_get_enum_value_number(jsn.at("ScheduleProgrammingVisibility").get<std::string>());
      #elif defined(SCHEDULE_PROGRAMMING_VISIBILITY_ENUM_NAME_AVAILABLE)
      tmp = schedule_programming_visibility_get_enum_value_number(jsn.at("ScheduleProgrammingVisibility").get<std::string>());
      #endif
    }
    new_state.schedule_programming_visibility = tmp;
  
    new_updated_state.schedule_programming_visibility = true;
  }


}


std::string get_json_payload_for_color_control_move_to_hue_command(
  
  const uic_mqtt_dotdot_color_control_command_move_to_hue_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Hue"] = nlohmann::json(fields->hue);
  command_with_no_fields = false;
  // Single Value
  // Enum MoveToHue / Direction
  #ifdef MOVE_TO_HUE_DIRECTION_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Direction"] =
    move_to_hue_direction_get_enum_value_name(
      (uint32_t)fields->direction);
  #elif defined(CC_DIRECTION_ENUM_NAME_AVAILABLE)
  json_payload["Direction"] =
    cc_direction_get_enum_value_name((uint32_t)fields->direction);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Direction"] = fields->direction;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["TransitionTime"] = nlohmann::json(fields->transition_time);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsMask"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_mask,
                                CCColorOptions);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsOverride"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_override,
                                CCColorOptions);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_color_control_move_to_hue(
  nlohmann::json &jsn,
  uint8_t &hue,
  
  CCDirection &direction,
  
  uint16_t &transition_time,
  
  uint8_t &options_mask,
  
  uint8_t &options_override
  
) {

  uint32_t Direction_enum_val = get_enum_decimal_value<CCDirection>("Direction", jsn);
  if (Direction_enum_val == std::numeric_limits<CCDirection>::max()) {
    #ifdef CC_DIRECTION_ENUM_NAME_AVAILABLE
    Direction_enum_val = cc_direction_get_enum_value_number(jsn.at("Direction").get<std::string>());
    #endif
  }
  if (jsn.at("Hue").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  hue = jsn.at("Hue").get< uint8_t >();
      if (jsn.at("Direction").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  direction = static_cast<CCDirection>(Direction_enum_val);
  if (jsn.at("TransitionTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  transition_time = jsn.at("TransitionTime").get< uint16_t >();
      if (jsn.at("OptionsMask").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_mask = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsMask", jsn, CCColorOptions);
  if (jsn.at("OptionsOverride").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_override = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsOverride", jsn, CCColorOptions);
}


std::string get_json_payload_for_color_control_move_hue_command(
  
  const uic_mqtt_dotdot_color_control_command_move_hue_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum MoveHue / MoveMode
  #ifdef MOVE_HUE_MOVE_MODE_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["MoveMode"] =
    move_hue_move_mode_get_enum_value_name(
      (uint32_t)fields->move_mode);
  #elif defined(CC_MOVE_MODE_ENUM_NAME_AVAILABLE)
  json_payload["MoveMode"] =
    cc_move_mode_get_enum_value_name((uint32_t)fields->move_mode);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["MoveMode"] = fields->move_mode;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Rate"] = nlohmann::json(fields->rate);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsMask"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_mask,
                                CCColorOptions);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsOverride"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_override,
                                CCColorOptions);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_color_control_move_hue(
  nlohmann::json &jsn,
  CCMoveMode &move_mode,
  
  uint8_t &rate,
  
  uint8_t &options_mask,
  
  uint8_t &options_override
  
) {

  uint32_t MoveMode_enum_val = get_enum_decimal_value<CCMoveMode>("MoveMode", jsn);
  if (MoveMode_enum_val == std::numeric_limits<CCMoveMode>::max()) {
    #ifdef CC_MOVE_MODE_ENUM_NAME_AVAILABLE
    MoveMode_enum_val = cc_move_mode_get_enum_value_number(jsn.at("MoveMode").get<std::string>());
    #endif
  }
  if (jsn.at("MoveMode").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  move_mode = static_cast<CCMoveMode>(MoveMode_enum_val);
  if (jsn.at("Rate").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  rate = jsn.at("Rate").get< uint8_t >();
      if (jsn.at("OptionsMask").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_mask = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsMask", jsn, CCColorOptions);
  if (jsn.at("OptionsOverride").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_override = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsOverride", jsn, CCColorOptions);
}


std::string get_json_payload_for_color_control_step_hue_command(
  
  const uic_mqtt_dotdot_color_control_command_step_hue_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum StepHue / StepMode
  #ifdef STEP_HUE_STEP_MODE_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["StepMode"] =
    step_hue_step_mode_get_enum_value_name(
      (uint32_t)fields->step_mode);
  #elif defined(CC_STEP_MODE_ENUM_NAME_AVAILABLE)
  json_payload["StepMode"] =
    cc_step_mode_get_enum_value_name((uint32_t)fields->step_mode);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["StepMode"] = fields->step_mode;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["StepSize"] = nlohmann::json(fields->step_size);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["TransitionTime"] = nlohmann::json(fields->transition_time);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsMask"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_mask,
                                CCColorOptions);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsOverride"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_override,
                                CCColorOptions);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_color_control_step_hue(
  nlohmann::json &jsn,
  CCStepMode &step_mode,
  
  uint8_t &step_size,
  
  uint8_t &transition_time,
  
  uint8_t &options_mask,
  
  uint8_t &options_override
  
) {

  uint32_t StepMode_enum_val = get_enum_decimal_value<CCStepMode>("StepMode", jsn);
  if (StepMode_enum_val == std::numeric_limits<CCStepMode>::max()) {
    #ifdef CC_STEP_MODE_ENUM_NAME_AVAILABLE
    StepMode_enum_val = cc_step_mode_get_enum_value_number(jsn.at("StepMode").get<std::string>());
    #endif
  }
  if (jsn.at("StepMode").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  step_mode = static_cast<CCStepMode>(StepMode_enum_val);
  if (jsn.at("StepSize").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  step_size = jsn.at("StepSize").get< uint8_t >();
      if (jsn.at("TransitionTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  transition_time = jsn.at("TransitionTime").get< uint8_t >();
      if (jsn.at("OptionsMask").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_mask = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsMask", jsn, CCColorOptions);
  if (jsn.at("OptionsOverride").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_override = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsOverride", jsn, CCColorOptions);
}


std::string get_json_payload_for_color_control_move_to_saturation_command(
  
  const uic_mqtt_dotdot_color_control_command_move_to_saturation_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Saturation"] = nlohmann::json(fields->saturation);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["TransitionTime"] = nlohmann::json(fields->transition_time);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsMask"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_mask,
                                CCColorOptions);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsOverride"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_override,
                                CCColorOptions);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_color_control_move_to_saturation(
  nlohmann::json &jsn,
  uint8_t &saturation,
  
  uint16_t &transition_time,
  
  uint8_t &options_mask,
  
  uint8_t &options_override
  
) {

  if (jsn.at("Saturation").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  saturation = jsn.at("Saturation").get< uint8_t >();
      if (jsn.at("TransitionTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  transition_time = jsn.at("TransitionTime").get< uint16_t >();
      if (jsn.at("OptionsMask").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_mask = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsMask", jsn, CCColorOptions);
  if (jsn.at("OptionsOverride").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_override = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsOverride", jsn, CCColorOptions);
}


std::string get_json_payload_for_color_control_move_saturation_command(
  
  const uic_mqtt_dotdot_color_control_command_move_saturation_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum MoveSaturation / MoveMode
  #ifdef MOVE_SATURATION_MOVE_MODE_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["MoveMode"] =
    move_saturation_move_mode_get_enum_value_name(
      (uint32_t)fields->move_mode);
  #elif defined(CC_MOVE_MODE_ENUM_NAME_AVAILABLE)
  json_payload["MoveMode"] =
    cc_move_mode_get_enum_value_name((uint32_t)fields->move_mode);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["MoveMode"] = fields->move_mode;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Rate"] = nlohmann::json(fields->rate);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsMask"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_mask,
                                CCColorOptions);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsOverride"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_override,
                                CCColorOptions);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_color_control_move_saturation(
  nlohmann::json &jsn,
  CCMoveMode &move_mode,
  
  uint8_t &rate,
  
  uint8_t &options_mask,
  
  uint8_t &options_override
  
) {

  uint32_t MoveMode_enum_val = get_enum_decimal_value<CCMoveMode>("MoveMode", jsn);
  if (MoveMode_enum_val == std::numeric_limits<CCMoveMode>::max()) {
    #ifdef CC_MOVE_MODE_ENUM_NAME_AVAILABLE
    MoveMode_enum_val = cc_move_mode_get_enum_value_number(jsn.at("MoveMode").get<std::string>());
    #endif
  }
  if (jsn.at("MoveMode").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  move_mode = static_cast<CCMoveMode>(MoveMode_enum_val);
  if (jsn.at("Rate").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  rate = jsn.at("Rate").get< uint8_t >();
      if (jsn.at("OptionsMask").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_mask = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsMask", jsn, CCColorOptions);
  if (jsn.at("OptionsOverride").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_override = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsOverride", jsn, CCColorOptions);
}


std::string get_json_payload_for_color_control_step_saturation_command(
  
  const uic_mqtt_dotdot_color_control_command_step_saturation_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum StepSaturation / StepMode
  #ifdef STEP_SATURATION_STEP_MODE_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["StepMode"] =
    step_saturation_step_mode_get_enum_value_name(
      (uint32_t)fields->step_mode);
  #elif defined(CC_STEP_MODE_ENUM_NAME_AVAILABLE)
  json_payload["StepMode"] =
    cc_step_mode_get_enum_value_name((uint32_t)fields->step_mode);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["StepMode"] = fields->step_mode;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["StepSize"] = nlohmann::json(fields->step_size);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["TransitionTime"] = nlohmann::json(fields->transition_time);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsMask"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_mask,
                                CCColorOptions);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsOverride"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_override,
                                CCColorOptions);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_color_control_step_saturation(
  nlohmann::json &jsn,
  CCStepMode &step_mode,
  
  uint8_t &step_size,
  
  uint8_t &transition_time,
  
  uint8_t &options_mask,
  
  uint8_t &options_override
  
) {

  uint32_t StepMode_enum_val = get_enum_decimal_value<CCStepMode>("StepMode", jsn);
  if (StepMode_enum_val == std::numeric_limits<CCStepMode>::max()) {
    #ifdef CC_STEP_MODE_ENUM_NAME_AVAILABLE
    StepMode_enum_val = cc_step_mode_get_enum_value_number(jsn.at("StepMode").get<std::string>());
    #endif
  }
  if (jsn.at("StepMode").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  step_mode = static_cast<CCStepMode>(StepMode_enum_val);
  if (jsn.at("StepSize").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  step_size = jsn.at("StepSize").get< uint8_t >();
      if (jsn.at("TransitionTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  transition_time = jsn.at("TransitionTime").get< uint8_t >();
      if (jsn.at("OptionsMask").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_mask = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsMask", jsn, CCColorOptions);
  if (jsn.at("OptionsOverride").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_override = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsOverride", jsn, CCColorOptions);
}


std::string get_json_payload_for_color_control_move_to_hue_and_saturation_command(
  
  const uic_mqtt_dotdot_color_control_command_move_to_hue_and_saturation_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Hue"] = nlohmann::json(fields->hue);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Saturation"] = nlohmann::json(fields->saturation);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["TransitionTime"] = nlohmann::json(fields->transition_time);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsMask"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_mask,
                                CCColorOptions);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsOverride"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_override,
                                CCColorOptions);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_color_control_move_to_hue_and_saturation(
  nlohmann::json &jsn,
  uint8_t &hue,
  
  uint8_t &saturation,
  
  uint16_t &transition_time,
  
  uint8_t &options_mask,
  
  uint8_t &options_override
  
) {

  if (jsn.at("Hue").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  hue = jsn.at("Hue").get< uint8_t >();
      if (jsn.at("Saturation").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  saturation = jsn.at("Saturation").get< uint8_t >();
      if (jsn.at("TransitionTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  transition_time = jsn.at("TransitionTime").get< uint16_t >();
      if (jsn.at("OptionsMask").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_mask = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsMask", jsn, CCColorOptions);
  if (jsn.at("OptionsOverride").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_override = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsOverride", jsn, CCColorOptions);
}


std::string get_json_payload_for_color_control_move_to_color_command(
  
  const uic_mqtt_dotdot_color_control_command_move_to_color_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["ColorX"] = nlohmann::json(fields->colorx);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["ColorY"] = nlohmann::json(fields->colory);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["TransitionTime"] = nlohmann::json(fields->transition_time);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsMask"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_mask,
                                CCColorOptions);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsOverride"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_override,
                                CCColorOptions);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_color_control_move_to_color(
  nlohmann::json &jsn,
  uint16_t &colorx,
  
  uint16_t &colory,
  
  uint16_t &transition_time,
  
  uint8_t &options_mask,
  
  uint8_t &options_override
  
) {

  if (jsn.at("ColorX").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  colorx = jsn.at("ColorX").get< uint16_t >();
      if (jsn.at("ColorY").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  colory = jsn.at("ColorY").get< uint16_t >();
      if (jsn.at("TransitionTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  transition_time = jsn.at("TransitionTime").get< uint16_t >();
      if (jsn.at("OptionsMask").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_mask = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsMask", jsn, CCColorOptions);
  if (jsn.at("OptionsOverride").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_override = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsOverride", jsn, CCColorOptions);
}


std::string get_json_payload_for_color_control_move_color_command(
  
  const uic_mqtt_dotdot_color_control_command_move_color_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["RateX"] = nlohmann::json(fields->ratex);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["RateY"] = nlohmann::json(fields->ratey);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsMask"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_mask,
                                CCColorOptions);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsOverride"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_override,
                                CCColorOptions);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_color_control_move_color(
  nlohmann::json &jsn,
  int16_t &ratex,
  
  int16_t &ratey,
  
  uint8_t &options_mask,
  
  uint8_t &options_override
  
) {

  if (jsn.at("RateX").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  ratex = jsn.at("RateX").get< int16_t >();
      if (jsn.at("RateY").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  ratey = jsn.at("RateY").get< int16_t >();
      if (jsn.at("OptionsMask").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_mask = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsMask", jsn, CCColorOptions);
  if (jsn.at("OptionsOverride").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_override = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsOverride", jsn, CCColorOptions);
}


std::string get_json_payload_for_color_control_step_color_command(
  
  const uic_mqtt_dotdot_color_control_command_step_color_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["StepX"] = nlohmann::json(fields->stepx);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["StepY"] = nlohmann::json(fields->stepy);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["TransitionTime"] = nlohmann::json(fields->transition_time);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsMask"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_mask,
                                CCColorOptions);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsOverride"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_override,
                                CCColorOptions);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_color_control_step_color(
  nlohmann::json &jsn,
  int16_t &stepx,
  
  int16_t &stepy,
  
  uint16_t &transition_time,
  
  uint8_t &options_mask,
  
  uint8_t &options_override
  
) {

  if (jsn.at("StepX").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  stepx = jsn.at("StepX").get< int16_t >();
      if (jsn.at("StepY").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  stepy = jsn.at("StepY").get< int16_t >();
      if (jsn.at("TransitionTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  transition_time = jsn.at("TransitionTime").get< uint16_t >();
      if (jsn.at("OptionsMask").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_mask = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsMask", jsn, CCColorOptions);
  if (jsn.at("OptionsOverride").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_override = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsOverride", jsn, CCColorOptions);
}


std::string get_json_payload_for_color_control_move_to_color_temperature_command(
  
  const uic_mqtt_dotdot_color_control_command_move_to_color_temperature_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["ColorTemperatureMireds"] = nlohmann::json(fields->color_temperature_mireds);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["TransitionTime"] = nlohmann::json(fields->transition_time);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsMask"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_mask,
                                CCColorOptions);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsOverride"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_override,
                                CCColorOptions);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_color_control_move_to_color_temperature(
  nlohmann::json &jsn,
  uint16_t &color_temperature_mireds,
  
  uint16_t &transition_time,
  
  uint8_t &options_mask,
  
  uint8_t &options_override
  
) {

  if (jsn.at("ColorTemperatureMireds").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  color_temperature_mireds = jsn.at("ColorTemperatureMireds").get< uint16_t >();
      if (jsn.at("TransitionTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  transition_time = jsn.at("TransitionTime").get< uint16_t >();
      if (jsn.at("OptionsMask").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_mask = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsMask", jsn, CCColorOptions);
  if (jsn.at("OptionsOverride").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_override = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsOverride", jsn, CCColorOptions);
}


std::string get_json_payload_for_color_control_enhanced_move_to_hue_command(
  
  const uic_mqtt_dotdot_color_control_command_enhanced_move_to_hue_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["EnhancedHue"] = nlohmann::json(fields->enhanced_hue);
  command_with_no_fields = false;
  // Single Value
  // Enum EnhancedMoveToHue / Direction
  #ifdef ENHANCED_MOVE_TO_HUE_DIRECTION_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Direction"] =
    enhanced_move_to_hue_direction_get_enum_value_name(
      (uint32_t)fields->direction);
  #elif defined(CC_DIRECTION_ENUM_NAME_AVAILABLE)
  json_payload["Direction"] =
    cc_direction_get_enum_value_name((uint32_t)fields->direction);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Direction"] = fields->direction;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["TransitionTime"] = nlohmann::json(fields->transition_time);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsMask"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_mask,
                                CCColorOptions);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsOverride"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_override,
                                CCColorOptions);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_color_control_enhanced_move_to_hue(
  nlohmann::json &jsn,
  uint16_t &enhanced_hue,
  
  CCDirection &direction,
  
  uint16_t &transition_time,
  
  uint8_t &options_mask,
  
  uint8_t &options_override
  
) {

  uint32_t Direction_enum_val = get_enum_decimal_value<CCDirection>("Direction", jsn);
  if (Direction_enum_val == std::numeric_limits<CCDirection>::max()) {
    #ifdef CC_DIRECTION_ENUM_NAME_AVAILABLE
    Direction_enum_val = cc_direction_get_enum_value_number(jsn.at("Direction").get<std::string>());
    #endif
  }
  if (jsn.at("EnhancedHue").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  enhanced_hue = jsn.at("EnhancedHue").get< uint16_t >();
      if (jsn.at("Direction").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  direction = static_cast<CCDirection>(Direction_enum_val);
  if (jsn.at("TransitionTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  transition_time = jsn.at("TransitionTime").get< uint16_t >();
      if (jsn.at("OptionsMask").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_mask = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsMask", jsn, CCColorOptions);
  if (jsn.at("OptionsOverride").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_override = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsOverride", jsn, CCColorOptions);
}


std::string get_json_payload_for_color_control_enhanced_move_hue_command(
  
  const uic_mqtt_dotdot_color_control_command_enhanced_move_hue_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum EnhancedMoveHue / MoveMode
  #ifdef ENHANCED_MOVE_HUE_MOVE_MODE_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["MoveMode"] =
    enhanced_move_hue_move_mode_get_enum_value_name(
      (uint32_t)fields->move_mode);
  #elif defined(CC_MOVE_MODE_ENUM_NAME_AVAILABLE)
  json_payload["MoveMode"] =
    cc_move_mode_get_enum_value_name((uint32_t)fields->move_mode);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["MoveMode"] = fields->move_mode;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Rate"] = nlohmann::json(fields->rate);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsMask"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_mask,
                                CCColorOptions);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsOverride"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_override,
                                CCColorOptions);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_color_control_enhanced_move_hue(
  nlohmann::json &jsn,
  CCMoveMode &move_mode,
  
  uint16_t &rate,
  
  uint8_t &options_mask,
  
  uint8_t &options_override
  
) {

  uint32_t MoveMode_enum_val = get_enum_decimal_value<CCMoveMode>("MoveMode", jsn);
  if (MoveMode_enum_val == std::numeric_limits<CCMoveMode>::max()) {
    #ifdef CC_MOVE_MODE_ENUM_NAME_AVAILABLE
    MoveMode_enum_val = cc_move_mode_get_enum_value_number(jsn.at("MoveMode").get<std::string>());
    #endif
  }
  if (jsn.at("MoveMode").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  move_mode = static_cast<CCMoveMode>(MoveMode_enum_val);
  if (jsn.at("Rate").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  rate = jsn.at("Rate").get< uint16_t >();
      if (jsn.at("OptionsMask").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_mask = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsMask", jsn, CCColorOptions);
  if (jsn.at("OptionsOverride").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_override = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsOverride", jsn, CCColorOptions);
}


std::string get_json_payload_for_color_control_enhanced_step_hue_command(
  
  const uic_mqtt_dotdot_color_control_command_enhanced_step_hue_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum EnhancedStepHue / StepMode
  #ifdef ENHANCED_STEP_HUE_STEP_MODE_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["StepMode"] =
    enhanced_step_hue_step_mode_get_enum_value_name(
      (uint32_t)fields->step_mode);
  #elif defined(CC_STEP_MODE_ENUM_NAME_AVAILABLE)
  json_payload["StepMode"] =
    cc_step_mode_get_enum_value_name((uint32_t)fields->step_mode);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["StepMode"] = fields->step_mode;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["StepSize"] = nlohmann::json(fields->step_size);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["TransitionTime"] = nlohmann::json(fields->transition_time);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsMask"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_mask,
                                CCColorOptions);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsOverride"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_override,
                                CCColorOptions);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_color_control_enhanced_step_hue(
  nlohmann::json &jsn,
  CCStepMode &step_mode,
  
  uint16_t &step_size,
  
  uint16_t &transition_time,
  
  uint8_t &options_mask,
  
  uint8_t &options_override
  
) {

  uint32_t StepMode_enum_val = get_enum_decimal_value<CCStepMode>("StepMode", jsn);
  if (StepMode_enum_val == std::numeric_limits<CCStepMode>::max()) {
    #ifdef CC_STEP_MODE_ENUM_NAME_AVAILABLE
    StepMode_enum_val = cc_step_mode_get_enum_value_number(jsn.at("StepMode").get<std::string>());
    #endif
  }
  if (jsn.at("StepMode").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  step_mode = static_cast<CCStepMode>(StepMode_enum_val);
  if (jsn.at("StepSize").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  step_size = jsn.at("StepSize").get< uint16_t >();
      if (jsn.at("TransitionTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  transition_time = jsn.at("TransitionTime").get< uint16_t >();
      if (jsn.at("OptionsMask").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_mask = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsMask", jsn, CCColorOptions);
  if (jsn.at("OptionsOverride").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_override = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsOverride", jsn, CCColorOptions);
}


std::string get_json_payload_for_color_control_enhanced_move_to_hue_and_saturation_command(
  
  const uic_mqtt_dotdot_color_control_command_enhanced_move_to_hue_and_saturation_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["EnhancedHue"] = nlohmann::json(fields->enhanced_hue);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Saturation"] = nlohmann::json(fields->saturation);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["TransitionTime"] = nlohmann::json(fields->transition_time);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsMask"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_mask,
                                CCColorOptions);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsOverride"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_override,
                                CCColorOptions);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_color_control_enhanced_move_to_hue_and_saturation(
  nlohmann::json &jsn,
  uint16_t &enhanced_hue,
  
  uint8_t &saturation,
  
  uint16_t &transition_time,
  
  uint8_t &options_mask,
  
  uint8_t &options_override
  
) {

  if (jsn.at("EnhancedHue").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  enhanced_hue = jsn.at("EnhancedHue").get< uint16_t >();
      if (jsn.at("Saturation").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  saturation = jsn.at("Saturation").get< uint8_t >();
      if (jsn.at("TransitionTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  transition_time = jsn.at("TransitionTime").get< uint16_t >();
      if (jsn.at("OptionsMask").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_mask = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsMask", jsn, CCColorOptions);
  if (jsn.at("OptionsOverride").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_override = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsOverride", jsn, CCColorOptions);
}


std::string get_json_payload_for_color_control_color_loop_set_command(
  
  const uic_mqtt_dotdot_color_control_command_color_loop_set_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["UpdateFlags"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->update_flags,
                                ColorLoopSetUpdateFlags);
  command_with_no_fields = false;
  // Single Value
  // Enum ColorLoopSet / Action
  #ifdef COLOR_LOOP_SET_ACTION_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Action"] =
    color_loop_set_action_get_enum_value_name(
      (uint32_t)fields->action);
  #elif defined(COLOR_LOOP_SET_ACTION_ENUM_NAME_AVAILABLE)
  json_payload["Action"] =
    color_loop_set_action_get_enum_value_name((uint32_t)fields->action);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Action"] = fields->action;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Enum ColorLoopSet / Direction
  #ifdef COLOR_LOOP_SET_DIRECTION_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Direction"] =
    color_loop_set_direction_get_enum_value_name(
      (uint32_t)fields->direction);
  #elif defined(CC_COLOR_LOOP_DIRECTION_ENUM_NAME_AVAILABLE)
  json_payload["Direction"] =
    cc_color_loop_direction_get_enum_value_name((uint32_t)fields->direction);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Direction"] = fields->direction;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Time"] = nlohmann::json(fields->time);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["StartHue"] = nlohmann::json(fields->start_hue);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsMask"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_mask,
                                CCColorOptions);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsOverride"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_override,
                                CCColorOptions);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_color_control_color_loop_set(
  nlohmann::json &jsn,
  uint8_t &update_flags,
  
  ColorLoopSetAction &action,
  
  CCColorLoopDirection &direction,
  
  uint16_t &time,
  
  uint16_t &start_hue,
  
  uint8_t &options_mask,
  
  uint8_t &options_override
  
) {

  uint32_t Action_enum_val = get_enum_decimal_value<ColorLoopSetAction>("Action", jsn);
  if (Action_enum_val == std::numeric_limits<ColorLoopSetAction>::max()) {
    #ifdef COLOR_LOOP_SET_ACTION_ENUM_NAME_AVAILABLE
    Action_enum_val = color_loop_set_action_get_enum_value_number(jsn.at("Action").get<std::string>());
    #endif
  }
  uint32_t Direction_enum_val = get_enum_decimal_value<CCColorLoopDirection>("Direction", jsn);
  if (Direction_enum_val == std::numeric_limits<CCColorLoopDirection>::max()) {
    #ifdef CC_COLOR_LOOP_DIRECTION_ENUM_NAME_AVAILABLE
    Direction_enum_val = cc_color_loop_direction_get_enum_value_number(jsn.at("Direction").get<std::string>());
    #endif
  }
  if (jsn.at("UpdateFlags").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  update_flags = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("UpdateFlags", jsn, ColorLoopSetUpdateFlags);
  if (jsn.at("Action").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  action = static_cast<ColorLoopSetAction>(Action_enum_val);
  if (jsn.at("Direction").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  direction = static_cast<CCColorLoopDirection>(Direction_enum_val);
  if (jsn.at("Time").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  time = jsn.at("Time").get< uint16_t >();
      if (jsn.at("StartHue").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  start_hue = jsn.at("StartHue").get< uint16_t >();
      if (jsn.at("OptionsMask").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_mask = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsMask", jsn, CCColorOptions);
  if (jsn.at("OptionsOverride").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_override = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsOverride", jsn, CCColorOptions);
}


std::string get_json_payload_for_color_control_stop_move_step_command(
  
  const uic_mqtt_dotdot_color_control_command_stop_move_step_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsMask"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_mask,
                                CCColorOptions);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsOverride"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_override,
                                CCColorOptions);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_color_control_stop_move_step(
  nlohmann::json &jsn,
  uint8_t &options_mask,
  
  uint8_t &options_override
  
) {

  if (jsn.at("OptionsMask").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_mask = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsMask", jsn, CCColorOptions);
  if (jsn.at("OptionsOverride").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_override = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsOverride", jsn, CCColorOptions);
}


std::string get_json_payload_for_color_control_move_color_temperature_command(
  
  const uic_mqtt_dotdot_color_control_command_move_color_temperature_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum MoveColorTemperature / MoveMode
  #ifdef MOVE_COLOR_TEMPERATURE_MOVE_MODE_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["MoveMode"] =
    move_color_temperature_move_mode_get_enum_value_name(
      (uint32_t)fields->move_mode);
  #elif defined(CC_MOVE_MODE_ENUM_NAME_AVAILABLE)
  json_payload["MoveMode"] =
    cc_move_mode_get_enum_value_name((uint32_t)fields->move_mode);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["MoveMode"] = fields->move_mode;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Rate"] = nlohmann::json(fields->rate);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["ColorTemperatureMinimumMireds"] = nlohmann::json(fields->color_temperature_minimum_mireds);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["ColorTemperatureMaximumMireds"] = nlohmann::json(fields->color_temperature_maximum_mireds);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsMask"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_mask,
                                CCColorOptions);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsOverride"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_override,
                                CCColorOptions);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_color_control_move_color_temperature(
  nlohmann::json &jsn,
  CCMoveMode &move_mode,
  
  uint16_t &rate,
  
  CCMinMiredsField &color_temperature_minimum_mireds,
  
  CCMaxMiredsField &color_temperature_maximum_mireds,
  
  uint8_t &options_mask,
  
  uint8_t &options_override
  
) {

  uint32_t MoveMode_enum_val = get_enum_decimal_value<CCMoveMode>("MoveMode", jsn);
  if (MoveMode_enum_val == std::numeric_limits<CCMoveMode>::max()) {
    #ifdef CC_MOVE_MODE_ENUM_NAME_AVAILABLE
    MoveMode_enum_val = cc_move_mode_get_enum_value_number(jsn.at("MoveMode").get<std::string>());
    #endif
  }
  if (jsn.at("MoveMode").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  move_mode = static_cast<CCMoveMode>(MoveMode_enum_val);
  if (jsn.at("Rate").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  rate = jsn.at("Rate").get< uint16_t >();
      if (jsn.at("ColorTemperatureMinimumMireds").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  color_temperature_minimum_mireds = jsn.at("ColorTemperatureMinimumMireds").get< CCMinMiredsField >();
      if (jsn.at("ColorTemperatureMaximumMireds").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  color_temperature_maximum_mireds = jsn.at("ColorTemperatureMaximumMireds").get< CCMaxMiredsField >();
      if (jsn.at("OptionsMask").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_mask = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsMask", jsn, CCColorOptions);
  if (jsn.at("OptionsOverride").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_override = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsOverride", jsn, CCColorOptions);
}


std::string get_json_payload_for_color_control_step_color_temperature_command(
  
  const uic_mqtt_dotdot_color_control_command_step_color_temperature_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum StepColorTemperature / StepMode
  #ifdef STEP_COLOR_TEMPERATURE_STEP_MODE_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["StepMode"] =
    step_color_temperature_step_mode_get_enum_value_name(
      (uint32_t)fields->step_mode);
  #elif defined(CC_STEP_MODE_ENUM_NAME_AVAILABLE)
  json_payload["StepMode"] =
    cc_step_mode_get_enum_value_name((uint32_t)fields->step_mode);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["StepMode"] = fields->step_mode;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["StepSize"] = nlohmann::json(fields->step_size);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["TransitionTime"] = nlohmann::json(fields->transition_time);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["ColorTemperatureMinimumMireds"] = nlohmann::json(fields->color_temperature_minimum_mireds);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["ColorTemperatureMaximumMireds"] = nlohmann::json(fields->color_temperature_maximum_mireds);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsMask"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_mask,
                                CCColorOptions);
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["OptionsOverride"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->options_override,
                                CCColorOptions);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_color_control_step_color_temperature(
  nlohmann::json &jsn,
  CCStepMode &step_mode,
  
  uint16_t &step_size,
  
  uint16_t &transition_time,
  
  CCMinMiredsField &color_temperature_minimum_mireds,
  
  CCMaxMiredsField &color_temperature_maximum_mireds,
  
  uint8_t &options_mask,
  
  uint8_t &options_override
  
) {

  uint32_t StepMode_enum_val = get_enum_decimal_value<CCStepMode>("StepMode", jsn);
  if (StepMode_enum_val == std::numeric_limits<CCStepMode>::max()) {
    #ifdef CC_STEP_MODE_ENUM_NAME_AVAILABLE
    StepMode_enum_val = cc_step_mode_get_enum_value_number(jsn.at("StepMode").get<std::string>());
    #endif
  }
  if (jsn.at("StepMode").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  step_mode = static_cast<CCStepMode>(StepMode_enum_val);
  if (jsn.at("StepSize").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  step_size = jsn.at("StepSize").get< uint16_t >();
      if (jsn.at("TransitionTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  transition_time = jsn.at("TransitionTime").get< uint16_t >();
      if (jsn.at("ColorTemperatureMinimumMireds").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  color_temperature_minimum_mireds = jsn.at("ColorTemperatureMinimumMireds").get< CCMinMiredsField >();
      if (jsn.at("ColorTemperatureMaximumMireds").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  color_temperature_maximum_mireds = jsn.at("ColorTemperatureMaximumMireds").get< CCMaxMiredsField >();
      if (jsn.at("OptionsMask").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_mask = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsMask", jsn, CCColorOptions);
  if (jsn.at("OptionsOverride").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  options_override = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("OptionsOverride", jsn, CCColorOptions);
}


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_color_control_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_color_control_state_t &new_state,
  uic_mqtt_dotdot_color_control_updated_state_t &new_updated_state
) {


  if (jsn.find("Options") != jsn.end()) {

    new_state.options = uic_dotdot_mqtt::get_bitmap_decimal_value("Options", jsn, CCColorOptions);
  
    new_updated_state.options = true;
  }

  if (jsn.find("WhitePointX") != jsn.end()) {

    new_state.white_pointx = jsn.at("WhitePointX").get<uint16_t>();
        
    new_updated_state.white_pointx = true;
  }

  if (jsn.find("WhitePointY") != jsn.end()) {

    new_state.white_pointy = jsn.at("WhitePointY").get<uint16_t>();
        
    new_updated_state.white_pointy = true;
  }

  if (jsn.find("ColorPointRX") != jsn.end()) {

    new_state.color_pointrx = jsn.at("ColorPointRX").get<uint16_t>();
        
    new_updated_state.color_pointrx = true;
  }

  if (jsn.find("ColorPointRY") != jsn.end()) {

    new_state.color_pointry = jsn.at("ColorPointRY").get<uint16_t>();
        
    new_updated_state.color_pointry = true;
  }

  if (jsn.find("ColorPointRIntensity") != jsn.end()) {

    new_state.color_pointr_intensity = jsn.at("ColorPointRIntensity").get<uint8_t>();
        
    new_updated_state.color_pointr_intensity = true;
  }

  if (jsn.find("ColorPointGX") != jsn.end()) {

    new_state.color_pointgx = jsn.at("ColorPointGX").get<uint16_t>();
        
    new_updated_state.color_pointgx = true;
  }

  if (jsn.find("ColorPointGY") != jsn.end()) {

    new_state.color_pointgy = jsn.at("ColorPointGY").get<uint16_t>();
        
    new_updated_state.color_pointgy = true;
  }

  if (jsn.find("ColorPointGIntensity") != jsn.end()) {

    new_state.color_pointg_intensity = jsn.at("ColorPointGIntensity").get<uint8_t>();
        
    new_updated_state.color_pointg_intensity = true;
  }

  if (jsn.find("ColorPointBX") != jsn.end()) {

    new_state.color_pointbx = jsn.at("ColorPointBX").get<uint16_t>();
        
    new_updated_state.color_pointbx = true;
  }

  if (jsn.find("ColorPointBY") != jsn.end()) {

    new_state.color_pointby = jsn.at("ColorPointBY").get<uint16_t>();
        
    new_updated_state.color_pointby = true;
  }

  if (jsn.find("ColorPointBIntensity") != jsn.end()) {

    new_state.color_pointb_intensity = jsn.at("ColorPointBIntensity").get<uint8_t>();
        
    new_updated_state.color_pointb_intensity = true;
  }

  if (jsn.find("StartUpColorTemperatureMireds") != jsn.end()) {

    new_state.start_up_color_temperature_mireds = jsn.at("StartUpColorTemperatureMireds").get<uint16_t>();
        
    new_updated_state.start_up_color_temperature_mireds = true;
  }


}


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_ballast_configuration_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_ballast_configuration_state_t &new_state,
  uic_mqtt_dotdot_ballast_configuration_updated_state_t &new_updated_state
) {


  if (jsn.find("MinLevel") != jsn.end()) {

    new_state.min_level = jsn.at("MinLevel").get<uint8_t>();
        
    new_updated_state.min_level = true;
  }

  if (jsn.find("MaxLevel") != jsn.end()) {

    new_state.max_level = jsn.at("MaxLevel").get<uint8_t>();
        
    new_updated_state.max_level = true;
  }

  if (jsn.find("PowerOnLevel") != jsn.end()) {

    new_state.power_on_level = jsn.at("PowerOnLevel").get<uint8_t>();
        
    new_updated_state.power_on_level = true;
  }

  if (jsn.find("PowerOnFadeTime") != jsn.end()) {

    new_state.power_on_fade_time = jsn.at("PowerOnFadeTime").get<uint16_t>();
        
    new_updated_state.power_on_fade_time = true;
  }

  if (jsn.find("IntrinsicBallastFactor") != jsn.end()) {

    new_state.intrinsic_ballast_factor = jsn.at("IntrinsicBallastFactor").get<uint8_t>();
        
    new_updated_state.intrinsic_ballast_factor = true;
  }

  if (jsn.find("BallastFactorAdjustment") != jsn.end()) {

    new_state.ballast_factor_adjustment = jsn.at("BallastFactorAdjustment").get<uint8_t>();
        
    new_updated_state.ballast_factor_adjustment = true;
  }

  if (jsn.find("LampType") != jsn.end()) {

    new_state.lamp_type = jsn.at("LampType").get_ptr<const std::string*>()->c_str();
  
    new_updated_state.lamp_type = true;
  }

  if (jsn.find("LampManufacturer") != jsn.end()) {

    new_state.lamp_manufacturer = jsn.at("LampManufacturer").get_ptr<const std::string*>()->c_str();
  
    new_updated_state.lamp_manufacturer = true;
  }

  if (jsn.find("LampRatedHours") != jsn.end()) {

    new_state.lamp_rated_hours = jsn.at("LampRatedHours").get<uint32_t>();
        
    new_updated_state.lamp_rated_hours = true;
  }

  if (jsn.find("LampBurnHours") != jsn.end()) {

    new_state.lamp_burn_hours = jsn.at("LampBurnHours").get<uint32_t>();
        
    new_updated_state.lamp_burn_hours = true;
  }

  if (jsn.find("LampAlarmMode") != jsn.end()) {

    new_state.lamp_alarm_mode = uic_dotdot_mqtt::get_bitmap_decimal_value("LampAlarmMode", jsn, BallastConfigurationLampAlarmMode);
  
    new_updated_state.lamp_alarm_mode = true;
  }

  if (jsn.find("LampBurnHoursTripPoint") != jsn.end()) {

    new_state.lamp_burn_hours_trip_point = jsn.at("LampBurnHoursTripPoint").get<uint32_t>();
        
    new_updated_state.lamp_burn_hours_trip_point = true;
  }


}


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_illuminance_measurement_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_illuminance_measurement_state_t &new_state,
  uic_mqtt_dotdot_illuminance_measurement_updated_state_t &new_updated_state
) {



}


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_illuminance_level_sensing_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_illuminance_level_sensing_state_t &new_state,
  uic_mqtt_dotdot_illuminance_level_sensing_updated_state_t &new_updated_state
) {


  if (jsn.find("IlluminanceTargetLevel") != jsn.end()) {

    new_state.illuminance_target_level = jsn.at("IlluminanceTargetLevel").get<uint16_t>();
        
    new_updated_state.illuminance_target_level = true;
  }


}


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_temperature_measurement_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_temperature_measurement_state_t &new_state,
  uic_mqtt_dotdot_temperature_measurement_updated_state_t &new_updated_state
) {



}


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_pressure_measurement_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_pressure_measurement_state_t &new_state,
  uic_mqtt_dotdot_pressure_measurement_updated_state_t &new_updated_state
) {



}


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_flow_measurement_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_flow_measurement_state_t &new_state,
  uic_mqtt_dotdot_flow_measurement_updated_state_t &new_updated_state
) {



}


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_relativity_humidity_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_relativity_humidity_state_t &new_state,
  uic_mqtt_dotdot_relativity_humidity_updated_state_t &new_updated_state
) {



}


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_occupancy_sensing_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_occupancy_sensing_state_t &new_state,
  uic_mqtt_dotdot_occupancy_sensing_updated_state_t &new_updated_state
) {


  if (jsn.find("PIROccupiedToUnoccupiedDelay") != jsn.end()) {

    new_state.pir_occupied_to_unoccupied_delay = jsn.at("PIROccupiedToUnoccupiedDelay").get<uint16_t>();
        
    new_updated_state.pir_occupied_to_unoccupied_delay = true;
  }

  if (jsn.find("PIRUnoccupiedToOccupiedDelay") != jsn.end()) {

    new_state.pir_unoccupied_to_occupied_delay = jsn.at("PIRUnoccupiedToOccupiedDelay").get<uint16_t>();
        
    new_updated_state.pir_unoccupied_to_occupied_delay = true;
  }

  if (jsn.find("PIRUnoccupiedToOccupiedThreshold") != jsn.end()) {

    new_state.pir_unoccupied_to_occupied_threshold = jsn.at("PIRUnoccupiedToOccupiedThreshold").get<uint8_t>();
        
    new_updated_state.pir_unoccupied_to_occupied_threshold = true;
  }

  if (jsn.find("UltrasonicOccupiedToUnoccupiedDelay") != jsn.end()) {

    new_state.ultrasonic_occupied_to_unoccupied_delay = jsn.at("UltrasonicOccupiedToUnoccupiedDelay").get<uint16_t>();
        
    new_updated_state.ultrasonic_occupied_to_unoccupied_delay = true;
  }

  if (jsn.find("UltrasonicUnoccupiedToOccupiedDelay") != jsn.end()) {

    new_state.ultrasonic_unoccupied_to_occupied_delay = jsn.at("UltrasonicUnoccupiedToOccupiedDelay").get<uint16_t>();
        
    new_updated_state.ultrasonic_unoccupied_to_occupied_delay = true;
  }

  if (jsn.find("UltrasonicUnoccupiedToOccupiedThreshold") != jsn.end()) {

    new_state.ultrasonic_unoccupied_to_occupied_threshold = jsn.at("UltrasonicUnoccupiedToOccupiedThreshold").get<uint8_t>();
        
    new_updated_state.ultrasonic_unoccupied_to_occupied_threshold = true;
  }

  if (jsn.find("PhysicalContactOccupiedToUnoccupiedDelay") != jsn.end()) {

    new_state.physical_contact_occupied_to_unoccupied_delay = jsn.at("PhysicalContactOccupiedToUnoccupiedDelay").get<uint16_t>();
        
    new_updated_state.physical_contact_occupied_to_unoccupied_delay = true;
  }

  if (jsn.find("PhysicalContactUnoccupiedToOccupiedDelay") != jsn.end()) {

    new_state.physical_contact_unoccupied_to_occupied_delay = jsn.at("PhysicalContactUnoccupiedToOccupiedDelay").get<uint16_t>();
        
    new_updated_state.physical_contact_unoccupied_to_occupied_delay = true;
  }

  if (jsn.find("PhysicalContactUnoccupiedToOccupiedThreshold") != jsn.end()) {

    new_state.physical_contact_unoccupied_to_occupied_threshold = jsn.at("PhysicalContactUnoccupiedToOccupiedThreshold").get<uint8_t>();
        
    new_updated_state.physical_contact_unoccupied_to_occupied_threshold = true;
  }


}


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_soil_moisture_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_soil_moisture_state_t &new_state,
  uic_mqtt_dotdot_soil_moisture_updated_state_t &new_updated_state
) {



}


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_ph_measurement_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_ph_measurement_state_t &new_state,
  uic_mqtt_dotdot_ph_measurement_updated_state_t &new_updated_state
) {



}


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_electrical_conductivity_measurement_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_electrical_conductivity_measurement_state_t &new_state,
  uic_mqtt_dotdot_electrical_conductivity_measurement_updated_state_t &new_updated_state
) {



}


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_wind_speed_measurement_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_wind_speed_measurement_state_t &new_state,
  uic_mqtt_dotdot_wind_speed_measurement_updated_state_t &new_updated_state
) {



}


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_carbon_monoxide_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_carbon_monoxide_state_t &new_state,
  uic_mqtt_dotdot_carbon_monoxide_updated_state_t &new_updated_state
) {



}


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_carbon_dioxide_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_carbon_dioxide_state_t &new_state,
  uic_mqtt_dotdot_carbon_dioxide_updated_state_t &new_updated_state
) {



}


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_pm25_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_pm25_state_t &new_state,
  uic_mqtt_dotdot_pm25_updated_state_t &new_updated_state
) {



}


std::string get_json_payload_for_ias_zone_zone_enroll_response_command(
  
  const uic_mqtt_dotdot_ias_zone_command_zone_enroll_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum ZoneEnrollResponse / EnrollResponseCode
  #ifdef ZONE_ENROLL_RESPONSE_ENROLL_RESPONSE_CODE_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["EnrollResponseCode"] =
    zone_enroll_response_enroll_response_code_get_enum_value_name(
      (uint32_t)fields->enroll_response_code);
  #elif defined(ZONE_ENROLL_RESPONSE_ENROLL_RESPONSE_CODE_ENUM_NAME_AVAILABLE)
  json_payload["EnrollResponseCode"] =
    zone_enroll_response_enroll_response_code_get_enum_value_name((uint32_t)fields->enroll_response_code);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["EnrollResponseCode"] = fields->enroll_response_code;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["ZoneID"] = nlohmann::json(fields->zoneid);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_ias_zone_zone_enroll_response(
  nlohmann::json &jsn,
  ZoneEnrollResponseEnrollResponseCode &enroll_response_code,
  
  uint8_t &zoneid
  
) {

  uint32_t EnrollResponseCode_enum_val = get_enum_decimal_value<ZoneEnrollResponseEnrollResponseCode>("EnrollResponseCode", jsn);
  if (EnrollResponseCode_enum_val == std::numeric_limits<ZoneEnrollResponseEnrollResponseCode>::max()) {
    #ifdef ZONE_ENROLL_RESPONSE_ENROLL_RESPONSE_CODE_ENUM_NAME_AVAILABLE
    EnrollResponseCode_enum_val = zone_enroll_response_enroll_response_code_get_enum_value_number(jsn.at("EnrollResponseCode").get<std::string>());
    #endif
  }
  if (jsn.at("EnrollResponseCode").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  enroll_response_code = static_cast<ZoneEnrollResponseEnrollResponseCode>(EnrollResponseCode_enum_val);
  if (jsn.at("ZoneID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  zoneid = jsn.at("ZoneID").get< uint8_t >();
    }


std::string get_json_payload_for_ias_zone_zone_status_change_notification_command(
  
  const uic_mqtt_dotdot_ias_zone_command_zone_status_change_notification_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["ZoneStatus"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->zone_status,
                                IasZoneStatus);
  command_with_no_fields = false;
  // Single Value
  // Unknown bitmask: we write the value directly.
  json_payload["ExtendedStatus"] = fields->extended_status;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["ZoneID"] = nlohmann::json(fields->zoneid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Delay"] = nlohmann::json(fields->delay);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_ias_zone_zone_status_change_notification(
  nlohmann::json &jsn,
  uint16_t &zone_status,
  
  uint8_t &extended_status,
  
  uint8_t &zoneid,
  
  uint16_t &delay
  
) {

  if (jsn.at("ZoneStatus").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  zone_status = (uint16_t)uic_dotdot_mqtt::get_bitmap_decimal_value("ZoneStatus", jsn, IasZoneStatus);
  if (jsn.at("ExtendedStatus").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  extended_status = jsn.at("ExtendedStatus").get<uint8_t>();
  if (jsn.at("ZoneID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  zoneid = jsn.at("ZoneID").get< uint8_t >();
      if (jsn.at("Delay").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  delay = jsn.at("Delay").get< uint16_t >();
    }


std::string get_json_payload_for_ias_zone_initiate_normal_operation_mode_command(
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}




std::string get_json_payload_for_ias_zone_zone_enroll_request_command(
  
  const uic_mqtt_dotdot_ias_zone_command_zone_enroll_request_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Enum ZoneEnrollRequest / ZoneType
  #ifdef ZONE_ENROLL_REQUEST_ZONE_TYPE_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["ZoneType"] =
    zone_enroll_request_zone_type_get_enum_value_name(
      (uint32_t)fields->zone_type);
  #elif defined(IAS_ZONE_TYPE_ENUM_NAME_AVAILABLE)
  json_payload["ZoneType"] =
    ias_zone_type_get_enum_value_name((uint32_t)fields->zone_type);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["ZoneType"] = fields->zone_type;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["ManufacturerCode"] = nlohmann::json(fields->manufacturer_code);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_ias_zone_zone_enroll_request(
  nlohmann::json &jsn,
  IasZoneType &zone_type,
  
  uint16_t &manufacturer_code
  
) {

  uint32_t ZoneType_enum_val = get_enum_decimal_value<IasZoneType>("ZoneType", jsn);
  if (ZoneType_enum_val == std::numeric_limits<IasZoneType>::max()) {
    #ifdef IAS_ZONE_TYPE_ENUM_NAME_AVAILABLE
    ZoneType_enum_val = ias_zone_type_get_enum_value_number(jsn.at("ZoneType").get<std::string>());
    #endif
  }
  if (jsn.at("ZoneType").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  zone_type = static_cast<IasZoneType>(ZoneType_enum_val);
  if (jsn.at("ManufacturerCode").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  manufacturer_code = jsn.at("ManufacturerCode").get< uint16_t >();
    }


std::string get_json_payload_for_ias_zone_initiate_test_mode_command(
  
  const uic_mqtt_dotdot_ias_zone_command_initiate_test_mode_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["TestModeDuration"] = nlohmann::json(fields->test_mode_duration);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["CurrentZoneSensitivityLevel"] = nlohmann::json(fields->current_zone_sensitivity_level);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_ias_zone_initiate_test_mode(
  nlohmann::json &jsn,
  uint8_t &test_mode_duration,
  
  uint8_t &current_zone_sensitivity_level
  
) {

  if (jsn.at("TestModeDuration").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  test_mode_duration = jsn.at("TestModeDuration").get< uint8_t >();
      if (jsn.at("CurrentZoneSensitivityLevel").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  current_zone_sensitivity_level = jsn.at("CurrentZoneSensitivityLevel").get< uint8_t >();
    }


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_ias_zone_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_ias_zone_state_t &new_state,
  uic_mqtt_dotdot_ias_zone_updated_state_t &new_updated_state
) {


  if (jsn.find("IASCIEAddress") != jsn.end()) {

    new_state.iascie_address = jsn.at("IASCIEAddress").get<EUI64>();
        
    new_updated_state.iascie_address = true;
  }

  if (jsn.find("CurrentZoneSensitivityLevel") != jsn.end()) {

    new_state.current_zone_sensitivity_level = jsn.at("CurrentZoneSensitivityLevel").get<uint8_t>();
        
    new_updated_state.current_zone_sensitivity_level = true;
  }


}


std::string get_json_payload_for_iaswd_start_warning_command(
  
  const uic_mqtt_dotdot_iaswd_command_start_warning_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["SirenConfiguration"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->siren_configuration,
                                StartWarningSirenConfiguration);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["WarningDuration"] = nlohmann::json(fields->warning_duration);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["StrobeDutyCycle"] = nlohmann::json(fields->strobe_duty_cycle);
  command_with_no_fields = false;
  // Single Value
  // Enum StartWarning / StrobeLevel
  #ifdef START_WARNING_STROBE_LEVEL_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["StrobeLevel"] =
    start_warning_strobe_level_get_enum_value_name(
      (uint32_t)fields->strobe_level);
  #elif defined(IASWD_LEVEL_ENUM_NAME_AVAILABLE)
  json_payload["StrobeLevel"] =
    iaswd_level_get_enum_value_name((uint32_t)fields->strobe_level);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["StrobeLevel"] = fields->strobe_level;
  #endif

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_iaswd_start_warning(
  nlohmann::json &jsn,
  uint8_t &siren_configuration,
  
  uint16_t &warning_duration,
  
  uint8_t &strobe_duty_cycle,
  
  IaswdLevel &strobe_level
  
) {

  uint32_t StrobeLevel_enum_val = get_enum_decimal_value<IaswdLevel>("StrobeLevel", jsn);
  if (StrobeLevel_enum_val == std::numeric_limits<IaswdLevel>::max()) {
    #ifdef IASWD_LEVEL_ENUM_NAME_AVAILABLE
    StrobeLevel_enum_val = iaswd_level_get_enum_value_number(jsn.at("StrobeLevel").get<std::string>());
    #endif
  }
  if (jsn.at("SirenConfiguration").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  siren_configuration = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("SirenConfiguration", jsn, StartWarningSirenConfiguration);
  if (jsn.at("WarningDuration").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  warning_duration = jsn.at("WarningDuration").get< uint16_t >();
      if (jsn.at("StrobeDutyCycle").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  strobe_duty_cycle = jsn.at("StrobeDutyCycle").get< uint8_t >();
      if (jsn.at("StrobeLevel").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  strobe_level = static_cast<IaswdLevel>(StrobeLevel_enum_val);
}


std::string get_json_payload_for_iaswd_squawk_command(
  
  const uic_mqtt_dotdot_iaswd_command_squawk_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Known bitmask, pull the list of "names" from the value
  json_payload["SquawkConfiguration"] = uic_dotdot_mqtt::get_bitmap_value_names(
                                (uint32_t)fields->squawk_configuration,
                                SquawkSquawkConfiguration);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_iaswd_squawk(
  nlohmann::json &jsn,
  uint8_t &squawk_configuration
  
) {

  if (jsn.at("SquawkConfiguration").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  squawk_configuration = (uint8_t)uic_dotdot_mqtt::get_bitmap_decimal_value("SquawkConfiguration", jsn, SquawkSquawkConfiguration);
}


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_iaswd_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_iaswd_state_t &new_state,
  uic_mqtt_dotdot_iaswd_updated_state_t &new_updated_state
) {


  if (jsn.find("MaxDuration") != jsn.end()) {

    new_state.max_duration = jsn.at("MaxDuration").get<uint16_t>();
        
    new_updated_state.max_duration = true;
  }


}


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_metering_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_metering_state_t &new_state,
  uic_mqtt_dotdot_metering_updated_state_t &new_updated_state
) {



}


std::string get_json_payload_for_electrical_measurement_get_profile_info_response_command(
  
  const uic_mqtt_dotdot_electrical_measurement_command_get_profile_info_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["ProfileCount"] = nlohmann::json(fields->profile_count);
  command_with_no_fields = false;
  // Single Value
  // Enum GetProfileInfoResponse / ProfileIntervalPeriod
  #ifdef GET_PROFILE_INFO_RESPONSE_PROFILE_INTERVAL_PERIOD_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["ProfileIntervalPeriod"] =
    get_profile_info_response_profile_interval_period_get_enum_value_name(
      (uint32_t)fields->profile_interval_period);
  #elif defined(PROFILE_INTERVAL_PERIOD_ENUM_NAME_AVAILABLE)
  json_payload["ProfileIntervalPeriod"] =
    profile_interval_period_get_enum_value_name((uint32_t)fields->profile_interval_period);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["ProfileIntervalPeriod"] = fields->profile_interval_period;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["MaxNumberOfIntervals"] = nlohmann::json(fields->max_number_of_intervals);
  command_with_no_fields = false;
  // We assume arrays are Non-enum and non-bitmask (struct, string or scalar)
  json_payload["ListOfAttributes"] = std::vector< uint16_t >(
    fields->list_of_attributes,
    fields->list_of_attributes + fields->list_of_attributes_count);


  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_electrical_measurement_get_profile_info_response(
  nlohmann::json &jsn,
  uint8_t &profile_count,
  
  ProfileIntervalPeriod &profile_interval_period,
  
  uint8_t &max_number_of_intervals,
  
  std::vector<uint16_t> &list_of_attributes

) {

  uint32_t ProfileIntervalPeriod_enum_val = get_enum_decimal_value<ProfileIntervalPeriod>("ProfileIntervalPeriod", jsn);
  if (ProfileIntervalPeriod_enum_val == std::numeric_limits<ProfileIntervalPeriod>::max()) {
    #ifdef PROFILE_INTERVAL_PERIOD_ENUM_NAME_AVAILABLE
    ProfileIntervalPeriod_enum_val = profile_interval_period_get_enum_value_number(jsn.at("ProfileIntervalPeriod").get<std::string>());
    #endif
  }
  if (jsn.at("ProfileCount").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  profile_count = jsn.at("ProfileCount").get< uint8_t >();
      if (jsn.at("ProfileIntervalPeriod").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  profile_interval_period = static_cast<ProfileIntervalPeriod>(ProfileIntervalPeriod_enum_val);
  if (jsn.at("MaxNumberOfIntervals").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  max_number_of_intervals = jsn.at("MaxNumberOfIntervals").get< uint8_t >();
      if (jsn.at("ListOfAttributes").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  list_of_attributes = jsn.at("ListOfAttributes").get< std::vector< uint16_t >>();
      }


std::string get_json_payload_for_electrical_measurement_get_profile_info_command(
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}




std::string get_json_payload_for_electrical_measurement_get_measurement_profile_response_command(
  
  const uic_mqtt_dotdot_electrical_measurement_command_get_measurement_profile_response_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["StartTime"] = nlohmann::json(fields->start_time);
  command_with_no_fields = false;
  // Single Value
  // Enum GetMeasurementProfileResponse / Status
  #ifdef GET_MEASUREMENT_PROFILE_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["Status"] =
    get_measurement_profile_response_status_get_enum_value_name(
      (uint32_t)fields->status);
  #elif defined(GET_MEASUREMENT_PROFILE_RESPONSE_STATUS_ENUM_NAME_AVAILABLE)
  json_payload["Status"] =
    get_measurement_profile_response_status_get_enum_value_name((uint32_t)fields->status);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["Status"] = fields->status;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Enum GetMeasurementProfileResponse / ProfileIntervalPeriod
  #ifdef GET_MEASUREMENT_PROFILE_RESPONSE_PROFILE_INTERVAL_PERIOD_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["ProfileIntervalPeriod"] =
    get_measurement_profile_response_profile_interval_period_get_enum_value_name(
      (uint32_t)fields->profile_interval_period);
  #elif defined(PROFILE_INTERVAL_PERIOD_ENUM_NAME_AVAILABLE)
  json_payload["ProfileIntervalPeriod"] =
    profile_interval_period_get_enum_value_name((uint32_t)fields->profile_interval_period);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["ProfileIntervalPeriod"] = fields->profile_interval_period;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["NumberOfIntervalsDelivered"] = nlohmann::json(fields->number_of_intervals_delivered);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["AttributeId"] = nlohmann::json(fields->attribute_id);
  command_with_no_fields = false;
  // We assume arrays are Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Intervals"] = std::vector< uint8_t >(
    fields->intervals,
    fields->intervals + fields->intervals_count);


  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_electrical_measurement_get_measurement_profile_response(
  nlohmann::json &jsn,
  UTC &start_time,
  
  GetMeasurementProfileResponseStatus &status,
  
  ProfileIntervalPeriod &profile_interval_period,
  
  uint8_t &number_of_intervals_delivered,
  
  uint16_t &attribute_id,
  
  std::vector<uint8_t> &intervals

) {

  uint32_t Status_enum_val = get_enum_decimal_value<GetMeasurementProfileResponseStatus>("Status", jsn);
  if (Status_enum_val == std::numeric_limits<GetMeasurementProfileResponseStatus>::max()) {
    #ifdef GET_MEASUREMENT_PROFILE_RESPONSE_STATUS_ENUM_NAME_AVAILABLE
    Status_enum_val = get_measurement_profile_response_status_get_enum_value_number(jsn.at("Status").get<std::string>());
    #endif
  }
  uint32_t ProfileIntervalPeriod_enum_val = get_enum_decimal_value<ProfileIntervalPeriod>("ProfileIntervalPeriod", jsn);
  if (ProfileIntervalPeriod_enum_val == std::numeric_limits<ProfileIntervalPeriod>::max()) {
    #ifdef PROFILE_INTERVAL_PERIOD_ENUM_NAME_AVAILABLE
    ProfileIntervalPeriod_enum_val = profile_interval_period_get_enum_value_number(jsn.at("ProfileIntervalPeriod").get<std::string>());
    #endif
  }
  if (jsn.at("StartTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  start_time = jsn.at("StartTime").get< UTC >();
      if (jsn.at("Status").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  status = static_cast<GetMeasurementProfileResponseStatus>(Status_enum_val);
  if (jsn.at("ProfileIntervalPeriod").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  profile_interval_period = static_cast<ProfileIntervalPeriod>(ProfileIntervalPeriod_enum_val);
  if (jsn.at("NumberOfIntervalsDelivered").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  number_of_intervals_delivered = jsn.at("NumberOfIntervalsDelivered").get< uint8_t >();
      if (jsn.at("AttributeId").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  attribute_id = jsn.at("AttributeId").get< uint16_t >();
      if (jsn.at("Intervals").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  intervals = jsn.at("Intervals").get< std::vector< uint8_t >>();
      }


std::string get_json_payload_for_electrical_measurement_get_measurement_profile_command(
  
  const uic_mqtt_dotdot_electrical_measurement_command_get_measurement_profile_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["AttributeID"] = nlohmann::json(fields->attributeid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["StartTime"] = nlohmann::json(fields->start_time);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["NumberOfIntervals"] = nlohmann::json(fields->number_of_intervals);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_electrical_measurement_get_measurement_profile(
  nlohmann::json &jsn,
  uint16_t &attributeid,
  
  UTC &start_time,
  
  uint8_t &number_of_intervals
  
) {

  if (jsn.at("AttributeID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  attributeid = jsn.at("AttributeID").get< uint16_t >();
      if (jsn.at("StartTime").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  start_time = jsn.at("StartTime").get< UTC >();
      if (jsn.at("NumberOfIntervals").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  number_of_intervals = jsn.at("NumberOfIntervals").get< uint8_t >();
    }


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_electrical_measurement_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_electrical_measurement_state_t &new_state,
  uic_mqtt_dotdot_electrical_measurement_updated_state_t &new_updated_state
) {


  if (jsn.find("AverageRMSVoltageMeasurementPeriod") != jsn.end()) {

    new_state.averagerms_voltage_measurement_period = jsn.at("AverageRMSVoltageMeasurementPeriod").get<uint16_t>();
        
    new_updated_state.averagerms_voltage_measurement_period = true;
  }

  if (jsn.find("AverageRMSOverVoltageCounter") != jsn.end()) {

    new_state.averagerms_over_voltage_counter = jsn.at("AverageRMSOverVoltageCounter").get<uint16_t>();
        
    new_updated_state.averagerms_over_voltage_counter = true;
  }

  if (jsn.find("AverageRMSUnderVoltageCounter") != jsn.end()) {

    new_state.averagerms_under_voltage_counter = jsn.at("AverageRMSUnderVoltageCounter").get<uint16_t>();
        
    new_updated_state.averagerms_under_voltage_counter = true;
  }

  if (jsn.find("RMSExtremeOverVoltagePeriod") != jsn.end()) {

    new_state.rms_extreme_over_voltage_period = jsn.at("RMSExtremeOverVoltagePeriod").get<uint16_t>();
        
    new_updated_state.rms_extreme_over_voltage_period = true;
  }

  if (jsn.find("RMSExtremeUnderVoltagePeriod") != jsn.end()) {

    new_state.rms_extreme_under_voltage_period = jsn.at("RMSExtremeUnderVoltagePeriod").get<uint16_t>();
        
    new_updated_state.rms_extreme_under_voltage_period = true;
  }

  if (jsn.find("RMSVoltageSagPeriod") != jsn.end()) {

    new_state.rms_voltage_sag_period = jsn.at("RMSVoltageSagPeriod").get<uint16_t>();
        
    new_updated_state.rms_voltage_sag_period = true;
  }

  if (jsn.find("RMSVoltageSwellPeriod") != jsn.end()) {

    new_state.rms_voltage_swell_period = jsn.at("RMSVoltageSwellPeriod").get<uint16_t>();
        
    new_updated_state.rms_voltage_swell_period = true;
  }

  if (jsn.find("DCOverloadAlarmsMask") != jsn.end()) {

    new_state.dc_overload_alarms_mask = uic_dotdot_mqtt::get_bitmap_decimal_value("DCOverloadAlarmsMask", jsn, ElectricalMeasurementDCOverloadAlarmsMask);
  
    new_updated_state.dc_overload_alarms_mask = true;
  }

  if (jsn.find("ACAlarmsMask") != jsn.end()) {

    new_state.ac_alarms_mask = uic_dotdot_mqtt::get_bitmap_decimal_value("ACAlarmsMask", jsn, ElectricalMeasurementACAlarmsMask);
  
    new_updated_state.ac_alarms_mask = true;
  }

  if (jsn.find("RMSExtremeOverVoltage") != jsn.end()) {

    new_state.rms_extreme_over_voltage = jsn.at("RMSExtremeOverVoltage").get<int16_t>();
        
    new_updated_state.rms_extreme_over_voltage = true;
  }

  if (jsn.find("RMSExtremeUnderVoltage") != jsn.end()) {

    new_state.rms_extreme_under_voltage = jsn.at("RMSExtremeUnderVoltage").get<int16_t>();
        
    new_updated_state.rms_extreme_under_voltage = true;
  }

  if (jsn.find("RMSVoltageSag") != jsn.end()) {

    new_state.rms_voltage_sag = jsn.at("RMSVoltageSag").get<int16_t>();
        
    new_updated_state.rms_voltage_sag = true;
  }

  if (jsn.find("RMSVoltageSwell") != jsn.end()) {

    new_state.rms_voltage_swell = jsn.at("RMSVoltageSwell").get<int16_t>();
        
    new_updated_state.rms_voltage_swell = true;
  }

  if (jsn.find("AverageRMSVoltageMeasurementPeriodPhB") != jsn.end()) {

    new_state.averagerms_voltage_measurement_period_phb = jsn.at("AverageRMSVoltageMeasurementPeriodPhB").get<uint16_t>();
        
    new_updated_state.averagerms_voltage_measurement_period_phb = true;
  }

  if (jsn.find("AverageRMSOverVoltageCounterPhB") != jsn.end()) {

    new_state.averagerms_over_voltage_counter_phb = jsn.at("AverageRMSOverVoltageCounterPhB").get<uint16_t>();
        
    new_updated_state.averagerms_over_voltage_counter_phb = true;
  }

  if (jsn.find("AverageRMSUnderVoltageCounterPhB") != jsn.end()) {

    new_state.averagerms_under_voltage_counter_phb = jsn.at("AverageRMSUnderVoltageCounterPhB").get<uint16_t>();
        
    new_updated_state.averagerms_under_voltage_counter_phb = true;
  }

  if (jsn.find("RMSExtremeOverVoltagePeriodPhB") != jsn.end()) {

    new_state.rms_extreme_over_voltage_period_phb = jsn.at("RMSExtremeOverVoltagePeriodPhB").get<uint16_t>();
        
    new_updated_state.rms_extreme_over_voltage_period_phb = true;
  }

  if (jsn.find("RMSExtremeUnderVoltagePeriodPhB") != jsn.end()) {

    new_state.rms_extreme_under_voltage_period_phb = jsn.at("RMSExtremeUnderVoltagePeriodPhB").get<uint16_t>();
        
    new_updated_state.rms_extreme_under_voltage_period_phb = true;
  }

  if (jsn.find("RMSVoltageSagPeriodPhB") != jsn.end()) {

    new_state.rms_voltage_sag_period_phb = jsn.at("RMSVoltageSagPeriodPhB").get<uint16_t>();
        
    new_updated_state.rms_voltage_sag_period_phb = true;
  }

  if (jsn.find("RMSVoltageSwellPeriodPhB") != jsn.end()) {

    new_state.rms_voltage_swell_period_phb = jsn.at("RMSVoltageSwellPeriodPhB").get<uint16_t>();
        
    new_updated_state.rms_voltage_swell_period_phb = true;
  }

  if (jsn.find("AverageRMSVoltageMeasurementPeriodPhC") != jsn.end()) {

    new_state.averagerms_voltage_measurement_period_phc = jsn.at("AverageRMSVoltageMeasurementPeriodPhC").get<uint16_t>();
        
    new_updated_state.averagerms_voltage_measurement_period_phc = true;
  }

  if (jsn.find("AverageRMSOverVoltageCounterPhC") != jsn.end()) {

    new_state.averagerms_over_voltage_counter_phc = jsn.at("AverageRMSOverVoltageCounterPhC").get<uint16_t>();
        
    new_updated_state.averagerms_over_voltage_counter_phc = true;
  }

  if (jsn.find("AverageRMSUnderVoltageCounterPhC") != jsn.end()) {

    new_state.averagerms_under_voltage_counter_phc = jsn.at("AverageRMSUnderVoltageCounterPhC").get<uint16_t>();
        
    new_updated_state.averagerms_under_voltage_counter_phc = true;
  }

  if (jsn.find("RMSExtremeOverVoltagePeriodPhC") != jsn.end()) {

    new_state.rms_extreme_over_voltage_period_phc = jsn.at("RMSExtremeOverVoltagePeriodPhC").get<uint16_t>();
        
    new_updated_state.rms_extreme_over_voltage_period_phc = true;
  }

  if (jsn.find("RMSExtremeUnderVoltagePeriodPhC") != jsn.end()) {

    new_state.rms_extreme_under_voltage_period_phc = jsn.at("RMSExtremeUnderVoltagePeriodPhC").get<uint16_t>();
        
    new_updated_state.rms_extreme_under_voltage_period_phc = true;
  }

  if (jsn.find("RMSVoltageSagPeriodPhC") != jsn.end()) {

    new_state.rms_voltage_sag_period_phc = jsn.at("RMSVoltageSagPeriodPhC").get<uint16_t>();
        
    new_updated_state.rms_voltage_sag_period_phc = true;
  }

  if (jsn.find("RMSVoltageSwellPeriodPhC") != jsn.end()) {

    new_state.rms_voltage_swell_period_phc = jsn.at("RMSVoltageSwellPeriodPhC").get<uint16_t>();
        
    new_updated_state.rms_voltage_swell_period_phc = true;
  }


}


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_diagnostics_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_diagnostics_state_t &new_state,
  uic_mqtt_dotdot_diagnostics_updated_state_t &new_updated_state
) {



}


std::string get_json_payload_for_protocol_controller_rf_telemetry_tx_report_command(
  
  const uic_mqtt_dotdot_protocol_controller_rf_telemetry_command_tx_report_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["SourceUNID"] = nlohmann::json(fields->sourceunid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["DestinationUNID"] = nlohmann::json(fields->destinationunid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["TransmissionSuccessful"] = nlohmann::json(fields->transmission_successful);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["TransmissionTimeMs"] = nlohmann::json(fields->transmission_time_ms);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["TxPowerdBm"] = nlohmann::json(fields->tx_powerd_bm);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["TxChannel"] = nlohmann::json(fields->tx_channel);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["RoutingAttempts"] = nlohmann::json(fields->routing_attempts);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["RouteChanged"] = nlohmann::json(fields->route_changed);
  command_with_no_fields = false;
  // Single Value
  // Enum TxReport / TransmissionSpeed
  #ifdef TX_REPORT_TRANSMISSION_SPEED_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["TransmissionSpeed"] =
    tx_report_transmission_speed_get_enum_value_name(
      (uint32_t)fields->transmission_speed);
  #elif defined(TX_REPORT_TRANSMISSION_SPEED_ENUM_NAME_AVAILABLE)
  json_payload["TransmissionSpeed"] =
    tx_report_transmission_speed_get_enum_value_name((uint32_t)fields->transmission_speed);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["TransmissionSpeed"] = fields->transmission_speed;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["MeasuredNoiseFloordBm"] = nlohmann::json(fields->measured_noise_floord_bm);
  command_with_no_fields = false;
  // We assume arrays are Non-enum and non-bitmask (struct, string or scalar)
  json_payload["LastRouteRepeaters"] = std::vector< const char* >(
    fields->last_route_repeaters,
    fields->last_route_repeaters + fields->last_route_repeaters_count);

  command_with_no_fields = false;
  // We assume arrays are Non-enum and non-bitmask (struct, string or scalar)
  json_payload["IncomingRSSIRepeaters"] = std::vector< int8_t >(
    fields->incomingrssi_repeaters,
    fields->incomingrssi_repeaters + fields->incomingrssi_repeaters_count);

  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["AckRSSI"] = nlohmann::json(fields->ackrssi);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["AckChannel"] = nlohmann::json(fields->ack_channel);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["LastRouteFailedLinkFunctionalUNID"] = nlohmann::json(fields->last_route_failed_link_functionalunid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["LastRouteFailedLinkNonFunctionalUNID"] = nlohmann::json(fields->last_route_failed_link_non_functionalunid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["DestinationAckTxPowerdBm"] = nlohmann::json(fields->destination_ack_tx_powerd_bm);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["DestinationAckMeasuredRSSI"] = nlohmann::json(fields->destination_ack_measuredrssi);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["DestinationAckMeasuredNoiseFloor"] = nlohmann::json(fields->destination_ack_measured_noise_floor);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_protocol_controller_rf_telemetry_tx_report(
  nlohmann::json &jsn,
  std::string &sourceunid,
  
  std::string &destinationunid,
  
  bool &transmission_successful,
  
  uint16_t &transmission_time_ms,
  
  int8_t &tx_powerd_bm,
  
  uint8_t &tx_channel,
  
  uint8_t &routing_attempts,
  
  bool &route_changed,
  
  TxReportTransmissionSpeed &transmission_speed,
  
  int8_t &measured_noise_floord_bm,
  
  std::vector<std::string> &last_route_repeaters,

  std::vector<int8_t> &incomingrssi_repeaters,

  int8_t &ackrssi,
  
  uint8_t &ack_channel,
  
  std::string &last_route_failed_link_functionalunid,
  
  std::string &last_route_failed_link_non_functionalunid,
  
  int8_t &destination_ack_tx_powerd_bm,
  
  int8_t &destination_ack_measuredrssi,
  
  int8_t &destination_ack_measured_noise_floor
  
) {

  uint32_t TransmissionSpeed_enum_val = get_enum_decimal_value<TxReportTransmissionSpeed>("TransmissionSpeed", jsn);
  if (TransmissionSpeed_enum_val == std::numeric_limits<TxReportTransmissionSpeed>::max()) {
    #ifdef TX_REPORT_TRANSMISSION_SPEED_ENUM_NAME_AVAILABLE
    TransmissionSpeed_enum_val = tx_report_transmission_speed_get_enum_value_number(jsn.at("TransmissionSpeed").get<std::string>());
    #endif
  }
  if (jsn.at("SourceUNID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  sourceunid = jsn.at("SourceUNID").get<std::string>();
            if (jsn.at("DestinationUNID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  destinationunid = jsn.at("DestinationUNID").get<std::string>();
            if (jsn.at("TransmissionSuccessful").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  transmission_successful = jsn.at("TransmissionSuccessful").get< bool >();
      if (jsn.at("TransmissionTimeMs").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  transmission_time_ms = jsn.at("TransmissionTimeMs").get< uint16_t >();
      if (jsn.at("TxPowerdBm").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  tx_powerd_bm = jsn.at("TxPowerdBm").get< int8_t >();
      if (jsn.at("TxChannel").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  tx_channel = jsn.at("TxChannel").get< uint8_t >();
      if (jsn.at("RoutingAttempts").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  routing_attempts = jsn.at("RoutingAttempts").get< uint8_t >();
      if (jsn.at("RouteChanged").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  route_changed = jsn.at("RouteChanged").get< bool >();
      if (jsn.at("TransmissionSpeed").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  transmission_speed = static_cast<TxReportTransmissionSpeed>(TransmissionSpeed_enum_val);
  if (jsn.at("MeasuredNoiseFloordBm").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  measured_noise_floord_bm = jsn.at("MeasuredNoiseFloordBm").get< int8_t >();
      if (jsn.at("LastRouteRepeaters").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  for (auto &LastRouteRepeaters_el : jsn.at("LastRouteRepeaters")) {
    last_route_repeaters.push_back(LastRouteRepeaters_el.get<std::string>());
  }
        if (jsn.at("IncomingRSSIRepeaters").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  incomingrssi_repeaters = jsn.at("IncomingRSSIRepeaters").get< std::vector< int8_t >>();
        if (jsn.at("AckRSSI").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  ackrssi = jsn.at("AckRSSI").get< int8_t >();
      if (jsn.at("AckChannel").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  ack_channel = jsn.at("AckChannel").get< uint8_t >();
      if (jsn.at("LastRouteFailedLinkFunctionalUNID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  last_route_failed_link_functionalunid = jsn.at("LastRouteFailedLinkFunctionalUNID").get<std::string>();
            if (jsn.at("LastRouteFailedLinkNonFunctionalUNID").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  last_route_failed_link_non_functionalunid = jsn.at("LastRouteFailedLinkNonFunctionalUNID").get<std::string>();
            if (jsn.at("DestinationAckTxPowerdBm").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  destination_ack_tx_powerd_bm = jsn.at("DestinationAckTxPowerdBm").get< int8_t >();
      if (jsn.at("DestinationAckMeasuredRSSI").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  destination_ack_measuredrssi = jsn.at("DestinationAckMeasuredRSSI").get< int8_t >();
      if (jsn.at("DestinationAckMeasuredNoiseFloor").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  destination_ack_measured_noise_floor = jsn.at("DestinationAckMeasuredNoiseFloor").get< int8_t >();
    }


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_protocol_controller_rf_telemetry_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_protocol_controller_rf_telemetry_state_t &new_state,
  uic_mqtt_dotdot_protocol_controller_rf_telemetry_updated_state_t &new_updated_state
) {


  if (jsn.find("TxReportEnabled") != jsn.end()) {

    new_state.tx_report_enabled = get_bool_from_json(jsn, "TxReportEnabled");
  
    new_updated_state.tx_report_enabled = true;
  }

  if (jsn.find("PTIEnabled") != jsn.end()) {

    new_state.pti_enabled = get_bool_from_json(jsn, "PTIEnabled");
  
    new_updated_state.pti_enabled = true;
  }


}


std::string get_json_payload_for_state_remove_command(
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}




std::string get_json_payload_for_state_remove_offline_command(
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}




std::string get_json_payload_for_state_discover_neighbors_command(
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}




std::string get_json_payload_for_state_interview_command(
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}




std::string get_json_payload_for_state_discover_security_command(
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}




/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_state_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_state_state_t &new_state,
  uic_mqtt_dotdot_state_updated_state_t &new_updated_state
) {



}


std::string get_json_payload_for_binding_bind_command(
  
  const uic_mqtt_dotdot_binding_command_bind_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["ClusterName"] = nlohmann::json(fields->cluster_name);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["DestinationUnid"] = nlohmann::json(fields->destination_unid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["DestinationEp"] = nlohmann::json(fields->destination_ep);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_binding_bind(
  nlohmann::json &jsn,
  std::string &cluster_name,
  
  std::string &destination_unid,
  
  uint8_t &destination_ep
  
) {

  if (jsn.at("ClusterName").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  cluster_name = jsn.at("ClusterName").get<std::string>();
            if (jsn.at("DestinationUnid").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  destination_unid = jsn.at("DestinationUnid").get<std::string>();
            if (jsn.at("DestinationEp").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  destination_ep = jsn.at("DestinationEp").get< uint8_t >();
    }


std::string get_json_payload_for_binding_unbind_command(
  
  const uic_mqtt_dotdot_binding_command_unbind_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["ClusterName"] = nlohmann::json(fields->cluster_name);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["DestinationUnid"] = nlohmann::json(fields->destination_unid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["DestinationEp"] = nlohmann::json(fields->destination_ep);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_binding_unbind(
  nlohmann::json &jsn,
  std::string &cluster_name,
  
  std::string &destination_unid,
  
  uint8_t &destination_ep
  
) {

  if (jsn.at("ClusterName").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  cluster_name = jsn.at("ClusterName").get<std::string>();
            if (jsn.at("DestinationUnid").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  destination_unid = jsn.at("DestinationUnid").get<std::string>();
            if (jsn.at("DestinationEp").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  destination_ep = jsn.at("DestinationEp").get< uint8_t >();
    }


std::string get_json_payload_for_binding_bind_to_protocol_controller_command(
  
  const uic_mqtt_dotdot_binding_command_bind_to_protocol_controller_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["ClusterName"] = nlohmann::json(fields->cluster_name);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_binding_bind_to_protocol_controller(
  nlohmann::json &jsn,
  std::string &cluster_name
  
) {

  if (jsn.at("ClusterName").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  cluster_name = jsn.at("ClusterName").get<std::string>();
          }


std::string get_json_payload_for_binding_unbind_from_protocol_controller_command(
  
  const uic_mqtt_dotdot_binding_command_unbind_from_protocol_controller_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["ClusterName"] = nlohmann::json(fields->cluster_name);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_binding_unbind_from_protocol_controller(
  nlohmann::json &jsn,
  std::string &cluster_name
  
) {

  if (jsn.at("ClusterName").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  cluster_name = jsn.at("ClusterName").get<std::string>();
          }


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_binding_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_binding_state_t &new_state,
  uic_mqtt_dotdot_binding_updated_state_t &new_updated_state
) {



}


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_system_metrics_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_system_metrics_state_t &new_state,
  uic_mqtt_dotdot_system_metrics_updated_state_t &new_updated_state
) {


  if (jsn.find("ReportingIntervalSeconds") != jsn.end()) {

    new_state.reporting_interval_seconds = jsn.at("ReportingIntervalSeconds").get<uint32_t>();
        
    new_updated_state.reporting_interval_seconds = true;
  }


}


std::string get_json_payload_for_application_monitoring_log_entry_command(
  
  const uic_mqtt_dotdot_application_monitoring_command_log_entry_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Timestamp"] = nlohmann::json(fields->timestamp);
  command_with_no_fields = false;
  // Single Value
  // Enum LogEntry / LogLevel
  #ifdef LOG_ENTRY_LOG_LEVEL_ENUM_NAME_AVAILABLE
  // Pick up the name from the value.
  json_payload["LogLevel"] =
    log_entry_log_level_get_enum_value_name(
      (uint32_t)fields->log_level);
  #elif defined(LOGGING_LEVEL_ENUM_ENUM_NAME_AVAILABLE)
  json_payload["LogLevel"] =
    logging_level_enum_get_enum_value_name((uint32_t)fields->log_level);
  #else
  // If there is no name value for the enum, just write it directly.
  json_payload["LogLevel"] = fields->log_level;
  #endif
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["LogTag"] = nlohmann::json(fields->log_tag);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["LogMessage"] = nlohmann::json(fields->log_message);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_application_monitoring_log_entry(
  nlohmann::json &jsn,
  std::string &timestamp,
  
  LoggingLevelEnum &log_level,
  
  std::string &log_tag,
  
  std::string &log_message
  
) {

  uint32_t LogLevel_enum_val = get_enum_decimal_value<LoggingLevelEnum>("LogLevel", jsn);
  if (LogLevel_enum_val == std::numeric_limits<LoggingLevelEnum>::max()) {
    #ifdef LOGGING_LEVEL_ENUM_ENUM_NAME_AVAILABLE
    LogLevel_enum_val = logging_level_enum_get_enum_value_number(jsn.at("LogLevel").get<std::string>());
    #endif
  }
  if (jsn.at("Timestamp").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  timestamp = jsn.at("Timestamp").get<std::string>();
            if (jsn.at("LogLevel").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
  log_level = static_cast<LoggingLevelEnum>(LogLevel_enum_val);
  if (jsn.at("LogTag").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  log_tag = jsn.at("LogTag").get<std::string>();
            if (jsn.at("LogMessage").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  log_message = jsn.at("LogMessage").get<std::string>();
          }


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_application_monitoring_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_application_monitoring_state_t &new_state,
  uic_mqtt_dotdot_application_monitoring_updated_state_t &new_updated_state
) {


  if (jsn.find("MQTTLoggingEnabled") != jsn.end()) {

    new_state.mqtt_logging_enabled = get_bool_from_json(jsn, "MQTTLoggingEnabled");
  
    new_updated_state.mqtt_logging_enabled = true;
  }

  if (jsn.find("MQTTLoggingLevel") != jsn.end()) {

    uint32_t tmp = get_enum_decimal_value<LoggingLevelEnum>("MQTTLoggingLevel", jsn);
    if (tmp == std::numeric_limits<LoggingLevelEnum>::max()) {
      #ifdef APPLICATION_MONITORING_MQTT_LOGGING_LEVEL_ENUM_NAME_AVAILABLE
      tmp = application_monitoring_mqtt_logging_level_get_enum_value_number(jsn.at("MQTTLoggingLevel").get<std::string>());
      #elif defined(MQTT_LOGGING_LEVEL_ENUM_NAME_AVAILABLE)
      tmp = mqtt_logging_level_get_enum_value_number(jsn.at("MQTTLoggingLevel").get<std::string>());
      #endif
    }
    new_state.mqtt_logging_level = tmp;
  
    new_updated_state.mqtt_logging_level = true;
  }

  if (jsn.find("MQTTStatisticsReportingIntervalSeconds") != jsn.end()) {

    new_state.mqtt_statistics_reporting_interval_seconds = jsn.at("MQTTStatisticsReportingIntervalSeconds").get<uint32_t>();
        
    new_updated_state.mqtt_statistics_reporting_interval_seconds = true;
  }

  if (jsn.find("ApplicationStatisticsReportingIntervalSeconds") != jsn.end()) {

    new_state.application_statistics_reporting_interval_seconds = jsn.at("ApplicationStatisticsReportingIntervalSeconds").get<uint32_t>();
        
    new_updated_state.application_statistics_reporting_interval_seconds = true;
  }


}


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_name_and_location_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_name_and_location_state_t &new_state,
  uic_mqtt_dotdot_name_and_location_updated_state_t &new_updated_state
) {


  if (jsn.find("Name") != jsn.end()) {

    new_state.name = jsn.at("Name").get_ptr<const std::string*>()->c_str();
  
    new_updated_state.name = true;
  }

  if (jsn.find("Location") != jsn.end()) {

    new_state.location = jsn.at("Location").get_ptr<const std::string*>()->c_str();
  
    new_updated_state.location = true;
  }


}


std::string get_json_payload_for_configuration_parameters_discover_parameter_command(
  
  const uic_mqtt_dotdot_configuration_parameters_command_discover_parameter_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["ParameterId"] = nlohmann::json(fields->parameter_id);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_configuration_parameters_discover_parameter(
  nlohmann::json &jsn,
  uint16_t &parameter_id
  
) {

  if (jsn.at("ParameterId").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  parameter_id = jsn.at("ParameterId").get< uint16_t >();
    }


std::string get_json_payload_for_configuration_parameters_default_reset_all_parameters_command(
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}




std::string get_json_payload_for_configuration_parameters_set_parameter_command(
  
  const uic_mqtt_dotdot_configuration_parameters_command_set_parameter_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["ParameterId"] = nlohmann::json(fields->parameter_id);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Value"] = nlohmann::json(fields->value);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_configuration_parameters_set_parameter(
  nlohmann::json &jsn,
  uint16_t &parameter_id,
  
  int64_t &value
  
) {

  if (jsn.at("ParameterId").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  parameter_id = jsn.at("ParameterId").get< uint16_t >();
      if (jsn.at("Value").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  value = jsn.at("Value").get< int64_t >();
    }


std::string get_json_payload_for_configuration_parameters_discover_parameter_range_command(
  
  const uic_mqtt_dotdot_configuration_parameters_command_discover_parameter_range_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["FirstParameterId"] = nlohmann::json(fields->first_parameter_id);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["LastParameterId"] = nlohmann::json(fields->last_parameter_id);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_configuration_parameters_discover_parameter_range(
  nlohmann::json &jsn,
  uint16_t &first_parameter_id,
  
  uint16_t &last_parameter_id
  
) {

  if (jsn.at("FirstParameterId").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  first_parameter_id = jsn.at("FirstParameterId").get< uint16_t >();
      if (jsn.at("LastParameterId").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  last_parameter_id = jsn.at("LastParameterId").get< uint16_t >();
    }


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_configuration_parameters_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_configuration_parameters_state_t &new_state,
  uic_mqtt_dotdot_configuration_parameters_updated_state_t &new_updated_state
) {



}


std::string get_json_payload_for_aox_locator_iq_report_command(
  
  const uic_mqtt_dotdot_aox_locator_command_iq_report_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["TagUnid"] = nlohmann::json(fields->tag_unid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Channel"] = nlohmann::json(fields->channel);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["RSSI"] = nlohmann::json(fields->rssi);
  command_with_no_fields = false;
  // We assume arrays are Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Samples"] = std::vector< int8_t >(
    fields->samples,
    fields->samples + fields->samples_count);

  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Sequence"] = nlohmann::json(fields->sequence);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_aox_locator_iq_report(
  nlohmann::json &jsn,
  std::string &tag_unid,
  
  uint8_t &channel,
  
  int8_t &rssi,
  
  std::vector<int8_t> &samples,

  int32_t &sequence
  
) {

  if (jsn.at("TagUnid").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  tag_unid = jsn.at("TagUnid").get<std::string>();
            if (jsn.at("Channel").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  channel = jsn.at("Channel").get< uint8_t >();
      if (jsn.at("RSSI").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  rssi = jsn.at("RSSI").get< int8_t >();
      if (jsn.at("Samples").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  samples = jsn.at("Samples").get< std::vector< int8_t >>();
        if (jsn.at("Sequence").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  sequence = jsn.at("Sequence").get< int32_t >();
    }


std::string get_json_payload_for_aox_locator_angle_report_command(
  
  const uic_mqtt_dotdot_aox_locator_command_angle_report_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["TagUnid"] = nlohmann::json(fields->tag_unid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Direction"] = nlohmann::json(fields->direction);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Deviation"] = nlohmann::json(fields->deviation);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Sequence"] = nlohmann::json(fields->sequence);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_aox_locator_angle_report(
  nlohmann::json &jsn,
  std::string &tag_unid,
  
  SphericalCoordinates &direction,
  
  SphericalCoordinates &deviation,
  
  int32_t &sequence
  
) {

  if (jsn.at("TagUnid").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  tag_unid = jsn.at("TagUnid").get<std::string>();
            if (jsn.at("Direction").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  direction = jsn.at("Direction").get< SphericalCoordinates >();
      if (jsn.at("Deviation").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  deviation = jsn.at("Deviation").get< SphericalCoordinates >();
      if (jsn.at("Sequence").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  sequence = jsn.at("Sequence").get< int32_t >();
    }


std::string get_json_payload_for_aox_locator_angle_correction_command(
  
  const uic_mqtt_dotdot_aox_locator_command_angle_correction_fields_t *fields
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["TagUnid"] = nlohmann::json(fields->tag_unid);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Direction"] = nlohmann::json(fields->direction);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Deviation"] = nlohmann::json(fields->deviation);
  command_with_no_fields = false;
  // Single Value
  // Non-enum and non-bitmask (struct, string or scalar)
  json_payload["Sequence"] = nlohmann::json(fields->sequence);

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}


void uic_mqtt_dotdot_parse_aox_locator_angle_correction(
  nlohmann::json &jsn,
  std::string &tag_unid,
  
  SphericalCoordinates &direction,
  
  SphericalCoordinates &deviation,
  
  int32_t &sequence
  
) {

  if (jsn.at("TagUnid").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
       
  tag_unid = jsn.at("TagUnid").get<std::string>();
            if (jsn.at("Direction").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  direction = jsn.at("Direction").get< SphericalCoordinates >();
      if (jsn.at("Deviation").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  deviation = jsn.at("Deviation").get< SphericalCoordinates >();
      if (jsn.at("Sequence").is_null()) {
    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
    return;
  }
        
  sequence = jsn.at("Sequence").get< int32_t >();
    }


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_aox_locator_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_aox_locator_state_t &new_state,
  uic_mqtt_dotdot_aox_locator_updated_state_t &new_updated_state,
  std::vector<MinMaxPair> &azimuth_mask,
  std::vector<MinMaxPair> &elevation_mask,
  std::vector<const char*> &allow_list,
  std::vector<int8_t> &antenna_array
) {


  if (jsn.find("ReportingMode") != jsn.end()) {

    uint32_t tmp = get_enum_decimal_value<AoXLocatorReportingMode>("ReportingMode", jsn);
    if (tmp == std::numeric_limits<AoXLocatorReportingMode>::max()) {
      #ifdef AOX_LOCATOR_REPORTING_MODE_ENUM_NAME_AVAILABLE
      tmp = aox_locator_reporting_mode_get_enum_value_number(jsn.at("ReportingMode").get<std::string>());
      #elif defined(REPORTING_MODE_ENUM_NAME_AVAILABLE)
      tmp = reporting_mode_get_enum_value_number(jsn.at("ReportingMode").get<std::string>());
      #endif
    }
    new_state.reporting_mode = tmp;
  
    new_updated_state.reporting_mode = true;
  }

  if (jsn.find("PositionAndOrientationValid") != jsn.end()) {

    new_state.position_and_orientation_valid = get_bool_from_json(jsn, "PositionAndOrientationValid");
  
    new_updated_state.position_and_orientation_valid = true;
  }

  if (jsn.find("PositionAndOrientation") != jsn.end()) {

    new_state.position_and_orientation = jsn.at("PositionAndOrientation").get<CoordinateAndOrientation>();
        
    new_updated_state.position_and_orientation = true;
  }

  if (jsn.find("AzimuthMask") != jsn.end()) {

    auto &azimuth_mask_jsn = jsn.at("AzimuthMask");
    for (size_t i = 0; i < azimuth_mask_jsn.size(); i++) {
      azimuth_mask.push_back(azimuth_mask_jsn.at(i).get<MinMaxPair>());
          }
    // Take our vector and pack it into the updated state
    new_state.azimuth_mask_count = azimuth_mask.size();
    new_state.azimuth_mask = azimuth_mask.data();

    new_updated_state.azimuth_mask = true;
  }

  if (jsn.find("ElevationMask") != jsn.end()) {

    auto &elevation_mask_jsn = jsn.at("ElevationMask");
    for (size_t i = 0; i < elevation_mask_jsn.size(); i++) {
      elevation_mask.push_back(elevation_mask_jsn.at(i).get<MinMaxPair>());
          }
    // Take our vector and pack it into the updated state
    new_state.elevation_mask_count = elevation_mask.size();
    new_state.elevation_mask = elevation_mask.data();

    new_updated_state.elevation_mask = true;
  }

  if (jsn.find("AllowList") != jsn.end()) {

    auto &allow_list_jsn = jsn.at("AllowList");
    for (size_t i = 0; i < allow_list_jsn.size(); i++) {
      allow_list.push_back(allow_list_jsn.at(i).get_ptr<const std::string*>()->c_str());
    }
    // Take our vector and pack it into the updated state
    new_state.allow_list_count = allow_list.size();
    new_state.allow_list = allow_list.data();

    new_updated_state.allow_list = true;
  }

  if (jsn.find("AoXMode") != jsn.end()) {

    uint32_t tmp = get_enum_decimal_value<AoXLocatorAoXMode>("AoXMode", jsn);
    if (tmp == std::numeric_limits<AoXLocatorAoXMode>::max()) {
      #ifdef AOX_LOCATOR_AOX_MODE_ENUM_NAME_AVAILABLE
      tmp = aox_locator_aox_mode_get_enum_value_number(jsn.at("AoXMode").get<std::string>());
      #elif defined(AOX_MODE_ENUM_NAME_AVAILABLE)
      tmp = aox_mode_get_enum_value_number(jsn.at("AoXMode").get<std::string>());
      #endif
    }
    new_state.aox_mode = tmp;
  
    new_updated_state.aox_mode = true;
  }

  if (jsn.find("AntennaMode") != jsn.end()) {

    uint32_t tmp = get_enum_decimal_value<AoXLocatorAntennaMode>("AntennaMode", jsn);
    if (tmp == std::numeric_limits<AoXLocatorAntennaMode>::max()) {
      #ifdef AOX_LOCATOR_ANTENNA_MODE_ENUM_NAME_AVAILABLE
      tmp = aox_locator_antenna_mode_get_enum_value_number(jsn.at("AntennaMode").get<std::string>());
      #elif defined(ANTENNA_MODE_ENUM_NAME_AVAILABLE)
      tmp = antenna_mode_get_enum_value_number(jsn.at("AntennaMode").get<std::string>());
      #endif
    }
    new_state.antenna_mode = tmp;
  
    new_updated_state.antenna_mode = true;
  }

  if (jsn.find("AntennaArray") != jsn.end()) {

    auto &antenna_array_jsn = jsn.at("AntennaArray");
    for (size_t i = 0; i < antenna_array_jsn.size(); i++) {
      antenna_array.push_back(antenna_array_jsn.at(i).get<int8_t>());
          }
    // Take our vector and pack it into the updated state
    new_state.antenna_array_count = antenna_array.size();
    new_state.antenna_array = antenna_array.data();

    new_updated_state.antenna_array = true;
  }

  if (jsn.find("PeriodSamples") != jsn.end()) {

    new_state.period_samples = jsn.at("PeriodSamples").get<int8_t>();
        
    new_updated_state.period_samples = true;
  }

  if (jsn.find("AngleFiltering") != jsn.end()) {

    new_state.angle_filtering = get_bool_from_json(jsn, "AngleFiltering");
  
    new_updated_state.angle_filtering = true;
  }

  if (jsn.find("AngleFilteringWeight") != jsn.end()) {

    new_state.angle_filtering_weight = jsn.at("AngleFilteringWeight").get<double>();
        
    new_updated_state.angle_filtering_weight = true;
  }

  if (jsn.find("AngleCorrectionTimeout") != jsn.end()) {

    new_state.angle_correction_timeout = jsn.at("AngleCorrectionTimeout").get<int8_t>();
        
    new_updated_state.angle_correction_timeout = true;
  }

  if (jsn.find("AngleCorrectionDelay") != jsn.end()) {

    new_state.angle_correction_delay = jsn.at("AngleCorrectionDelay").get<int8_t>();
        
    new_updated_state.angle_correction_delay = true;
  }

  if (jsn.find("CTEMode") != jsn.end()) {

    uint32_t tmp = get_enum_decimal_value<AoXLocatorCTEMode>("CTEMode", jsn);
    if (tmp == std::numeric_limits<AoXLocatorCTEMode>::max()) {
      #ifdef AOX_LOCATOR_CTE_MODE_ENUM_NAME_AVAILABLE
      tmp = aox_locator_cte_mode_get_enum_value_number(jsn.at("CTEMode").get<std::string>());
      #elif defined(CTE_MODE_ENUM_NAME_AVAILABLE)
      tmp = cte_mode_get_enum_value_number(jsn.at("CTEMode").get<std::string>());
      #endif
    }
    new_state.cte_mode = tmp;
  
    new_updated_state.cte_mode = true;
  }

  if (jsn.find("CTESamplingInterval") != jsn.end()) {

    new_state.cte_sampling_interval = jsn.at("CTESamplingInterval").get<int8_t>();
        
    new_updated_state.cte_sampling_interval = true;
  }

  if (jsn.find("CTELength") != jsn.end()) {

    new_state.cte_length = jsn.at("CTELength").get<int8_t>();
        
    new_updated_state.cte_length = true;
  }

  if (jsn.find("SlotDuration") != jsn.end()) {

    new_state.slot_duration = jsn.at("SlotDuration").get<int8_t>();
        
    new_updated_state.slot_duration = true;
  }


}


/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_aox_position_estimation_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_aox_position_estimation_state_t &new_state,
  uic_mqtt_dotdot_aox_position_estimation_updated_state_t &new_updated_state
) {



}


std::string get_json_payload_for_protocol_controller_network_management_write_command(
  
){
  bool command_with_no_fields = true;

  // Create a JSON payload from all the parameters
  nlohmann::json json_payload;

  // Get the string
  if (command_with_no_fields == true) {
    return std::string("{}");
  }
  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
}




/**
 * @brief JSON parser for ::WriteAttributes command arguments.
 *
 * Parse incoming JSON object to populate command arguments passed in by reference.
 */
void uic_mqtt_dotdot_parse_protocol_controller_network_management_write_attributes(
  nlohmann::json &jsn,
  uic_mqtt_dotdot_protocol_controller_network_management_state_t &new_state,
  uic_mqtt_dotdot_protocol_controller_network_management_updated_state_t &new_updated_state
) {



}

