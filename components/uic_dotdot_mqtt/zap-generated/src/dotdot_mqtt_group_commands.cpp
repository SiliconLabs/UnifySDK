/******************************************************************************
 * # License
 * <b>Copyright 2022 Silicon Laboratories Inc. www.silabs.com</b>
 ******************************************************************************
 * The licensor of this software is Silicon Laboratories Inc. Your use of this
 * software is governed by the terms of Silicon Labs Master Software License
 * Agreement (MSLA) available at
 * www.silabs.com/about-us/legal/master-software-license-agreement. This
 * software is distributed to you in Source Code format and is governed by the
 * sections of the MSLA applicable to Source Code.
 *
 *****************************************************************************/

// This file is generated by ZCL Advanced Platform generator. Please don't edit manually.
#include <string>
#include <vector>
#include <cinttypes>

#include <nlohmann/json.hpp>

// Unify includes
#include "sl_log.h"
#include "sl_status.h"
#include "uic_mqtt.h"
#include "uic_typedefs.h"

// Component inclues
#include "dotdot_mqtt.h"
#include "dotdot_mqtt.hpp"
#include "dotdot_mqtt_group_commands.h"
#include "dotdot_mqtt_command_helpers.hpp"
#include "dotdot_mqtt_parsing_helpers.hpp"

static constexpr char LOG_TAG[] = "dotdot_mqtt";
static constexpr char LOG_FMT_JSON_PARSE_FAIL[] = "by-group %s::%s: Unable to parse JSON payload: check payload syntax";
static constexpr char LOG_FMT_JSON_ERROR[] = "by-group %s::%s: Unable to parse JSON payload: %s";

static const char TOPIC_BY_GROUP_PREFIX[] = "ucl/by-group/+/";

 /**
 * @brief Function that dispatches incoming commands to an entire group.
 **/
static group_dispatch_t group_dispatch_callback = nullptr;

// Callbacks pointers

static uic_mqtt_dotdot_by_group_basic_reset_to_factory_defaults_callback_t uic_mqtt_dotdot_by_group_basic_reset_to_factory_defaults_callback = nullptr;
static uic_mqtt_dotdot_by_group_basic_write_attributes_callback_t uic_mqtt_dotdot_by_group_basic_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_power_configuration_write_attributes_callback_t uic_mqtt_dotdot_by_group_power_configuration_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_device_temperature_configuration_write_attributes_callback_t uic_mqtt_dotdot_by_group_device_temperature_configuration_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_identify_identify_callback_t uic_mqtt_dotdot_by_group_identify_identify_callback = nullptr;
static uic_mqtt_dotdot_by_group_identify_identify_query_response_callback_t uic_mqtt_dotdot_by_group_identify_identify_query_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_identify_identify_query_callback_t uic_mqtt_dotdot_by_group_identify_identify_query_callback = nullptr;
static uic_mqtt_dotdot_by_group_identify_trigger_effect_callback_t uic_mqtt_dotdot_by_group_identify_trigger_effect_callback = nullptr;
static uic_mqtt_dotdot_by_group_identify_write_attributes_callback_t uic_mqtt_dotdot_by_group_identify_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_groups_add_group_callback_t uic_mqtt_dotdot_by_group_groups_add_group_callback = nullptr;
static uic_mqtt_dotdot_by_group_groups_add_group_response_callback_t uic_mqtt_dotdot_by_group_groups_add_group_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_groups_view_group_callback_t uic_mqtt_dotdot_by_group_groups_view_group_callback = nullptr;
static uic_mqtt_dotdot_by_group_groups_view_group_response_callback_t uic_mqtt_dotdot_by_group_groups_view_group_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_groups_get_group_membership_callback_t uic_mqtt_dotdot_by_group_groups_get_group_membership_callback = nullptr;
static uic_mqtt_dotdot_by_group_groups_get_group_membership_response_callback_t uic_mqtt_dotdot_by_group_groups_get_group_membership_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_groups_remove_group_callback_t uic_mqtt_dotdot_by_group_groups_remove_group_callback = nullptr;
static uic_mqtt_dotdot_by_group_groups_remove_group_response_callback_t uic_mqtt_dotdot_by_group_groups_remove_group_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_groups_remove_all_groups_callback_t uic_mqtt_dotdot_by_group_groups_remove_all_groups_callback = nullptr;
static uic_mqtt_dotdot_by_group_groups_add_group_if_identifying_callback_t uic_mqtt_dotdot_by_group_groups_add_group_if_identifying_callback = nullptr;
static uic_mqtt_dotdot_by_group_groups_write_attributes_callback_t uic_mqtt_dotdot_by_group_groups_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_scenes_add_scene_callback_t uic_mqtt_dotdot_by_group_scenes_add_scene_callback = nullptr;
static uic_mqtt_dotdot_by_group_scenes_add_scene_response_callback_t uic_mqtt_dotdot_by_group_scenes_add_scene_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_scenes_view_scene_callback_t uic_mqtt_dotdot_by_group_scenes_view_scene_callback = nullptr;
static uic_mqtt_dotdot_by_group_scenes_view_scene_response_callback_t uic_mqtt_dotdot_by_group_scenes_view_scene_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_scenes_remove_scene_callback_t uic_mqtt_dotdot_by_group_scenes_remove_scene_callback = nullptr;
static uic_mqtt_dotdot_by_group_scenes_remove_scene_response_callback_t uic_mqtt_dotdot_by_group_scenes_remove_scene_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_scenes_remove_all_scenes_callback_t uic_mqtt_dotdot_by_group_scenes_remove_all_scenes_callback = nullptr;
static uic_mqtt_dotdot_by_group_scenes_remove_all_scenes_response_callback_t uic_mqtt_dotdot_by_group_scenes_remove_all_scenes_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_scenes_store_scene_callback_t uic_mqtt_dotdot_by_group_scenes_store_scene_callback = nullptr;
static uic_mqtt_dotdot_by_group_scenes_store_scene_response_callback_t uic_mqtt_dotdot_by_group_scenes_store_scene_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_scenes_recall_scene_callback_t uic_mqtt_dotdot_by_group_scenes_recall_scene_callback = nullptr;
static uic_mqtt_dotdot_by_group_scenes_get_scene_membership_callback_t uic_mqtt_dotdot_by_group_scenes_get_scene_membership_callback = nullptr;
static uic_mqtt_dotdot_by_group_scenes_get_scene_membership_response_callback_t uic_mqtt_dotdot_by_group_scenes_get_scene_membership_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_scenes_enhanced_add_scene_callback_t uic_mqtt_dotdot_by_group_scenes_enhanced_add_scene_callback = nullptr;
static uic_mqtt_dotdot_by_group_scenes_enhanced_add_scene_response_callback_t uic_mqtt_dotdot_by_group_scenes_enhanced_add_scene_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_scenes_enhanced_view_scene_callback_t uic_mqtt_dotdot_by_group_scenes_enhanced_view_scene_callback = nullptr;
static uic_mqtt_dotdot_by_group_scenes_enhanced_view_scene_response_callback_t uic_mqtt_dotdot_by_group_scenes_enhanced_view_scene_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_scenes_copy_scene_callback_t uic_mqtt_dotdot_by_group_scenes_copy_scene_callback = nullptr;
static uic_mqtt_dotdot_by_group_scenes_copy_scene_response_callback_t uic_mqtt_dotdot_by_group_scenes_copy_scene_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_scenes_write_attributes_callback_t uic_mqtt_dotdot_by_group_scenes_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_on_off_off_callback_t uic_mqtt_dotdot_by_group_on_off_off_callback = nullptr;
static uic_mqtt_dotdot_by_group_on_off_on_callback_t uic_mqtt_dotdot_by_group_on_off_on_callback = nullptr;
static uic_mqtt_dotdot_by_group_on_off_toggle_callback_t uic_mqtt_dotdot_by_group_on_off_toggle_callback = nullptr;
static uic_mqtt_dotdot_by_group_on_off_off_with_effect_callback_t uic_mqtt_dotdot_by_group_on_off_off_with_effect_callback = nullptr;
static uic_mqtt_dotdot_by_group_on_off_on_with_recall_global_scene_callback_t uic_mqtt_dotdot_by_group_on_off_on_with_recall_global_scene_callback = nullptr;
static uic_mqtt_dotdot_by_group_on_off_on_with_timed_off_callback_t uic_mqtt_dotdot_by_group_on_off_on_with_timed_off_callback = nullptr;
static uic_mqtt_dotdot_by_group_on_off_write_attributes_callback_t uic_mqtt_dotdot_by_group_on_off_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_level_move_to_level_callback_t uic_mqtt_dotdot_by_group_level_move_to_level_callback = nullptr;
static uic_mqtt_dotdot_by_group_level_move_callback_t uic_mqtt_dotdot_by_group_level_move_callback = nullptr;
static uic_mqtt_dotdot_by_group_level_step_callback_t uic_mqtt_dotdot_by_group_level_step_callback = nullptr;
static uic_mqtt_dotdot_by_group_level_stop_callback_t uic_mqtt_dotdot_by_group_level_stop_callback = nullptr;
static uic_mqtt_dotdot_by_group_level_move_to_level_with_on_off_callback_t uic_mqtt_dotdot_by_group_level_move_to_level_with_on_off_callback = nullptr;
static uic_mqtt_dotdot_by_group_level_move_with_on_off_callback_t uic_mqtt_dotdot_by_group_level_move_with_on_off_callback = nullptr;
static uic_mqtt_dotdot_by_group_level_step_with_on_off_callback_t uic_mqtt_dotdot_by_group_level_step_with_on_off_callback = nullptr;
static uic_mqtt_dotdot_by_group_level_stop_with_on_off_callback_t uic_mqtt_dotdot_by_group_level_stop_with_on_off_callback = nullptr;
static uic_mqtt_dotdot_by_group_level_move_to_closest_frequency_callback_t uic_mqtt_dotdot_by_group_level_move_to_closest_frequency_callback = nullptr;
static uic_mqtt_dotdot_by_group_level_write_attributes_callback_t uic_mqtt_dotdot_by_group_level_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_alarms_reset_alarm_callback_t uic_mqtt_dotdot_by_group_alarms_reset_alarm_callback = nullptr;
static uic_mqtt_dotdot_by_group_alarms_alarm_callback_t uic_mqtt_dotdot_by_group_alarms_alarm_callback = nullptr;
static uic_mqtt_dotdot_by_group_alarms_reset_all_alarms_callback_t uic_mqtt_dotdot_by_group_alarms_reset_all_alarms_callback = nullptr;
static uic_mqtt_dotdot_by_group_alarms_get_alarm_response_callback_t uic_mqtt_dotdot_by_group_alarms_get_alarm_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_alarms_get_alarm_callback_t uic_mqtt_dotdot_by_group_alarms_get_alarm_callback = nullptr;
static uic_mqtt_dotdot_by_group_alarms_reset_alarm_log_callback_t uic_mqtt_dotdot_by_group_alarms_reset_alarm_log_callback = nullptr;
static uic_mqtt_dotdot_by_group_alarms_write_attributes_callback_t uic_mqtt_dotdot_by_group_alarms_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_time_write_attributes_callback_t uic_mqtt_dotdot_by_group_time_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_ota_upgrade_image_notify_callback_t uic_mqtt_dotdot_by_group_ota_upgrade_image_notify_callback = nullptr;
static uic_mqtt_dotdot_by_group_ota_upgrade_query_next_image_request_callback_t uic_mqtt_dotdot_by_group_ota_upgrade_query_next_image_request_callback = nullptr;
static uic_mqtt_dotdot_by_group_ota_upgrade_query_next_image_response_callback_t uic_mqtt_dotdot_by_group_ota_upgrade_query_next_image_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_ota_upgrade_image_block_request_callback_t uic_mqtt_dotdot_by_group_ota_upgrade_image_block_request_callback = nullptr;
static uic_mqtt_dotdot_by_group_ota_upgrade_image_page_request_callback_t uic_mqtt_dotdot_by_group_ota_upgrade_image_page_request_callback = nullptr;
static uic_mqtt_dotdot_by_group_ota_upgrade_image_block_response_callback_t uic_mqtt_dotdot_by_group_ota_upgrade_image_block_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_ota_upgrade_upgrade_end_request_callback_t uic_mqtt_dotdot_by_group_ota_upgrade_upgrade_end_request_callback = nullptr;
static uic_mqtt_dotdot_by_group_ota_upgrade_upgrade_end_response_callback_t uic_mqtt_dotdot_by_group_ota_upgrade_upgrade_end_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_ota_upgrade_query_device_specific_file_request_callback_t uic_mqtt_dotdot_by_group_ota_upgrade_query_device_specific_file_request_callback = nullptr;
static uic_mqtt_dotdot_by_group_ota_upgrade_query_device_specific_file_response_callback_t uic_mqtt_dotdot_by_group_ota_upgrade_query_device_specific_file_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_ota_upgrade_write_attributes_callback_t uic_mqtt_dotdot_by_group_ota_upgrade_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_poll_control_check_in_callback_t uic_mqtt_dotdot_by_group_poll_control_check_in_callback = nullptr;
static uic_mqtt_dotdot_by_group_poll_control_check_in_response_callback_t uic_mqtt_dotdot_by_group_poll_control_check_in_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_poll_control_fast_poll_stop_callback_t uic_mqtt_dotdot_by_group_poll_control_fast_poll_stop_callback = nullptr;
static uic_mqtt_dotdot_by_group_poll_control_set_long_poll_interval_callback_t uic_mqtt_dotdot_by_group_poll_control_set_long_poll_interval_callback = nullptr;
static uic_mqtt_dotdot_by_group_poll_control_set_short_poll_interval_callback_t uic_mqtt_dotdot_by_group_poll_control_set_short_poll_interval_callback = nullptr;
static uic_mqtt_dotdot_by_group_poll_control_write_attributes_callback_t uic_mqtt_dotdot_by_group_poll_control_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_shade_configuration_write_attributes_callback_t uic_mqtt_dotdot_by_group_shade_configuration_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_door_lock_lock_door_callback_t uic_mqtt_dotdot_by_group_door_lock_lock_door_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_lock_door_response_callback_t uic_mqtt_dotdot_by_group_door_lock_lock_door_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_unlock_door_callback_t uic_mqtt_dotdot_by_group_door_lock_unlock_door_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_unlock_door_response_callback_t uic_mqtt_dotdot_by_group_door_lock_unlock_door_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_toggle_callback_t uic_mqtt_dotdot_by_group_door_lock_toggle_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_toggle_response_callback_t uic_mqtt_dotdot_by_group_door_lock_toggle_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_unlock_with_timeout_callback_t uic_mqtt_dotdot_by_group_door_lock_unlock_with_timeout_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_unlock_with_timeout_response_callback_t uic_mqtt_dotdot_by_group_door_lock_unlock_with_timeout_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_get_log_record_callback_t uic_mqtt_dotdot_by_group_door_lock_get_log_record_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_get_log_record_response_callback_t uic_mqtt_dotdot_by_group_door_lock_get_log_record_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_setpin_code_callback_t uic_mqtt_dotdot_by_group_door_lock_setpin_code_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_setpin_code_response_callback_t uic_mqtt_dotdot_by_group_door_lock_setpin_code_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_getpin_code_callback_t uic_mqtt_dotdot_by_group_door_lock_getpin_code_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_getpin_code_response_callback_t uic_mqtt_dotdot_by_group_door_lock_getpin_code_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_clearpin_code_callback_t uic_mqtt_dotdot_by_group_door_lock_clearpin_code_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_clearpin_code_response_callback_t uic_mqtt_dotdot_by_group_door_lock_clearpin_code_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_clear_allpin_codes_callback_t uic_mqtt_dotdot_by_group_door_lock_clear_allpin_codes_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_clear_allpin_codes_response_callback_t uic_mqtt_dotdot_by_group_door_lock_clear_allpin_codes_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_set_user_status_callback_t uic_mqtt_dotdot_by_group_door_lock_set_user_status_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_set_user_status_response_callback_t uic_mqtt_dotdot_by_group_door_lock_set_user_status_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_get_user_status_callback_t uic_mqtt_dotdot_by_group_door_lock_get_user_status_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_get_user_status_response_callback_t uic_mqtt_dotdot_by_group_door_lock_get_user_status_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_set_weekday_schedule_callback_t uic_mqtt_dotdot_by_group_door_lock_set_weekday_schedule_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_set_weekday_schedule_response_callback_t uic_mqtt_dotdot_by_group_door_lock_set_weekday_schedule_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_get_weekday_schedule_callback_t uic_mqtt_dotdot_by_group_door_lock_get_weekday_schedule_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_get_weekday_schedule_response_callback_t uic_mqtt_dotdot_by_group_door_lock_get_weekday_schedule_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_clear_weekday_schedule_callback_t uic_mqtt_dotdot_by_group_door_lock_clear_weekday_schedule_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_clear_weekday_schedule_response_callback_t uic_mqtt_dotdot_by_group_door_lock_clear_weekday_schedule_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_set_year_day_schedule_callback_t uic_mqtt_dotdot_by_group_door_lock_set_year_day_schedule_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_set_year_day_schedule_response_callback_t uic_mqtt_dotdot_by_group_door_lock_set_year_day_schedule_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_get_year_day_schedule_callback_t uic_mqtt_dotdot_by_group_door_lock_get_year_day_schedule_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_get_year_day_schedule_response_callback_t uic_mqtt_dotdot_by_group_door_lock_get_year_day_schedule_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_clear_year_day_schedule_callback_t uic_mqtt_dotdot_by_group_door_lock_clear_year_day_schedule_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_clear_year_day_schedule_response_callback_t uic_mqtt_dotdot_by_group_door_lock_clear_year_day_schedule_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_set_holiday_schedule_callback_t uic_mqtt_dotdot_by_group_door_lock_set_holiday_schedule_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_set_holiday_schedule_response_callback_t uic_mqtt_dotdot_by_group_door_lock_set_holiday_schedule_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_get_holiday_schedule_callback_t uic_mqtt_dotdot_by_group_door_lock_get_holiday_schedule_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_get_holiday_schedule_response_callback_t uic_mqtt_dotdot_by_group_door_lock_get_holiday_schedule_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_clear_holiday_schedule_callback_t uic_mqtt_dotdot_by_group_door_lock_clear_holiday_schedule_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_clear_holiday_schedule_response_callback_t uic_mqtt_dotdot_by_group_door_lock_clear_holiday_schedule_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_set_user_type_callback_t uic_mqtt_dotdot_by_group_door_lock_set_user_type_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_set_user_type_response_callback_t uic_mqtt_dotdot_by_group_door_lock_set_user_type_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_get_user_type_callback_t uic_mqtt_dotdot_by_group_door_lock_get_user_type_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_get_user_type_response_callback_t uic_mqtt_dotdot_by_group_door_lock_get_user_type_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_setrfid_code_callback_t uic_mqtt_dotdot_by_group_door_lock_setrfid_code_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_setrfid_code_response_callback_t uic_mqtt_dotdot_by_group_door_lock_setrfid_code_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_getrfid_code_callback_t uic_mqtt_dotdot_by_group_door_lock_getrfid_code_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_getrfid_code_response_callback_t uic_mqtt_dotdot_by_group_door_lock_getrfid_code_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_clearrfid_code_callback_t uic_mqtt_dotdot_by_group_door_lock_clearrfid_code_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_clearrfid_code_response_callback_t uic_mqtt_dotdot_by_group_door_lock_clearrfid_code_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_clear_allrfid_codes_callback_t uic_mqtt_dotdot_by_group_door_lock_clear_allrfid_codes_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_clear_allrfid_codes_response_callback_t uic_mqtt_dotdot_by_group_door_lock_clear_allrfid_codes_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_operating_event_notification_callback_t uic_mqtt_dotdot_by_group_door_lock_operating_event_notification_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_programming_event_notification_callback_t uic_mqtt_dotdot_by_group_door_lock_programming_event_notification_callback = nullptr;
static uic_mqtt_dotdot_by_group_door_lock_write_attributes_callback_t uic_mqtt_dotdot_by_group_door_lock_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_window_covering_up_or_open_callback_t uic_mqtt_dotdot_by_group_window_covering_up_or_open_callback = nullptr;
static uic_mqtt_dotdot_by_group_window_covering_down_or_close_callback_t uic_mqtt_dotdot_by_group_window_covering_down_or_close_callback = nullptr;
static uic_mqtt_dotdot_by_group_window_covering_stop_callback_t uic_mqtt_dotdot_by_group_window_covering_stop_callback = nullptr;
static uic_mqtt_dotdot_by_group_window_covering_go_to_lift_value_callback_t uic_mqtt_dotdot_by_group_window_covering_go_to_lift_value_callback = nullptr;
static uic_mqtt_dotdot_by_group_window_covering_go_to_lift_percentage_callback_t uic_mqtt_dotdot_by_group_window_covering_go_to_lift_percentage_callback = nullptr;
static uic_mqtt_dotdot_by_group_window_covering_go_to_tilt_value_callback_t uic_mqtt_dotdot_by_group_window_covering_go_to_tilt_value_callback = nullptr;
static uic_mqtt_dotdot_by_group_window_covering_go_to_tilt_percentage_callback_t uic_mqtt_dotdot_by_group_window_covering_go_to_tilt_percentage_callback = nullptr;
static uic_mqtt_dotdot_by_group_window_covering_write_attributes_callback_t uic_mqtt_dotdot_by_group_window_covering_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_barrier_control_go_to_percent_callback_t uic_mqtt_dotdot_by_group_barrier_control_go_to_percent_callback = nullptr;
static uic_mqtt_dotdot_by_group_barrier_control_stop_callback_t uic_mqtt_dotdot_by_group_barrier_control_stop_callback = nullptr;
static uic_mqtt_dotdot_by_group_barrier_control_write_attributes_callback_t uic_mqtt_dotdot_by_group_barrier_control_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_pump_configuration_and_control_write_attributes_callback_t uic_mqtt_dotdot_by_group_pump_configuration_and_control_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_thermostat_setpoint_raise_or_lower_callback_t uic_mqtt_dotdot_by_group_thermostat_setpoint_raise_or_lower_callback = nullptr;
static uic_mqtt_dotdot_by_group_thermostat_get_weekly_schedule_response_callback_t uic_mqtt_dotdot_by_group_thermostat_get_weekly_schedule_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_thermostat_set_weekly_schedule_callback_t uic_mqtt_dotdot_by_group_thermostat_set_weekly_schedule_callback = nullptr;
static uic_mqtt_dotdot_by_group_thermostat_get_relay_status_log_response_callback_t uic_mqtt_dotdot_by_group_thermostat_get_relay_status_log_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_thermostat_get_weekly_schedule_callback_t uic_mqtt_dotdot_by_group_thermostat_get_weekly_schedule_callback = nullptr;
static uic_mqtt_dotdot_by_group_thermostat_clear_weekly_schedule_callback_t uic_mqtt_dotdot_by_group_thermostat_clear_weekly_schedule_callback = nullptr;
static uic_mqtt_dotdot_by_group_thermostat_get_relay_status_log_callback_t uic_mqtt_dotdot_by_group_thermostat_get_relay_status_log_callback = nullptr;
static uic_mqtt_dotdot_by_group_thermostat_write_attributes_callback_t uic_mqtt_dotdot_by_group_thermostat_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_fan_control_write_attributes_callback_t uic_mqtt_dotdot_by_group_fan_control_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_dehumidification_control_write_attributes_callback_t uic_mqtt_dotdot_by_group_dehumidification_control_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_thermostat_user_interface_configuration_write_attributes_callback_t uic_mqtt_dotdot_by_group_thermostat_user_interface_configuration_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_color_control_move_to_hue_callback_t uic_mqtt_dotdot_by_group_color_control_move_to_hue_callback = nullptr;
static uic_mqtt_dotdot_by_group_color_control_move_hue_callback_t uic_mqtt_dotdot_by_group_color_control_move_hue_callback = nullptr;
static uic_mqtt_dotdot_by_group_color_control_step_hue_callback_t uic_mqtt_dotdot_by_group_color_control_step_hue_callback = nullptr;
static uic_mqtt_dotdot_by_group_color_control_move_to_saturation_callback_t uic_mqtt_dotdot_by_group_color_control_move_to_saturation_callback = nullptr;
static uic_mqtt_dotdot_by_group_color_control_move_saturation_callback_t uic_mqtt_dotdot_by_group_color_control_move_saturation_callback = nullptr;
static uic_mqtt_dotdot_by_group_color_control_step_saturation_callback_t uic_mqtt_dotdot_by_group_color_control_step_saturation_callback = nullptr;
static uic_mqtt_dotdot_by_group_color_control_move_to_hue_and_saturation_callback_t uic_mqtt_dotdot_by_group_color_control_move_to_hue_and_saturation_callback = nullptr;
static uic_mqtt_dotdot_by_group_color_control_move_to_color_callback_t uic_mqtt_dotdot_by_group_color_control_move_to_color_callback = nullptr;
static uic_mqtt_dotdot_by_group_color_control_move_color_callback_t uic_mqtt_dotdot_by_group_color_control_move_color_callback = nullptr;
static uic_mqtt_dotdot_by_group_color_control_step_color_callback_t uic_mqtt_dotdot_by_group_color_control_step_color_callback = nullptr;
static uic_mqtt_dotdot_by_group_color_control_move_to_color_temperature_callback_t uic_mqtt_dotdot_by_group_color_control_move_to_color_temperature_callback = nullptr;
static uic_mqtt_dotdot_by_group_color_control_enhanced_move_to_hue_callback_t uic_mqtt_dotdot_by_group_color_control_enhanced_move_to_hue_callback = nullptr;
static uic_mqtt_dotdot_by_group_color_control_enhanced_move_hue_callback_t uic_mqtt_dotdot_by_group_color_control_enhanced_move_hue_callback = nullptr;
static uic_mqtt_dotdot_by_group_color_control_enhanced_step_hue_callback_t uic_mqtt_dotdot_by_group_color_control_enhanced_step_hue_callback = nullptr;
static uic_mqtt_dotdot_by_group_color_control_enhanced_move_to_hue_and_saturation_callback_t uic_mqtt_dotdot_by_group_color_control_enhanced_move_to_hue_and_saturation_callback = nullptr;
static uic_mqtt_dotdot_by_group_color_control_color_loop_set_callback_t uic_mqtt_dotdot_by_group_color_control_color_loop_set_callback = nullptr;
static uic_mqtt_dotdot_by_group_color_control_stop_move_step_callback_t uic_mqtt_dotdot_by_group_color_control_stop_move_step_callback = nullptr;
static uic_mqtt_dotdot_by_group_color_control_move_color_temperature_callback_t uic_mqtt_dotdot_by_group_color_control_move_color_temperature_callback = nullptr;
static uic_mqtt_dotdot_by_group_color_control_step_color_temperature_callback_t uic_mqtt_dotdot_by_group_color_control_step_color_temperature_callback = nullptr;
static uic_mqtt_dotdot_by_group_color_control_write_attributes_callback_t uic_mqtt_dotdot_by_group_color_control_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_ballast_configuration_write_attributes_callback_t uic_mqtt_dotdot_by_group_ballast_configuration_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_illuminance_measurement_write_attributes_callback_t uic_mqtt_dotdot_by_group_illuminance_measurement_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_illuminance_level_sensing_write_attributes_callback_t uic_mqtt_dotdot_by_group_illuminance_level_sensing_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_temperature_measurement_write_attributes_callback_t uic_mqtt_dotdot_by_group_temperature_measurement_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_pressure_measurement_write_attributes_callback_t uic_mqtt_dotdot_by_group_pressure_measurement_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_flow_measurement_write_attributes_callback_t uic_mqtt_dotdot_by_group_flow_measurement_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_relativity_humidity_write_attributes_callback_t uic_mqtt_dotdot_by_group_relativity_humidity_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_occupancy_sensing_write_attributes_callback_t uic_mqtt_dotdot_by_group_occupancy_sensing_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_ph_measurement_write_attributes_callback_t uic_mqtt_dotdot_by_group_ph_measurement_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_electrical_conductivity_measurement_write_attributes_callback_t uic_mqtt_dotdot_by_group_electrical_conductivity_measurement_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_wind_speed_measurement_write_attributes_callback_t uic_mqtt_dotdot_by_group_wind_speed_measurement_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_carbon_monoxide_write_attributes_callback_t uic_mqtt_dotdot_by_group_carbon_monoxide_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_ias_zone_zone_enroll_response_callback_t uic_mqtt_dotdot_by_group_ias_zone_zone_enroll_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_ias_zone_zone_status_change_notification_callback_t uic_mqtt_dotdot_by_group_ias_zone_zone_status_change_notification_callback = nullptr;
static uic_mqtt_dotdot_by_group_ias_zone_initiate_normal_operation_mode_callback_t uic_mqtt_dotdot_by_group_ias_zone_initiate_normal_operation_mode_callback = nullptr;
static uic_mqtt_dotdot_by_group_ias_zone_zone_enroll_request_callback_t uic_mqtt_dotdot_by_group_ias_zone_zone_enroll_request_callback = nullptr;
static uic_mqtt_dotdot_by_group_ias_zone_initiate_test_mode_callback_t uic_mqtt_dotdot_by_group_ias_zone_initiate_test_mode_callback = nullptr;
static uic_mqtt_dotdot_by_group_ias_zone_write_attributes_callback_t uic_mqtt_dotdot_by_group_ias_zone_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_iaswd_start_warning_callback_t uic_mqtt_dotdot_by_group_iaswd_start_warning_callback = nullptr;
static uic_mqtt_dotdot_by_group_iaswd_squawk_callback_t uic_mqtt_dotdot_by_group_iaswd_squawk_callback = nullptr;
static uic_mqtt_dotdot_by_group_iaswd_write_attributes_callback_t uic_mqtt_dotdot_by_group_iaswd_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_metering_write_attributes_callback_t uic_mqtt_dotdot_by_group_metering_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_electrical_measurement_get_profile_info_response_callback_t uic_mqtt_dotdot_by_group_electrical_measurement_get_profile_info_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_electrical_measurement_get_profile_info_callback_t uic_mqtt_dotdot_by_group_electrical_measurement_get_profile_info_callback = nullptr;
static uic_mqtt_dotdot_by_group_electrical_measurement_get_measurement_profile_response_callback_t uic_mqtt_dotdot_by_group_electrical_measurement_get_measurement_profile_response_callback = nullptr;
static uic_mqtt_dotdot_by_group_electrical_measurement_get_measurement_profile_callback_t uic_mqtt_dotdot_by_group_electrical_measurement_get_measurement_profile_callback = nullptr;
static uic_mqtt_dotdot_by_group_electrical_measurement_write_attributes_callback_t uic_mqtt_dotdot_by_group_electrical_measurement_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_diagnostics_write_attributes_callback_t uic_mqtt_dotdot_by_group_diagnostics_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_binding_bind_callback_t uic_mqtt_dotdot_by_group_binding_bind_callback = nullptr;
static uic_mqtt_dotdot_by_group_binding_unbind_callback_t uic_mqtt_dotdot_by_group_binding_unbind_callback = nullptr;
static uic_mqtt_dotdot_by_group_binding_bind_to_protocol_controller_callback_t uic_mqtt_dotdot_by_group_binding_bind_to_protocol_controller_callback = nullptr;
static uic_mqtt_dotdot_by_group_binding_unbind_from_protocol_controller_callback_t uic_mqtt_dotdot_by_group_binding_unbind_from_protocol_controller_callback = nullptr;
static uic_mqtt_dotdot_by_group_binding_write_attributes_callback_t uic_mqtt_dotdot_by_group_binding_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_name_and_location_write_attributes_callback_t uic_mqtt_dotdot_by_group_name_and_location_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_configuration_parameters_discover_parameter_callback_t uic_mqtt_dotdot_by_group_configuration_parameters_discover_parameter_callback = nullptr;
static uic_mqtt_dotdot_by_group_configuration_parameters_default_reset_all_parameters_callback_t uic_mqtt_dotdot_by_group_configuration_parameters_default_reset_all_parameters_callback = nullptr;
static uic_mqtt_dotdot_by_group_configuration_parameters_set_parameter_callback_t uic_mqtt_dotdot_by_group_configuration_parameters_set_parameter_callback = nullptr;
static uic_mqtt_dotdot_by_group_configuration_parameters_discover_parameter_range_callback_t uic_mqtt_dotdot_by_group_configuration_parameters_discover_parameter_range_callback = nullptr;
static uic_mqtt_dotdot_by_group_configuration_parameters_write_attributes_callback_t uic_mqtt_dotdot_by_group_configuration_parameters_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_aox_locator_iq_report_callback_t uic_mqtt_dotdot_by_group_aox_locator_iq_report_callback = nullptr;
static uic_mqtt_dotdot_by_group_aox_locator_angle_report_callback_t uic_mqtt_dotdot_by_group_aox_locator_angle_report_callback = nullptr;
static uic_mqtt_dotdot_by_group_aox_locator_angle_correction_callback_t uic_mqtt_dotdot_by_group_aox_locator_angle_correction_callback = nullptr;
static uic_mqtt_dotdot_by_group_aox_locator_write_attributes_callback_t uic_mqtt_dotdot_by_group_aox_locator_write_attributes_callback = nullptr;


static uic_mqtt_dotdot_by_group_aox_position_estimation_write_attributes_callback_t uic_mqtt_dotdot_by_group_aox_position_estimation_write_attributes_callback = nullptr;



// Callbacks setters

void uic_mqtt_dotdot_by_group_basic_reset_to_factory_defaults_callback_set(const uic_mqtt_dotdot_by_group_basic_reset_to_factory_defaults_callback_t callback)
{
  uic_mqtt_dotdot_by_group_basic_reset_to_factory_defaults_callback = callback;
}

void uic_mqtt_dotdot_by_group_basic_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_basic_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_basic_write_attributes_callback = callback;
}



// Callbacks setters
void uic_mqtt_dotdot_by_group_power_configuration_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_power_configuration_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_power_configuration_write_attributes_callback = callback;
}



// Callbacks setters
void uic_mqtt_dotdot_by_group_device_temperature_configuration_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_device_temperature_configuration_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_device_temperature_configuration_write_attributes_callback = callback;
}



// Callbacks setters

void uic_mqtt_dotdot_by_group_identify_identify_callback_set(const uic_mqtt_dotdot_by_group_identify_identify_callback_t callback)
{
  uic_mqtt_dotdot_by_group_identify_identify_callback = callback;
}


void uic_mqtt_dotdot_by_group_identify_identify_query_response_callback_set(const uic_mqtt_dotdot_by_group_identify_identify_query_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_identify_identify_query_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_identify_identify_query_callback_set(const uic_mqtt_dotdot_by_group_identify_identify_query_callback_t callback)
{
  uic_mqtt_dotdot_by_group_identify_identify_query_callback = callback;
}


void uic_mqtt_dotdot_by_group_identify_trigger_effect_callback_set(const uic_mqtt_dotdot_by_group_identify_trigger_effect_callback_t callback)
{
  uic_mqtt_dotdot_by_group_identify_trigger_effect_callback = callback;
}

void uic_mqtt_dotdot_by_group_identify_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_identify_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_identify_write_attributes_callback = callback;
}



// Callbacks setters

void uic_mqtt_dotdot_by_group_groups_add_group_callback_set(const uic_mqtt_dotdot_by_group_groups_add_group_callback_t callback)
{
  uic_mqtt_dotdot_by_group_groups_add_group_callback = callback;
}


void uic_mqtt_dotdot_by_group_groups_add_group_response_callback_set(const uic_mqtt_dotdot_by_group_groups_add_group_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_groups_add_group_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_groups_view_group_callback_set(const uic_mqtt_dotdot_by_group_groups_view_group_callback_t callback)
{
  uic_mqtt_dotdot_by_group_groups_view_group_callback = callback;
}


void uic_mqtt_dotdot_by_group_groups_view_group_response_callback_set(const uic_mqtt_dotdot_by_group_groups_view_group_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_groups_view_group_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_groups_get_group_membership_callback_set(const uic_mqtt_dotdot_by_group_groups_get_group_membership_callback_t callback)
{
  uic_mqtt_dotdot_by_group_groups_get_group_membership_callback = callback;
}


void uic_mqtt_dotdot_by_group_groups_get_group_membership_response_callback_set(const uic_mqtt_dotdot_by_group_groups_get_group_membership_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_groups_get_group_membership_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_groups_remove_group_callback_set(const uic_mqtt_dotdot_by_group_groups_remove_group_callback_t callback)
{
  uic_mqtt_dotdot_by_group_groups_remove_group_callback = callback;
}


void uic_mqtt_dotdot_by_group_groups_remove_group_response_callback_set(const uic_mqtt_dotdot_by_group_groups_remove_group_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_groups_remove_group_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_groups_remove_all_groups_callback_set(const uic_mqtt_dotdot_by_group_groups_remove_all_groups_callback_t callback)
{
  uic_mqtt_dotdot_by_group_groups_remove_all_groups_callback = callback;
}


void uic_mqtt_dotdot_by_group_groups_add_group_if_identifying_callback_set(const uic_mqtt_dotdot_by_group_groups_add_group_if_identifying_callback_t callback)
{
  uic_mqtt_dotdot_by_group_groups_add_group_if_identifying_callback = callback;
}

void uic_mqtt_dotdot_by_group_groups_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_groups_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_groups_write_attributes_callback = callback;
}



// Callbacks setters

void uic_mqtt_dotdot_by_group_scenes_add_scene_callback_set(const uic_mqtt_dotdot_by_group_scenes_add_scene_callback_t callback)
{
  uic_mqtt_dotdot_by_group_scenes_add_scene_callback = callback;
}


void uic_mqtt_dotdot_by_group_scenes_add_scene_response_callback_set(const uic_mqtt_dotdot_by_group_scenes_add_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_scenes_add_scene_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_scenes_view_scene_callback_set(const uic_mqtt_dotdot_by_group_scenes_view_scene_callback_t callback)
{
  uic_mqtt_dotdot_by_group_scenes_view_scene_callback = callback;
}


void uic_mqtt_dotdot_by_group_scenes_view_scene_response_callback_set(const uic_mqtt_dotdot_by_group_scenes_view_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_scenes_view_scene_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_scenes_remove_scene_callback_set(const uic_mqtt_dotdot_by_group_scenes_remove_scene_callback_t callback)
{
  uic_mqtt_dotdot_by_group_scenes_remove_scene_callback = callback;
}


void uic_mqtt_dotdot_by_group_scenes_remove_scene_response_callback_set(const uic_mqtt_dotdot_by_group_scenes_remove_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_scenes_remove_scene_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_scenes_remove_all_scenes_callback_set(const uic_mqtt_dotdot_by_group_scenes_remove_all_scenes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_scenes_remove_all_scenes_callback = callback;
}


void uic_mqtt_dotdot_by_group_scenes_remove_all_scenes_response_callback_set(const uic_mqtt_dotdot_by_group_scenes_remove_all_scenes_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_scenes_remove_all_scenes_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_scenes_store_scene_callback_set(const uic_mqtt_dotdot_by_group_scenes_store_scene_callback_t callback)
{
  uic_mqtt_dotdot_by_group_scenes_store_scene_callback = callback;
}


void uic_mqtt_dotdot_by_group_scenes_store_scene_response_callback_set(const uic_mqtt_dotdot_by_group_scenes_store_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_scenes_store_scene_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_scenes_recall_scene_callback_set(const uic_mqtt_dotdot_by_group_scenes_recall_scene_callback_t callback)
{
  uic_mqtt_dotdot_by_group_scenes_recall_scene_callback = callback;
}


void uic_mqtt_dotdot_by_group_scenes_get_scene_membership_callback_set(const uic_mqtt_dotdot_by_group_scenes_get_scene_membership_callback_t callback)
{
  uic_mqtt_dotdot_by_group_scenes_get_scene_membership_callback = callback;
}


void uic_mqtt_dotdot_by_group_scenes_get_scene_membership_response_callback_set(const uic_mqtt_dotdot_by_group_scenes_get_scene_membership_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_scenes_get_scene_membership_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_scenes_enhanced_add_scene_callback_set(const uic_mqtt_dotdot_by_group_scenes_enhanced_add_scene_callback_t callback)
{
  uic_mqtt_dotdot_by_group_scenes_enhanced_add_scene_callback = callback;
}


void uic_mqtt_dotdot_by_group_scenes_enhanced_add_scene_response_callback_set(const uic_mqtt_dotdot_by_group_scenes_enhanced_add_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_scenes_enhanced_add_scene_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_scenes_enhanced_view_scene_callback_set(const uic_mqtt_dotdot_by_group_scenes_enhanced_view_scene_callback_t callback)
{
  uic_mqtt_dotdot_by_group_scenes_enhanced_view_scene_callback = callback;
}


void uic_mqtt_dotdot_by_group_scenes_enhanced_view_scene_response_callback_set(const uic_mqtt_dotdot_by_group_scenes_enhanced_view_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_scenes_enhanced_view_scene_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_scenes_copy_scene_callback_set(const uic_mqtt_dotdot_by_group_scenes_copy_scene_callback_t callback)
{
  uic_mqtt_dotdot_by_group_scenes_copy_scene_callback = callback;
}


void uic_mqtt_dotdot_by_group_scenes_copy_scene_response_callback_set(const uic_mqtt_dotdot_by_group_scenes_copy_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_scenes_copy_scene_response_callback = callback;
}

void uic_mqtt_dotdot_by_group_scenes_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_scenes_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_scenes_write_attributes_callback = callback;
}



// Callbacks setters

void uic_mqtt_dotdot_by_group_on_off_off_callback_set(const uic_mqtt_dotdot_by_group_on_off_off_callback_t callback)
{
  uic_mqtt_dotdot_by_group_on_off_off_callback = callback;
}


void uic_mqtt_dotdot_by_group_on_off_on_callback_set(const uic_mqtt_dotdot_by_group_on_off_on_callback_t callback)
{
  uic_mqtt_dotdot_by_group_on_off_on_callback = callback;
}


void uic_mqtt_dotdot_by_group_on_off_toggle_callback_set(const uic_mqtt_dotdot_by_group_on_off_toggle_callback_t callback)
{
  uic_mqtt_dotdot_by_group_on_off_toggle_callback = callback;
}


void uic_mqtt_dotdot_by_group_on_off_off_with_effect_callback_set(const uic_mqtt_dotdot_by_group_on_off_off_with_effect_callback_t callback)
{
  uic_mqtt_dotdot_by_group_on_off_off_with_effect_callback = callback;
}


void uic_mqtt_dotdot_by_group_on_off_on_with_recall_global_scene_callback_set(const uic_mqtt_dotdot_by_group_on_off_on_with_recall_global_scene_callback_t callback)
{
  uic_mqtt_dotdot_by_group_on_off_on_with_recall_global_scene_callback = callback;
}


void uic_mqtt_dotdot_by_group_on_off_on_with_timed_off_callback_set(const uic_mqtt_dotdot_by_group_on_off_on_with_timed_off_callback_t callback)
{
  uic_mqtt_dotdot_by_group_on_off_on_with_timed_off_callback = callback;
}

void uic_mqtt_dotdot_by_group_on_off_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_on_off_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_on_off_write_attributes_callback = callback;
}



// Callbacks setters

void uic_mqtt_dotdot_by_group_level_move_to_level_callback_set(const uic_mqtt_dotdot_by_group_level_move_to_level_callback_t callback)
{
  uic_mqtt_dotdot_by_group_level_move_to_level_callback = callback;
}


void uic_mqtt_dotdot_by_group_level_move_callback_set(const uic_mqtt_dotdot_by_group_level_move_callback_t callback)
{
  uic_mqtt_dotdot_by_group_level_move_callback = callback;
}


void uic_mqtt_dotdot_by_group_level_step_callback_set(const uic_mqtt_dotdot_by_group_level_step_callback_t callback)
{
  uic_mqtt_dotdot_by_group_level_step_callback = callback;
}


void uic_mqtt_dotdot_by_group_level_stop_callback_set(const uic_mqtt_dotdot_by_group_level_stop_callback_t callback)
{
  uic_mqtt_dotdot_by_group_level_stop_callback = callback;
}


void uic_mqtt_dotdot_by_group_level_move_to_level_with_on_off_callback_set(const uic_mqtt_dotdot_by_group_level_move_to_level_with_on_off_callback_t callback)
{
  uic_mqtt_dotdot_by_group_level_move_to_level_with_on_off_callback = callback;
}


void uic_mqtt_dotdot_by_group_level_move_with_on_off_callback_set(const uic_mqtt_dotdot_by_group_level_move_with_on_off_callback_t callback)
{
  uic_mqtt_dotdot_by_group_level_move_with_on_off_callback = callback;
}


void uic_mqtt_dotdot_by_group_level_step_with_on_off_callback_set(const uic_mqtt_dotdot_by_group_level_step_with_on_off_callback_t callback)
{
  uic_mqtt_dotdot_by_group_level_step_with_on_off_callback = callback;
}


void uic_mqtt_dotdot_by_group_level_stop_with_on_off_callback_set(const uic_mqtt_dotdot_by_group_level_stop_with_on_off_callback_t callback)
{
  uic_mqtt_dotdot_by_group_level_stop_with_on_off_callback = callback;
}


void uic_mqtt_dotdot_by_group_level_move_to_closest_frequency_callback_set(const uic_mqtt_dotdot_by_group_level_move_to_closest_frequency_callback_t callback)
{
  uic_mqtt_dotdot_by_group_level_move_to_closest_frequency_callback = callback;
}

void uic_mqtt_dotdot_by_group_level_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_level_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_level_write_attributes_callback = callback;
}



// Callbacks setters

void uic_mqtt_dotdot_by_group_alarms_reset_alarm_callback_set(const uic_mqtt_dotdot_by_group_alarms_reset_alarm_callback_t callback)
{
  uic_mqtt_dotdot_by_group_alarms_reset_alarm_callback = callback;
}


void uic_mqtt_dotdot_by_group_alarms_alarm_callback_set(const uic_mqtt_dotdot_by_group_alarms_alarm_callback_t callback)
{
  uic_mqtt_dotdot_by_group_alarms_alarm_callback = callback;
}


void uic_mqtt_dotdot_by_group_alarms_reset_all_alarms_callback_set(const uic_mqtt_dotdot_by_group_alarms_reset_all_alarms_callback_t callback)
{
  uic_mqtt_dotdot_by_group_alarms_reset_all_alarms_callback = callback;
}


void uic_mqtt_dotdot_by_group_alarms_get_alarm_response_callback_set(const uic_mqtt_dotdot_by_group_alarms_get_alarm_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_alarms_get_alarm_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_alarms_get_alarm_callback_set(const uic_mqtt_dotdot_by_group_alarms_get_alarm_callback_t callback)
{
  uic_mqtt_dotdot_by_group_alarms_get_alarm_callback = callback;
}


void uic_mqtt_dotdot_by_group_alarms_reset_alarm_log_callback_set(const uic_mqtt_dotdot_by_group_alarms_reset_alarm_log_callback_t callback)
{
  uic_mqtt_dotdot_by_group_alarms_reset_alarm_log_callback = callback;
}

void uic_mqtt_dotdot_by_group_alarms_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_alarms_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_alarms_write_attributes_callback = callback;
}



// Callbacks setters
void uic_mqtt_dotdot_by_group_time_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_time_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_time_write_attributes_callback = callback;
}



// Callbacks setters

void uic_mqtt_dotdot_by_group_ota_upgrade_image_notify_callback_set(const uic_mqtt_dotdot_by_group_ota_upgrade_image_notify_callback_t callback)
{
  uic_mqtt_dotdot_by_group_ota_upgrade_image_notify_callback = callback;
}


void uic_mqtt_dotdot_by_group_ota_upgrade_query_next_image_request_callback_set(const uic_mqtt_dotdot_by_group_ota_upgrade_query_next_image_request_callback_t callback)
{
  uic_mqtt_dotdot_by_group_ota_upgrade_query_next_image_request_callback = callback;
}


void uic_mqtt_dotdot_by_group_ota_upgrade_query_next_image_response_callback_set(const uic_mqtt_dotdot_by_group_ota_upgrade_query_next_image_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_ota_upgrade_query_next_image_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_ota_upgrade_image_block_request_callback_set(const uic_mqtt_dotdot_by_group_ota_upgrade_image_block_request_callback_t callback)
{
  uic_mqtt_dotdot_by_group_ota_upgrade_image_block_request_callback = callback;
}


void uic_mqtt_dotdot_by_group_ota_upgrade_image_page_request_callback_set(const uic_mqtt_dotdot_by_group_ota_upgrade_image_page_request_callback_t callback)
{
  uic_mqtt_dotdot_by_group_ota_upgrade_image_page_request_callback = callback;
}


void uic_mqtt_dotdot_by_group_ota_upgrade_image_block_response_callback_set(const uic_mqtt_dotdot_by_group_ota_upgrade_image_block_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_ota_upgrade_image_block_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_ota_upgrade_upgrade_end_request_callback_set(const uic_mqtt_dotdot_by_group_ota_upgrade_upgrade_end_request_callback_t callback)
{
  uic_mqtt_dotdot_by_group_ota_upgrade_upgrade_end_request_callback = callback;
}


void uic_mqtt_dotdot_by_group_ota_upgrade_upgrade_end_response_callback_set(const uic_mqtt_dotdot_by_group_ota_upgrade_upgrade_end_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_ota_upgrade_upgrade_end_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_ota_upgrade_query_device_specific_file_request_callback_set(const uic_mqtt_dotdot_by_group_ota_upgrade_query_device_specific_file_request_callback_t callback)
{
  uic_mqtt_dotdot_by_group_ota_upgrade_query_device_specific_file_request_callback = callback;
}


void uic_mqtt_dotdot_by_group_ota_upgrade_query_device_specific_file_response_callback_set(const uic_mqtt_dotdot_by_group_ota_upgrade_query_device_specific_file_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_ota_upgrade_query_device_specific_file_response_callback = callback;
}

void uic_mqtt_dotdot_by_group_ota_upgrade_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_ota_upgrade_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_ota_upgrade_write_attributes_callback = callback;
}



// Callbacks setters

void uic_mqtt_dotdot_by_group_poll_control_check_in_callback_set(const uic_mqtt_dotdot_by_group_poll_control_check_in_callback_t callback)
{
  uic_mqtt_dotdot_by_group_poll_control_check_in_callback = callback;
}


void uic_mqtt_dotdot_by_group_poll_control_check_in_response_callback_set(const uic_mqtt_dotdot_by_group_poll_control_check_in_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_poll_control_check_in_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_poll_control_fast_poll_stop_callback_set(const uic_mqtt_dotdot_by_group_poll_control_fast_poll_stop_callback_t callback)
{
  uic_mqtt_dotdot_by_group_poll_control_fast_poll_stop_callback = callback;
}


void uic_mqtt_dotdot_by_group_poll_control_set_long_poll_interval_callback_set(const uic_mqtt_dotdot_by_group_poll_control_set_long_poll_interval_callback_t callback)
{
  uic_mqtt_dotdot_by_group_poll_control_set_long_poll_interval_callback = callback;
}


void uic_mqtt_dotdot_by_group_poll_control_set_short_poll_interval_callback_set(const uic_mqtt_dotdot_by_group_poll_control_set_short_poll_interval_callback_t callback)
{
  uic_mqtt_dotdot_by_group_poll_control_set_short_poll_interval_callback = callback;
}

void uic_mqtt_dotdot_by_group_poll_control_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_poll_control_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_poll_control_write_attributes_callback = callback;
}



// Callbacks setters
void uic_mqtt_dotdot_by_group_shade_configuration_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_shade_configuration_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_shade_configuration_write_attributes_callback = callback;
}



// Callbacks setters

void uic_mqtt_dotdot_by_group_door_lock_lock_door_callback_set(const uic_mqtt_dotdot_by_group_door_lock_lock_door_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_lock_door_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_lock_door_response_callback_set(const uic_mqtt_dotdot_by_group_door_lock_lock_door_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_lock_door_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_unlock_door_callback_set(const uic_mqtt_dotdot_by_group_door_lock_unlock_door_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_unlock_door_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_unlock_door_response_callback_set(const uic_mqtt_dotdot_by_group_door_lock_unlock_door_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_unlock_door_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_toggle_callback_set(const uic_mqtt_dotdot_by_group_door_lock_toggle_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_toggle_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_toggle_response_callback_set(const uic_mqtt_dotdot_by_group_door_lock_toggle_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_toggle_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_unlock_with_timeout_callback_set(const uic_mqtt_dotdot_by_group_door_lock_unlock_with_timeout_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_unlock_with_timeout_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_unlock_with_timeout_response_callback_set(const uic_mqtt_dotdot_by_group_door_lock_unlock_with_timeout_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_unlock_with_timeout_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_get_log_record_callback_set(const uic_mqtt_dotdot_by_group_door_lock_get_log_record_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_get_log_record_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_get_log_record_response_callback_set(const uic_mqtt_dotdot_by_group_door_lock_get_log_record_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_get_log_record_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_setpin_code_callback_set(const uic_mqtt_dotdot_by_group_door_lock_setpin_code_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_setpin_code_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_setpin_code_response_callback_set(const uic_mqtt_dotdot_by_group_door_lock_setpin_code_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_setpin_code_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_getpin_code_callback_set(const uic_mqtt_dotdot_by_group_door_lock_getpin_code_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_getpin_code_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_getpin_code_response_callback_set(const uic_mqtt_dotdot_by_group_door_lock_getpin_code_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_getpin_code_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_clearpin_code_callback_set(const uic_mqtt_dotdot_by_group_door_lock_clearpin_code_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_clearpin_code_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_clearpin_code_response_callback_set(const uic_mqtt_dotdot_by_group_door_lock_clearpin_code_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_clearpin_code_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_clear_allpin_codes_callback_set(const uic_mqtt_dotdot_by_group_door_lock_clear_allpin_codes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_clear_allpin_codes_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_clear_allpin_codes_response_callback_set(const uic_mqtt_dotdot_by_group_door_lock_clear_allpin_codes_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_clear_allpin_codes_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_set_user_status_callback_set(const uic_mqtt_dotdot_by_group_door_lock_set_user_status_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_set_user_status_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_set_user_status_response_callback_set(const uic_mqtt_dotdot_by_group_door_lock_set_user_status_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_set_user_status_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_get_user_status_callback_set(const uic_mqtt_dotdot_by_group_door_lock_get_user_status_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_get_user_status_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_get_user_status_response_callback_set(const uic_mqtt_dotdot_by_group_door_lock_get_user_status_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_get_user_status_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_set_weekday_schedule_callback_set(const uic_mqtt_dotdot_by_group_door_lock_set_weekday_schedule_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_set_weekday_schedule_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_set_weekday_schedule_response_callback_set(const uic_mqtt_dotdot_by_group_door_lock_set_weekday_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_set_weekday_schedule_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_get_weekday_schedule_callback_set(const uic_mqtt_dotdot_by_group_door_lock_get_weekday_schedule_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_get_weekday_schedule_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_get_weekday_schedule_response_callback_set(const uic_mqtt_dotdot_by_group_door_lock_get_weekday_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_get_weekday_schedule_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_clear_weekday_schedule_callback_set(const uic_mqtt_dotdot_by_group_door_lock_clear_weekday_schedule_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_clear_weekday_schedule_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_clear_weekday_schedule_response_callback_set(const uic_mqtt_dotdot_by_group_door_lock_clear_weekday_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_clear_weekday_schedule_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_set_year_day_schedule_callback_set(const uic_mqtt_dotdot_by_group_door_lock_set_year_day_schedule_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_set_year_day_schedule_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_set_year_day_schedule_response_callback_set(const uic_mqtt_dotdot_by_group_door_lock_set_year_day_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_set_year_day_schedule_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_get_year_day_schedule_callback_set(const uic_mqtt_dotdot_by_group_door_lock_get_year_day_schedule_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_get_year_day_schedule_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_get_year_day_schedule_response_callback_set(const uic_mqtt_dotdot_by_group_door_lock_get_year_day_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_get_year_day_schedule_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_clear_year_day_schedule_callback_set(const uic_mqtt_dotdot_by_group_door_lock_clear_year_day_schedule_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_clear_year_day_schedule_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_clear_year_day_schedule_response_callback_set(const uic_mqtt_dotdot_by_group_door_lock_clear_year_day_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_clear_year_day_schedule_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_set_holiday_schedule_callback_set(const uic_mqtt_dotdot_by_group_door_lock_set_holiday_schedule_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_set_holiday_schedule_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_set_holiday_schedule_response_callback_set(const uic_mqtt_dotdot_by_group_door_lock_set_holiday_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_set_holiday_schedule_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_get_holiday_schedule_callback_set(const uic_mqtt_dotdot_by_group_door_lock_get_holiday_schedule_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_get_holiday_schedule_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_get_holiday_schedule_response_callback_set(const uic_mqtt_dotdot_by_group_door_lock_get_holiday_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_get_holiday_schedule_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_clear_holiday_schedule_callback_set(const uic_mqtt_dotdot_by_group_door_lock_clear_holiday_schedule_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_clear_holiday_schedule_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_clear_holiday_schedule_response_callback_set(const uic_mqtt_dotdot_by_group_door_lock_clear_holiday_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_clear_holiday_schedule_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_set_user_type_callback_set(const uic_mqtt_dotdot_by_group_door_lock_set_user_type_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_set_user_type_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_set_user_type_response_callback_set(const uic_mqtt_dotdot_by_group_door_lock_set_user_type_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_set_user_type_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_get_user_type_callback_set(const uic_mqtt_dotdot_by_group_door_lock_get_user_type_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_get_user_type_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_get_user_type_response_callback_set(const uic_mqtt_dotdot_by_group_door_lock_get_user_type_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_get_user_type_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_setrfid_code_callback_set(const uic_mqtt_dotdot_by_group_door_lock_setrfid_code_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_setrfid_code_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_setrfid_code_response_callback_set(const uic_mqtt_dotdot_by_group_door_lock_setrfid_code_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_setrfid_code_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_getrfid_code_callback_set(const uic_mqtt_dotdot_by_group_door_lock_getrfid_code_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_getrfid_code_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_getrfid_code_response_callback_set(const uic_mqtt_dotdot_by_group_door_lock_getrfid_code_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_getrfid_code_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_clearrfid_code_callback_set(const uic_mqtt_dotdot_by_group_door_lock_clearrfid_code_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_clearrfid_code_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_clearrfid_code_response_callback_set(const uic_mqtt_dotdot_by_group_door_lock_clearrfid_code_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_clearrfid_code_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_clear_allrfid_codes_callback_set(const uic_mqtt_dotdot_by_group_door_lock_clear_allrfid_codes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_clear_allrfid_codes_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_clear_allrfid_codes_response_callback_set(const uic_mqtt_dotdot_by_group_door_lock_clear_allrfid_codes_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_clear_allrfid_codes_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_operating_event_notification_callback_set(const uic_mqtt_dotdot_by_group_door_lock_operating_event_notification_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_operating_event_notification_callback = callback;
}


void uic_mqtt_dotdot_by_group_door_lock_programming_event_notification_callback_set(const uic_mqtt_dotdot_by_group_door_lock_programming_event_notification_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_programming_event_notification_callback = callback;
}

void uic_mqtt_dotdot_by_group_door_lock_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_door_lock_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_door_lock_write_attributes_callback = callback;
}



// Callbacks setters

void uic_mqtt_dotdot_by_group_window_covering_up_or_open_callback_set(const uic_mqtt_dotdot_by_group_window_covering_up_or_open_callback_t callback)
{
  uic_mqtt_dotdot_by_group_window_covering_up_or_open_callback = callback;
}


void uic_mqtt_dotdot_by_group_window_covering_down_or_close_callback_set(const uic_mqtt_dotdot_by_group_window_covering_down_or_close_callback_t callback)
{
  uic_mqtt_dotdot_by_group_window_covering_down_or_close_callback = callback;
}


void uic_mqtt_dotdot_by_group_window_covering_stop_callback_set(const uic_mqtt_dotdot_by_group_window_covering_stop_callback_t callback)
{
  uic_mqtt_dotdot_by_group_window_covering_stop_callback = callback;
}


void uic_mqtt_dotdot_by_group_window_covering_go_to_lift_value_callback_set(const uic_mqtt_dotdot_by_group_window_covering_go_to_lift_value_callback_t callback)
{
  uic_mqtt_dotdot_by_group_window_covering_go_to_lift_value_callback = callback;
}


void uic_mqtt_dotdot_by_group_window_covering_go_to_lift_percentage_callback_set(const uic_mqtt_dotdot_by_group_window_covering_go_to_lift_percentage_callback_t callback)
{
  uic_mqtt_dotdot_by_group_window_covering_go_to_lift_percentage_callback = callback;
}


void uic_mqtt_dotdot_by_group_window_covering_go_to_tilt_value_callback_set(const uic_mqtt_dotdot_by_group_window_covering_go_to_tilt_value_callback_t callback)
{
  uic_mqtt_dotdot_by_group_window_covering_go_to_tilt_value_callback = callback;
}


void uic_mqtt_dotdot_by_group_window_covering_go_to_tilt_percentage_callback_set(const uic_mqtt_dotdot_by_group_window_covering_go_to_tilt_percentage_callback_t callback)
{
  uic_mqtt_dotdot_by_group_window_covering_go_to_tilt_percentage_callback = callback;
}

void uic_mqtt_dotdot_by_group_window_covering_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_window_covering_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_window_covering_write_attributes_callback = callback;
}



// Callbacks setters

void uic_mqtt_dotdot_by_group_barrier_control_go_to_percent_callback_set(const uic_mqtt_dotdot_by_group_barrier_control_go_to_percent_callback_t callback)
{
  uic_mqtt_dotdot_by_group_barrier_control_go_to_percent_callback = callback;
}


void uic_mqtt_dotdot_by_group_barrier_control_stop_callback_set(const uic_mqtt_dotdot_by_group_barrier_control_stop_callback_t callback)
{
  uic_mqtt_dotdot_by_group_barrier_control_stop_callback = callback;
}

void uic_mqtt_dotdot_by_group_barrier_control_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_barrier_control_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_barrier_control_write_attributes_callback = callback;
}



// Callbacks setters
void uic_mqtt_dotdot_by_group_pump_configuration_and_control_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_pump_configuration_and_control_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_pump_configuration_and_control_write_attributes_callback = callback;
}



// Callbacks setters

void uic_mqtt_dotdot_by_group_thermostat_setpoint_raise_or_lower_callback_set(const uic_mqtt_dotdot_by_group_thermostat_setpoint_raise_or_lower_callback_t callback)
{
  uic_mqtt_dotdot_by_group_thermostat_setpoint_raise_or_lower_callback = callback;
}


void uic_mqtt_dotdot_by_group_thermostat_get_weekly_schedule_response_callback_set(const uic_mqtt_dotdot_by_group_thermostat_get_weekly_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_thermostat_get_weekly_schedule_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_thermostat_set_weekly_schedule_callback_set(const uic_mqtt_dotdot_by_group_thermostat_set_weekly_schedule_callback_t callback)
{
  uic_mqtt_dotdot_by_group_thermostat_set_weekly_schedule_callback = callback;
}


void uic_mqtt_dotdot_by_group_thermostat_get_relay_status_log_response_callback_set(const uic_mqtt_dotdot_by_group_thermostat_get_relay_status_log_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_thermostat_get_relay_status_log_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_thermostat_get_weekly_schedule_callback_set(const uic_mqtt_dotdot_by_group_thermostat_get_weekly_schedule_callback_t callback)
{
  uic_mqtt_dotdot_by_group_thermostat_get_weekly_schedule_callback = callback;
}


void uic_mqtt_dotdot_by_group_thermostat_clear_weekly_schedule_callback_set(const uic_mqtt_dotdot_by_group_thermostat_clear_weekly_schedule_callback_t callback)
{
  uic_mqtt_dotdot_by_group_thermostat_clear_weekly_schedule_callback = callback;
}


void uic_mqtt_dotdot_by_group_thermostat_get_relay_status_log_callback_set(const uic_mqtt_dotdot_by_group_thermostat_get_relay_status_log_callback_t callback)
{
  uic_mqtt_dotdot_by_group_thermostat_get_relay_status_log_callback = callback;
}

void uic_mqtt_dotdot_by_group_thermostat_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_thermostat_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_thermostat_write_attributes_callback = callback;
}



// Callbacks setters
void uic_mqtt_dotdot_by_group_fan_control_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_fan_control_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_fan_control_write_attributes_callback = callback;
}



// Callbacks setters
void uic_mqtt_dotdot_by_group_dehumidification_control_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_dehumidification_control_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_dehumidification_control_write_attributes_callback = callback;
}



// Callbacks setters
void uic_mqtt_dotdot_by_group_thermostat_user_interface_configuration_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_thermostat_user_interface_configuration_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_thermostat_user_interface_configuration_write_attributes_callback = callback;
}



// Callbacks setters

void uic_mqtt_dotdot_by_group_color_control_move_to_hue_callback_set(const uic_mqtt_dotdot_by_group_color_control_move_to_hue_callback_t callback)
{
  uic_mqtt_dotdot_by_group_color_control_move_to_hue_callback = callback;
}


void uic_mqtt_dotdot_by_group_color_control_move_hue_callback_set(const uic_mqtt_dotdot_by_group_color_control_move_hue_callback_t callback)
{
  uic_mqtt_dotdot_by_group_color_control_move_hue_callback = callback;
}


void uic_mqtt_dotdot_by_group_color_control_step_hue_callback_set(const uic_mqtt_dotdot_by_group_color_control_step_hue_callback_t callback)
{
  uic_mqtt_dotdot_by_group_color_control_step_hue_callback = callback;
}


void uic_mqtt_dotdot_by_group_color_control_move_to_saturation_callback_set(const uic_mqtt_dotdot_by_group_color_control_move_to_saturation_callback_t callback)
{
  uic_mqtt_dotdot_by_group_color_control_move_to_saturation_callback = callback;
}


void uic_mqtt_dotdot_by_group_color_control_move_saturation_callback_set(const uic_mqtt_dotdot_by_group_color_control_move_saturation_callback_t callback)
{
  uic_mqtt_dotdot_by_group_color_control_move_saturation_callback = callback;
}


void uic_mqtt_dotdot_by_group_color_control_step_saturation_callback_set(const uic_mqtt_dotdot_by_group_color_control_step_saturation_callback_t callback)
{
  uic_mqtt_dotdot_by_group_color_control_step_saturation_callback = callback;
}


void uic_mqtt_dotdot_by_group_color_control_move_to_hue_and_saturation_callback_set(const uic_mqtt_dotdot_by_group_color_control_move_to_hue_and_saturation_callback_t callback)
{
  uic_mqtt_dotdot_by_group_color_control_move_to_hue_and_saturation_callback = callback;
}


void uic_mqtt_dotdot_by_group_color_control_move_to_color_callback_set(const uic_mqtt_dotdot_by_group_color_control_move_to_color_callback_t callback)
{
  uic_mqtt_dotdot_by_group_color_control_move_to_color_callback = callback;
}


void uic_mqtt_dotdot_by_group_color_control_move_color_callback_set(const uic_mqtt_dotdot_by_group_color_control_move_color_callback_t callback)
{
  uic_mqtt_dotdot_by_group_color_control_move_color_callback = callback;
}


void uic_mqtt_dotdot_by_group_color_control_step_color_callback_set(const uic_mqtt_dotdot_by_group_color_control_step_color_callback_t callback)
{
  uic_mqtt_dotdot_by_group_color_control_step_color_callback = callback;
}


void uic_mqtt_dotdot_by_group_color_control_move_to_color_temperature_callback_set(const uic_mqtt_dotdot_by_group_color_control_move_to_color_temperature_callback_t callback)
{
  uic_mqtt_dotdot_by_group_color_control_move_to_color_temperature_callback = callback;
}


void uic_mqtt_dotdot_by_group_color_control_enhanced_move_to_hue_callback_set(const uic_mqtt_dotdot_by_group_color_control_enhanced_move_to_hue_callback_t callback)
{
  uic_mqtt_dotdot_by_group_color_control_enhanced_move_to_hue_callback = callback;
}


void uic_mqtt_dotdot_by_group_color_control_enhanced_move_hue_callback_set(const uic_mqtt_dotdot_by_group_color_control_enhanced_move_hue_callback_t callback)
{
  uic_mqtt_dotdot_by_group_color_control_enhanced_move_hue_callback = callback;
}


void uic_mqtt_dotdot_by_group_color_control_enhanced_step_hue_callback_set(const uic_mqtt_dotdot_by_group_color_control_enhanced_step_hue_callback_t callback)
{
  uic_mqtt_dotdot_by_group_color_control_enhanced_step_hue_callback = callback;
}


void uic_mqtt_dotdot_by_group_color_control_enhanced_move_to_hue_and_saturation_callback_set(const uic_mqtt_dotdot_by_group_color_control_enhanced_move_to_hue_and_saturation_callback_t callback)
{
  uic_mqtt_dotdot_by_group_color_control_enhanced_move_to_hue_and_saturation_callback = callback;
}


void uic_mqtt_dotdot_by_group_color_control_color_loop_set_callback_set(const uic_mqtt_dotdot_by_group_color_control_color_loop_set_callback_t callback)
{
  uic_mqtt_dotdot_by_group_color_control_color_loop_set_callback = callback;
}


void uic_mqtt_dotdot_by_group_color_control_stop_move_step_callback_set(const uic_mqtt_dotdot_by_group_color_control_stop_move_step_callback_t callback)
{
  uic_mqtt_dotdot_by_group_color_control_stop_move_step_callback = callback;
}


void uic_mqtt_dotdot_by_group_color_control_move_color_temperature_callback_set(const uic_mqtt_dotdot_by_group_color_control_move_color_temperature_callback_t callback)
{
  uic_mqtt_dotdot_by_group_color_control_move_color_temperature_callback = callback;
}


void uic_mqtt_dotdot_by_group_color_control_step_color_temperature_callback_set(const uic_mqtt_dotdot_by_group_color_control_step_color_temperature_callback_t callback)
{
  uic_mqtt_dotdot_by_group_color_control_step_color_temperature_callback = callback;
}

void uic_mqtt_dotdot_by_group_color_control_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_color_control_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_color_control_write_attributes_callback = callback;
}



// Callbacks setters
void uic_mqtt_dotdot_by_group_ballast_configuration_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_ballast_configuration_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_ballast_configuration_write_attributes_callback = callback;
}



// Callbacks setters
void uic_mqtt_dotdot_by_group_illuminance_measurement_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_illuminance_measurement_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_illuminance_measurement_write_attributes_callback = callback;
}



// Callbacks setters
void uic_mqtt_dotdot_by_group_illuminance_level_sensing_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_illuminance_level_sensing_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_illuminance_level_sensing_write_attributes_callback = callback;
}



// Callbacks setters
void uic_mqtt_dotdot_by_group_temperature_measurement_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_temperature_measurement_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_temperature_measurement_write_attributes_callback = callback;
}



// Callbacks setters
void uic_mqtt_dotdot_by_group_pressure_measurement_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_pressure_measurement_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_pressure_measurement_write_attributes_callback = callback;
}



// Callbacks setters
void uic_mqtt_dotdot_by_group_flow_measurement_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_flow_measurement_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_flow_measurement_write_attributes_callback = callback;
}



// Callbacks setters
void uic_mqtt_dotdot_by_group_relativity_humidity_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_relativity_humidity_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_relativity_humidity_write_attributes_callback = callback;
}



// Callbacks setters
void uic_mqtt_dotdot_by_group_occupancy_sensing_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_occupancy_sensing_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_occupancy_sensing_write_attributes_callback = callback;
}



// Callbacks setters
void uic_mqtt_dotdot_by_group_ph_measurement_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_ph_measurement_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_ph_measurement_write_attributes_callback = callback;
}



// Callbacks setters
void uic_mqtt_dotdot_by_group_electrical_conductivity_measurement_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_electrical_conductivity_measurement_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_electrical_conductivity_measurement_write_attributes_callback = callback;
}



// Callbacks setters
void uic_mqtt_dotdot_by_group_wind_speed_measurement_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_wind_speed_measurement_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_wind_speed_measurement_write_attributes_callback = callback;
}



// Callbacks setters
void uic_mqtt_dotdot_by_group_carbon_monoxide_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_carbon_monoxide_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_carbon_monoxide_write_attributes_callback = callback;
}



// Callbacks setters

void uic_mqtt_dotdot_by_group_ias_zone_zone_enroll_response_callback_set(const uic_mqtt_dotdot_by_group_ias_zone_zone_enroll_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_ias_zone_zone_enroll_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_ias_zone_zone_status_change_notification_callback_set(const uic_mqtt_dotdot_by_group_ias_zone_zone_status_change_notification_callback_t callback)
{
  uic_mqtt_dotdot_by_group_ias_zone_zone_status_change_notification_callback = callback;
}


void uic_mqtt_dotdot_by_group_ias_zone_initiate_normal_operation_mode_callback_set(const uic_mqtt_dotdot_by_group_ias_zone_initiate_normal_operation_mode_callback_t callback)
{
  uic_mqtt_dotdot_by_group_ias_zone_initiate_normal_operation_mode_callback = callback;
}


void uic_mqtt_dotdot_by_group_ias_zone_zone_enroll_request_callback_set(const uic_mqtt_dotdot_by_group_ias_zone_zone_enroll_request_callback_t callback)
{
  uic_mqtt_dotdot_by_group_ias_zone_zone_enroll_request_callback = callback;
}


void uic_mqtt_dotdot_by_group_ias_zone_initiate_test_mode_callback_set(const uic_mqtt_dotdot_by_group_ias_zone_initiate_test_mode_callback_t callback)
{
  uic_mqtt_dotdot_by_group_ias_zone_initiate_test_mode_callback = callback;
}

void uic_mqtt_dotdot_by_group_ias_zone_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_ias_zone_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_ias_zone_write_attributes_callback = callback;
}



// Callbacks setters

void uic_mqtt_dotdot_by_group_iaswd_start_warning_callback_set(const uic_mqtt_dotdot_by_group_iaswd_start_warning_callback_t callback)
{
  uic_mqtt_dotdot_by_group_iaswd_start_warning_callback = callback;
}


void uic_mqtt_dotdot_by_group_iaswd_squawk_callback_set(const uic_mqtt_dotdot_by_group_iaswd_squawk_callback_t callback)
{
  uic_mqtt_dotdot_by_group_iaswd_squawk_callback = callback;
}

void uic_mqtt_dotdot_by_group_iaswd_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_iaswd_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_iaswd_write_attributes_callback = callback;
}



// Callbacks setters
void uic_mqtt_dotdot_by_group_metering_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_metering_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_metering_write_attributes_callback = callback;
}



// Callbacks setters

void uic_mqtt_dotdot_by_group_electrical_measurement_get_profile_info_response_callback_set(const uic_mqtt_dotdot_by_group_electrical_measurement_get_profile_info_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_electrical_measurement_get_profile_info_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_electrical_measurement_get_profile_info_callback_set(const uic_mqtt_dotdot_by_group_electrical_measurement_get_profile_info_callback_t callback)
{
  uic_mqtt_dotdot_by_group_electrical_measurement_get_profile_info_callback = callback;
}


void uic_mqtt_dotdot_by_group_electrical_measurement_get_measurement_profile_response_callback_set(const uic_mqtt_dotdot_by_group_electrical_measurement_get_measurement_profile_response_callback_t callback)
{
  uic_mqtt_dotdot_by_group_electrical_measurement_get_measurement_profile_response_callback = callback;
}


void uic_mqtt_dotdot_by_group_electrical_measurement_get_measurement_profile_callback_set(const uic_mqtt_dotdot_by_group_electrical_measurement_get_measurement_profile_callback_t callback)
{
  uic_mqtt_dotdot_by_group_electrical_measurement_get_measurement_profile_callback = callback;
}

void uic_mqtt_dotdot_by_group_electrical_measurement_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_electrical_measurement_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_electrical_measurement_write_attributes_callback = callback;
}



// Callbacks setters
void uic_mqtt_dotdot_by_group_diagnostics_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_diagnostics_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_diagnostics_write_attributes_callback = callback;
}



// Callbacks setters

void uic_mqtt_dotdot_by_group_binding_bind_callback_set(const uic_mqtt_dotdot_by_group_binding_bind_callback_t callback)
{
  uic_mqtt_dotdot_by_group_binding_bind_callback = callback;
}


void uic_mqtt_dotdot_by_group_binding_unbind_callback_set(const uic_mqtt_dotdot_by_group_binding_unbind_callback_t callback)
{
  uic_mqtt_dotdot_by_group_binding_unbind_callback = callback;
}


void uic_mqtt_dotdot_by_group_binding_bind_to_protocol_controller_callback_set(const uic_mqtt_dotdot_by_group_binding_bind_to_protocol_controller_callback_t callback)
{
  uic_mqtt_dotdot_by_group_binding_bind_to_protocol_controller_callback = callback;
}


void uic_mqtt_dotdot_by_group_binding_unbind_from_protocol_controller_callback_set(const uic_mqtt_dotdot_by_group_binding_unbind_from_protocol_controller_callback_t callback)
{
  uic_mqtt_dotdot_by_group_binding_unbind_from_protocol_controller_callback = callback;
}

void uic_mqtt_dotdot_by_group_binding_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_binding_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_binding_write_attributes_callback = callback;
}



// Callbacks setters
void uic_mqtt_dotdot_by_group_name_and_location_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_name_and_location_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_name_and_location_write_attributes_callback = callback;
}



// Callbacks setters

void uic_mqtt_dotdot_by_group_configuration_parameters_discover_parameter_callback_set(const uic_mqtt_dotdot_by_group_configuration_parameters_discover_parameter_callback_t callback)
{
  uic_mqtt_dotdot_by_group_configuration_parameters_discover_parameter_callback = callback;
}


void uic_mqtt_dotdot_by_group_configuration_parameters_default_reset_all_parameters_callback_set(const uic_mqtt_dotdot_by_group_configuration_parameters_default_reset_all_parameters_callback_t callback)
{
  uic_mqtt_dotdot_by_group_configuration_parameters_default_reset_all_parameters_callback = callback;
}


void uic_mqtt_dotdot_by_group_configuration_parameters_set_parameter_callback_set(const uic_mqtt_dotdot_by_group_configuration_parameters_set_parameter_callback_t callback)
{
  uic_mqtt_dotdot_by_group_configuration_parameters_set_parameter_callback = callback;
}


void uic_mqtt_dotdot_by_group_configuration_parameters_discover_parameter_range_callback_set(const uic_mqtt_dotdot_by_group_configuration_parameters_discover_parameter_range_callback_t callback)
{
  uic_mqtt_dotdot_by_group_configuration_parameters_discover_parameter_range_callback = callback;
}

void uic_mqtt_dotdot_by_group_configuration_parameters_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_configuration_parameters_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_configuration_parameters_write_attributes_callback = callback;
}



// Callbacks setters

void uic_mqtt_dotdot_by_group_aox_locator_iq_report_callback_set(const uic_mqtt_dotdot_by_group_aox_locator_iq_report_callback_t callback)
{
  uic_mqtt_dotdot_by_group_aox_locator_iq_report_callback = callback;
}


void uic_mqtt_dotdot_by_group_aox_locator_angle_report_callback_set(const uic_mqtt_dotdot_by_group_aox_locator_angle_report_callback_t callback)
{
  uic_mqtt_dotdot_by_group_aox_locator_angle_report_callback = callback;
}


void uic_mqtt_dotdot_by_group_aox_locator_angle_correction_callback_set(const uic_mqtt_dotdot_by_group_aox_locator_angle_correction_callback_t callback)
{
  uic_mqtt_dotdot_by_group_aox_locator_angle_correction_callback = callback;
}

void uic_mqtt_dotdot_by_group_aox_locator_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_aox_locator_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_aox_locator_write_attributes_callback = callback;
}



// Callbacks setters
void uic_mqtt_dotdot_by_group_aox_position_estimation_write_attributes_callback_set(
  const uic_mqtt_dotdot_by_group_aox_position_estimation_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_by_group_aox_position_estimation_write_attributes_callback = callback;
}




// Callback function for incoming publications on ucl/by-group/+/Basic/Commands/ResetToFactoryDefaults
static void uic_mqtt_dotdot_on_by_group_basic_reset_to_factory_defaults(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_basic_reset_to_factory_defaults_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_basic_reset_to_factory_defaults_callback != nullptr) {

    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Basic", "ResetToFactoryDefaults");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic", "ResetToFactoryDefaults", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic", "ResetToFactoryDefaults", "");
        return;
      }

      uic_mqtt_dotdot_by_group_basic_reset_to_factory_defaults_callback(
        group_id
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));

      group_dispatch_callback(
        group_id,
        "Basic",
        "ResetToFactoryDefaults",
        message,
        message_length,
        uic_mqtt_dotdot_on_basic_reset_to_factory_defaults);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ResetToFactoryDefaults: Unable to parse JSON payload.\n");
      return;
    }
  }

}

static void uic_mqtt_dotdot_on_by_group_basic_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_basic_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_basic_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "Basic",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_basic_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "Basic: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_basic_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_basic_state_t new_state = {};
    uic_mqtt_dotdot_basic_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_basic_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Basic", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_basic_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_basic_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_basic_write_attributes_callback) {
    subscription_topic = topic_bygroup + "Basic/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_basic_WriteAttributes);
  }
  if (uic_mqtt_dotdot_by_group_basic_reset_to_factory_defaults_callback) {
    subscription_topic = topic_bygroup + "Basic/Commands/ResetToFactoryDefaults";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_basic_reset_to_factory_defaults);
  }

  return SL_STATUS_OK;
}




static void uic_mqtt_dotdot_on_by_group_power_configuration_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_power_configuration_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_power_configuration_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "PowerConfiguration",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_power_configuration_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "PowerConfiguration: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_power_configuration_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_power_configuration_state_t new_state = {};
    uic_mqtt_dotdot_power_configuration_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_power_configuration_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PowerConfiguration", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_power_configuration_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_power_configuration_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_power_configuration_write_attributes_callback) {
    subscription_topic = topic_bygroup + "PowerConfiguration/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_power_configuration_WriteAttributes);
  }

  return SL_STATUS_OK;
}




static void uic_mqtt_dotdot_on_by_group_device_temperature_configuration_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_device_temperature_configuration_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_device_temperature_configuration_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "DeviceTemperatureConfiguration",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_device_temperature_configuration_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "DeviceTemperatureConfiguration: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_device_temperature_configuration_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_device_temperature_configuration_state_t new_state = {};
    uic_mqtt_dotdot_device_temperature_configuration_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_device_temperature_configuration_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DeviceTemperatureConfiguration", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DeviceTemperatureConfiguration", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DeviceTemperatureConfiguration", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_device_temperature_configuration_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_device_temperature_configuration_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_device_temperature_configuration_write_attributes_callback) {
    subscription_topic = topic_bygroup + "DeviceTemperatureConfiguration/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_device_temperature_configuration_WriteAttributes);
  }

  return SL_STATUS_OK;
}




// Callback function for incoming publications on ucl/by-group/+/Identify/Commands/Identify
static void uic_mqtt_dotdot_on_by_group_identify_identify(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_identify_identify_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_identify_identify_callback != nullptr) {

    
    uic_mqtt_dotdot_identify_command_identify_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_identify_identify(
          jsn,
          fields.identify_time
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Identify", "Identify");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "Identify", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "Identify", "");
        return;
      }

      uic_mqtt_dotdot_by_group_identify_identify_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_identify_identify_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("IdentifyTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Identify::Identify: Missing command-argument: IdentifyTime\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Identify",
        "Identify",
        message,
        message_length,
        uic_mqtt_dotdot_on_identify_identify);

    } catch (...) {
      sl_log_debug(LOG_TAG, "Identify: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Identify/Commands/IdentifyQueryResponse
static void uic_mqtt_dotdot_on_by_group_identify_identify_query_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_identify_identify_query_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_identify_identify_query_response_callback != nullptr) {

    
    uic_mqtt_dotdot_identify_command_identify_query_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_identify_identify_query_response(
          jsn,
          fields.timeout
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Identify", "IdentifyQueryResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "IdentifyQueryResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "IdentifyQueryResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_identify_identify_query_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_identify_identify_query_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Timeout") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Identify::IdentifyQueryResponse: Missing command-argument: Timeout\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Identify",
        "IdentifyQueryResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_identify_identify_query_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "IdentifyQueryResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Identify/Commands/IdentifyQuery
static void uic_mqtt_dotdot_on_by_group_identify_identify_query(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_identify_identify_query_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_identify_identify_query_callback != nullptr) {

    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Identify", "IdentifyQuery");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "IdentifyQuery", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "IdentifyQuery", "");
        return;
      }

      uic_mqtt_dotdot_by_group_identify_identify_query_callback(
        group_id
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_identify_identify_query_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));

      group_dispatch_callback(
        group_id,
        "Identify",
        "IdentifyQuery",
        message,
        message_length,
        uic_mqtt_dotdot_on_identify_identify_query);

    } catch (...) {
      sl_log_debug(LOG_TAG, "IdentifyQuery: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Identify/Commands/TriggerEffect
static void uic_mqtt_dotdot_on_by_group_identify_trigger_effect(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_identify_trigger_effect_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_identify_trigger_effect_callback != nullptr) {

    
    uic_mqtt_dotdot_identify_command_trigger_effect_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_identify_trigger_effect(
          jsn,
          fields.effect_identifier,
              
          fields.effect_variant
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Identify", "TriggerEffect");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "TriggerEffect", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "TriggerEffect", "");
        return;
      }

      uic_mqtt_dotdot_by_group_identify_trigger_effect_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_identify_trigger_effect_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("EffectIdentifier") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Identify::TriggerEffect: Missing command-argument: EffectIdentifier\n");
        return;
      }
      if (jsn.find("EffectVariant") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Identify::TriggerEffect: Missing command-argument: EffectVariant\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Identify",
        "TriggerEffect",
        message,
        message_length,
        uic_mqtt_dotdot_on_identify_trigger_effect);

    } catch (...) {
      sl_log_debug(LOG_TAG, "TriggerEffect: Unable to parse JSON payload.\n");
      return;
    }
  }

}

static void uic_mqtt_dotdot_on_by_group_identify_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_identify_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_identify_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "Identify",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_identify_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "Identify: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_identify_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_identify_state_t new_state = {};
    uic_mqtt_dotdot_identify_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_identify_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Identify", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_identify_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_identify_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_identify_write_attributes_callback) {
    subscription_topic = topic_bygroup + "Identify/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_identify_WriteAttributes);
  }
  if (uic_mqtt_dotdot_by_group_identify_identify_callback) {
    subscription_topic = topic_bygroup + "Identify/Commands/Identify";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_identify_identify);
  }
  if (uic_mqtt_dotdot_by_group_identify_identify_query_response_callback) {
    subscription_topic = topic_bygroup + "Identify/Commands/IdentifyQueryResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_identify_identify_query_response);
  }
  if (uic_mqtt_dotdot_by_group_identify_identify_query_callback) {
    subscription_topic = topic_bygroup + "Identify/Commands/IdentifyQuery";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_identify_identify_query);
  }
  if (uic_mqtt_dotdot_by_group_identify_trigger_effect_callback) {
    subscription_topic = topic_bygroup + "Identify/Commands/TriggerEffect";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_identify_trigger_effect);
  }

  return SL_STATUS_OK;
}




// Callback function for incoming publications on ucl/by-group/+/Groups/Commands/AddGroup
static void uic_mqtt_dotdot_on_by_group_groups_add_group(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_groups_add_group_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_groups_add_group_callback != nullptr) {

    
    uic_mqtt_dotdot_groups_command_add_group_fields_t fields;
      std::string group_name;
    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_groups_add_group(
          jsn,
          fields.group_id,
              
          group_name
      );

      // Populate list fields from vector or string types
              fields.group_name = group_name.c_str();
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "AddGroup");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "AddGroup", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "AddGroup", "");
        return;
      }

      uic_mqtt_dotdot_by_group_groups_add_group_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_groups_add_group_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("GroupId") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Groups::AddGroup: Missing command-argument: GroupId\n");
        return;
      }
      if (jsn.find("GroupName") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Groups::AddGroup: Missing command-argument: GroupName\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Groups",
        "AddGroup",
        message,
        message_length,
        uic_mqtt_dotdot_on_groups_add_group);

    } catch (...) {
      sl_log_debug(LOG_TAG, "AddGroup: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Groups/Commands/AddGroupResponse
static void uic_mqtt_dotdot_on_by_group_groups_add_group_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_groups_add_group_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_groups_add_group_response_callback != nullptr) {

    
    uic_mqtt_dotdot_groups_command_add_group_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_groups_add_group_response(
          jsn,
          fields.status,
              
          fields.group_id
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "AddGroupResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "AddGroupResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "AddGroupResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_groups_add_group_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_groups_add_group_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Groups::AddGroupResponse: Missing command-argument: Status\n");
        return;
      }
      if (jsn.find("GroupId") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Groups::AddGroupResponse: Missing command-argument: GroupId\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Groups",
        "AddGroupResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_groups_add_group_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "AddGroupResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Groups/Commands/ViewGroup
static void uic_mqtt_dotdot_on_by_group_groups_view_group(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_groups_view_group_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_groups_view_group_callback != nullptr) {

    
    uic_mqtt_dotdot_groups_command_view_group_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_groups_view_group(
          jsn,
          fields.group_id
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "ViewGroup");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "ViewGroup", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "ViewGroup", "");
        return;
      }

      uic_mqtt_dotdot_by_group_groups_view_group_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_groups_view_group_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("GroupId") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Groups::ViewGroup: Missing command-argument: GroupId\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Groups",
        "ViewGroup",
        message,
        message_length,
        uic_mqtt_dotdot_on_groups_view_group);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ViewGroup: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Groups/Commands/ViewGroupResponse
static void uic_mqtt_dotdot_on_by_group_groups_view_group_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_groups_view_group_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_groups_view_group_response_callback != nullptr) {

    
    uic_mqtt_dotdot_groups_command_view_group_response_fields_t fields;
      std::string group_name;
    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_groups_view_group_response(
          jsn,
          fields.status,
              
          fields.group_id,
              
          group_name
      );

      // Populate list fields from vector or string types
              fields.group_name = group_name.c_str();
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "ViewGroupResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "ViewGroupResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "ViewGroupResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_groups_view_group_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_groups_view_group_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Groups::ViewGroupResponse: Missing command-argument: Status\n");
        return;
      }
      if (jsn.find("GroupId") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Groups::ViewGroupResponse: Missing command-argument: GroupId\n");
        return;
      }
      if (jsn.find("GroupName") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Groups::ViewGroupResponse: Missing command-argument: GroupName\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Groups",
        "ViewGroupResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_groups_view_group_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ViewGroupResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Groups/Commands/GetGroupMembership
static void uic_mqtt_dotdot_on_by_group_groups_get_group_membership(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_groups_get_group_membership_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_groups_get_group_membership_callback != nullptr) {

    
    uic_mqtt_dotdot_groups_command_get_group_membership_fields_t fields;
      std::vector<uint16_t> group_list;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_groups_get_group_membership(
          jsn,
          group_list
      );

      // Populate list fields from vector or string types
      
        fields.group_list_count = group_list.size();
        fields.group_list = group_list.data();


      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "GetGroupMembership");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "GetGroupMembership", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "GetGroupMembership", "");
        return;
      }

      uic_mqtt_dotdot_by_group_groups_get_group_membership_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_groups_get_group_membership_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("GroupList") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Groups::GetGroupMembership: Missing command-argument: GroupList\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Groups",
        "GetGroupMembership",
        message,
        message_length,
        uic_mqtt_dotdot_on_groups_get_group_membership);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GetGroupMembership: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Groups/Commands/GetGroupMembershipResponse
static void uic_mqtt_dotdot_on_by_group_groups_get_group_membership_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_groups_get_group_membership_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_groups_get_group_membership_response_callback != nullptr) {

    
    uic_mqtt_dotdot_groups_command_get_group_membership_response_fields_t fields;
      std::vector<uint16_t> group_list;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_groups_get_group_membership_response(
          jsn,
          fields.capacity,
              
          group_list
      );

      // Populate list fields from vector or string types
      
        fields.group_list_count = group_list.size();
        fields.group_list = group_list.data();


      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "GetGroupMembershipResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "GetGroupMembershipResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "GetGroupMembershipResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_groups_get_group_membership_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_groups_get_group_membership_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Capacity") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Groups::GetGroupMembershipResponse: Missing command-argument: Capacity\n");
        return;
      }
      if (jsn.find("GroupList") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Groups::GetGroupMembershipResponse: Missing command-argument: GroupList\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Groups",
        "GetGroupMembershipResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_groups_get_group_membership_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GetGroupMembershipResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Groups/Commands/RemoveGroup
static void uic_mqtt_dotdot_on_by_group_groups_remove_group(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_groups_remove_group_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_groups_remove_group_callback != nullptr) {

    
    uic_mqtt_dotdot_groups_command_remove_group_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_groups_remove_group(
          jsn,
          fields.group_id
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "RemoveGroup");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "RemoveGroup", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "RemoveGroup", "");
        return;
      }

      uic_mqtt_dotdot_by_group_groups_remove_group_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_groups_remove_group_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("GroupId") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Groups::RemoveGroup: Missing command-argument: GroupId\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Groups",
        "RemoveGroup",
        message,
        message_length,
        uic_mqtt_dotdot_on_groups_remove_group);

    } catch (...) {
      sl_log_debug(LOG_TAG, "RemoveGroup: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Groups/Commands/RemoveGroupResponse
static void uic_mqtt_dotdot_on_by_group_groups_remove_group_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_groups_remove_group_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_groups_remove_group_response_callback != nullptr) {

    
    uic_mqtt_dotdot_groups_command_remove_group_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_groups_remove_group_response(
          jsn,
          fields.status,
              
          fields.group_id
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "RemoveGroupResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "RemoveGroupResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "RemoveGroupResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_groups_remove_group_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_groups_remove_group_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Groups::RemoveGroupResponse: Missing command-argument: Status\n");
        return;
      }
      if (jsn.find("GroupId") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Groups::RemoveGroupResponse: Missing command-argument: GroupId\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Groups",
        "RemoveGroupResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_groups_remove_group_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "RemoveGroupResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Groups/Commands/RemoveAllGroups
static void uic_mqtt_dotdot_on_by_group_groups_remove_all_groups(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_groups_remove_all_groups_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_groups_remove_all_groups_callback != nullptr) {

    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "RemoveAllGroups");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "RemoveAllGroups", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "RemoveAllGroups", "");
        return;
      }

      uic_mqtt_dotdot_by_group_groups_remove_all_groups_callback(
        group_id
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_groups_remove_all_groups_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));

      group_dispatch_callback(
        group_id,
        "Groups",
        "RemoveAllGroups",
        message,
        message_length,
        uic_mqtt_dotdot_on_groups_remove_all_groups);

    } catch (...) {
      sl_log_debug(LOG_TAG, "RemoveAllGroups: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Groups/Commands/AddGroupIfIdentifying
static void uic_mqtt_dotdot_on_by_group_groups_add_group_if_identifying(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_groups_add_group_if_identifying_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_groups_add_group_if_identifying_callback != nullptr) {

    
    uic_mqtt_dotdot_groups_command_add_group_if_identifying_fields_t fields;
      std::string group_name;
    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_groups_add_group_if_identifying(
          jsn,
          fields.group_id,
              
          group_name
      );

      // Populate list fields from vector or string types
              fields.group_name = group_name.c_str();
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "AddGroupIfIdentifying");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "AddGroupIfIdentifying", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "AddGroupIfIdentifying", "");
        return;
      }

      uic_mqtt_dotdot_by_group_groups_add_group_if_identifying_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_groups_add_group_if_identifying_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("GroupId") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Groups::AddGroupIfIdentifying: Missing command-argument: GroupId\n");
        return;
      }
      if (jsn.find("GroupName") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Groups::AddGroupIfIdentifying: Missing command-argument: GroupName\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Groups",
        "AddGroupIfIdentifying",
        message,
        message_length,
        uic_mqtt_dotdot_on_groups_add_group_if_identifying);

    } catch (...) {
      sl_log_debug(LOG_TAG, "AddGroupIfIdentifying: Unable to parse JSON payload.\n");
      return;
    }
  }

}

static void uic_mqtt_dotdot_on_by_group_groups_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_groups_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_groups_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "Groups",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_groups_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "Groups: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_groups_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_groups_state_t new_state = {};
    uic_mqtt_dotdot_groups_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_groups_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_groups_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_groups_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_groups_write_attributes_callback) {
    subscription_topic = topic_bygroup + "Groups/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_groups_WriteAttributes);
  }
  if (uic_mqtt_dotdot_by_group_groups_add_group_callback) {
    subscription_topic = topic_bygroup + "Groups/Commands/AddGroup";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_groups_add_group);
  }
  if (uic_mqtt_dotdot_by_group_groups_add_group_response_callback) {
    subscription_topic = topic_bygroup + "Groups/Commands/AddGroupResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_groups_add_group_response);
  }
  if (uic_mqtt_dotdot_by_group_groups_view_group_callback) {
    subscription_topic = topic_bygroup + "Groups/Commands/ViewGroup";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_groups_view_group);
  }
  if (uic_mqtt_dotdot_by_group_groups_view_group_response_callback) {
    subscription_topic = topic_bygroup + "Groups/Commands/ViewGroupResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_groups_view_group_response);
  }
  if (uic_mqtt_dotdot_by_group_groups_get_group_membership_callback) {
    subscription_topic = topic_bygroup + "Groups/Commands/GetGroupMembership";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_groups_get_group_membership);
  }
  if (uic_mqtt_dotdot_by_group_groups_get_group_membership_response_callback) {
    subscription_topic = topic_bygroup + "Groups/Commands/GetGroupMembershipResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_groups_get_group_membership_response);
  }
  if (uic_mqtt_dotdot_by_group_groups_remove_group_callback) {
    subscription_topic = topic_bygroup + "Groups/Commands/RemoveGroup";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_groups_remove_group);
  }
  if (uic_mqtt_dotdot_by_group_groups_remove_group_response_callback) {
    subscription_topic = topic_bygroup + "Groups/Commands/RemoveGroupResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_groups_remove_group_response);
  }
  if (uic_mqtt_dotdot_by_group_groups_remove_all_groups_callback) {
    subscription_topic = topic_bygroup + "Groups/Commands/RemoveAllGroups";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_groups_remove_all_groups);
  }
  if (uic_mqtt_dotdot_by_group_groups_add_group_if_identifying_callback) {
    subscription_topic = topic_bygroup + "Groups/Commands/AddGroupIfIdentifying";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_groups_add_group_if_identifying);
  }

  return SL_STATUS_OK;
}




// Callback function for incoming publications on ucl/by-group/+/Scenes/Commands/AddScene
static void uic_mqtt_dotdot_on_by_group_scenes_add_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_scenes_add_scene_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_scenes_add_scene_callback != nullptr) {

    
    uic_mqtt_dotdot_scenes_command_add_scene_fields_t fields;
      std::string scene_name;
          std::vector<SExtensionFieldSetList> extension_field_sets;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_scenes_add_scene(
          jsn,
          fields.groupid,
              
          fields.sceneid,
              
          fields.transition_time,
              
          scene_name,
      
          extension_field_sets,
      
          fields.transition_time100ms
              );

      // Populate list fields from vector or string types
              fields.scene_name = scene_name.c_str();
      
        fields.extension_field_sets_count = extension_field_sets.size();
        fields.extension_field_sets = extension_field_sets.data();


      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "AddScene");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "AddScene", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "AddScene", "");
        return;
      }

      uic_mqtt_dotdot_by_group_scenes_add_scene_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_scenes_add_scene_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("GroupID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::AddScene: Missing command-argument: GroupID\n");
        return;
      }
      if (jsn.find("SceneID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::AddScene: Missing command-argument: SceneID\n");
        return;
      }
      if (jsn.find("TransitionTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::AddScene: Missing command-argument: TransitionTime\n");
        return;
      }
      if (jsn.find("SceneName") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::AddScene: Missing command-argument: SceneName\n");
        return;
      }
      if (jsn.find("ExtensionFieldSets") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::AddScene: Missing command-argument: ExtensionFieldSets\n");
        return;
      }
      if (jsn.find("TransitionTime100ms") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::AddScene: Missing command-argument: TransitionTime100ms\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Scenes",
        "AddScene",
        message,
        message_length,
        uic_mqtt_dotdot_on_scenes_add_scene);

    } catch (...) {
      sl_log_debug(LOG_TAG, "AddScene: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Scenes/Commands/AddSceneResponse
static void uic_mqtt_dotdot_on_by_group_scenes_add_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_scenes_add_scene_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_scenes_add_scene_response_callback != nullptr) {

    
    uic_mqtt_dotdot_scenes_command_add_scene_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_scenes_add_scene_response(
          jsn,
          fields.status,
              
          fields.groupid,
              
          fields.sceneid
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "AddSceneResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "AddSceneResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "AddSceneResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_scenes_add_scene_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_scenes_add_scene_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::AddSceneResponse: Missing command-argument: Status\n");
        return;
      }
      if (jsn.find("GroupID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::AddSceneResponse: Missing command-argument: GroupID\n");
        return;
      }
      if (jsn.find("SceneID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::AddSceneResponse: Missing command-argument: SceneID\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Scenes",
        "AddSceneResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_scenes_add_scene_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "AddSceneResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Scenes/Commands/ViewScene
static void uic_mqtt_dotdot_on_by_group_scenes_view_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_scenes_view_scene_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_scenes_view_scene_callback != nullptr) {

    
    uic_mqtt_dotdot_scenes_command_view_scene_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_scenes_view_scene(
          jsn,
          fields.groupid,
              
          fields.sceneid
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "ViewScene");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "ViewScene", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "ViewScene", "");
        return;
      }

      uic_mqtt_dotdot_by_group_scenes_view_scene_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_scenes_view_scene_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("GroupID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::ViewScene: Missing command-argument: GroupID\n");
        return;
      }
      if (jsn.find("SceneID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::ViewScene: Missing command-argument: SceneID\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Scenes",
        "ViewScene",
        message,
        message_length,
        uic_mqtt_dotdot_on_scenes_view_scene);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ViewScene: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Scenes/Commands/ViewSceneResponse
static void uic_mqtt_dotdot_on_by_group_scenes_view_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_scenes_view_scene_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_scenes_view_scene_response_callback != nullptr) {

    
    uic_mqtt_dotdot_scenes_command_view_scene_response_fields_t fields;
      std::string scene_name;
          std::vector<SExtensionFieldSetList> extension_field_sets;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_scenes_view_scene_response(
          jsn,
          fields.status,
              
          fields.groupid,
              
          fields.sceneid,
              
          fields.transition_time,
              
          scene_name,
      
          extension_field_sets
      );

      // Populate list fields from vector or string types
              fields.scene_name = scene_name.c_str();
      
        fields.extension_field_sets_count = extension_field_sets.size();
        fields.extension_field_sets = extension_field_sets.data();


      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "ViewSceneResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "ViewSceneResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "ViewSceneResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_scenes_view_scene_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_scenes_view_scene_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::ViewSceneResponse: Missing command-argument: Status\n");
        return;
      }
      if (jsn.find("GroupID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::ViewSceneResponse: Missing command-argument: GroupID\n");
        return;
      }
      if (jsn.find("SceneID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::ViewSceneResponse: Missing command-argument: SceneID\n");
        return;
      }
      if (jsn.find("TransitionTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::ViewSceneResponse: Missing command-argument: TransitionTime\n");
        return;
      }
      if (jsn.find("SceneName") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::ViewSceneResponse: Missing command-argument: SceneName\n");
        return;
      }
      if (jsn.find("ExtensionFieldSets") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::ViewSceneResponse: Missing command-argument: ExtensionFieldSets\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Scenes",
        "ViewSceneResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_scenes_view_scene_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ViewSceneResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Scenes/Commands/RemoveScene
static void uic_mqtt_dotdot_on_by_group_scenes_remove_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_scenes_remove_scene_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_scenes_remove_scene_callback != nullptr) {

    
    uic_mqtt_dotdot_scenes_command_remove_scene_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_scenes_remove_scene(
          jsn,
          fields.groupid,
              
          fields.sceneid
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "RemoveScene");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveScene", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveScene", "");
        return;
      }

      uic_mqtt_dotdot_by_group_scenes_remove_scene_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_scenes_remove_scene_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("GroupID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::RemoveScene: Missing command-argument: GroupID\n");
        return;
      }
      if (jsn.find("SceneID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::RemoveScene: Missing command-argument: SceneID\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Scenes",
        "RemoveScene",
        message,
        message_length,
        uic_mqtt_dotdot_on_scenes_remove_scene);

    } catch (...) {
      sl_log_debug(LOG_TAG, "RemoveScene: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Scenes/Commands/RemoveSceneResponse
static void uic_mqtt_dotdot_on_by_group_scenes_remove_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_scenes_remove_scene_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_scenes_remove_scene_response_callback != nullptr) {

    
    uic_mqtt_dotdot_scenes_command_remove_scene_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_scenes_remove_scene_response(
          jsn,
          fields.status,
              
          fields.groupid,
              
          fields.sceneid
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "RemoveSceneResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveSceneResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveSceneResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_scenes_remove_scene_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_scenes_remove_scene_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::RemoveSceneResponse: Missing command-argument: Status\n");
        return;
      }
      if (jsn.find("GroupID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::RemoveSceneResponse: Missing command-argument: GroupID\n");
        return;
      }
      if (jsn.find("SceneID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::RemoveSceneResponse: Missing command-argument: SceneID\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Scenes",
        "RemoveSceneResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_scenes_remove_scene_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "RemoveSceneResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Scenes/Commands/RemoveAllScenes
static void uic_mqtt_dotdot_on_by_group_scenes_remove_all_scenes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_scenes_remove_all_scenes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_scenes_remove_all_scenes_callback != nullptr) {

    
    uic_mqtt_dotdot_scenes_command_remove_all_scenes_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_scenes_remove_all_scenes(
          jsn,
          fields.groupid
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "RemoveAllScenes");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveAllScenes", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveAllScenes", "");
        return;
      }

      uic_mqtt_dotdot_by_group_scenes_remove_all_scenes_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_scenes_remove_all_scenes_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("GroupID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::RemoveAllScenes: Missing command-argument: GroupID\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Scenes",
        "RemoveAllScenes",
        message,
        message_length,
        uic_mqtt_dotdot_on_scenes_remove_all_scenes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "RemoveAllScenes: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Scenes/Commands/RemoveAllScenesResponse
static void uic_mqtt_dotdot_on_by_group_scenes_remove_all_scenes_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_scenes_remove_all_scenes_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_scenes_remove_all_scenes_response_callback != nullptr) {

    
    uic_mqtt_dotdot_scenes_command_remove_all_scenes_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_scenes_remove_all_scenes_response(
          jsn,
          fields.status,
              
          fields.groupid
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "RemoveAllScenesResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveAllScenesResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveAllScenesResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_scenes_remove_all_scenes_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::RemoveAllScenesResponse: Missing command-argument: Status\n");
        return;
      }
      if (jsn.find("GroupID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::RemoveAllScenesResponse: Missing command-argument: GroupID\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Scenes",
        "RemoveAllScenesResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_scenes_remove_all_scenes_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "RemoveAllScenesResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Scenes/Commands/StoreScene
static void uic_mqtt_dotdot_on_by_group_scenes_store_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_scenes_store_scene_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_scenes_store_scene_callback != nullptr) {

    
    uic_mqtt_dotdot_scenes_command_store_scene_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_scenes_store_scene(
          jsn,
          fields.groupid,
              
          fields.sceneid
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "StoreScene");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "StoreScene", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "StoreScene", "");
        return;
      }

      uic_mqtt_dotdot_by_group_scenes_store_scene_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_scenes_store_scene_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("GroupID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::StoreScene: Missing command-argument: GroupID\n");
        return;
      }
      if (jsn.find("SceneID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::StoreScene: Missing command-argument: SceneID\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Scenes",
        "StoreScene",
        message,
        message_length,
        uic_mqtt_dotdot_on_scenes_store_scene);

    } catch (...) {
      sl_log_debug(LOG_TAG, "StoreScene: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Scenes/Commands/StoreSceneResponse
static void uic_mqtt_dotdot_on_by_group_scenes_store_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_scenes_store_scene_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_scenes_store_scene_response_callback != nullptr) {

    
    uic_mqtt_dotdot_scenes_command_store_scene_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_scenes_store_scene_response(
          jsn,
          fields.status,
              
          fields.groupid,
              
          fields.sceneid
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "StoreSceneResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "StoreSceneResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "StoreSceneResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_scenes_store_scene_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_scenes_store_scene_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::StoreSceneResponse: Missing command-argument: Status\n");
        return;
      }
      if (jsn.find("GroupID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::StoreSceneResponse: Missing command-argument: GroupID\n");
        return;
      }
      if (jsn.find("SceneID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::StoreSceneResponse: Missing command-argument: SceneID\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Scenes",
        "StoreSceneResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_scenes_store_scene_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "StoreSceneResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Scenes/Commands/RecallScene
static void uic_mqtt_dotdot_on_by_group_scenes_recall_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_scenes_recall_scene_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_scenes_recall_scene_callback != nullptr) {

    
    uic_mqtt_dotdot_scenes_command_recall_scene_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_scenes_recall_scene(
          jsn,
          fields.groupid,
              
          fields.sceneid,
              
          fields.transition_time
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "RecallScene");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RecallScene", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RecallScene", "");
        return;
      }

      uic_mqtt_dotdot_by_group_scenes_recall_scene_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_scenes_recall_scene_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("GroupID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::RecallScene: Missing command-argument: GroupID\n");
        return;
      }
      if (jsn.find("SceneID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::RecallScene: Missing command-argument: SceneID\n");
        return;
      }
      if (jsn.find("TransitionTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::RecallScene: Missing command-argument: TransitionTime\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Scenes",
        "RecallScene",
        message,
        message_length,
        uic_mqtt_dotdot_on_scenes_recall_scene);

    } catch (...) {
      sl_log_debug(LOG_TAG, "RecallScene: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Scenes/Commands/GetSceneMembership
static void uic_mqtt_dotdot_on_by_group_scenes_get_scene_membership(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_scenes_get_scene_membership_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_scenes_get_scene_membership_callback != nullptr) {

    
    uic_mqtt_dotdot_scenes_command_get_scene_membership_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_scenes_get_scene_membership(
          jsn,
          fields.groupid
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "GetSceneMembership");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "GetSceneMembership", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "GetSceneMembership", "");
        return;
      }

      uic_mqtt_dotdot_by_group_scenes_get_scene_membership_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_scenes_get_scene_membership_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("GroupID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::GetSceneMembership: Missing command-argument: GroupID\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Scenes",
        "GetSceneMembership",
        message,
        message_length,
        uic_mqtt_dotdot_on_scenes_get_scene_membership);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GetSceneMembership: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Scenes/Commands/GetSceneMembershipResponse
static void uic_mqtt_dotdot_on_by_group_scenes_get_scene_membership_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_scenes_get_scene_membership_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_scenes_get_scene_membership_response_callback != nullptr) {

    
    uic_mqtt_dotdot_scenes_command_get_scene_membership_response_fields_t fields;
      std::vector<uint8_t> scene_list;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_scenes_get_scene_membership_response(
          jsn,
          fields.status,
              
          fields.capacity,
              
          fields.groupid,
              
          scene_list
      );

      // Populate list fields from vector or string types
      
        fields.scene_list_count = scene_list.size();
        fields.scene_list = scene_list.data();


      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "GetSceneMembershipResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "GetSceneMembershipResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "GetSceneMembershipResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_scenes_get_scene_membership_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_scenes_get_scene_membership_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::GetSceneMembershipResponse: Missing command-argument: Status\n");
        return;
      }
      if (jsn.find("Capacity") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::GetSceneMembershipResponse: Missing command-argument: Capacity\n");
        return;
      }
      if (jsn.find("GroupID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::GetSceneMembershipResponse: Missing command-argument: GroupID\n");
        return;
      }
      if (jsn.find("SceneList") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::GetSceneMembershipResponse: Missing command-argument: SceneList\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Scenes",
        "GetSceneMembershipResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_scenes_get_scene_membership_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GetSceneMembershipResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Scenes/Commands/EnhancedAddScene
static void uic_mqtt_dotdot_on_by_group_scenes_enhanced_add_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_scenes_enhanced_add_scene_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_scenes_enhanced_add_scene_callback != nullptr) {

    
    uic_mqtt_dotdot_scenes_command_enhanced_add_scene_fields_t fields;
      std::string scene_name;
          std::vector<SExtensionFieldSetList> extension_field_sets;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_scenes_enhanced_add_scene(
          jsn,
          fields.groupid,
              
          fields.sceneid,
              
          fields.transition_time,
              
          scene_name,
      
          extension_field_sets
      );

      // Populate list fields from vector or string types
              fields.scene_name = scene_name.c_str();
      
        fields.extension_field_sets_count = extension_field_sets.size();
        fields.extension_field_sets = extension_field_sets.data();


      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "EnhancedAddScene");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedAddScene", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedAddScene", "");
        return;
      }

      uic_mqtt_dotdot_by_group_scenes_enhanced_add_scene_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_scenes_enhanced_add_scene_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("GroupID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::EnhancedAddScene: Missing command-argument: GroupID\n");
        return;
      }
      if (jsn.find("SceneID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::EnhancedAddScene: Missing command-argument: SceneID\n");
        return;
      }
      if (jsn.find("TransitionTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::EnhancedAddScene: Missing command-argument: TransitionTime\n");
        return;
      }
      if (jsn.find("SceneName") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::EnhancedAddScene: Missing command-argument: SceneName\n");
        return;
      }
      if (jsn.find("ExtensionFieldSets") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::EnhancedAddScene: Missing command-argument: ExtensionFieldSets\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Scenes",
        "EnhancedAddScene",
        message,
        message_length,
        uic_mqtt_dotdot_on_scenes_enhanced_add_scene);

    } catch (...) {
      sl_log_debug(LOG_TAG, "EnhancedAddScene: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Scenes/Commands/EnhancedAddSceneResponse
static void uic_mqtt_dotdot_on_by_group_scenes_enhanced_add_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_scenes_enhanced_add_scene_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_scenes_enhanced_add_scene_response_callback != nullptr) {

    
    uic_mqtt_dotdot_scenes_command_enhanced_add_scene_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_scenes_enhanced_add_scene_response(
          jsn,
          fields.status,
              
          fields.groupid,
              
          fields.sceneid
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "EnhancedAddSceneResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedAddSceneResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedAddSceneResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_scenes_enhanced_add_scene_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::EnhancedAddSceneResponse: Missing command-argument: Status\n");
        return;
      }
      if (jsn.find("GroupID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::EnhancedAddSceneResponse: Missing command-argument: GroupID\n");
        return;
      }
      if (jsn.find("SceneID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::EnhancedAddSceneResponse: Missing command-argument: SceneID\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Scenes",
        "EnhancedAddSceneResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_scenes_enhanced_add_scene_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "EnhancedAddSceneResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Scenes/Commands/EnhancedViewScene
static void uic_mqtt_dotdot_on_by_group_scenes_enhanced_view_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_scenes_enhanced_view_scene_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_scenes_enhanced_view_scene_callback != nullptr) {

    
    uic_mqtt_dotdot_scenes_command_enhanced_view_scene_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_scenes_enhanced_view_scene(
          jsn,
          fields.groupid,
              
          fields.sceneid
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "EnhancedViewScene");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedViewScene", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedViewScene", "");
        return;
      }

      uic_mqtt_dotdot_by_group_scenes_enhanced_view_scene_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_scenes_enhanced_view_scene_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("GroupID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::EnhancedViewScene: Missing command-argument: GroupID\n");
        return;
      }
      if (jsn.find("SceneID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::EnhancedViewScene: Missing command-argument: SceneID\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Scenes",
        "EnhancedViewScene",
        message,
        message_length,
        uic_mqtt_dotdot_on_scenes_enhanced_view_scene);

    } catch (...) {
      sl_log_debug(LOG_TAG, "EnhancedViewScene: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Scenes/Commands/EnhancedViewSceneResponse
static void uic_mqtt_dotdot_on_by_group_scenes_enhanced_view_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_scenes_enhanced_view_scene_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_scenes_enhanced_view_scene_response_callback != nullptr) {

    
    uic_mqtt_dotdot_scenes_command_enhanced_view_scene_response_fields_t fields;
      std::string scene_name;
          std::vector<SExtensionFieldSetList> extension_field_sets;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_scenes_enhanced_view_scene_response(
          jsn,
          fields.status,
              
          fields.groupid,
              
          fields.sceneid,
              
          fields.transition_time,
              
          scene_name,
      
          extension_field_sets
      );

      // Populate list fields from vector or string types
              fields.scene_name = scene_name.c_str();
      
        fields.extension_field_sets_count = extension_field_sets.size();
        fields.extension_field_sets = extension_field_sets.data();


      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "EnhancedViewSceneResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedViewSceneResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedViewSceneResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_scenes_enhanced_view_scene_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::EnhancedViewSceneResponse: Missing command-argument: Status\n");
        return;
      }
      if (jsn.find("GroupID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::EnhancedViewSceneResponse: Missing command-argument: GroupID\n");
        return;
      }
      if (jsn.find("SceneID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::EnhancedViewSceneResponse: Missing command-argument: SceneID\n");
        return;
      }
      if (jsn.find("TransitionTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::EnhancedViewSceneResponse: Missing command-argument: TransitionTime\n");
        return;
      }
      if (jsn.find("SceneName") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::EnhancedViewSceneResponse: Missing command-argument: SceneName\n");
        return;
      }
      if (jsn.find("ExtensionFieldSets") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::EnhancedViewSceneResponse: Missing command-argument: ExtensionFieldSets\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Scenes",
        "EnhancedViewSceneResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_scenes_enhanced_view_scene_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "EnhancedViewSceneResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Scenes/Commands/CopyScene
static void uic_mqtt_dotdot_on_by_group_scenes_copy_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_scenes_copy_scene_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_scenes_copy_scene_callback != nullptr) {

    
    uic_mqtt_dotdot_scenes_command_copy_scene_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_scenes_copy_scene(
          jsn,
          fields.mode,
              
          fields.group_identifier_from,
              
          fields.scene_identifier_from,
              
          fields.group_identifier_to,
              
          fields.scene_identifier_to
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "CopyScene");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "CopyScene", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "CopyScene", "");
        return;
      }

      uic_mqtt_dotdot_by_group_scenes_copy_scene_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_scenes_copy_scene_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Mode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::CopyScene: Missing command-argument: Mode\n");
        return;
      }
      if (jsn.find("GroupIdentifierFrom") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::CopyScene: Missing command-argument: GroupIdentifierFrom\n");
        return;
      }
      if (jsn.find("SceneIdentifierFrom") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::CopyScene: Missing command-argument: SceneIdentifierFrom\n");
        return;
      }
      if (jsn.find("GroupIdentifierTo") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::CopyScene: Missing command-argument: GroupIdentifierTo\n");
        return;
      }
      if (jsn.find("SceneIdentifierTo") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::CopyScene: Missing command-argument: SceneIdentifierTo\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Scenes",
        "CopyScene",
        message,
        message_length,
        uic_mqtt_dotdot_on_scenes_copy_scene);

    } catch (...) {
      sl_log_debug(LOG_TAG, "CopyScene: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Scenes/Commands/CopySceneResponse
static void uic_mqtt_dotdot_on_by_group_scenes_copy_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_scenes_copy_scene_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_scenes_copy_scene_response_callback != nullptr) {

    
    uic_mqtt_dotdot_scenes_command_copy_scene_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_scenes_copy_scene_response(
          jsn,
          fields.status,
              
          fields.group_identifier_from,
              
          fields.scene_identifier_from
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "CopySceneResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "CopySceneResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "CopySceneResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_scenes_copy_scene_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_scenes_copy_scene_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::CopySceneResponse: Missing command-argument: Status\n");
        return;
      }
      if (jsn.find("GroupIdentifierFrom") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::CopySceneResponse: Missing command-argument: GroupIdentifierFrom\n");
        return;
      }
      if (jsn.find("SceneIdentifierFrom") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Scenes::CopySceneResponse: Missing command-argument: SceneIdentifierFrom\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Scenes",
        "CopySceneResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_scenes_copy_scene_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "CopySceneResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

static void uic_mqtt_dotdot_on_by_group_scenes_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_scenes_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_scenes_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "Scenes",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_scenes_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "Scenes: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_scenes_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_scenes_state_t new_state = {};
    uic_mqtt_dotdot_scenes_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_scenes_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_scenes_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_scenes_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_scenes_write_attributes_callback) {
    subscription_topic = topic_bygroup + "Scenes/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_scenes_WriteAttributes);
  }
  if (uic_mqtt_dotdot_by_group_scenes_add_scene_callback) {
    subscription_topic = topic_bygroup + "Scenes/Commands/AddScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_scenes_add_scene);
  }
  if (uic_mqtt_dotdot_by_group_scenes_add_scene_response_callback) {
    subscription_topic = topic_bygroup + "Scenes/Commands/AddSceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_scenes_add_scene_response);
  }
  if (uic_mqtt_dotdot_by_group_scenes_view_scene_callback) {
    subscription_topic = topic_bygroup + "Scenes/Commands/ViewScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_scenes_view_scene);
  }
  if (uic_mqtt_dotdot_by_group_scenes_view_scene_response_callback) {
    subscription_topic = topic_bygroup + "Scenes/Commands/ViewSceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_scenes_view_scene_response);
  }
  if (uic_mqtt_dotdot_by_group_scenes_remove_scene_callback) {
    subscription_topic = topic_bygroup + "Scenes/Commands/RemoveScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_scenes_remove_scene);
  }
  if (uic_mqtt_dotdot_by_group_scenes_remove_scene_response_callback) {
    subscription_topic = topic_bygroup + "Scenes/Commands/RemoveSceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_scenes_remove_scene_response);
  }
  if (uic_mqtt_dotdot_by_group_scenes_remove_all_scenes_callback) {
    subscription_topic = topic_bygroup + "Scenes/Commands/RemoveAllScenes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_scenes_remove_all_scenes);
  }
  if (uic_mqtt_dotdot_by_group_scenes_remove_all_scenes_response_callback) {
    subscription_topic = topic_bygroup + "Scenes/Commands/RemoveAllScenesResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_scenes_remove_all_scenes_response);
  }
  if (uic_mqtt_dotdot_by_group_scenes_store_scene_callback) {
    subscription_topic = topic_bygroup + "Scenes/Commands/StoreScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_scenes_store_scene);
  }
  if (uic_mqtt_dotdot_by_group_scenes_store_scene_response_callback) {
    subscription_topic = topic_bygroup + "Scenes/Commands/StoreSceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_scenes_store_scene_response);
  }
  if (uic_mqtt_dotdot_by_group_scenes_recall_scene_callback) {
    subscription_topic = topic_bygroup + "Scenes/Commands/RecallScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_scenes_recall_scene);
  }
  if (uic_mqtt_dotdot_by_group_scenes_get_scene_membership_callback) {
    subscription_topic = topic_bygroup + "Scenes/Commands/GetSceneMembership";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_scenes_get_scene_membership);
  }
  if (uic_mqtt_dotdot_by_group_scenes_get_scene_membership_response_callback) {
    subscription_topic = topic_bygroup + "Scenes/Commands/GetSceneMembershipResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_scenes_get_scene_membership_response);
  }
  if (uic_mqtt_dotdot_by_group_scenes_enhanced_add_scene_callback) {
    subscription_topic = topic_bygroup + "Scenes/Commands/EnhancedAddScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_scenes_enhanced_add_scene);
  }
  if (uic_mqtt_dotdot_by_group_scenes_enhanced_add_scene_response_callback) {
    subscription_topic = topic_bygroup + "Scenes/Commands/EnhancedAddSceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_scenes_enhanced_add_scene_response);
  }
  if (uic_mqtt_dotdot_by_group_scenes_enhanced_view_scene_callback) {
    subscription_topic = topic_bygroup + "Scenes/Commands/EnhancedViewScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_scenes_enhanced_view_scene);
  }
  if (uic_mqtt_dotdot_by_group_scenes_enhanced_view_scene_response_callback) {
    subscription_topic = topic_bygroup + "Scenes/Commands/EnhancedViewSceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_scenes_enhanced_view_scene_response);
  }
  if (uic_mqtt_dotdot_by_group_scenes_copy_scene_callback) {
    subscription_topic = topic_bygroup + "Scenes/Commands/CopyScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_scenes_copy_scene);
  }
  if (uic_mqtt_dotdot_by_group_scenes_copy_scene_response_callback) {
    subscription_topic = topic_bygroup + "Scenes/Commands/CopySceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_scenes_copy_scene_response);
  }

  return SL_STATUS_OK;
}




// Callback function for incoming publications on ucl/by-group/+/OnOff/Commands/Off
static void uic_mqtt_dotdot_on_by_group_on_off_off(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_on_off_off_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_on_off_off_callback != nullptr) {

    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OnOff", "Off");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "Off", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "Off", "");
        return;
      }

      uic_mqtt_dotdot_by_group_on_off_off_callback(
        group_id
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_on_off_off_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));

      group_dispatch_callback(
        group_id,
        "OnOff",
        "Off",
        message,
        message_length,
        uic_mqtt_dotdot_on_on_off_off);

    } catch (...) {
      sl_log_debug(LOG_TAG, "Off: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/OnOff/Commands/On
static void uic_mqtt_dotdot_on_by_group_on_off_on(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_on_off_on_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_on_off_on_callback != nullptr) {

    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OnOff", "On");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "On", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "On", "");
        return;
      }

      uic_mqtt_dotdot_by_group_on_off_on_callback(
        group_id
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_on_off_on_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));

      group_dispatch_callback(
        group_id,
        "OnOff",
        "On",
        message,
        message_length,
        uic_mqtt_dotdot_on_on_off_on);

    } catch (...) {
      sl_log_debug(LOG_TAG, "On: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/OnOff/Commands/Toggle
static void uic_mqtt_dotdot_on_by_group_on_off_toggle(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_on_off_toggle_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_on_off_toggle_callback != nullptr) {

    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OnOff", "Toggle");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "Toggle", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "Toggle", "");
        return;
      }

      uic_mqtt_dotdot_by_group_on_off_toggle_callback(
        group_id
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_on_off_toggle_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));

      group_dispatch_callback(
        group_id,
        "OnOff",
        "Toggle",
        message,
        message_length,
        uic_mqtt_dotdot_on_on_off_toggle);

    } catch (...) {
      sl_log_debug(LOG_TAG, "Toggle: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/OnOff/Commands/OffWithEffect
static void uic_mqtt_dotdot_on_by_group_on_off_off_with_effect(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_on_off_off_with_effect_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_on_off_off_with_effect_callback != nullptr) {

    
    uic_mqtt_dotdot_on_off_command_off_with_effect_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_on_off_off_with_effect(
          jsn,
          fields.effect_identifier,
              
          fields.effect_variant
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OnOff", "OffWithEffect");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "OffWithEffect", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "OffWithEffect", "");
        return;
      }

      uic_mqtt_dotdot_by_group_on_off_off_with_effect_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_on_off_off_with_effect_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("EffectIdentifier") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OnOff::OffWithEffect: Missing command-argument: EffectIdentifier\n");
        return;
      }
      if (jsn.find("EffectVariant") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OnOff::OffWithEffect: Missing command-argument: EffectVariant\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "OnOff",
        "OffWithEffect",
        message,
        message_length,
        uic_mqtt_dotdot_on_on_off_off_with_effect);

    } catch (...) {
      sl_log_debug(LOG_TAG, "OffWithEffect: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/OnOff/Commands/OnWithRecallGlobalScene
static void uic_mqtt_dotdot_on_by_group_on_off_on_with_recall_global_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_on_off_on_with_recall_global_scene_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_on_off_on_with_recall_global_scene_callback != nullptr) {

    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OnOff", "OnWithRecallGlobalScene");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "OnWithRecallGlobalScene", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "OnWithRecallGlobalScene", "");
        return;
      }

      uic_mqtt_dotdot_by_group_on_off_on_with_recall_global_scene_callback(
        group_id
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));

      group_dispatch_callback(
        group_id,
        "OnOff",
        "OnWithRecallGlobalScene",
        message,
        message_length,
        uic_mqtt_dotdot_on_on_off_on_with_recall_global_scene);

    } catch (...) {
      sl_log_debug(LOG_TAG, "OnWithRecallGlobalScene: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/OnOff/Commands/OnWithTimedOff
static void uic_mqtt_dotdot_on_by_group_on_off_on_with_timed_off(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_on_off_on_with_timed_off_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_on_off_on_with_timed_off_callback != nullptr) {

    
    uic_mqtt_dotdot_on_off_command_on_with_timed_off_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_on_off_on_with_timed_off(
          jsn,
          fields.on_off_control,
              
          fields.on_time,
              
          fields.off_wait_time
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OnOff", "OnWithTimedOff");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "OnWithTimedOff", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "OnWithTimedOff", "");
        return;
      }

      uic_mqtt_dotdot_by_group_on_off_on_with_timed_off_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_on_off_on_with_timed_off_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("OnOffControl") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OnOff::OnWithTimedOff: Missing command-argument: OnOffControl\n");
        return;
      }
      if (jsn.find("OnTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OnOff::OnWithTimedOff: Missing command-argument: OnTime\n");
        return;
      }
      if (jsn.find("OffWaitTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OnOff::OnWithTimedOff: Missing command-argument: OffWaitTime\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "OnOff",
        "OnWithTimedOff",
        message,
        message_length,
        uic_mqtt_dotdot_on_on_off_on_with_timed_off);

    } catch (...) {
      sl_log_debug(LOG_TAG, "OnWithTimedOff: Unable to parse JSON payload.\n");
      return;
    }
  }

}

static void uic_mqtt_dotdot_on_by_group_on_off_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_on_off_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_on_off_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "OnOff",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_on_off_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "OnOff: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_on_off_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_on_off_state_t new_state = {};
    uic_mqtt_dotdot_on_off_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_on_off_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OnOff", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_on_off_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_on_off_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_on_off_write_attributes_callback) {
    subscription_topic = topic_bygroup + "OnOff/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_on_off_WriteAttributes);
  }
  if (uic_mqtt_dotdot_by_group_on_off_off_callback) {
    subscription_topic = topic_bygroup + "OnOff/Commands/Off";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_on_off_off);
  }
  if (uic_mqtt_dotdot_by_group_on_off_on_callback) {
    subscription_topic = topic_bygroup + "OnOff/Commands/On";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_on_off_on);
  }
  if (uic_mqtt_dotdot_by_group_on_off_toggle_callback) {
    subscription_topic = topic_bygroup + "OnOff/Commands/Toggle";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_on_off_toggle);
  }
  if (uic_mqtt_dotdot_by_group_on_off_off_with_effect_callback) {
    subscription_topic = topic_bygroup + "OnOff/Commands/OffWithEffect";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_on_off_off_with_effect);
  }
  if (uic_mqtt_dotdot_by_group_on_off_on_with_recall_global_scene_callback) {
    subscription_topic = topic_bygroup + "OnOff/Commands/OnWithRecallGlobalScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_on_off_on_with_recall_global_scene);
  }
  if (uic_mqtt_dotdot_by_group_on_off_on_with_timed_off_callback) {
    subscription_topic = topic_bygroup + "OnOff/Commands/OnWithTimedOff";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_on_off_on_with_timed_off);
  }

  return SL_STATUS_OK;
}




// Callback function for incoming publications on ucl/by-group/+/Level/Commands/MoveToLevel
static void uic_mqtt_dotdot_on_by_group_level_move_to_level(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_level_move_to_level_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_level_move_to_level_callback != nullptr) {

    
    uic_mqtt_dotdot_level_command_move_to_level_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_level_move_to_level(
          jsn,
          fields.level,
              
          fields.transition_time,
              
          fields.options_mask,
              
          fields.options_override
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "MoveToLevel");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveToLevel", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveToLevel", "");
        return;
      }

      uic_mqtt_dotdot_by_group_level_move_to_level_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_level_move_to_level_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Level") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Level::MoveToLevel: Missing command-argument: Level\n");
        return;
      }
      if (jsn.find("TransitionTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Level::MoveToLevel: Missing command-argument: TransitionTime\n");
        return;
      }
      if (jsn.find("OptionsMask") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Level::MoveToLevel: Missing command-argument: OptionsMask\n");
        return;
      }
      if (jsn.find("OptionsOverride") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Level::MoveToLevel: Missing command-argument: OptionsOverride\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Level",
        "MoveToLevel",
        message,
        message_length,
        uic_mqtt_dotdot_on_level_move_to_level);

    } catch (...) {
      sl_log_debug(LOG_TAG, "MoveToLevel: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Level/Commands/Move
static void uic_mqtt_dotdot_on_by_group_level_move(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_level_move_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_level_move_callback != nullptr) {

    
    uic_mqtt_dotdot_level_command_move_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_level_move(
          jsn,
          fields.move_mode,
              
          fields.rate,
              
          fields.options_mask,
              
          fields.options_override
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "Move");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "Move", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "Move", "");
        return;
      }

      uic_mqtt_dotdot_by_group_level_move_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_level_move_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("MoveMode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Level::Move: Missing command-argument: MoveMode\n");
        return;
      }
      if (jsn.find("Rate") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Level::Move: Missing command-argument: Rate\n");
        return;
      }
      if (jsn.find("OptionsMask") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Level::Move: Missing command-argument: OptionsMask\n");
        return;
      }
      if (jsn.find("OptionsOverride") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Level::Move: Missing command-argument: OptionsOverride\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Level",
        "Move",
        message,
        message_length,
        uic_mqtt_dotdot_on_level_move);

    } catch (...) {
      sl_log_debug(LOG_TAG, "Move: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Level/Commands/Step
static void uic_mqtt_dotdot_on_by_group_level_step(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_level_step_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_level_step_callback != nullptr) {

    
    uic_mqtt_dotdot_level_command_step_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_level_step(
          jsn,
          fields.step_mode,
              
          fields.step_size,
              
          fields.transition_time,
              
          fields.options_mask,
              
          fields.options_override
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "Step");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "Step", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "Step", "");
        return;
      }

      uic_mqtt_dotdot_by_group_level_step_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_level_step_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("StepMode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Level::Step: Missing command-argument: StepMode\n");
        return;
      }
      if (jsn.find("StepSize") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Level::Step: Missing command-argument: StepSize\n");
        return;
      }
      if (jsn.find("TransitionTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Level::Step: Missing command-argument: TransitionTime\n");
        return;
      }
      if (jsn.find("OptionsMask") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Level::Step: Missing command-argument: OptionsMask\n");
        return;
      }
      if (jsn.find("OptionsOverride") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Level::Step: Missing command-argument: OptionsOverride\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Level",
        "Step",
        message,
        message_length,
        uic_mqtt_dotdot_on_level_step);

    } catch (...) {
      sl_log_debug(LOG_TAG, "Step: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Level/Commands/Stop
static void uic_mqtt_dotdot_on_by_group_level_stop(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_level_stop_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_level_stop_callback != nullptr) {

    
    uic_mqtt_dotdot_level_command_stop_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_level_stop(
          jsn,
          fields.options_mask,
              
          fields.options_override
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "Stop");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "Stop", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "Stop", "");
        return;
      }

      uic_mqtt_dotdot_by_group_level_stop_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_level_stop_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("OptionsMask") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Level::Stop: Missing command-argument: OptionsMask\n");
        return;
      }
      if (jsn.find("OptionsOverride") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Level::Stop: Missing command-argument: OptionsOverride\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Level",
        "Stop",
        message,
        message_length,
        uic_mqtt_dotdot_on_level_stop);

    } catch (...) {
      sl_log_debug(LOG_TAG, "Stop: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Level/Commands/MoveToLevelWithOnOff
static void uic_mqtt_dotdot_on_by_group_level_move_to_level_with_on_off(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_level_move_to_level_with_on_off_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_level_move_to_level_with_on_off_callback != nullptr) {

    
    uic_mqtt_dotdot_level_command_move_to_level_with_on_off_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_level_move_to_level_with_on_off(
          jsn,
          fields.level,
              
          fields.transition_time,
              
          fields.options_mask,
              
          fields.options_override
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "MoveToLevelWithOnOff");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveToLevelWithOnOff", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveToLevelWithOnOff", "");
        return;
      }

      uic_mqtt_dotdot_by_group_level_move_to_level_with_on_off_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_level_move_to_level_with_on_off_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Level") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Level::MoveToLevelWithOnOff: Missing command-argument: Level\n");
        return;
      }
      if (jsn.find("TransitionTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Level::MoveToLevelWithOnOff: Missing command-argument: TransitionTime\n");
        return;
      }
      if (jsn.find("OptionsMask") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Level::MoveToLevelWithOnOff: Missing command-argument: OptionsMask\n");
        return;
      }
      if (jsn.find("OptionsOverride") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Level::MoveToLevelWithOnOff: Missing command-argument: OptionsOverride\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Level",
        "MoveToLevelWithOnOff",
        message,
        message_length,
        uic_mqtt_dotdot_on_level_move_to_level_with_on_off);

    } catch (...) {
      sl_log_debug(LOG_TAG, "MoveToLevelWithOnOff: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Level/Commands/MoveWithOnOff
static void uic_mqtt_dotdot_on_by_group_level_move_with_on_off(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_level_move_with_on_off_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_level_move_with_on_off_callback != nullptr) {

    
    uic_mqtt_dotdot_level_command_move_with_on_off_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_level_move_with_on_off(
          jsn,
          fields.move_mode,
              
          fields.rate,
              
          fields.options_mask,
              
          fields.options_override
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "MoveWithOnOff");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveWithOnOff", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveWithOnOff", "");
        return;
      }

      uic_mqtt_dotdot_by_group_level_move_with_on_off_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_level_move_with_on_off_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("MoveMode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Level::MoveWithOnOff: Missing command-argument: MoveMode\n");
        return;
      }
      if (jsn.find("Rate") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Level::MoveWithOnOff: Missing command-argument: Rate\n");
        return;
      }
      if (jsn.find("OptionsMask") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Level::MoveWithOnOff: Missing command-argument: OptionsMask\n");
        return;
      }
      if (jsn.find("OptionsOverride") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Level::MoveWithOnOff: Missing command-argument: OptionsOverride\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Level",
        "MoveWithOnOff",
        message,
        message_length,
        uic_mqtt_dotdot_on_level_move_with_on_off);

    } catch (...) {
      sl_log_debug(LOG_TAG, "MoveWithOnOff: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Level/Commands/StepWithOnOff
static void uic_mqtt_dotdot_on_by_group_level_step_with_on_off(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_level_step_with_on_off_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_level_step_with_on_off_callback != nullptr) {

    
    uic_mqtt_dotdot_level_command_step_with_on_off_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_level_step_with_on_off(
          jsn,
          fields.step_mode,
              
          fields.step_size,
              
          fields.transition_time,
              
          fields.options_mask,
              
          fields.options_override
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "StepWithOnOff");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "StepWithOnOff", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "StepWithOnOff", "");
        return;
      }

      uic_mqtt_dotdot_by_group_level_step_with_on_off_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_level_step_with_on_off_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("StepMode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Level::StepWithOnOff: Missing command-argument: StepMode\n");
        return;
      }
      if (jsn.find("StepSize") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Level::StepWithOnOff: Missing command-argument: StepSize\n");
        return;
      }
      if (jsn.find("TransitionTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Level::StepWithOnOff: Missing command-argument: TransitionTime\n");
        return;
      }
      if (jsn.find("OptionsMask") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Level::StepWithOnOff: Missing command-argument: OptionsMask\n");
        return;
      }
      if (jsn.find("OptionsOverride") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Level::StepWithOnOff: Missing command-argument: OptionsOverride\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Level",
        "StepWithOnOff",
        message,
        message_length,
        uic_mqtt_dotdot_on_level_step_with_on_off);

    } catch (...) {
      sl_log_debug(LOG_TAG, "StepWithOnOff: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Level/Commands/StopWithOnOff
static void uic_mqtt_dotdot_on_by_group_level_stop_with_on_off(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_level_stop_with_on_off_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_level_stop_with_on_off_callback != nullptr) {

    
    uic_mqtt_dotdot_level_command_stop_with_on_off_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_level_stop_with_on_off(
          jsn,
          fields.options_mask,
              
          fields.options_override
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "StopWithOnOff");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "StopWithOnOff", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "StopWithOnOff", "");
        return;
      }

      uic_mqtt_dotdot_by_group_level_stop_with_on_off_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_level_stop_with_on_off_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("OptionsMask") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Level::StopWithOnOff: Missing command-argument: OptionsMask\n");
        return;
      }
      if (jsn.find("OptionsOverride") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Level::StopWithOnOff: Missing command-argument: OptionsOverride\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Level",
        "StopWithOnOff",
        message,
        message_length,
        uic_mqtt_dotdot_on_level_stop_with_on_off);

    } catch (...) {
      sl_log_debug(LOG_TAG, "StopWithOnOff: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Level/Commands/MoveToClosestFrequency
static void uic_mqtt_dotdot_on_by_group_level_move_to_closest_frequency(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_level_move_to_closest_frequency_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_level_move_to_closest_frequency_callback != nullptr) {

    
    uic_mqtt_dotdot_level_command_move_to_closest_frequency_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_level_move_to_closest_frequency(
          jsn,
          fields.frequency
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "MoveToClosestFrequency");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveToClosestFrequency", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveToClosestFrequency", "");
        return;
      }

      uic_mqtt_dotdot_by_group_level_move_to_closest_frequency_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_level_move_to_closest_frequency_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Frequency") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Level::MoveToClosestFrequency: Missing command-argument: Frequency\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Level",
        "MoveToClosestFrequency",
        message,
        message_length,
        uic_mqtt_dotdot_on_level_move_to_closest_frequency);

    } catch (...) {
      sl_log_debug(LOG_TAG, "MoveToClosestFrequency: Unable to parse JSON payload.\n");
      return;
    }
  }

}

static void uic_mqtt_dotdot_on_by_group_level_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_level_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_level_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "Level",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_level_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "Level: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_level_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_level_state_t new_state = {};
    uic_mqtt_dotdot_level_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_level_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_level_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_level_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_level_write_attributes_callback) {
    subscription_topic = topic_bygroup + "Level/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_level_WriteAttributes);
  }
  if (uic_mqtt_dotdot_by_group_level_move_to_level_callback) {
    subscription_topic = topic_bygroup + "Level/Commands/MoveToLevel";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_level_move_to_level);
  }
  if (uic_mqtt_dotdot_by_group_level_move_callback) {
    subscription_topic = topic_bygroup + "Level/Commands/Move";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_level_move);
  }
  if (uic_mqtt_dotdot_by_group_level_step_callback) {
    subscription_topic = topic_bygroup + "Level/Commands/Step";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_level_step);
  }
  if (uic_mqtt_dotdot_by_group_level_stop_callback) {
    subscription_topic = topic_bygroup + "Level/Commands/Stop";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_level_stop);
  }
  if (uic_mqtt_dotdot_by_group_level_move_to_level_with_on_off_callback) {
    subscription_topic = topic_bygroup + "Level/Commands/MoveToLevelWithOnOff";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_level_move_to_level_with_on_off);
  }
  if (uic_mqtt_dotdot_by_group_level_move_with_on_off_callback) {
    subscription_topic = topic_bygroup + "Level/Commands/MoveWithOnOff";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_level_move_with_on_off);
  }
  if (uic_mqtt_dotdot_by_group_level_step_with_on_off_callback) {
    subscription_topic = topic_bygroup + "Level/Commands/StepWithOnOff";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_level_step_with_on_off);
  }
  if (uic_mqtt_dotdot_by_group_level_stop_with_on_off_callback) {
    subscription_topic = topic_bygroup + "Level/Commands/StopWithOnOff";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_level_stop_with_on_off);
  }
  if (uic_mqtt_dotdot_by_group_level_move_to_closest_frequency_callback) {
    subscription_topic = topic_bygroup + "Level/Commands/MoveToClosestFrequency";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_level_move_to_closest_frequency);
  }

  return SL_STATUS_OK;
}




// Callback function for incoming publications on ucl/by-group/+/Alarms/Commands/ResetAlarm
static void uic_mqtt_dotdot_on_by_group_alarms_reset_alarm(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_alarms_reset_alarm_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_alarms_reset_alarm_callback != nullptr) {

    
    uic_mqtt_dotdot_alarms_command_reset_alarm_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_alarms_reset_alarm(
          jsn,
          fields.alarm_code,
              
          fields.cluster_identifier
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Alarms", "ResetAlarm");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "ResetAlarm", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "ResetAlarm", "");
        return;
      }

      uic_mqtt_dotdot_by_group_alarms_reset_alarm_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_alarms_reset_alarm_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("AlarmCode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Alarms::ResetAlarm: Missing command-argument: AlarmCode\n");
        return;
      }
      if (jsn.find("ClusterIdentifier") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Alarms::ResetAlarm: Missing command-argument: ClusterIdentifier\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Alarms",
        "ResetAlarm",
        message,
        message_length,
        uic_mqtt_dotdot_on_alarms_reset_alarm);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ResetAlarm: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Alarms/Commands/Alarm
static void uic_mqtt_dotdot_on_by_group_alarms_alarm(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_alarms_alarm_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_alarms_alarm_callback != nullptr) {

    
    uic_mqtt_dotdot_alarms_command_alarm_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_alarms_alarm(
          jsn,
          fields.alarm_code,
              
          fields.cluster_identifier
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Alarms", "Alarm");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "Alarm", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "Alarm", "");
        return;
      }

      uic_mqtt_dotdot_by_group_alarms_alarm_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_alarms_alarm_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("AlarmCode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Alarms::Alarm: Missing command-argument: AlarmCode\n");
        return;
      }
      if (jsn.find("ClusterIdentifier") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Alarms::Alarm: Missing command-argument: ClusterIdentifier\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Alarms",
        "Alarm",
        message,
        message_length,
        uic_mqtt_dotdot_on_alarms_alarm);

    } catch (...) {
      sl_log_debug(LOG_TAG, "Alarm: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Alarms/Commands/ResetAllAlarms
static void uic_mqtt_dotdot_on_by_group_alarms_reset_all_alarms(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_alarms_reset_all_alarms_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_alarms_reset_all_alarms_callback != nullptr) {

    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Alarms", "ResetAllAlarms");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "ResetAllAlarms", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "ResetAllAlarms", "");
        return;
      }

      uic_mqtt_dotdot_by_group_alarms_reset_all_alarms_callback(
        group_id
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_alarms_reset_all_alarms_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));

      group_dispatch_callback(
        group_id,
        "Alarms",
        "ResetAllAlarms",
        message,
        message_length,
        uic_mqtt_dotdot_on_alarms_reset_all_alarms);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ResetAllAlarms: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Alarms/Commands/GetAlarmResponse
static void uic_mqtt_dotdot_on_by_group_alarms_get_alarm_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_alarms_get_alarm_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_alarms_get_alarm_response_callback != nullptr) {

    
    uic_mqtt_dotdot_alarms_command_get_alarm_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_alarms_get_alarm_response(
          jsn,
          fields.status,
              
          fields.alarm_code,
              
          fields.cluster_identifier,
              
          fields.time_stamp
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Alarms", "GetAlarmResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "GetAlarmResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "GetAlarmResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_alarms_get_alarm_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_alarms_get_alarm_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Alarms::GetAlarmResponse: Missing command-argument: Status\n");
        return;
      }
      if (jsn.find("AlarmCode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Alarms::GetAlarmResponse: Missing command-argument: AlarmCode\n");
        return;
      }
      if (jsn.find("ClusterIdentifier") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Alarms::GetAlarmResponse: Missing command-argument: ClusterIdentifier\n");
        return;
      }
      if (jsn.find("TimeStamp") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Alarms::GetAlarmResponse: Missing command-argument: TimeStamp\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Alarms",
        "GetAlarmResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_alarms_get_alarm_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GetAlarmResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Alarms/Commands/GetAlarm
static void uic_mqtt_dotdot_on_by_group_alarms_get_alarm(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_alarms_get_alarm_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_alarms_get_alarm_callback != nullptr) {

    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Alarms", "GetAlarm");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "GetAlarm", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "GetAlarm", "");
        return;
      }

      uic_mqtt_dotdot_by_group_alarms_get_alarm_callback(
        group_id
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_alarms_get_alarm_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));

      group_dispatch_callback(
        group_id,
        "Alarms",
        "GetAlarm",
        message,
        message_length,
        uic_mqtt_dotdot_on_alarms_get_alarm);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GetAlarm: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Alarms/Commands/ResetAlarmLog
static void uic_mqtt_dotdot_on_by_group_alarms_reset_alarm_log(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_alarms_reset_alarm_log_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_alarms_reset_alarm_log_callback != nullptr) {

    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Alarms", "ResetAlarmLog");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "ResetAlarmLog", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "ResetAlarmLog", "");
        return;
      }

      uic_mqtt_dotdot_by_group_alarms_reset_alarm_log_callback(
        group_id
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_alarms_reset_alarm_log_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));

      group_dispatch_callback(
        group_id,
        "Alarms",
        "ResetAlarmLog",
        message,
        message_length,
        uic_mqtt_dotdot_on_alarms_reset_alarm_log);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ResetAlarmLog: Unable to parse JSON payload.\n");
      return;
    }
  }

}

static void uic_mqtt_dotdot_on_by_group_alarms_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_alarms_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_alarms_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "Alarms",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_alarms_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "Alarms: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_alarms_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_alarms_state_t new_state = {};
    uic_mqtt_dotdot_alarms_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_alarms_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Alarms", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_alarms_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_alarms_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_alarms_write_attributes_callback) {
    subscription_topic = topic_bygroup + "Alarms/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_alarms_WriteAttributes);
  }
  if (uic_mqtt_dotdot_by_group_alarms_reset_alarm_callback) {
    subscription_topic = topic_bygroup + "Alarms/Commands/ResetAlarm";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_alarms_reset_alarm);
  }
  if (uic_mqtt_dotdot_by_group_alarms_alarm_callback) {
    subscription_topic = topic_bygroup + "Alarms/Commands/Alarm";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_alarms_alarm);
  }
  if (uic_mqtt_dotdot_by_group_alarms_reset_all_alarms_callback) {
    subscription_topic = topic_bygroup + "Alarms/Commands/ResetAllAlarms";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_alarms_reset_all_alarms);
  }
  if (uic_mqtt_dotdot_by_group_alarms_get_alarm_response_callback) {
    subscription_topic = topic_bygroup + "Alarms/Commands/GetAlarmResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_alarms_get_alarm_response);
  }
  if (uic_mqtt_dotdot_by_group_alarms_get_alarm_callback) {
    subscription_topic = topic_bygroup + "Alarms/Commands/GetAlarm";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_alarms_get_alarm);
  }
  if (uic_mqtt_dotdot_by_group_alarms_reset_alarm_log_callback) {
    subscription_topic = topic_bygroup + "Alarms/Commands/ResetAlarmLog";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_alarms_reset_alarm_log);
  }

  return SL_STATUS_OK;
}




static void uic_mqtt_dotdot_on_by_group_time_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_time_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_time_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "Time",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_time_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "Time: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_time_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_time_state_t new_state = {};
    uic_mqtt_dotdot_time_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_time_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Time", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Time", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Time", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_time_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_time_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_time_write_attributes_callback) {
    subscription_topic = topic_bygroup + "Time/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_time_WriteAttributes);
  }

  return SL_STATUS_OK;
}




// Callback function for incoming publications on ucl/by-group/+/OTAUpgrade/Commands/ImageNotify
static void uic_mqtt_dotdot_on_by_group_ota_upgrade_image_notify(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_ota_upgrade_image_notify_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_ota_upgrade_image_notify_callback != nullptr) {

    
    uic_mqtt_dotdot_ota_upgrade_command_image_notify_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_ota_upgrade_image_notify(
          jsn,
          fields.payload_type,
              
          fields.query_jitter,
              
          fields.manufacturer_code,
              
          fields.image_type,
              
          fields.new_file_version
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OTAUpgrade", "ImageNotify");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "ImageNotify", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "ImageNotify", "");
        return;
      }

      uic_mqtt_dotdot_by_group_ota_upgrade_image_notify_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_ota_upgrade_image_notify_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("PayloadType") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::ImageNotify: Missing command-argument: PayloadType\n");
        return;
      }
      if (jsn.find("QueryJitter") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::ImageNotify: Missing command-argument: QueryJitter\n");
        return;
      }
      if (jsn.find("ManufacturerCode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::ImageNotify: Missing command-argument: ManufacturerCode\n");
        return;
      }
      if (jsn.find("ImageType") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::ImageNotify: Missing command-argument: ImageType\n");
        return;
      }
      if (jsn.find("NewFileVersion") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::ImageNotify: Missing command-argument: NewFileVersion\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "OTAUpgrade",
        "ImageNotify",
        message,
        message_length,
        uic_mqtt_dotdot_on_ota_upgrade_image_notify);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ImageNotify: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/OTAUpgrade/Commands/QueryNextImageRequest
static void uic_mqtt_dotdot_on_by_group_ota_upgrade_query_next_image_request(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_ota_upgrade_query_next_image_request_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_ota_upgrade_query_next_image_request_callback != nullptr) {

    
    uic_mqtt_dotdot_ota_upgrade_command_query_next_image_request_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_ota_upgrade_query_next_image_request(
          jsn,
          fields.field_control,
              
          fields.manufacturer_code,
              
          fields.image_type,
              
          fields.current_file_version,
              
          fields.hardware_version
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OTAUpgrade", "QueryNextImageRequest");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "QueryNextImageRequest", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "QueryNextImageRequest", "");
        return;
      }

      uic_mqtt_dotdot_by_group_ota_upgrade_query_next_image_request_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_ota_upgrade_query_next_image_request_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("FieldControl") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::QueryNextImageRequest: Missing command-argument: FieldControl\n");
        return;
      }
      if (jsn.find("ManufacturerCode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::QueryNextImageRequest: Missing command-argument: ManufacturerCode\n");
        return;
      }
      if (jsn.find("ImageType") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::QueryNextImageRequest: Missing command-argument: ImageType\n");
        return;
      }
      if (jsn.find("CurrentFileVersion") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::QueryNextImageRequest: Missing command-argument: CurrentFileVersion\n");
        return;
      }
      if (jsn.find("HardwareVersion") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::QueryNextImageRequest: Missing command-argument: HardwareVersion\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "OTAUpgrade",
        "QueryNextImageRequest",
        message,
        message_length,
        uic_mqtt_dotdot_on_ota_upgrade_query_next_image_request);

    } catch (...) {
      sl_log_debug(LOG_TAG, "QueryNextImageRequest: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/OTAUpgrade/Commands/QueryNextImageResponse
static void uic_mqtt_dotdot_on_by_group_ota_upgrade_query_next_image_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_ota_upgrade_query_next_image_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_ota_upgrade_query_next_image_response_callback != nullptr) {

    
    uic_mqtt_dotdot_ota_upgrade_command_query_next_image_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_ota_upgrade_query_next_image_response(
          jsn,
          fields.status,
              
          fields.manufacturer_code,
              
          fields.image_type,
              
          fields.file_version,
              
          fields.image_size
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OTAUpgrade", "QueryNextImageResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "QueryNextImageResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "QueryNextImageResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_ota_upgrade_query_next_image_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_ota_upgrade_query_next_image_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::QueryNextImageResponse: Missing command-argument: Status\n");
        return;
      }
      if (jsn.find("ManufacturerCode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::QueryNextImageResponse: Missing command-argument: ManufacturerCode\n");
        return;
      }
      if (jsn.find("ImageType") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::QueryNextImageResponse: Missing command-argument: ImageType\n");
        return;
      }
      if (jsn.find("FileVersion") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::QueryNextImageResponse: Missing command-argument: FileVersion\n");
        return;
      }
      if (jsn.find("ImageSize") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::QueryNextImageResponse: Missing command-argument: ImageSize\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "OTAUpgrade",
        "QueryNextImageResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_ota_upgrade_query_next_image_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "QueryNextImageResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/OTAUpgrade/Commands/ImageBlockRequest
static void uic_mqtt_dotdot_on_by_group_ota_upgrade_image_block_request(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_ota_upgrade_image_block_request_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_ota_upgrade_image_block_request_callback != nullptr) {

    
    uic_mqtt_dotdot_ota_upgrade_command_image_block_request_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_ota_upgrade_image_block_request(
          jsn,
          fields.field_control,
              
          fields.manufacturer_code,
              
          fields.image_type,
              
          fields.file_version,
              
          fields.file_offset,
              
          fields.maximum_data_size,
              
          fields.request_node_address,
              
          fields.minimum_block_period
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OTAUpgrade", "ImageBlockRequest");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "ImageBlockRequest", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "ImageBlockRequest", "");
        return;
      }

      uic_mqtt_dotdot_by_group_ota_upgrade_image_block_request_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_ota_upgrade_image_block_request_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("FieldControl") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::ImageBlockRequest: Missing command-argument: FieldControl\n");
        return;
      }
      if (jsn.find("ManufacturerCode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::ImageBlockRequest: Missing command-argument: ManufacturerCode\n");
        return;
      }
      if (jsn.find("ImageType") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::ImageBlockRequest: Missing command-argument: ImageType\n");
        return;
      }
      if (jsn.find("FileVersion") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::ImageBlockRequest: Missing command-argument: FileVersion\n");
        return;
      }
      if (jsn.find("FileOffset") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::ImageBlockRequest: Missing command-argument: FileOffset\n");
        return;
      }
      if (jsn.find("MaximumDataSize") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::ImageBlockRequest: Missing command-argument: MaximumDataSize\n");
        return;
      }
      if (jsn.find("RequestNodeAddress") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::ImageBlockRequest: Missing command-argument: RequestNodeAddress\n");
        return;
      }
      if (jsn.find("MinimumBlockPeriod") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::ImageBlockRequest: Missing command-argument: MinimumBlockPeriod\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "OTAUpgrade",
        "ImageBlockRequest",
        message,
        message_length,
        uic_mqtt_dotdot_on_ota_upgrade_image_block_request);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ImageBlockRequest: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/OTAUpgrade/Commands/ImagePageRequest
static void uic_mqtt_dotdot_on_by_group_ota_upgrade_image_page_request(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_ota_upgrade_image_page_request_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_ota_upgrade_image_page_request_callback != nullptr) {

    
    uic_mqtt_dotdot_ota_upgrade_command_image_page_request_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_ota_upgrade_image_page_request(
          jsn,
          fields.field_control,
              
          fields.manufacturer_code,
              
          fields.image_type,
              
          fields.file_version,
              
          fields.file_offset,
              
          fields.maximum_data_size,
              
          fields.page_size,
              
          fields.response_spacing,
              
          fields.request_node_address
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OTAUpgrade", "ImagePageRequest");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "ImagePageRequest", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "ImagePageRequest", "");
        return;
      }

      uic_mqtt_dotdot_by_group_ota_upgrade_image_page_request_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_ota_upgrade_image_page_request_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("FieldControl") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::ImagePageRequest: Missing command-argument: FieldControl\n");
        return;
      }
      if (jsn.find("ManufacturerCode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::ImagePageRequest: Missing command-argument: ManufacturerCode\n");
        return;
      }
      if (jsn.find("ImageType") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::ImagePageRequest: Missing command-argument: ImageType\n");
        return;
      }
      if (jsn.find("FileVersion") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::ImagePageRequest: Missing command-argument: FileVersion\n");
        return;
      }
      if (jsn.find("FileOffset") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::ImagePageRequest: Missing command-argument: FileOffset\n");
        return;
      }
      if (jsn.find("MaximumDataSize") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::ImagePageRequest: Missing command-argument: MaximumDataSize\n");
        return;
      }
      if (jsn.find("PageSize") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::ImagePageRequest: Missing command-argument: PageSize\n");
        return;
      }
      if (jsn.find("ResponseSpacing") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::ImagePageRequest: Missing command-argument: ResponseSpacing\n");
        return;
      }
      if (jsn.find("RequestNodeAddress") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::ImagePageRequest: Missing command-argument: RequestNodeAddress\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "OTAUpgrade",
        "ImagePageRequest",
        message,
        message_length,
        uic_mqtt_dotdot_on_ota_upgrade_image_page_request);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ImagePageRequest: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/OTAUpgrade/Commands/ImageBlockResponse
static void uic_mqtt_dotdot_on_by_group_ota_upgrade_image_block_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_ota_upgrade_image_block_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_ota_upgrade_image_block_response_callback != nullptr) {

    
    uic_mqtt_dotdot_ota_upgrade_command_image_block_response_fields_t fields;
      std::string image_data;
    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_ota_upgrade_image_block_response(
          jsn,
          fields.status,
              
          fields.manufacturer_code,
              
          fields.image_type,
              
          fields.file_version,
              
          fields.file_offset,
              
          image_data,
      
          fields.current_time,
              
          fields.request_time,
              
          fields.minimum_block_period
              );

      // Populate list fields from vector or string types
              fields.image_data = image_data.c_str();
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OTAUpgrade", "ImageBlockResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "ImageBlockResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "ImageBlockResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_ota_upgrade_image_block_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_ota_upgrade_image_block_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::ImageBlockResponse: Missing command-argument: Status\n");
        return;
      }
      if (jsn.find("ManufacturerCode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::ImageBlockResponse: Missing command-argument: ManufacturerCode\n");
        return;
      }
      if (jsn.find("ImageType") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::ImageBlockResponse: Missing command-argument: ImageType\n");
        return;
      }
      if (jsn.find("FileVersion") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::ImageBlockResponse: Missing command-argument: FileVersion\n");
        return;
      }
      if (jsn.find("FileOffset") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::ImageBlockResponse: Missing command-argument: FileOffset\n");
        return;
      }
      if (jsn.find("ImageData") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::ImageBlockResponse: Missing command-argument: ImageData\n");
        return;
      }
      if (jsn.find("CurrentTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::ImageBlockResponse: Missing command-argument: CurrentTime\n");
        return;
      }
      if (jsn.find("RequestTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::ImageBlockResponse: Missing command-argument: RequestTime\n");
        return;
      }
      if (jsn.find("MinimumBlockPeriod") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::ImageBlockResponse: Missing command-argument: MinimumBlockPeriod\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "OTAUpgrade",
        "ImageBlockResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_ota_upgrade_image_block_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ImageBlockResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/OTAUpgrade/Commands/UpgradeEndRequest
static void uic_mqtt_dotdot_on_by_group_ota_upgrade_upgrade_end_request(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_ota_upgrade_upgrade_end_request_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_ota_upgrade_upgrade_end_request_callback != nullptr) {

    
    uic_mqtt_dotdot_ota_upgrade_command_upgrade_end_request_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_ota_upgrade_upgrade_end_request(
          jsn,
          fields.status,
              
          fields.manufacturer_code,
              
          fields.image_type,
              
          fields.file_version
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OTAUpgrade", "UpgradeEndRequest");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "UpgradeEndRequest", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "UpgradeEndRequest", "");
        return;
      }

      uic_mqtt_dotdot_by_group_ota_upgrade_upgrade_end_request_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_ota_upgrade_upgrade_end_request_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::UpgradeEndRequest: Missing command-argument: Status\n");
        return;
      }
      if (jsn.find("ManufacturerCode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::UpgradeEndRequest: Missing command-argument: ManufacturerCode\n");
        return;
      }
      if (jsn.find("ImageType") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::UpgradeEndRequest: Missing command-argument: ImageType\n");
        return;
      }
      if (jsn.find("FileVersion") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::UpgradeEndRequest: Missing command-argument: FileVersion\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "OTAUpgrade",
        "UpgradeEndRequest",
        message,
        message_length,
        uic_mqtt_dotdot_on_ota_upgrade_upgrade_end_request);

    } catch (...) {
      sl_log_debug(LOG_TAG, "UpgradeEndRequest: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/OTAUpgrade/Commands/UpgradeEndResponse
static void uic_mqtt_dotdot_on_by_group_ota_upgrade_upgrade_end_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_ota_upgrade_upgrade_end_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_ota_upgrade_upgrade_end_response_callback != nullptr) {

    
    uic_mqtt_dotdot_ota_upgrade_command_upgrade_end_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_ota_upgrade_upgrade_end_response(
          jsn,
          fields.manufacturer_code,
              
          fields.image_type,
              
          fields.file_version,
              
          fields.current_time,
              
          fields.upgrade_time
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OTAUpgrade", "UpgradeEndResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "UpgradeEndResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "UpgradeEndResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_ota_upgrade_upgrade_end_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_ota_upgrade_upgrade_end_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("ManufacturerCode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::UpgradeEndResponse: Missing command-argument: ManufacturerCode\n");
        return;
      }
      if (jsn.find("ImageType") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::UpgradeEndResponse: Missing command-argument: ImageType\n");
        return;
      }
      if (jsn.find("FileVersion") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::UpgradeEndResponse: Missing command-argument: FileVersion\n");
        return;
      }
      if (jsn.find("CurrentTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::UpgradeEndResponse: Missing command-argument: CurrentTime\n");
        return;
      }
      if (jsn.find("UpgradeTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::UpgradeEndResponse: Missing command-argument: UpgradeTime\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "OTAUpgrade",
        "UpgradeEndResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_ota_upgrade_upgrade_end_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "UpgradeEndResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/OTAUpgrade/Commands/QueryDeviceSpecificFileRequest
static void uic_mqtt_dotdot_on_by_group_ota_upgrade_query_device_specific_file_request(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_ota_upgrade_query_device_specific_file_request_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_ota_upgrade_query_device_specific_file_request_callback != nullptr) {

    
    uic_mqtt_dotdot_ota_upgrade_command_query_device_specific_file_request_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_ota_upgrade_query_device_specific_file_request(
          jsn,
          fields.request_node_address,
              
          fields.manufacturer_code,
              
          fields.image_type,
              
          fields.file_version,
              
          fields.current_zigbee_stack_version
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OTAUpgrade", "QueryDeviceSpecificFileRequest");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "QueryDeviceSpecificFileRequest", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "QueryDeviceSpecificFileRequest", "");
        return;
      }

      uic_mqtt_dotdot_by_group_ota_upgrade_query_device_specific_file_request_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_ota_upgrade_query_device_specific_file_request_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("RequestNodeAddress") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::QueryDeviceSpecificFileRequest: Missing command-argument: RequestNodeAddress\n");
        return;
      }
      if (jsn.find("ManufacturerCode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::QueryDeviceSpecificFileRequest: Missing command-argument: ManufacturerCode\n");
        return;
      }
      if (jsn.find("ImageType") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::QueryDeviceSpecificFileRequest: Missing command-argument: ImageType\n");
        return;
      }
      if (jsn.find("FileVersion") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::QueryDeviceSpecificFileRequest: Missing command-argument: FileVersion\n");
        return;
      }
      if (jsn.find("CurrentZigbeeStackVersion") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::QueryDeviceSpecificFileRequest: Missing command-argument: CurrentZigbeeStackVersion\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "OTAUpgrade",
        "QueryDeviceSpecificFileRequest",
        message,
        message_length,
        uic_mqtt_dotdot_on_ota_upgrade_query_device_specific_file_request);

    } catch (...) {
      sl_log_debug(LOG_TAG, "QueryDeviceSpecificFileRequest: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/OTAUpgrade/Commands/QueryDeviceSpecificFileResponse
static void uic_mqtt_dotdot_on_by_group_ota_upgrade_query_device_specific_file_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_ota_upgrade_query_device_specific_file_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_ota_upgrade_query_device_specific_file_response_callback != nullptr) {

    
    uic_mqtt_dotdot_ota_upgrade_command_query_device_specific_file_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_ota_upgrade_query_device_specific_file_response(
          jsn,
          fields.status,
              
          fields.manufacturer_code,
              
          fields.image_type,
              
          fields.file_version,
              
          fields.image_size
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OTAUpgrade", "QueryDeviceSpecificFileResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "QueryDeviceSpecificFileResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "QueryDeviceSpecificFileResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_ota_upgrade_query_device_specific_file_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_ota_upgrade_query_device_specific_file_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::QueryDeviceSpecificFileResponse: Missing command-argument: Status\n");
        return;
      }
      if (jsn.find("ManufacturerCode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::QueryDeviceSpecificFileResponse: Missing command-argument: ManufacturerCode\n");
        return;
      }
      if (jsn.find("ImageType") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::QueryDeviceSpecificFileResponse: Missing command-argument: ImageType\n");
        return;
      }
      if (jsn.find("FileVersion") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::QueryDeviceSpecificFileResponse: Missing command-argument: FileVersion\n");
        return;
      }
      if (jsn.find("ImageSize") == jsn.end()) {
        sl_log_debug(LOG_TAG, "OTAUpgrade::QueryDeviceSpecificFileResponse: Missing command-argument: ImageSize\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "OTAUpgrade",
        "QueryDeviceSpecificFileResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_ota_upgrade_query_device_specific_file_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "QueryDeviceSpecificFileResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

static void uic_mqtt_dotdot_on_by_group_ota_upgrade_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_ota_upgrade_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_ota_upgrade_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "OTAUpgrade",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_ota_upgrade_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "OTAUpgrade: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_ota_upgrade_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_ota_upgrade_state_t new_state = {};
    uic_mqtt_dotdot_ota_upgrade_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_ota_upgrade_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OTAUpgrade", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_ota_upgrade_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_ota_upgrade_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_ota_upgrade_write_attributes_callback) {
    subscription_topic = topic_bygroup + "OTAUpgrade/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_ota_upgrade_WriteAttributes);
  }
  if (uic_mqtt_dotdot_by_group_ota_upgrade_image_notify_callback) {
    subscription_topic = topic_bygroup + "OTAUpgrade/Commands/ImageNotify";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_ota_upgrade_image_notify);
  }
  if (uic_mqtt_dotdot_by_group_ota_upgrade_query_next_image_request_callback) {
    subscription_topic = topic_bygroup + "OTAUpgrade/Commands/QueryNextImageRequest";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_ota_upgrade_query_next_image_request);
  }
  if (uic_mqtt_dotdot_by_group_ota_upgrade_query_next_image_response_callback) {
    subscription_topic = topic_bygroup + "OTAUpgrade/Commands/QueryNextImageResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_ota_upgrade_query_next_image_response);
  }
  if (uic_mqtt_dotdot_by_group_ota_upgrade_image_block_request_callback) {
    subscription_topic = topic_bygroup + "OTAUpgrade/Commands/ImageBlockRequest";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_ota_upgrade_image_block_request);
  }
  if (uic_mqtt_dotdot_by_group_ota_upgrade_image_page_request_callback) {
    subscription_topic = topic_bygroup + "OTAUpgrade/Commands/ImagePageRequest";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_ota_upgrade_image_page_request);
  }
  if (uic_mqtt_dotdot_by_group_ota_upgrade_image_block_response_callback) {
    subscription_topic = topic_bygroup + "OTAUpgrade/Commands/ImageBlockResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_ota_upgrade_image_block_response);
  }
  if (uic_mqtt_dotdot_by_group_ota_upgrade_upgrade_end_request_callback) {
    subscription_topic = topic_bygroup + "OTAUpgrade/Commands/UpgradeEndRequest";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_ota_upgrade_upgrade_end_request);
  }
  if (uic_mqtt_dotdot_by_group_ota_upgrade_upgrade_end_response_callback) {
    subscription_topic = topic_bygroup + "OTAUpgrade/Commands/UpgradeEndResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_ota_upgrade_upgrade_end_response);
  }
  if (uic_mqtt_dotdot_by_group_ota_upgrade_query_device_specific_file_request_callback) {
    subscription_topic = topic_bygroup + "OTAUpgrade/Commands/QueryDeviceSpecificFileRequest";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_ota_upgrade_query_device_specific_file_request);
  }
  if (uic_mqtt_dotdot_by_group_ota_upgrade_query_device_specific_file_response_callback) {
    subscription_topic = topic_bygroup + "OTAUpgrade/Commands/QueryDeviceSpecificFileResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_ota_upgrade_query_device_specific_file_response);
  }

  return SL_STATUS_OK;
}




// Callback function for incoming publications on ucl/by-group/+/PollControl/Commands/CheckIn
static void uic_mqtt_dotdot_on_by_group_poll_control_check_in(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_poll_control_check_in_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_poll_control_check_in_callback != nullptr) {

    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PollControl", "CheckIn");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "CheckIn", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "CheckIn", "");
        return;
      }

      uic_mqtt_dotdot_by_group_poll_control_check_in_callback(
        group_id
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_poll_control_check_in_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));

      group_dispatch_callback(
        group_id,
        "PollControl",
        "CheckIn",
        message,
        message_length,
        uic_mqtt_dotdot_on_poll_control_check_in);

    } catch (...) {
      sl_log_debug(LOG_TAG, "CheckIn: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/PollControl/Commands/CheckInResponse
static void uic_mqtt_dotdot_on_by_group_poll_control_check_in_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_poll_control_check_in_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_poll_control_check_in_response_callback != nullptr) {

    
    uic_mqtt_dotdot_poll_control_command_check_in_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_poll_control_check_in_response(
          jsn,
          fields.start_fast_polling,
              
          fields.fast_poll_timeout
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PollControl", "CheckInResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "CheckInResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "CheckInResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_poll_control_check_in_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_poll_control_check_in_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("StartFastPolling") == jsn.end()) {
        sl_log_debug(LOG_TAG, "PollControl::CheckInResponse: Missing command-argument: StartFastPolling\n");
        return;
      }
      if (jsn.find("FastPollTimeout") == jsn.end()) {
        sl_log_debug(LOG_TAG, "PollControl::CheckInResponse: Missing command-argument: FastPollTimeout\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "PollControl",
        "CheckInResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_poll_control_check_in_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "CheckInResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/PollControl/Commands/FastPollStop
static void uic_mqtt_dotdot_on_by_group_poll_control_fast_poll_stop(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_poll_control_fast_poll_stop_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_poll_control_fast_poll_stop_callback != nullptr) {

    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PollControl", "FastPollStop");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "FastPollStop", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "FastPollStop", "");
        return;
      }

      uic_mqtt_dotdot_by_group_poll_control_fast_poll_stop_callback(
        group_id
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_poll_control_fast_poll_stop_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));

      group_dispatch_callback(
        group_id,
        "PollControl",
        "FastPollStop",
        message,
        message_length,
        uic_mqtt_dotdot_on_poll_control_fast_poll_stop);

    } catch (...) {
      sl_log_debug(LOG_TAG, "FastPollStop: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/PollControl/Commands/SetLongPollInterval
static void uic_mqtt_dotdot_on_by_group_poll_control_set_long_poll_interval(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_poll_control_set_long_poll_interval_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_poll_control_set_long_poll_interval_callback != nullptr) {

    
    uic_mqtt_dotdot_poll_control_command_set_long_poll_interval_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_poll_control_set_long_poll_interval(
          jsn,
          fields.new_long_poll_interval
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PollControl", "SetLongPollInterval");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "SetLongPollInterval", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "SetLongPollInterval", "");
        return;
      }

      uic_mqtt_dotdot_by_group_poll_control_set_long_poll_interval_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("NewLongPollInterval") == jsn.end()) {
        sl_log_debug(LOG_TAG, "PollControl::SetLongPollInterval: Missing command-argument: NewLongPollInterval\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "PollControl",
        "SetLongPollInterval",
        message,
        message_length,
        uic_mqtt_dotdot_on_poll_control_set_long_poll_interval);

    } catch (...) {
      sl_log_debug(LOG_TAG, "SetLongPollInterval: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/PollControl/Commands/SetShortPollInterval
static void uic_mqtt_dotdot_on_by_group_poll_control_set_short_poll_interval(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_poll_control_set_short_poll_interval_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_poll_control_set_short_poll_interval_callback != nullptr) {

    
    uic_mqtt_dotdot_poll_control_command_set_short_poll_interval_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_poll_control_set_short_poll_interval(
          jsn,
          fields.new_short_poll_interval
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PollControl", "SetShortPollInterval");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "SetShortPollInterval", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "SetShortPollInterval", "");
        return;
      }

      uic_mqtt_dotdot_by_group_poll_control_set_short_poll_interval_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("NewShortPollInterval") == jsn.end()) {
        sl_log_debug(LOG_TAG, "PollControl::SetShortPollInterval: Missing command-argument: NewShortPollInterval\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "PollControl",
        "SetShortPollInterval",
        message,
        message_length,
        uic_mqtt_dotdot_on_poll_control_set_short_poll_interval);

    } catch (...) {
      sl_log_debug(LOG_TAG, "SetShortPollInterval: Unable to parse JSON payload.\n");
      return;
    }
  }

}

static void uic_mqtt_dotdot_on_by_group_poll_control_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_poll_control_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_poll_control_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "PollControl",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_poll_control_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "PollControl: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_poll_control_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_poll_control_state_t new_state = {};
    uic_mqtt_dotdot_poll_control_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_poll_control_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PollControl", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_poll_control_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_poll_control_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_poll_control_write_attributes_callback) {
    subscription_topic = topic_bygroup + "PollControl/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_poll_control_WriteAttributes);
  }
  if (uic_mqtt_dotdot_by_group_poll_control_check_in_callback) {
    subscription_topic = topic_bygroup + "PollControl/Commands/CheckIn";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_poll_control_check_in);
  }
  if (uic_mqtt_dotdot_by_group_poll_control_check_in_response_callback) {
    subscription_topic = topic_bygroup + "PollControl/Commands/CheckInResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_poll_control_check_in_response);
  }
  if (uic_mqtt_dotdot_by_group_poll_control_fast_poll_stop_callback) {
    subscription_topic = topic_bygroup + "PollControl/Commands/FastPollStop";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_poll_control_fast_poll_stop);
  }
  if (uic_mqtt_dotdot_by_group_poll_control_set_long_poll_interval_callback) {
    subscription_topic = topic_bygroup + "PollControl/Commands/SetLongPollInterval";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_poll_control_set_long_poll_interval);
  }
  if (uic_mqtt_dotdot_by_group_poll_control_set_short_poll_interval_callback) {
    subscription_topic = topic_bygroup + "PollControl/Commands/SetShortPollInterval";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_poll_control_set_short_poll_interval);
  }

  return SL_STATUS_OK;
}




static void uic_mqtt_dotdot_on_by_group_shade_configuration_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_shade_configuration_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_shade_configuration_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "ShadeConfiguration",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_shade_configuration_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ShadeConfiguration: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_shade_configuration_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_shade_configuration_state_t new_state = {};
    uic_mqtt_dotdot_shade_configuration_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_shade_configuration_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ShadeConfiguration", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ShadeConfiguration", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ShadeConfiguration", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_shade_configuration_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_shade_configuration_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_shade_configuration_write_attributes_callback) {
    subscription_topic = topic_bygroup + "ShadeConfiguration/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_shade_configuration_WriteAttributes);
  }

  return SL_STATUS_OK;
}




// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/LockDoor
static void uic_mqtt_dotdot_on_by_group_door_lock_lock_door(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_lock_door_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_lock_door_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_lock_door_fields_t fields;
      std::string pin_orrfid_code;
    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_lock_door(
          jsn,
          pin_orrfid_code
      );

      // Populate list fields from vector or string types
              fields.pin_orrfid_code = pin_orrfid_code.c_str();
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "LockDoor");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "LockDoor", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "LockDoor", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_lock_door_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_lock_door_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("PINOrRFIDCode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::LockDoor: Missing command-argument: PINOrRFIDCode\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "LockDoor",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_lock_door);

    } catch (...) {
      sl_log_debug(LOG_TAG, "LockDoor: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/LockDoorResponse
static void uic_mqtt_dotdot_on_by_group_door_lock_lock_door_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_lock_door_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_lock_door_response_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_lock_door_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_lock_door_response(
          jsn,
          fields.status
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "LockDoorResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "LockDoorResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "LockDoorResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_lock_door_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_lock_door_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::LockDoorResponse: Missing command-argument: Status\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "LockDoorResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_lock_door_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "LockDoorResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/UnlockDoor
static void uic_mqtt_dotdot_on_by_group_door_lock_unlock_door(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_unlock_door_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_unlock_door_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_unlock_door_fields_t fields;
      std::string pin_orrfid_code;
    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_unlock_door(
          jsn,
          pin_orrfid_code
      );

      // Populate list fields from vector or string types
              fields.pin_orrfid_code = pin_orrfid_code.c_str();
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "UnlockDoor");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockDoor", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockDoor", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_unlock_door_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_unlock_door_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("PINOrRFIDCode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::UnlockDoor: Missing command-argument: PINOrRFIDCode\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "UnlockDoor",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_unlock_door);

    } catch (...) {
      sl_log_debug(LOG_TAG, "UnlockDoor: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/UnlockDoorResponse
static void uic_mqtt_dotdot_on_by_group_door_lock_unlock_door_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_unlock_door_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_unlock_door_response_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_unlock_door_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_unlock_door_response(
          jsn,
          fields.status
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "UnlockDoorResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockDoorResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockDoorResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_unlock_door_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_unlock_door_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::UnlockDoorResponse: Missing command-argument: Status\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "UnlockDoorResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_unlock_door_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "UnlockDoorResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/Toggle
static void uic_mqtt_dotdot_on_by_group_door_lock_toggle(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_toggle_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_toggle_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_toggle_fields_t fields;
      std::string pin_orrfid_code;
    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_toggle(
          jsn,
          pin_orrfid_code
      );

      // Populate list fields from vector or string types
              fields.pin_orrfid_code = pin_orrfid_code.c_str();
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "Toggle");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "Toggle", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "Toggle", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_toggle_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_toggle_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("PINOrRFIDCode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::Toggle: Missing command-argument: PINOrRFIDCode\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "Toggle",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_toggle);

    } catch (...) {
      sl_log_debug(LOG_TAG, "Toggle: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/ToggleResponse
static void uic_mqtt_dotdot_on_by_group_door_lock_toggle_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_toggle_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_toggle_response_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_toggle_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_toggle_response(
          jsn,
          fields.status
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ToggleResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ToggleResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ToggleResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_toggle_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_toggle_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::ToggleResponse: Missing command-argument: Status\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "ToggleResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_toggle_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ToggleResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/UnlockWithTimeout
static void uic_mqtt_dotdot_on_by_group_door_lock_unlock_with_timeout(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_unlock_with_timeout_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_unlock_with_timeout_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_unlock_with_timeout_fields_t fields;
      std::string pin_orrfid_code;
    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_unlock_with_timeout(
          jsn,
          fields.timeout_in_seconds,
              
          pin_orrfid_code
      );

      // Populate list fields from vector or string types
              fields.pin_orrfid_code = pin_orrfid_code.c_str();
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "UnlockWithTimeout");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockWithTimeout", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockWithTimeout", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_unlock_with_timeout_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("TimeoutInSeconds") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::UnlockWithTimeout: Missing command-argument: TimeoutInSeconds\n");
        return;
      }
      if (jsn.find("PINOrRFIDCode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::UnlockWithTimeout: Missing command-argument: PINOrRFIDCode\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "UnlockWithTimeout",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_unlock_with_timeout);

    } catch (...) {
      sl_log_debug(LOG_TAG, "UnlockWithTimeout: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/UnlockWithTimeoutResponse
static void uic_mqtt_dotdot_on_by_group_door_lock_unlock_with_timeout_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_unlock_with_timeout_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_unlock_with_timeout_response_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_unlock_with_timeout_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_unlock_with_timeout_response(
          jsn,
          fields.status
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "UnlockWithTimeoutResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockWithTimeoutResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockWithTimeoutResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_unlock_with_timeout_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::UnlockWithTimeoutResponse: Missing command-argument: Status\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "UnlockWithTimeoutResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_unlock_with_timeout_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "UnlockWithTimeoutResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/GetLogRecord
static void uic_mqtt_dotdot_on_by_group_door_lock_get_log_record(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_get_log_record_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_get_log_record_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_get_log_record_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_get_log_record(
          jsn,
          fields.log_index
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetLogRecord");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetLogRecord", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetLogRecord", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_get_log_record_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_get_log_record_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("LogIndex") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetLogRecord: Missing command-argument: LogIndex\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "GetLogRecord",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_get_log_record);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GetLogRecord: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/GetLogRecordResponse
static void uic_mqtt_dotdot_on_by_group_door_lock_get_log_record_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_get_log_record_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_get_log_record_response_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_get_log_record_response_fields_t fields;
      std::string pin;
    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_get_log_record_response(
          jsn,
          fields.log_entryid,
              
          fields.timestamp,
              
          fields.event_type,
              
          fields.source_operation_event,
              
          fields.eventid_or_alarm_code,
              
          fields.userid,
              
          pin
      );

      // Populate list fields from vector or string types
              fields.pin = pin.c_str();
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetLogRecordResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetLogRecordResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetLogRecordResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_get_log_record_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_get_log_record_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("LogEntryID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetLogRecordResponse: Missing command-argument: LogEntryID\n");
        return;
      }
      if (jsn.find("Timestamp") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetLogRecordResponse: Missing command-argument: Timestamp\n");
        return;
      }
      if (jsn.find("EventType") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetLogRecordResponse: Missing command-argument: EventType\n");
        return;
      }
      if (jsn.find("SourceOperationEvent") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetLogRecordResponse: Missing command-argument: SourceOperationEvent\n");
        return;
      }
      if (jsn.find("EventIDOrAlarmCode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetLogRecordResponse: Missing command-argument: EventIDOrAlarmCode\n");
        return;
      }
      if (jsn.find("UserID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetLogRecordResponse: Missing command-argument: UserID\n");
        return;
      }
      if (jsn.find("PIN") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetLogRecordResponse: Missing command-argument: PIN\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "GetLogRecordResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_get_log_record_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GetLogRecordResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/SetPINCode
static void uic_mqtt_dotdot_on_by_group_door_lock_setpin_code(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_setpin_code_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_setpin_code_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_setpin_code_fields_t fields;
      std::string pin;
    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_setpin_code(
          jsn,
          fields.userid,
              
          fields.user_status,
              
          fields.user_type,
              
          pin
      );

      // Populate list fields from vector or string types
              fields.pin = pin.c_str();
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetPINCode");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetPINCode", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetPINCode", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_setpin_code_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_setpin_code_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("UserID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SetPINCode: Missing command-argument: UserID\n");
        return;
      }
      if (jsn.find("UserStatus") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SetPINCode: Missing command-argument: UserStatus\n");
        return;
      }
      if (jsn.find("UserType") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SetPINCode: Missing command-argument: UserType\n");
        return;
      }
      if (jsn.find("PIN") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SetPINCode: Missing command-argument: PIN\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "SetPINCode",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_setpin_code);

    } catch (...) {
      sl_log_debug(LOG_TAG, "SetPINCode: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/SetPINCodeResponse
static void uic_mqtt_dotdot_on_by_group_door_lock_setpin_code_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_setpin_code_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_setpin_code_response_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_setpin_code_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_setpin_code_response(
          jsn,
          fields.status
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetPINCodeResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetPINCodeResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetPINCodeResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_setpin_code_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_setpin_code_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SetPINCodeResponse: Missing command-argument: Status\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "SetPINCodeResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_setpin_code_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "SetPINCodeResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/GetPINCode
static void uic_mqtt_dotdot_on_by_group_door_lock_getpin_code(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_getpin_code_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_getpin_code_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_getpin_code_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_getpin_code(
          jsn,
          fields.userid
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetPINCode");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetPINCode", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetPINCode", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_getpin_code_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_getpin_code_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("UserID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetPINCode: Missing command-argument: UserID\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "GetPINCode",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_getpin_code);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GetPINCode: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/GetPINCodeResponse
static void uic_mqtt_dotdot_on_by_group_door_lock_getpin_code_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_getpin_code_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_getpin_code_response_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_getpin_code_response_fields_t fields;
      std::string code;
    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_getpin_code_response(
          jsn,
          fields.userid,
              
          fields.user_status,
              
          fields.user_type,
              
          code
      );

      // Populate list fields from vector or string types
              fields.code = code.c_str();
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetPINCodeResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetPINCodeResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetPINCodeResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_getpin_code_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_getpin_code_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("UserID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetPINCodeResponse: Missing command-argument: UserID\n");
        return;
      }
      if (jsn.find("UserStatus") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetPINCodeResponse: Missing command-argument: UserStatus\n");
        return;
      }
      if (jsn.find("UserType") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetPINCodeResponse: Missing command-argument: UserType\n");
        return;
      }
      if (jsn.find("Code") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetPINCodeResponse: Missing command-argument: Code\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "GetPINCodeResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_getpin_code_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GetPINCodeResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/ClearPINCode
static void uic_mqtt_dotdot_on_by_group_door_lock_clearpin_code(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_clearpin_code_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_clearpin_code_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_clearpin_code_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_clearpin_code(
          jsn,
          fields.userid
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearPINCode");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearPINCode", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearPINCode", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_clearpin_code_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_clearpin_code_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("UserID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::ClearPINCode: Missing command-argument: UserID\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "ClearPINCode",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_clearpin_code);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ClearPINCode: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/ClearPINCodeResponse
static void uic_mqtt_dotdot_on_by_group_door_lock_clearpin_code_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_clearpin_code_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_clearpin_code_response_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_clearpin_code_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_clearpin_code_response(
          jsn,
          fields.status
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearPINCodeResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearPINCodeResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearPINCodeResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_clearpin_code_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_clearpin_code_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::ClearPINCodeResponse: Missing command-argument: Status\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "ClearPINCodeResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_clearpin_code_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ClearPINCodeResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/ClearAllPINCodes
static void uic_mqtt_dotdot_on_by_group_door_lock_clear_allpin_codes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_clear_allpin_codes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_clear_allpin_codes_callback != nullptr) {

    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearAllPINCodes");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllPINCodes", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllPINCodes", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_clear_allpin_codes_callback(
        group_id
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_clear_allpin_codes_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "ClearAllPINCodes",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_clear_allpin_codes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ClearAllPINCodes: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/ClearAllPINCodesResponse
static void uic_mqtt_dotdot_on_by_group_door_lock_clear_allpin_codes_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_clear_allpin_codes_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_clear_allpin_codes_response_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_clear_allpin_codes_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_clear_allpin_codes_response(
          jsn,
          fields.status
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearAllPINCodesResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllPINCodesResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllPINCodesResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_clear_allpin_codes_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_clear_allpin_codes_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::ClearAllPINCodesResponse: Missing command-argument: Status\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "ClearAllPINCodesResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_clear_allpin_codes_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ClearAllPINCodesResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/SetUserStatus
static void uic_mqtt_dotdot_on_by_group_door_lock_set_user_status(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_set_user_status_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_set_user_status_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_set_user_status_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_set_user_status(
          jsn,
          fields.userid,
              
          fields.user_status
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetUserStatus");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserStatus", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserStatus", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_set_user_status_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_set_user_status_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("UserID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SetUserStatus: Missing command-argument: UserID\n");
        return;
      }
      if (jsn.find("UserStatus") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SetUserStatus: Missing command-argument: UserStatus\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "SetUserStatus",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_set_user_status);

    } catch (...) {
      sl_log_debug(LOG_TAG, "SetUserStatus: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/SetUserStatusResponse
static void uic_mqtt_dotdot_on_by_group_door_lock_set_user_status_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_set_user_status_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_set_user_status_response_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_set_user_status_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_set_user_status_response(
          jsn,
          fields.status
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetUserStatusResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserStatusResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserStatusResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_set_user_status_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_set_user_status_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SetUserStatusResponse: Missing command-argument: Status\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "SetUserStatusResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_set_user_status_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "SetUserStatusResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/GetUserStatus
static void uic_mqtt_dotdot_on_by_group_door_lock_get_user_status(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_get_user_status_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_get_user_status_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_get_user_status_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_get_user_status(
          jsn,
          fields.userid
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetUserStatus");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserStatus", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserStatus", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_get_user_status_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_get_user_status_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("UserID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetUserStatus: Missing command-argument: UserID\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "GetUserStatus",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_get_user_status);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GetUserStatus: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/GetUserStatusResponse
static void uic_mqtt_dotdot_on_by_group_door_lock_get_user_status_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_get_user_status_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_get_user_status_response_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_get_user_status_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_get_user_status_response(
          jsn,
          fields.userid,
              
          fields.user_status
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetUserStatusResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserStatusResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserStatusResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_get_user_status_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_get_user_status_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("UserID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetUserStatusResponse: Missing command-argument: UserID\n");
        return;
      }
      if (jsn.find("UserStatus") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetUserStatusResponse: Missing command-argument: UserStatus\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "GetUserStatusResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_get_user_status_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GetUserStatusResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/SetWeekdaySchedule
static void uic_mqtt_dotdot_on_by_group_door_lock_set_weekday_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_set_weekday_schedule_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_set_weekday_schedule_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_set_weekday_schedule_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_set_weekday_schedule(
          jsn,
          fields.scheduleid,
              
          fields.userid,
              
          fields.days_mask,
              
          fields.start_hour,
              
          fields.start_minute,
              
          fields.end_hour,
              
          fields.end_minute
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetWeekdaySchedule");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetWeekdaySchedule", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetWeekdaySchedule", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_set_weekday_schedule_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("ScheduleID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SetWeekdaySchedule: Missing command-argument: ScheduleID\n");
        return;
      }
      if (jsn.find("UserID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SetWeekdaySchedule: Missing command-argument: UserID\n");
        return;
      }
      if (jsn.find("DaysMask") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SetWeekdaySchedule: Missing command-argument: DaysMask\n");
        return;
      }
      if (jsn.find("StartHour") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SetWeekdaySchedule: Missing command-argument: StartHour\n");
        return;
      }
      if (jsn.find("StartMinute") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SetWeekdaySchedule: Missing command-argument: StartMinute\n");
        return;
      }
      if (jsn.find("EndHour") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SetWeekdaySchedule: Missing command-argument: EndHour\n");
        return;
      }
      if (jsn.find("EndMinute") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SetWeekdaySchedule: Missing command-argument: EndMinute\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "SetWeekdaySchedule",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_set_weekday_schedule);

    } catch (...) {
      sl_log_debug(LOG_TAG, "SetWeekdaySchedule: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/SetWeekdayScheduleResponse
static void uic_mqtt_dotdot_on_by_group_door_lock_set_weekday_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_set_weekday_schedule_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_set_weekday_schedule_response_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_set_weekday_schedule_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_set_weekday_schedule_response(
          jsn,
          fields.status
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetWeekdayScheduleResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetWeekdayScheduleResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetWeekdayScheduleResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_set_weekday_schedule_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SetWeekdayScheduleResponse: Missing command-argument: Status\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "SetWeekdayScheduleResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_set_weekday_schedule_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "SetWeekdayScheduleResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/GetWeekdaySchedule
static void uic_mqtt_dotdot_on_by_group_door_lock_get_weekday_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_get_weekday_schedule_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_get_weekday_schedule_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_get_weekday_schedule_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_get_weekday_schedule(
          jsn,
          fields.scheduleid,
              
          fields.userid
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetWeekdaySchedule");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetWeekdaySchedule", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetWeekdaySchedule", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_get_weekday_schedule_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("ScheduleID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetWeekdaySchedule: Missing command-argument: ScheduleID\n");
        return;
      }
      if (jsn.find("UserID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetWeekdaySchedule: Missing command-argument: UserID\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "GetWeekdaySchedule",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_get_weekday_schedule);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GetWeekdaySchedule: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/GetWeekdayScheduleResponse
static void uic_mqtt_dotdot_on_by_group_door_lock_get_weekday_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_get_weekday_schedule_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_get_weekday_schedule_response_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_get_weekday_schedule_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_get_weekday_schedule_response(
          jsn,
          fields.scheduleid,
              
          fields.userid,
              
          fields.status,
              
          fields.days_mask,
              
          fields.start_hour,
              
          fields.start_minute,
              
          fields.end_hour,
              
          fields.end_minute
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetWeekdayScheduleResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetWeekdayScheduleResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetWeekdayScheduleResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_get_weekday_schedule_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("ScheduleID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetWeekdayScheduleResponse: Missing command-argument: ScheduleID\n");
        return;
      }
      if (jsn.find("UserID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetWeekdayScheduleResponse: Missing command-argument: UserID\n");
        return;
      }
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetWeekdayScheduleResponse: Missing command-argument: Status\n");
        return;
      }
      if (jsn.find("DaysMask") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetWeekdayScheduleResponse: Missing command-argument: DaysMask\n");
        return;
      }
      if (jsn.find("StartHour") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetWeekdayScheduleResponse: Missing command-argument: StartHour\n");
        return;
      }
      if (jsn.find("StartMinute") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetWeekdayScheduleResponse: Missing command-argument: StartMinute\n");
        return;
      }
      if (jsn.find("EndHour") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetWeekdayScheduleResponse: Missing command-argument: EndHour\n");
        return;
      }
      if (jsn.find("EndMinute") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetWeekdayScheduleResponse: Missing command-argument: EndMinute\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "GetWeekdayScheduleResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_get_weekday_schedule_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GetWeekdayScheduleResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/ClearWeekdaySchedule
static void uic_mqtt_dotdot_on_by_group_door_lock_clear_weekday_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_clear_weekday_schedule_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_clear_weekday_schedule_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_clear_weekday_schedule_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_clear_weekday_schedule(
          jsn,
          fields.scheduleid,
              
          fields.userid
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearWeekdaySchedule");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearWeekdaySchedule", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearWeekdaySchedule", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_clear_weekday_schedule_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("ScheduleID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::ClearWeekdaySchedule: Missing command-argument: ScheduleID\n");
        return;
      }
      if (jsn.find("UserID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::ClearWeekdaySchedule: Missing command-argument: UserID\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "ClearWeekdaySchedule",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_clear_weekday_schedule);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ClearWeekdaySchedule: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/ClearWeekdayScheduleResponse
static void uic_mqtt_dotdot_on_by_group_door_lock_clear_weekday_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_clear_weekday_schedule_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_clear_weekday_schedule_response_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_clear_weekday_schedule_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_clear_weekday_schedule_response(
          jsn,
          fields.status
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearWeekdayScheduleResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearWeekdayScheduleResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearWeekdayScheduleResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_clear_weekday_schedule_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::ClearWeekdayScheduleResponse: Missing command-argument: Status\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "ClearWeekdayScheduleResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_clear_weekday_schedule_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ClearWeekdayScheduleResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/SetYearDaySchedule
static void uic_mqtt_dotdot_on_by_group_door_lock_set_year_day_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_set_year_day_schedule_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_set_year_day_schedule_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_set_year_day_schedule_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_set_year_day_schedule(
          jsn,
          fields.scheduleid,
              
          fields.userid,
              
          fields.local_start_time,
              
          fields.local_end_time
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetYearDaySchedule");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetYearDaySchedule", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetYearDaySchedule", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_set_year_day_schedule_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("ScheduleID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SetYearDaySchedule: Missing command-argument: ScheduleID\n");
        return;
      }
      if (jsn.find("UserID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SetYearDaySchedule: Missing command-argument: UserID\n");
        return;
      }
      if (jsn.find("LocalStartTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SetYearDaySchedule: Missing command-argument: LocalStartTime\n");
        return;
      }
      if (jsn.find("LocalEndTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SetYearDaySchedule: Missing command-argument: LocalEndTime\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "SetYearDaySchedule",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_set_year_day_schedule);

    } catch (...) {
      sl_log_debug(LOG_TAG, "SetYearDaySchedule: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/SetYearDayScheduleResponse
static void uic_mqtt_dotdot_on_by_group_door_lock_set_year_day_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_set_year_day_schedule_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_set_year_day_schedule_response_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_set_year_day_schedule_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_set_year_day_schedule_response(
          jsn,
          fields.status
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetYearDayScheduleResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetYearDayScheduleResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetYearDayScheduleResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_set_year_day_schedule_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SetYearDayScheduleResponse: Missing command-argument: Status\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "SetYearDayScheduleResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_set_year_day_schedule_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "SetYearDayScheduleResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/GetYearDaySchedule
static void uic_mqtt_dotdot_on_by_group_door_lock_get_year_day_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_get_year_day_schedule_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_get_year_day_schedule_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_get_year_day_schedule_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_get_year_day_schedule(
          jsn,
          fields.scheduleid,
              
          fields.userid
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetYearDaySchedule");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetYearDaySchedule", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetYearDaySchedule", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_get_year_day_schedule_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("ScheduleID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetYearDaySchedule: Missing command-argument: ScheduleID\n");
        return;
      }
      if (jsn.find("UserID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetYearDaySchedule: Missing command-argument: UserID\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "GetYearDaySchedule",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_get_year_day_schedule);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GetYearDaySchedule: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/GetYearDayScheduleResponse
static void uic_mqtt_dotdot_on_by_group_door_lock_get_year_day_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_get_year_day_schedule_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_get_year_day_schedule_response_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_get_year_day_schedule_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_get_year_day_schedule_response(
          jsn,
          fields.scheduleid,
              
          fields.userid,
              
          fields.status,
              
          fields.local_start_time,
              
          fields.local_end_time
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetYearDayScheduleResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetYearDayScheduleResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetYearDayScheduleResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_get_year_day_schedule_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("ScheduleID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetYearDayScheduleResponse: Missing command-argument: ScheduleID\n");
        return;
      }
      if (jsn.find("UserID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetYearDayScheduleResponse: Missing command-argument: UserID\n");
        return;
      }
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetYearDayScheduleResponse: Missing command-argument: Status\n");
        return;
      }
      if (jsn.find("LocalStartTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetYearDayScheduleResponse: Missing command-argument: LocalStartTime\n");
        return;
      }
      if (jsn.find("LocalEndTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetYearDayScheduleResponse: Missing command-argument: LocalEndTime\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "GetYearDayScheduleResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_get_year_day_schedule_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GetYearDayScheduleResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/ClearYearDaySchedule
static void uic_mqtt_dotdot_on_by_group_door_lock_clear_year_day_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_clear_year_day_schedule_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_clear_year_day_schedule_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_clear_year_day_schedule_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_clear_year_day_schedule(
          jsn,
          fields.scheduleid,
              
          fields.userid
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearYearDaySchedule");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearYearDaySchedule", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearYearDaySchedule", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_clear_year_day_schedule_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("ScheduleID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::ClearYearDaySchedule: Missing command-argument: ScheduleID\n");
        return;
      }
      if (jsn.find("UserID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::ClearYearDaySchedule: Missing command-argument: UserID\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "ClearYearDaySchedule",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_clear_year_day_schedule);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ClearYearDaySchedule: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/ClearYearDayScheduleResponse
static void uic_mqtt_dotdot_on_by_group_door_lock_clear_year_day_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_clear_year_day_schedule_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_clear_year_day_schedule_response_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_clear_year_day_schedule_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_clear_year_day_schedule_response(
          jsn,
          fields.status
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearYearDayScheduleResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearYearDayScheduleResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearYearDayScheduleResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_clear_year_day_schedule_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::ClearYearDayScheduleResponse: Missing command-argument: Status\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "ClearYearDayScheduleResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_clear_year_day_schedule_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ClearYearDayScheduleResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/SetHolidaySchedule
static void uic_mqtt_dotdot_on_by_group_door_lock_set_holiday_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_set_holiday_schedule_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_set_holiday_schedule_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_set_holiday_schedule_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_set_holiday_schedule(
          jsn,
          fields.holiday_scheduleid,
              
          fields.local_start_time,
              
          fields.local_end_time,
              
          fields.operating_mode_during_holiday
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetHolidaySchedule");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetHolidaySchedule", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetHolidaySchedule", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_set_holiday_schedule_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("HolidayScheduleID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SetHolidaySchedule: Missing command-argument: HolidayScheduleID\n");
        return;
      }
      if (jsn.find("LocalStartTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SetHolidaySchedule: Missing command-argument: LocalStartTime\n");
        return;
      }
      if (jsn.find("LocalEndTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SetHolidaySchedule: Missing command-argument: LocalEndTime\n");
        return;
      }
      if (jsn.find("OperatingModeDuringHoliday") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SetHolidaySchedule: Missing command-argument: OperatingModeDuringHoliday\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "SetHolidaySchedule",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_set_holiday_schedule);

    } catch (...) {
      sl_log_debug(LOG_TAG, "SetHolidaySchedule: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/SetHolidayScheduleResponse
static void uic_mqtt_dotdot_on_by_group_door_lock_set_holiday_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_set_holiday_schedule_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_set_holiday_schedule_response_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_set_holiday_schedule_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_set_holiday_schedule_response(
          jsn,
          fields.status
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetHolidayScheduleResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetHolidayScheduleResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetHolidayScheduleResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_set_holiday_schedule_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SetHolidayScheduleResponse: Missing command-argument: Status\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "SetHolidayScheduleResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_set_holiday_schedule_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "SetHolidayScheduleResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/GetHolidaySchedule
static void uic_mqtt_dotdot_on_by_group_door_lock_get_holiday_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_get_holiday_schedule_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_get_holiday_schedule_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_get_holiday_schedule_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_get_holiday_schedule(
          jsn,
          fields.holiday_scheduleid
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetHolidaySchedule");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetHolidaySchedule", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetHolidaySchedule", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_get_holiday_schedule_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("HolidayScheduleID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetHolidaySchedule: Missing command-argument: HolidayScheduleID\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "GetHolidaySchedule",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_get_holiday_schedule);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GetHolidaySchedule: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/GetHolidayScheduleResponse
static void uic_mqtt_dotdot_on_by_group_door_lock_get_holiday_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_get_holiday_schedule_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_get_holiday_schedule_response_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_get_holiday_schedule_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_get_holiday_schedule_response(
          jsn,
          fields.holiday_scheduleid,
              
          fields.status,
              
          fields.local_start_time,
              
          fields.local_end_time,
              
          fields.operating_mode_during_holiday
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetHolidayScheduleResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetHolidayScheduleResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetHolidayScheduleResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_get_holiday_schedule_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("HolidayScheduleID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetHolidayScheduleResponse: Missing command-argument: HolidayScheduleID\n");
        return;
      }
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetHolidayScheduleResponse: Missing command-argument: Status\n");
        return;
      }
      if (jsn.find("LocalStartTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetHolidayScheduleResponse: Missing command-argument: LocalStartTime\n");
        return;
      }
      if (jsn.find("LocalEndTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetHolidayScheduleResponse: Missing command-argument: LocalEndTime\n");
        return;
      }
      if (jsn.find("OperatingModeDuringHoliday") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetHolidayScheduleResponse: Missing command-argument: OperatingModeDuringHoliday\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "GetHolidayScheduleResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_get_holiday_schedule_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GetHolidayScheduleResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/ClearHolidaySchedule
static void uic_mqtt_dotdot_on_by_group_door_lock_clear_holiday_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_clear_holiday_schedule_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_clear_holiday_schedule_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_clear_holiday_schedule_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_clear_holiday_schedule(
          jsn,
          fields.holiday_scheduleid
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearHolidaySchedule");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearHolidaySchedule", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearHolidaySchedule", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_clear_holiday_schedule_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("HolidayScheduleID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::ClearHolidaySchedule: Missing command-argument: HolidayScheduleID\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "ClearHolidaySchedule",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_clear_holiday_schedule);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ClearHolidaySchedule: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/ClearHolidayScheduleResponse
static void uic_mqtt_dotdot_on_by_group_door_lock_clear_holiday_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_clear_holiday_schedule_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_clear_holiday_schedule_response_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_clear_holiday_schedule_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_clear_holiday_schedule_response(
          jsn,
          fields.status
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearHolidayScheduleResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearHolidayScheduleResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearHolidayScheduleResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_clear_holiday_schedule_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::ClearHolidayScheduleResponse: Missing command-argument: Status\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "ClearHolidayScheduleResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_clear_holiday_schedule_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ClearHolidayScheduleResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/SetUserType
static void uic_mqtt_dotdot_on_by_group_door_lock_set_user_type(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_set_user_type_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_set_user_type_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_set_user_type_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_set_user_type(
          jsn,
          fields.userid,
              
          fields.user_type
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetUserType");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserType", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserType", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_set_user_type_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_set_user_type_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("UserID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SetUserType: Missing command-argument: UserID\n");
        return;
      }
      if (jsn.find("UserType") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SetUserType: Missing command-argument: UserType\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "SetUserType",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_set_user_type);

    } catch (...) {
      sl_log_debug(LOG_TAG, "SetUserType: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/SetUserTypeResponse
static void uic_mqtt_dotdot_on_by_group_door_lock_set_user_type_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_set_user_type_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_set_user_type_response_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_set_user_type_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_set_user_type_response(
          jsn,
          fields.status
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetUserTypeResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserTypeResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserTypeResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_set_user_type_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_set_user_type_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SetUserTypeResponse: Missing command-argument: Status\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "SetUserTypeResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_set_user_type_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "SetUserTypeResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/GetUserType
static void uic_mqtt_dotdot_on_by_group_door_lock_get_user_type(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_get_user_type_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_get_user_type_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_get_user_type_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_get_user_type(
          jsn,
          fields.userid
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetUserType");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserType", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserType", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_get_user_type_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_get_user_type_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("UserID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetUserType: Missing command-argument: UserID\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "GetUserType",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_get_user_type);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GetUserType: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/GetUserTypeResponse
static void uic_mqtt_dotdot_on_by_group_door_lock_get_user_type_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_get_user_type_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_get_user_type_response_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_get_user_type_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_get_user_type_response(
          jsn,
          fields.userid,
              
          fields.user_type
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetUserTypeResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserTypeResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserTypeResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_get_user_type_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_get_user_type_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("UserID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetUserTypeResponse: Missing command-argument: UserID\n");
        return;
      }
      if (jsn.find("UserType") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetUserTypeResponse: Missing command-argument: UserType\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "GetUserTypeResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_get_user_type_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GetUserTypeResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/SetRFIDCode
static void uic_mqtt_dotdot_on_by_group_door_lock_setrfid_code(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_setrfid_code_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_setrfid_code_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_setrfid_code_fields_t fields;
      std::string rfid_code;
    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_setrfid_code(
          jsn,
          fields.userid,
              
          fields.user_status,
              
          fields.user_type,
              
          rfid_code
      );

      // Populate list fields from vector or string types
              fields.rfid_code = rfid_code.c_str();
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetRFIDCode");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetRFIDCode", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetRFIDCode", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_setrfid_code_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_setrfid_code_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("UserID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SetRFIDCode: Missing command-argument: UserID\n");
        return;
      }
      if (jsn.find("UserStatus") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SetRFIDCode: Missing command-argument: UserStatus\n");
        return;
      }
      if (jsn.find("UserType") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SetRFIDCode: Missing command-argument: UserType\n");
        return;
      }
      if (jsn.find("RFIDCode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SetRFIDCode: Missing command-argument: RFIDCode\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "SetRFIDCode",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_setrfid_code);

    } catch (...) {
      sl_log_debug(LOG_TAG, "SetRFIDCode: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/SetRFIDCodeResponse
static void uic_mqtt_dotdot_on_by_group_door_lock_setrfid_code_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_setrfid_code_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_setrfid_code_response_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_setrfid_code_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_setrfid_code_response(
          jsn,
          fields.status
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetRFIDCodeResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetRFIDCodeResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetRFIDCodeResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_setrfid_code_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_setrfid_code_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SetRFIDCodeResponse: Missing command-argument: Status\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "SetRFIDCodeResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_setrfid_code_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "SetRFIDCodeResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/GetRFIDCode
static void uic_mqtt_dotdot_on_by_group_door_lock_getrfid_code(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_getrfid_code_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_getrfid_code_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_getrfid_code_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_getrfid_code(
          jsn,
          fields.userid
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetRFIDCode");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetRFIDCode", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetRFIDCode", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_getrfid_code_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_getrfid_code_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("UserID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetRFIDCode: Missing command-argument: UserID\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "GetRFIDCode",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_getrfid_code);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GetRFIDCode: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/GetRFIDCodeResponse
static void uic_mqtt_dotdot_on_by_group_door_lock_getrfid_code_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_getrfid_code_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_getrfid_code_response_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_getrfid_code_response_fields_t fields;
      std::string rfid_code;
    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_getrfid_code_response(
          jsn,
          fields.userid,
              
          fields.user_status,
              
          fields.user_type,
              
          rfid_code
      );

      // Populate list fields from vector or string types
              fields.rfid_code = rfid_code.c_str();
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetRFIDCodeResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetRFIDCodeResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetRFIDCodeResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_getrfid_code_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_getrfid_code_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("UserID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetRFIDCodeResponse: Missing command-argument: UserID\n");
        return;
      }
      if (jsn.find("UserStatus") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetRFIDCodeResponse: Missing command-argument: UserStatus\n");
        return;
      }
      if (jsn.find("UserType") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetRFIDCodeResponse: Missing command-argument: UserType\n");
        return;
      }
      if (jsn.find("RFIDCode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::GetRFIDCodeResponse: Missing command-argument: RFIDCode\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "GetRFIDCodeResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_getrfid_code_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GetRFIDCodeResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/ClearRFIDCode
static void uic_mqtt_dotdot_on_by_group_door_lock_clearrfid_code(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_clearrfid_code_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_clearrfid_code_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_clearrfid_code_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_clearrfid_code(
          jsn,
          fields.userid
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearRFIDCode");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearRFIDCode", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearRFIDCode", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_clearrfid_code_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_clearrfid_code_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("UserID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::ClearRFIDCode: Missing command-argument: UserID\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "ClearRFIDCode",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_clearrfid_code);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ClearRFIDCode: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/ClearRFIDCodeResponse
static void uic_mqtt_dotdot_on_by_group_door_lock_clearrfid_code_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_clearrfid_code_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_clearrfid_code_response_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_clearrfid_code_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_clearrfid_code_response(
          jsn,
          fields.status
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearRFIDCodeResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearRFIDCodeResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearRFIDCodeResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_clearrfid_code_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_clearrfid_code_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::ClearRFIDCodeResponse: Missing command-argument: Status\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "ClearRFIDCodeResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_clearrfid_code_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ClearRFIDCodeResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/ClearAllRFIDCodes
static void uic_mqtt_dotdot_on_by_group_door_lock_clear_allrfid_codes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_clear_allrfid_codes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_clear_allrfid_codes_callback != nullptr) {

    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearAllRFIDCodes");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllRFIDCodes", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllRFIDCodes", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_clear_allrfid_codes_callback(
        group_id
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_clear_allrfid_codes_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "ClearAllRFIDCodes",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_clear_allrfid_codes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ClearAllRFIDCodes: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/ClearAllRFIDCodesResponse
static void uic_mqtt_dotdot_on_by_group_door_lock_clear_allrfid_codes_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_clear_allrfid_codes_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_clear_allrfid_codes_response_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_clear_allrfid_codes_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_clear_allrfid_codes_response(
          jsn,
          fields.status
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearAllRFIDCodesResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllRFIDCodesResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllRFIDCodesResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_clear_allrfid_codes_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_clear_allrfid_codes_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::ClearAllRFIDCodesResponse: Missing command-argument: Status\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "ClearAllRFIDCodesResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_clear_allrfid_codes_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ClearAllRFIDCodesResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/OperatingEventNotification
static void uic_mqtt_dotdot_on_by_group_door_lock_operating_event_notification(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_operating_event_notification_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_operating_event_notification_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_operating_event_notification_fields_t fields;
      std::string pin;
          std::string data;
    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_operating_event_notification(
          jsn,
          fields.operation_event_source,
              
          fields.operation_event_code,
              
          fields.userid,
              
          pin,
      
          fields.local_time,
              
          data
      );

      // Populate list fields from vector or string types
              fields.pin = pin.c_str();
              fields.data = data.c_str();
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "OperatingEventNotification");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "OperatingEventNotification", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "OperatingEventNotification", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_operating_event_notification_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_operating_event_notification_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("OperationEventSource") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::OperatingEventNotification: Missing command-argument: OperationEventSource\n");
        return;
      }
      if (jsn.find("OperationEventCode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::OperatingEventNotification: Missing command-argument: OperationEventCode\n");
        return;
      }
      if (jsn.find("UserID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::OperatingEventNotification: Missing command-argument: UserID\n");
        return;
      }
      if (jsn.find("PIN") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::OperatingEventNotification: Missing command-argument: PIN\n");
        return;
      }
      if (jsn.find("LocalTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::OperatingEventNotification: Missing command-argument: LocalTime\n");
        return;
      }
      if (jsn.find("Data") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::OperatingEventNotification: Missing command-argument: Data\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "OperatingEventNotification",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_operating_event_notification);

    } catch (...) {
      sl_log_debug(LOG_TAG, "OperatingEventNotification: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/DoorLock/Commands/ProgrammingEventNotification
static void uic_mqtt_dotdot_on_by_group_door_lock_programming_event_notification(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_programming_event_notification_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_door_lock_programming_event_notification_callback != nullptr) {

    
    uic_mqtt_dotdot_door_lock_command_programming_event_notification_fields_t fields;
      std::string pin;
          std::string data;
    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_door_lock_programming_event_notification(
          jsn,
          fields.program_event_source,
              
          fields.program_event_code,
              
          fields.userid,
              
          pin,
      
          fields.user_type,
              
          fields.user_status,
              
          fields.local_time,
              
          data
      );

      // Populate list fields from vector or string types
              fields.pin = pin.c_str();
              fields.data = data.c_str();
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ProgrammingEventNotification");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ProgrammingEventNotification", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ProgrammingEventNotification", "");
        return;
      }

      uic_mqtt_dotdot_by_group_door_lock_programming_event_notification_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_programming_event_notification_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("ProgramEventSource") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::ProgrammingEventNotification: Missing command-argument: ProgramEventSource\n");
        return;
      }
      if (jsn.find("ProgramEventCode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::ProgrammingEventNotification: Missing command-argument: ProgramEventCode\n");
        return;
      }
      if (jsn.find("UserID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::ProgrammingEventNotification: Missing command-argument: UserID\n");
        return;
      }
      if (jsn.find("PIN") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::ProgrammingEventNotification: Missing command-argument: PIN\n");
        return;
      }
      if (jsn.find("UserType") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::ProgrammingEventNotification: Missing command-argument: UserType\n");
        return;
      }
      if (jsn.find("UserStatus") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::ProgrammingEventNotification: Missing command-argument: UserStatus\n");
        return;
      }
      if (jsn.find("LocalTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::ProgrammingEventNotification: Missing command-argument: LocalTime\n");
        return;
      }
      if (jsn.find("Data") == jsn.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::ProgrammingEventNotification: Missing command-argument: Data\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "DoorLock",
        "ProgrammingEventNotification",
        message,
        message_length,
        uic_mqtt_dotdot_on_door_lock_programming_event_notification);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ProgrammingEventNotification: Unable to parse JSON payload.\n");
      return;
    }
  }

}

static void uic_mqtt_dotdot_on_by_group_door_lock_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_door_lock_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_door_lock_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "DoorLock",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_door_lock_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "DoorLock: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_door_lock_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_door_lock_state_t new_state = {};
    uic_mqtt_dotdot_door_lock_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_door_lock_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_door_lock_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_door_lock_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_door_lock_write_attributes_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_WriteAttributes);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_lock_door_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/LockDoor";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_lock_door);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_lock_door_response_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/LockDoorResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_lock_door_response);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_unlock_door_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/UnlockDoor";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_unlock_door);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_unlock_door_response_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/UnlockDoorResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_unlock_door_response);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_toggle_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/Toggle";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_toggle);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_toggle_response_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/ToggleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_toggle_response);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_unlock_with_timeout_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/UnlockWithTimeout";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_unlock_with_timeout);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_unlock_with_timeout_response_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/UnlockWithTimeoutResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_unlock_with_timeout_response);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_get_log_record_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/GetLogRecord";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_get_log_record);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_get_log_record_response_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/GetLogRecordResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_get_log_record_response);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_setpin_code_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/SetPINCode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_setpin_code);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_setpin_code_response_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/SetPINCodeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_setpin_code_response);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_getpin_code_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/GetPINCode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_getpin_code);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_getpin_code_response_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/GetPINCodeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_getpin_code_response);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_clearpin_code_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/ClearPINCode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_clearpin_code);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_clearpin_code_response_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/ClearPINCodeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_clearpin_code_response);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_clear_allpin_codes_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/ClearAllPINCodes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_clear_allpin_codes);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_clear_allpin_codes_response_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/ClearAllPINCodesResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_clear_allpin_codes_response);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_set_user_status_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/SetUserStatus";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_set_user_status);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_set_user_status_response_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/SetUserStatusResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_set_user_status_response);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_get_user_status_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/GetUserStatus";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_get_user_status);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_get_user_status_response_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/GetUserStatusResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_get_user_status_response);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_set_weekday_schedule_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/SetWeekdaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_set_weekday_schedule);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_set_weekday_schedule_response_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/SetWeekdayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_set_weekday_schedule_response);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_get_weekday_schedule_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/GetWeekdaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_get_weekday_schedule);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_get_weekday_schedule_response_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/GetWeekdayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_get_weekday_schedule_response);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_clear_weekday_schedule_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/ClearWeekdaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_clear_weekday_schedule);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_clear_weekday_schedule_response_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/ClearWeekdayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_clear_weekday_schedule_response);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_set_year_day_schedule_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/SetYearDaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_set_year_day_schedule);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_set_year_day_schedule_response_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/SetYearDayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_set_year_day_schedule_response);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_get_year_day_schedule_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/GetYearDaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_get_year_day_schedule);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_get_year_day_schedule_response_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/GetYearDayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_get_year_day_schedule_response);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_clear_year_day_schedule_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/ClearYearDaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_clear_year_day_schedule);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_clear_year_day_schedule_response_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/ClearYearDayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_clear_year_day_schedule_response);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_set_holiday_schedule_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/SetHolidaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_set_holiday_schedule);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_set_holiday_schedule_response_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/SetHolidayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_set_holiday_schedule_response);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_get_holiday_schedule_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/GetHolidaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_get_holiday_schedule);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_get_holiday_schedule_response_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/GetHolidayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_get_holiday_schedule_response);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_clear_holiday_schedule_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/ClearHolidaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_clear_holiday_schedule);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_clear_holiday_schedule_response_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/ClearHolidayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_clear_holiday_schedule_response);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_set_user_type_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/SetUserType";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_set_user_type);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_set_user_type_response_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/SetUserTypeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_set_user_type_response);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_get_user_type_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/GetUserType";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_get_user_type);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_get_user_type_response_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/GetUserTypeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_get_user_type_response);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_setrfid_code_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/SetRFIDCode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_setrfid_code);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_setrfid_code_response_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/SetRFIDCodeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_setrfid_code_response);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_getrfid_code_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/GetRFIDCode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_getrfid_code);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_getrfid_code_response_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/GetRFIDCodeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_getrfid_code_response);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_clearrfid_code_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/ClearRFIDCode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_clearrfid_code);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_clearrfid_code_response_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/ClearRFIDCodeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_clearrfid_code_response);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_clear_allrfid_codes_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/ClearAllRFIDCodes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_clear_allrfid_codes);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_clear_allrfid_codes_response_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/ClearAllRFIDCodesResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_clear_allrfid_codes_response);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_operating_event_notification_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/OperatingEventNotification";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_operating_event_notification);
  }
  if (uic_mqtt_dotdot_by_group_door_lock_programming_event_notification_callback) {
    subscription_topic = topic_bygroup + "DoorLock/Commands/ProgrammingEventNotification";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_door_lock_programming_event_notification);
  }

  return SL_STATUS_OK;
}




// Callback function for incoming publications on ucl/by-group/+/WindowCovering/Commands/UpOrOpen
static void uic_mqtt_dotdot_on_by_group_window_covering_up_or_open(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_window_covering_up_or_open_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_window_covering_up_or_open_callback != nullptr) {

    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "UpOrOpen");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "UpOrOpen", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "UpOrOpen", "");
        return;
      }

      uic_mqtt_dotdot_by_group_window_covering_up_or_open_callback(
        group_id
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_window_covering_up_or_open_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));

      group_dispatch_callback(
        group_id,
        "WindowCovering",
        "UpOrOpen",
        message,
        message_length,
        uic_mqtt_dotdot_on_window_covering_up_or_open);

    } catch (...) {
      sl_log_debug(LOG_TAG, "UpOrOpen: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/WindowCovering/Commands/DownOrClose
static void uic_mqtt_dotdot_on_by_group_window_covering_down_or_close(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_window_covering_down_or_close_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_window_covering_down_or_close_callback != nullptr) {

    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "DownOrClose");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "DownOrClose", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "DownOrClose", "");
        return;
      }

      uic_mqtt_dotdot_by_group_window_covering_down_or_close_callback(
        group_id
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_window_covering_down_or_close_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));

      group_dispatch_callback(
        group_id,
        "WindowCovering",
        "DownOrClose",
        message,
        message_length,
        uic_mqtt_dotdot_on_window_covering_down_or_close);

    } catch (...) {
      sl_log_debug(LOG_TAG, "DownOrClose: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/WindowCovering/Commands/Stop
static void uic_mqtt_dotdot_on_by_group_window_covering_stop(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_window_covering_stop_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_window_covering_stop_callback != nullptr) {

    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "Stop");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "Stop", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "Stop", "");
        return;
      }

      uic_mqtt_dotdot_by_group_window_covering_stop_callback(
        group_id
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_window_covering_stop_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));

      group_dispatch_callback(
        group_id,
        "WindowCovering",
        "Stop",
        message,
        message_length,
        uic_mqtt_dotdot_on_window_covering_stop);

    } catch (...) {
      sl_log_debug(LOG_TAG, "Stop: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/WindowCovering/Commands/GoToLiftValue
static void uic_mqtt_dotdot_on_by_group_window_covering_go_to_lift_value(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_window_covering_go_to_lift_value_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_window_covering_go_to_lift_value_callback != nullptr) {

    
    uic_mqtt_dotdot_window_covering_command_go_to_lift_value_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_window_covering_go_to_lift_value(
          jsn,
          fields.lift_value
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "GoToLiftValue");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToLiftValue", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToLiftValue", "");
        return;
      }

      uic_mqtt_dotdot_by_group_window_covering_go_to_lift_value_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_window_covering_go_to_lift_value_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("LiftValue") == jsn.end()) {
        sl_log_debug(LOG_TAG, "WindowCovering::GoToLiftValue: Missing command-argument: LiftValue\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "WindowCovering",
        "GoToLiftValue",
        message,
        message_length,
        uic_mqtt_dotdot_on_window_covering_go_to_lift_value);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GoToLiftValue: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/WindowCovering/Commands/GoToLiftPercentage
static void uic_mqtt_dotdot_on_by_group_window_covering_go_to_lift_percentage(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_window_covering_go_to_lift_percentage_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_window_covering_go_to_lift_percentage_callback != nullptr) {

    
    uic_mqtt_dotdot_window_covering_command_go_to_lift_percentage_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_window_covering_go_to_lift_percentage(
          jsn,
          fields.percentage_lift_value
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "GoToLiftPercentage");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToLiftPercentage", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToLiftPercentage", "");
        return;
      }

      uic_mqtt_dotdot_by_group_window_covering_go_to_lift_percentage_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("PercentageLiftValue") == jsn.end()) {
        sl_log_debug(LOG_TAG, "WindowCovering::GoToLiftPercentage: Missing command-argument: PercentageLiftValue\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "WindowCovering",
        "GoToLiftPercentage",
        message,
        message_length,
        uic_mqtt_dotdot_on_window_covering_go_to_lift_percentage);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GoToLiftPercentage: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/WindowCovering/Commands/GoToTiltValue
static void uic_mqtt_dotdot_on_by_group_window_covering_go_to_tilt_value(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_window_covering_go_to_tilt_value_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_window_covering_go_to_tilt_value_callback != nullptr) {

    
    uic_mqtt_dotdot_window_covering_command_go_to_tilt_value_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_window_covering_go_to_tilt_value(
          jsn,
          fields.tilt_value
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "GoToTiltValue");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToTiltValue", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToTiltValue", "");
        return;
      }

      uic_mqtt_dotdot_by_group_window_covering_go_to_tilt_value_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("TiltValue") == jsn.end()) {
        sl_log_debug(LOG_TAG, "WindowCovering::GoToTiltValue: Missing command-argument: TiltValue\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "WindowCovering",
        "GoToTiltValue",
        message,
        message_length,
        uic_mqtt_dotdot_on_window_covering_go_to_tilt_value);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GoToTiltValue: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/WindowCovering/Commands/GoToTiltPercentage
static void uic_mqtt_dotdot_on_by_group_window_covering_go_to_tilt_percentage(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_window_covering_go_to_tilt_percentage_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_window_covering_go_to_tilt_percentage_callback != nullptr) {

    
    uic_mqtt_dotdot_window_covering_command_go_to_tilt_percentage_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_window_covering_go_to_tilt_percentage(
          jsn,
          fields.percentage_tilt_value
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "GoToTiltPercentage");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToTiltPercentage", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToTiltPercentage", "");
        return;
      }

      uic_mqtt_dotdot_by_group_window_covering_go_to_tilt_percentage_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("PercentageTiltValue") == jsn.end()) {
        sl_log_debug(LOG_TAG, "WindowCovering::GoToTiltPercentage: Missing command-argument: PercentageTiltValue\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "WindowCovering",
        "GoToTiltPercentage",
        message,
        message_length,
        uic_mqtt_dotdot_on_window_covering_go_to_tilt_percentage);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GoToTiltPercentage: Unable to parse JSON payload.\n");
      return;
    }
  }

}

static void uic_mqtt_dotdot_on_by_group_window_covering_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_window_covering_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_window_covering_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "WindowCovering",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_window_covering_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "WindowCovering: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_window_covering_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_window_covering_state_t new_state = {};
    uic_mqtt_dotdot_window_covering_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_window_covering_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_window_covering_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_window_covering_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_window_covering_write_attributes_callback) {
    subscription_topic = topic_bygroup + "WindowCovering/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_window_covering_WriteAttributes);
  }
  if (uic_mqtt_dotdot_by_group_window_covering_up_or_open_callback) {
    subscription_topic = topic_bygroup + "WindowCovering/Commands/UpOrOpen";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_window_covering_up_or_open);
  }
  if (uic_mqtt_dotdot_by_group_window_covering_down_or_close_callback) {
    subscription_topic = topic_bygroup + "WindowCovering/Commands/DownOrClose";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_window_covering_down_or_close);
  }
  if (uic_mqtt_dotdot_by_group_window_covering_stop_callback) {
    subscription_topic = topic_bygroup + "WindowCovering/Commands/Stop";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_window_covering_stop);
  }
  if (uic_mqtt_dotdot_by_group_window_covering_go_to_lift_value_callback) {
    subscription_topic = topic_bygroup + "WindowCovering/Commands/GoToLiftValue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_window_covering_go_to_lift_value);
  }
  if (uic_mqtt_dotdot_by_group_window_covering_go_to_lift_percentage_callback) {
    subscription_topic = topic_bygroup + "WindowCovering/Commands/GoToLiftPercentage";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_window_covering_go_to_lift_percentage);
  }
  if (uic_mqtt_dotdot_by_group_window_covering_go_to_tilt_value_callback) {
    subscription_topic = topic_bygroup + "WindowCovering/Commands/GoToTiltValue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_window_covering_go_to_tilt_value);
  }
  if (uic_mqtt_dotdot_by_group_window_covering_go_to_tilt_percentage_callback) {
    subscription_topic = topic_bygroup + "WindowCovering/Commands/GoToTiltPercentage";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_window_covering_go_to_tilt_percentage);
  }

  return SL_STATUS_OK;
}




// Callback function for incoming publications on ucl/by-group/+/BarrierControl/Commands/GoToPercent
static void uic_mqtt_dotdot_on_by_group_barrier_control_go_to_percent(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_barrier_control_go_to_percent_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_barrier_control_go_to_percent_callback != nullptr) {

    
    uic_mqtt_dotdot_barrier_control_command_go_to_percent_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_barrier_control_go_to_percent(
          jsn,
          fields.percent_open
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "BarrierControl", "GoToPercent");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl", "GoToPercent", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl", "GoToPercent", "");
        return;
      }

      uic_mqtt_dotdot_by_group_barrier_control_go_to_percent_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_barrier_control_go_to_percent_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("PercentOpen") == jsn.end()) {
        sl_log_debug(LOG_TAG, "BarrierControl::GoToPercent: Missing command-argument: PercentOpen\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "BarrierControl",
        "GoToPercent",
        message,
        message_length,
        uic_mqtt_dotdot_on_barrier_control_go_to_percent);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GoToPercent: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/BarrierControl/Commands/Stop
static void uic_mqtt_dotdot_on_by_group_barrier_control_stop(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_barrier_control_stop_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_barrier_control_stop_callback != nullptr) {

    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "BarrierControl", "Stop");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl", "Stop", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl", "Stop", "");
        return;
      }

      uic_mqtt_dotdot_by_group_barrier_control_stop_callback(
        group_id
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_barrier_control_stop_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));

      group_dispatch_callback(
        group_id,
        "BarrierControl",
        "Stop",
        message,
        message_length,
        uic_mqtt_dotdot_on_barrier_control_stop);

    } catch (...) {
      sl_log_debug(LOG_TAG, "Stop: Unable to parse JSON payload.\n");
      return;
    }
  }

}

static void uic_mqtt_dotdot_on_by_group_barrier_control_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_barrier_control_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_barrier_control_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "BarrierControl",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_barrier_control_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "BarrierControl: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_barrier_control_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_barrier_control_state_t new_state = {};
    uic_mqtt_dotdot_barrier_control_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_barrier_control_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "BarrierControl", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_barrier_control_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_barrier_control_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_barrier_control_write_attributes_callback) {
    subscription_topic = topic_bygroup + "BarrierControl/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_barrier_control_WriteAttributes);
  }
  if (uic_mqtt_dotdot_by_group_barrier_control_go_to_percent_callback) {
    subscription_topic = topic_bygroup + "BarrierControl/Commands/GoToPercent";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_barrier_control_go_to_percent);
  }
  if (uic_mqtt_dotdot_by_group_barrier_control_stop_callback) {
    subscription_topic = topic_bygroup + "BarrierControl/Commands/Stop";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_barrier_control_stop);
  }

  return SL_STATUS_OK;
}




static void uic_mqtt_dotdot_on_by_group_pump_configuration_and_control_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_pump_configuration_and_control_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_pump_configuration_and_control_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "PumpConfigurationAndControl",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_pump_configuration_and_control_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "PumpConfigurationAndControl: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_pump_configuration_and_control_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_pump_configuration_and_control_state_t new_state = {};
    uic_mqtt_dotdot_pump_configuration_and_control_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_pump_configuration_and_control_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PumpConfigurationAndControl", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_pump_configuration_and_control_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_pump_configuration_and_control_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_pump_configuration_and_control_write_attributes_callback) {
    subscription_topic = topic_bygroup + "PumpConfigurationAndControl/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_pump_configuration_and_control_WriteAttributes);
  }

  return SL_STATUS_OK;
}




// Callback function for incoming publications on ucl/by-group/+/Thermostat/Commands/SetpointRaiseOrLower
static void uic_mqtt_dotdot_on_by_group_thermostat_setpoint_raise_or_lower(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_thermostat_setpoint_raise_or_lower_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_thermostat_setpoint_raise_or_lower_callback != nullptr) {

    
    uic_mqtt_dotdot_thermostat_command_setpoint_raise_or_lower_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_thermostat_setpoint_raise_or_lower(
          jsn,
          fields.mode,
              
          fields.amount
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "SetpointRaiseOrLower");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "SetpointRaiseOrLower", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "SetpointRaiseOrLower", "");
        return;
      }

      uic_mqtt_dotdot_by_group_thermostat_setpoint_raise_or_lower_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Mode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::SetpointRaiseOrLower: Missing command-argument: Mode\n");
        return;
      }
      if (jsn.find("Amount") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::SetpointRaiseOrLower: Missing command-argument: Amount\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Thermostat",
        "SetpointRaiseOrLower",
        message,
        message_length,
        uic_mqtt_dotdot_on_thermostat_setpoint_raise_or_lower);

    } catch (...) {
      sl_log_debug(LOG_TAG, "SetpointRaiseOrLower: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Thermostat/Commands/GetWeeklyScheduleResponse
static void uic_mqtt_dotdot_on_by_group_thermostat_get_weekly_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_thermostat_get_weekly_schedule_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_thermostat_get_weekly_schedule_response_callback != nullptr) {

    
    uic_mqtt_dotdot_thermostat_command_get_weekly_schedule_response_fields_t fields;
      std::vector<TransitionType> transitions;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_thermostat_get_weekly_schedule_response(
          jsn,
          fields.number_of_transitions,
              
          fields.day_of_week,
              
          fields.mode,
              
          transitions
      );

      // Populate list fields from vector or string types
      
        fields.transitions_count = transitions.size();
        fields.transitions = transitions.data();


      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "GetWeeklyScheduleResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetWeeklyScheduleResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetWeeklyScheduleResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_thermostat_get_weekly_schedule_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("NumberOfTransitions") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::GetWeeklyScheduleResponse: Missing command-argument: NumberOfTransitions\n");
        return;
      }
      if (jsn.find("DayOfWeek") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::GetWeeklyScheduleResponse: Missing command-argument: DayOfWeek\n");
        return;
      }
      if (jsn.find("Mode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::GetWeeklyScheduleResponse: Missing command-argument: Mode\n");
        return;
      }
      if (jsn.find("Transitions") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::GetWeeklyScheduleResponse: Missing command-argument: Transitions\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Thermostat",
        "GetWeeklyScheduleResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_thermostat_get_weekly_schedule_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GetWeeklyScheduleResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Thermostat/Commands/SetWeeklySchedule
static void uic_mqtt_dotdot_on_by_group_thermostat_set_weekly_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_thermostat_set_weekly_schedule_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_thermostat_set_weekly_schedule_callback != nullptr) {

    
    uic_mqtt_dotdot_thermostat_command_set_weekly_schedule_fields_t fields;
      std::vector<TransitionType> transitions;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_thermostat_set_weekly_schedule(
          jsn,
          fields.number_of_transitions,
              
          fields.day_of_week,
              
          fields.mode,
              
          transitions
      );

      // Populate list fields from vector or string types
      
        fields.transitions_count = transitions.size();
        fields.transitions = transitions.data();


      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "SetWeeklySchedule");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "SetWeeklySchedule", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "SetWeeklySchedule", "");
        return;
      }

      uic_mqtt_dotdot_by_group_thermostat_set_weekly_schedule_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("NumberOfTransitions") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::SetWeeklySchedule: Missing command-argument: NumberOfTransitions\n");
        return;
      }
      if (jsn.find("DayOfWeek") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::SetWeeklySchedule: Missing command-argument: DayOfWeek\n");
        return;
      }
      if (jsn.find("Mode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::SetWeeklySchedule: Missing command-argument: Mode\n");
        return;
      }
      if (jsn.find("Transitions") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::SetWeeklySchedule: Missing command-argument: Transitions\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Thermostat",
        "SetWeeklySchedule",
        message,
        message_length,
        uic_mqtt_dotdot_on_thermostat_set_weekly_schedule);

    } catch (...) {
      sl_log_debug(LOG_TAG, "SetWeeklySchedule: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Thermostat/Commands/GetRelayStatusLogResponse
static void uic_mqtt_dotdot_on_by_group_thermostat_get_relay_status_log_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_thermostat_get_relay_status_log_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_thermostat_get_relay_status_log_response_callback != nullptr) {

    
    uic_mqtt_dotdot_thermostat_command_get_relay_status_log_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_thermostat_get_relay_status_log_response(
          jsn,
          fields.time_of_day,
              
          fields.relay_status,
              
          fields.local_temperature,
              
          fields.humidity_percentage,
              
          fields.set_point,
              
          fields.unread_entries
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "GetRelayStatusLogResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetRelayStatusLogResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetRelayStatusLogResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_thermostat_get_relay_status_log_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("TimeOfDay") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::GetRelayStatusLogResponse: Missing command-argument: TimeOfDay\n");
        return;
      }
      if (jsn.find("RelayStatus") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::GetRelayStatusLogResponse: Missing command-argument: RelayStatus\n");
        return;
      }
      if (jsn.find("LocalTemperature") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::GetRelayStatusLogResponse: Missing command-argument: LocalTemperature\n");
        return;
      }
      if (jsn.find("HumidityPercentage") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::GetRelayStatusLogResponse: Missing command-argument: HumidityPercentage\n");
        return;
      }
      if (jsn.find("SetPoint") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::GetRelayStatusLogResponse: Missing command-argument: SetPoint\n");
        return;
      }
      if (jsn.find("UnreadEntries") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::GetRelayStatusLogResponse: Missing command-argument: UnreadEntries\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Thermostat",
        "GetRelayStatusLogResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_thermostat_get_relay_status_log_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GetRelayStatusLogResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Thermostat/Commands/GetWeeklySchedule
static void uic_mqtt_dotdot_on_by_group_thermostat_get_weekly_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_thermostat_get_weekly_schedule_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_thermostat_get_weekly_schedule_callback != nullptr) {

    
    uic_mqtt_dotdot_thermostat_command_get_weekly_schedule_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_thermostat_get_weekly_schedule(
          jsn,
          fields.days_to_return,
              
          fields.mode_to_return
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "GetWeeklySchedule");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetWeeklySchedule", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetWeeklySchedule", "");
        return;
      }

      uic_mqtt_dotdot_by_group_thermostat_get_weekly_schedule_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("DaysToReturn") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::GetWeeklySchedule: Missing command-argument: DaysToReturn\n");
        return;
      }
      if (jsn.find("ModeToReturn") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::GetWeeklySchedule: Missing command-argument: ModeToReturn\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Thermostat",
        "GetWeeklySchedule",
        message,
        message_length,
        uic_mqtt_dotdot_on_thermostat_get_weekly_schedule);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GetWeeklySchedule: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Thermostat/Commands/ClearWeeklySchedule
static void uic_mqtt_dotdot_on_by_group_thermostat_clear_weekly_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_thermostat_clear_weekly_schedule_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_thermostat_clear_weekly_schedule_callback != nullptr) {

    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "ClearWeeklySchedule");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "ClearWeeklySchedule", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "ClearWeeklySchedule", "");
        return;
      }

      uic_mqtt_dotdot_by_group_thermostat_clear_weekly_schedule_callback(
        group_id
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));

      group_dispatch_callback(
        group_id,
        "Thermostat",
        "ClearWeeklySchedule",
        message,
        message_length,
        uic_mqtt_dotdot_on_thermostat_clear_weekly_schedule);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ClearWeeklySchedule: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Thermostat/Commands/GetRelayStatusLog
static void uic_mqtt_dotdot_on_by_group_thermostat_get_relay_status_log(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_thermostat_get_relay_status_log_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_thermostat_get_relay_status_log_callback != nullptr) {

    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "GetRelayStatusLog");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetRelayStatusLog", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetRelayStatusLog", "");
        return;
      }

      uic_mqtt_dotdot_by_group_thermostat_get_relay_status_log_callback(
        group_id
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_thermostat_get_relay_status_log_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));

      group_dispatch_callback(
        group_id,
        "Thermostat",
        "GetRelayStatusLog",
        message,
        message_length,
        uic_mqtt_dotdot_on_thermostat_get_relay_status_log);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GetRelayStatusLog: Unable to parse JSON payload.\n");
      return;
    }
  }

}

static void uic_mqtt_dotdot_on_by_group_thermostat_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_thermostat_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_thermostat_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "Thermostat",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_thermostat_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "Thermostat: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_thermostat_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_thermostat_state_t new_state = {};
    uic_mqtt_dotdot_thermostat_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_thermostat_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_thermostat_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_thermostat_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_thermostat_write_attributes_callback) {
    subscription_topic = topic_bygroup + "Thermostat/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_thermostat_WriteAttributes);
  }
  if (uic_mqtt_dotdot_by_group_thermostat_setpoint_raise_or_lower_callback) {
    subscription_topic = topic_bygroup + "Thermostat/Commands/SetpointRaiseOrLower";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_thermostat_setpoint_raise_or_lower);
  }
  if (uic_mqtt_dotdot_by_group_thermostat_get_weekly_schedule_response_callback) {
    subscription_topic = topic_bygroup + "Thermostat/Commands/GetWeeklyScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_thermostat_get_weekly_schedule_response);
  }
  if (uic_mqtt_dotdot_by_group_thermostat_set_weekly_schedule_callback) {
    subscription_topic = topic_bygroup + "Thermostat/Commands/SetWeeklySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_thermostat_set_weekly_schedule);
  }
  if (uic_mqtt_dotdot_by_group_thermostat_get_relay_status_log_response_callback) {
    subscription_topic = topic_bygroup + "Thermostat/Commands/GetRelayStatusLogResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_thermostat_get_relay_status_log_response);
  }
  if (uic_mqtt_dotdot_by_group_thermostat_get_weekly_schedule_callback) {
    subscription_topic = topic_bygroup + "Thermostat/Commands/GetWeeklySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_thermostat_get_weekly_schedule);
  }
  if (uic_mqtt_dotdot_by_group_thermostat_clear_weekly_schedule_callback) {
    subscription_topic = topic_bygroup + "Thermostat/Commands/ClearWeeklySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_thermostat_clear_weekly_schedule);
  }
  if (uic_mqtt_dotdot_by_group_thermostat_get_relay_status_log_callback) {
    subscription_topic = topic_bygroup + "Thermostat/Commands/GetRelayStatusLog";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_thermostat_get_relay_status_log);
  }

  return SL_STATUS_OK;
}




static void uic_mqtt_dotdot_on_by_group_fan_control_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_fan_control_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_fan_control_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "FanControl",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_fan_control_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "FanControl: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_fan_control_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_fan_control_state_t new_state = {};
    uic_mqtt_dotdot_fan_control_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_fan_control_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "FanControl", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "FanControl", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "FanControl", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_fan_control_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_fan_control_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_fan_control_write_attributes_callback) {
    subscription_topic = topic_bygroup + "FanControl/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_fan_control_WriteAttributes);
  }

  return SL_STATUS_OK;
}




static void uic_mqtt_dotdot_on_by_group_dehumidification_control_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_dehumidification_control_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_dehumidification_control_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "DehumidificationControl",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_dehumidification_control_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "DehumidificationControl: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_dehumidification_control_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_dehumidification_control_state_t new_state = {};
    uic_mqtt_dotdot_dehumidification_control_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_dehumidification_control_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DehumidificationControl", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DehumidificationControl", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DehumidificationControl", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_dehumidification_control_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_dehumidification_control_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_dehumidification_control_write_attributes_callback) {
    subscription_topic = topic_bygroup + "DehumidificationControl/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_dehumidification_control_WriteAttributes);
  }

  return SL_STATUS_OK;
}




static void uic_mqtt_dotdot_on_by_group_thermostat_user_interface_configuration_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_thermostat_user_interface_configuration_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_thermostat_user_interface_configuration_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "ThermostatUserInterfaceConfiguration",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_thermostat_user_interface_configuration_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ThermostatUserInterfaceConfiguration: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_thermostat_user_interface_configuration_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_thermostat_user_interface_configuration_state_t new_state = {};
    uic_mqtt_dotdot_thermostat_user_interface_configuration_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_thermostat_user_interface_configuration_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ThermostatUserInterfaceConfiguration", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ThermostatUserInterfaceConfiguration", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ThermostatUserInterfaceConfiguration", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_thermostat_user_interface_configuration_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_thermostat_user_interface_configuration_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_thermostat_user_interface_configuration_write_attributes_callback) {
    subscription_topic = topic_bygroup + "ThermostatUserInterfaceConfiguration/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_thermostat_user_interface_configuration_WriteAttributes);
  }

  return SL_STATUS_OK;
}




// Callback function for incoming publications on ucl/by-group/+/ColorControl/Commands/MoveToHue
static void uic_mqtt_dotdot_on_by_group_color_control_move_to_hue(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_color_control_move_to_hue_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_color_control_move_to_hue_callback != nullptr) {

    
    uic_mqtt_dotdot_color_control_command_move_to_hue_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_color_control_move_to_hue(
          jsn,
          fields.hue,
              
          fields.direction,
              
          fields.transition_time,
              
          fields.options_mask,
              
          fields.options_override
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveToHue");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToHue", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToHue", "");
        return;
      }

      uic_mqtt_dotdot_by_group_color_control_move_to_hue_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_color_control_move_to_hue_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Hue") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveToHue: Missing command-argument: Hue\n");
        return;
      }
      if (jsn.find("Direction") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveToHue: Missing command-argument: Direction\n");
        return;
      }
      if (jsn.find("TransitionTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveToHue: Missing command-argument: TransitionTime\n");
        return;
      }
      if (jsn.find("OptionsMask") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveToHue: Missing command-argument: OptionsMask\n");
        return;
      }
      if (jsn.find("OptionsOverride") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveToHue: Missing command-argument: OptionsOverride\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "ColorControl",
        "MoveToHue",
        message,
        message_length,
        uic_mqtt_dotdot_on_color_control_move_to_hue);

    } catch (...) {
      sl_log_debug(LOG_TAG, "MoveToHue: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/ColorControl/Commands/MoveHue
static void uic_mqtt_dotdot_on_by_group_color_control_move_hue(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_color_control_move_hue_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_color_control_move_hue_callback != nullptr) {

    
    uic_mqtt_dotdot_color_control_command_move_hue_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_color_control_move_hue(
          jsn,
          fields.move_mode,
              
          fields.rate,
              
          fields.options_mask,
              
          fields.options_override
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveHue");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveHue", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveHue", "");
        return;
      }

      uic_mqtt_dotdot_by_group_color_control_move_hue_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_color_control_move_hue_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("MoveMode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveHue: Missing command-argument: MoveMode\n");
        return;
      }
      if (jsn.find("Rate") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveHue: Missing command-argument: Rate\n");
        return;
      }
      if (jsn.find("OptionsMask") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveHue: Missing command-argument: OptionsMask\n");
        return;
      }
      if (jsn.find("OptionsOverride") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveHue: Missing command-argument: OptionsOverride\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "ColorControl",
        "MoveHue",
        message,
        message_length,
        uic_mqtt_dotdot_on_color_control_move_hue);

    } catch (...) {
      sl_log_debug(LOG_TAG, "MoveHue: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/ColorControl/Commands/StepHue
static void uic_mqtt_dotdot_on_by_group_color_control_step_hue(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_color_control_step_hue_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_color_control_step_hue_callback != nullptr) {

    
    uic_mqtt_dotdot_color_control_command_step_hue_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_color_control_step_hue(
          jsn,
          fields.step_mode,
              
          fields.step_size,
              
          fields.transition_time,
              
          fields.options_mask,
              
          fields.options_override
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "StepHue");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepHue", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepHue", "");
        return;
      }

      uic_mqtt_dotdot_by_group_color_control_step_hue_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_color_control_step_hue_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("StepMode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::StepHue: Missing command-argument: StepMode\n");
        return;
      }
      if (jsn.find("StepSize") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::StepHue: Missing command-argument: StepSize\n");
        return;
      }
      if (jsn.find("TransitionTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::StepHue: Missing command-argument: TransitionTime\n");
        return;
      }
      if (jsn.find("OptionsMask") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::StepHue: Missing command-argument: OptionsMask\n");
        return;
      }
      if (jsn.find("OptionsOverride") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::StepHue: Missing command-argument: OptionsOverride\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "ColorControl",
        "StepHue",
        message,
        message_length,
        uic_mqtt_dotdot_on_color_control_step_hue);

    } catch (...) {
      sl_log_debug(LOG_TAG, "StepHue: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/ColorControl/Commands/MoveToSaturation
static void uic_mqtt_dotdot_on_by_group_color_control_move_to_saturation(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_color_control_move_to_saturation_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_color_control_move_to_saturation_callback != nullptr) {

    
    uic_mqtt_dotdot_color_control_command_move_to_saturation_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_color_control_move_to_saturation(
          jsn,
          fields.saturation,
              
          fields.transition_time,
              
          fields.options_mask,
              
          fields.options_override
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveToSaturation");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToSaturation", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToSaturation", "");
        return;
      }

      uic_mqtt_dotdot_by_group_color_control_move_to_saturation_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_color_control_move_to_saturation_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Saturation") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveToSaturation: Missing command-argument: Saturation\n");
        return;
      }
      if (jsn.find("TransitionTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveToSaturation: Missing command-argument: TransitionTime\n");
        return;
      }
      if (jsn.find("OptionsMask") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveToSaturation: Missing command-argument: OptionsMask\n");
        return;
      }
      if (jsn.find("OptionsOverride") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveToSaturation: Missing command-argument: OptionsOverride\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "ColorControl",
        "MoveToSaturation",
        message,
        message_length,
        uic_mqtt_dotdot_on_color_control_move_to_saturation);

    } catch (...) {
      sl_log_debug(LOG_TAG, "MoveToSaturation: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/ColorControl/Commands/MoveSaturation
static void uic_mqtt_dotdot_on_by_group_color_control_move_saturation(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_color_control_move_saturation_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_color_control_move_saturation_callback != nullptr) {

    
    uic_mqtt_dotdot_color_control_command_move_saturation_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_color_control_move_saturation(
          jsn,
          fields.move_mode,
              
          fields.rate,
              
          fields.options_mask,
              
          fields.options_override
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveSaturation");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveSaturation", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveSaturation", "");
        return;
      }

      uic_mqtt_dotdot_by_group_color_control_move_saturation_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_color_control_move_saturation_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("MoveMode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveSaturation: Missing command-argument: MoveMode\n");
        return;
      }
      if (jsn.find("Rate") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveSaturation: Missing command-argument: Rate\n");
        return;
      }
      if (jsn.find("OptionsMask") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveSaturation: Missing command-argument: OptionsMask\n");
        return;
      }
      if (jsn.find("OptionsOverride") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveSaturation: Missing command-argument: OptionsOverride\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "ColorControl",
        "MoveSaturation",
        message,
        message_length,
        uic_mqtt_dotdot_on_color_control_move_saturation);

    } catch (...) {
      sl_log_debug(LOG_TAG, "MoveSaturation: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/ColorControl/Commands/StepSaturation
static void uic_mqtt_dotdot_on_by_group_color_control_step_saturation(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_color_control_step_saturation_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_color_control_step_saturation_callback != nullptr) {

    
    uic_mqtt_dotdot_color_control_command_step_saturation_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_color_control_step_saturation(
          jsn,
          fields.step_mode,
              
          fields.step_size,
              
          fields.transition_time,
              
          fields.options_mask,
              
          fields.options_override
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "StepSaturation");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepSaturation", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepSaturation", "");
        return;
      }

      uic_mqtt_dotdot_by_group_color_control_step_saturation_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_color_control_step_saturation_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("StepMode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::StepSaturation: Missing command-argument: StepMode\n");
        return;
      }
      if (jsn.find("StepSize") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::StepSaturation: Missing command-argument: StepSize\n");
        return;
      }
      if (jsn.find("TransitionTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::StepSaturation: Missing command-argument: TransitionTime\n");
        return;
      }
      if (jsn.find("OptionsMask") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::StepSaturation: Missing command-argument: OptionsMask\n");
        return;
      }
      if (jsn.find("OptionsOverride") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::StepSaturation: Missing command-argument: OptionsOverride\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "ColorControl",
        "StepSaturation",
        message,
        message_length,
        uic_mqtt_dotdot_on_color_control_step_saturation);

    } catch (...) {
      sl_log_debug(LOG_TAG, "StepSaturation: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/ColorControl/Commands/MoveToHueAndSaturation
static void uic_mqtt_dotdot_on_by_group_color_control_move_to_hue_and_saturation(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_color_control_move_to_hue_and_saturation_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_color_control_move_to_hue_and_saturation_callback != nullptr) {

    
    uic_mqtt_dotdot_color_control_command_move_to_hue_and_saturation_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_color_control_move_to_hue_and_saturation(
          jsn,
          fields.hue,
              
          fields.saturation,
              
          fields.transition_time,
              
          fields.options_mask,
              
          fields.options_override
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveToHueAndSaturation");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToHueAndSaturation", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToHueAndSaturation", "");
        return;
      }

      uic_mqtt_dotdot_by_group_color_control_move_to_hue_and_saturation_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("Hue") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveToHueAndSaturation: Missing command-argument: Hue\n");
        return;
      }
      if (jsn.find("Saturation") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveToHueAndSaturation: Missing command-argument: Saturation\n");
        return;
      }
      if (jsn.find("TransitionTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveToHueAndSaturation: Missing command-argument: TransitionTime\n");
        return;
      }
      if (jsn.find("OptionsMask") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveToHueAndSaturation: Missing command-argument: OptionsMask\n");
        return;
      }
      if (jsn.find("OptionsOverride") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveToHueAndSaturation: Missing command-argument: OptionsOverride\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "ColorControl",
        "MoveToHueAndSaturation",
        message,
        message_length,
        uic_mqtt_dotdot_on_color_control_move_to_hue_and_saturation);

    } catch (...) {
      sl_log_debug(LOG_TAG, "MoveToHueAndSaturation: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/ColorControl/Commands/MoveToColor
static void uic_mqtt_dotdot_on_by_group_color_control_move_to_color(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_color_control_move_to_color_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_color_control_move_to_color_callback != nullptr) {

    
    uic_mqtt_dotdot_color_control_command_move_to_color_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_color_control_move_to_color(
          jsn,
          fields.colorx,
              
          fields.colory,
              
          fields.transition_time,
              
          fields.options_mask,
              
          fields.options_override
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveToColor");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToColor", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToColor", "");
        return;
      }

      uic_mqtt_dotdot_by_group_color_control_move_to_color_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_color_control_move_to_color_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("ColorX") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveToColor: Missing command-argument: ColorX\n");
        return;
      }
      if (jsn.find("ColorY") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveToColor: Missing command-argument: ColorY\n");
        return;
      }
      if (jsn.find("TransitionTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveToColor: Missing command-argument: TransitionTime\n");
        return;
      }
      if (jsn.find("OptionsMask") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveToColor: Missing command-argument: OptionsMask\n");
        return;
      }
      if (jsn.find("OptionsOverride") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveToColor: Missing command-argument: OptionsOverride\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "ColorControl",
        "MoveToColor",
        message,
        message_length,
        uic_mqtt_dotdot_on_color_control_move_to_color);

    } catch (...) {
      sl_log_debug(LOG_TAG, "MoveToColor: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/ColorControl/Commands/MoveColor
static void uic_mqtt_dotdot_on_by_group_color_control_move_color(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_color_control_move_color_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_color_control_move_color_callback != nullptr) {

    
    uic_mqtt_dotdot_color_control_command_move_color_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_color_control_move_color(
          jsn,
          fields.ratex,
              
          fields.ratey,
              
          fields.options_mask,
              
          fields.options_override
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveColor");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveColor", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveColor", "");
        return;
      }

      uic_mqtt_dotdot_by_group_color_control_move_color_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_color_control_move_color_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("RateX") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveColor: Missing command-argument: RateX\n");
        return;
      }
      if (jsn.find("RateY") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveColor: Missing command-argument: RateY\n");
        return;
      }
      if (jsn.find("OptionsMask") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveColor: Missing command-argument: OptionsMask\n");
        return;
      }
      if (jsn.find("OptionsOverride") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveColor: Missing command-argument: OptionsOverride\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "ColorControl",
        "MoveColor",
        message,
        message_length,
        uic_mqtt_dotdot_on_color_control_move_color);

    } catch (...) {
      sl_log_debug(LOG_TAG, "MoveColor: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/ColorControl/Commands/StepColor
static void uic_mqtt_dotdot_on_by_group_color_control_step_color(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_color_control_step_color_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_color_control_step_color_callback != nullptr) {

    
    uic_mqtt_dotdot_color_control_command_step_color_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_color_control_step_color(
          jsn,
          fields.stepx,
              
          fields.stepy,
              
          fields.transition_time,
              
          fields.options_mask,
              
          fields.options_override
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "StepColor");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepColor", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepColor", "");
        return;
      }

      uic_mqtt_dotdot_by_group_color_control_step_color_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_color_control_step_color_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("StepX") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::StepColor: Missing command-argument: StepX\n");
        return;
      }
      if (jsn.find("StepY") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::StepColor: Missing command-argument: StepY\n");
        return;
      }
      if (jsn.find("TransitionTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::StepColor: Missing command-argument: TransitionTime\n");
        return;
      }
      if (jsn.find("OptionsMask") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::StepColor: Missing command-argument: OptionsMask\n");
        return;
      }
      if (jsn.find("OptionsOverride") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::StepColor: Missing command-argument: OptionsOverride\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "ColorControl",
        "StepColor",
        message,
        message_length,
        uic_mqtt_dotdot_on_color_control_step_color);

    } catch (...) {
      sl_log_debug(LOG_TAG, "StepColor: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/ColorControl/Commands/MoveToColorTemperature
static void uic_mqtt_dotdot_on_by_group_color_control_move_to_color_temperature(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_color_control_move_to_color_temperature_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_color_control_move_to_color_temperature_callback != nullptr) {

    
    uic_mqtt_dotdot_color_control_command_move_to_color_temperature_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_color_control_move_to_color_temperature(
          jsn,
          fields.color_temperature_mireds,
              
          fields.transition_time,
              
          fields.options_mask,
              
          fields.options_override
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveToColorTemperature");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToColorTemperature", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToColorTemperature", "");
        return;
      }

      uic_mqtt_dotdot_by_group_color_control_move_to_color_temperature_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_color_control_move_to_color_temperature_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("ColorTemperatureMireds") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveToColorTemperature: Missing command-argument: ColorTemperatureMireds\n");
        return;
      }
      if (jsn.find("TransitionTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveToColorTemperature: Missing command-argument: TransitionTime\n");
        return;
      }
      if (jsn.find("OptionsMask") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveToColorTemperature: Missing command-argument: OptionsMask\n");
        return;
      }
      if (jsn.find("OptionsOverride") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveToColorTemperature: Missing command-argument: OptionsOverride\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "ColorControl",
        "MoveToColorTemperature",
        message,
        message_length,
        uic_mqtt_dotdot_on_color_control_move_to_color_temperature);

    } catch (...) {
      sl_log_debug(LOG_TAG, "MoveToColorTemperature: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/ColorControl/Commands/EnhancedMoveToHue
static void uic_mqtt_dotdot_on_by_group_color_control_enhanced_move_to_hue(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_color_control_enhanced_move_to_hue_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_color_control_enhanced_move_to_hue_callback != nullptr) {

    
    uic_mqtt_dotdot_color_control_command_enhanced_move_to_hue_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_color_control_enhanced_move_to_hue(
          jsn,
          fields.enhanced_hue,
              
          fields.direction,
              
          fields.transition_time,
              
          fields.options_mask,
              
          fields.options_override
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "EnhancedMoveToHue");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedMoveToHue", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedMoveToHue", "");
        return;
      }

      uic_mqtt_dotdot_by_group_color_control_enhanced_move_to_hue_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("EnhancedHue") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::EnhancedMoveToHue: Missing command-argument: EnhancedHue\n");
        return;
      }
      if (jsn.find("Direction") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::EnhancedMoveToHue: Missing command-argument: Direction\n");
        return;
      }
      if (jsn.find("TransitionTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::EnhancedMoveToHue: Missing command-argument: TransitionTime\n");
        return;
      }
      if (jsn.find("OptionsMask") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::EnhancedMoveToHue: Missing command-argument: OptionsMask\n");
        return;
      }
      if (jsn.find("OptionsOverride") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::EnhancedMoveToHue: Missing command-argument: OptionsOverride\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "ColorControl",
        "EnhancedMoveToHue",
        message,
        message_length,
        uic_mqtt_dotdot_on_color_control_enhanced_move_to_hue);

    } catch (...) {
      sl_log_debug(LOG_TAG, "EnhancedMoveToHue: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/ColorControl/Commands/EnhancedMoveHue
static void uic_mqtt_dotdot_on_by_group_color_control_enhanced_move_hue(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_color_control_enhanced_move_hue_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_color_control_enhanced_move_hue_callback != nullptr) {

    
    uic_mqtt_dotdot_color_control_command_enhanced_move_hue_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_color_control_enhanced_move_hue(
          jsn,
          fields.move_mode,
              
          fields.rate,
              
          fields.options_mask,
              
          fields.options_override
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "EnhancedMoveHue");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedMoveHue", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedMoveHue", "");
        return;
      }

      uic_mqtt_dotdot_by_group_color_control_enhanced_move_hue_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_color_control_enhanced_move_hue_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("MoveMode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::EnhancedMoveHue: Missing command-argument: MoveMode\n");
        return;
      }
      if (jsn.find("Rate") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::EnhancedMoveHue: Missing command-argument: Rate\n");
        return;
      }
      if (jsn.find("OptionsMask") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::EnhancedMoveHue: Missing command-argument: OptionsMask\n");
        return;
      }
      if (jsn.find("OptionsOverride") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::EnhancedMoveHue: Missing command-argument: OptionsOverride\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "ColorControl",
        "EnhancedMoveHue",
        message,
        message_length,
        uic_mqtt_dotdot_on_color_control_enhanced_move_hue);

    } catch (...) {
      sl_log_debug(LOG_TAG, "EnhancedMoveHue: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/ColorControl/Commands/EnhancedStepHue
static void uic_mqtt_dotdot_on_by_group_color_control_enhanced_step_hue(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_color_control_enhanced_step_hue_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_color_control_enhanced_step_hue_callback != nullptr) {

    
    uic_mqtt_dotdot_color_control_command_enhanced_step_hue_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_color_control_enhanced_step_hue(
          jsn,
          fields.step_mode,
              
          fields.step_size,
              
          fields.transition_time,
              
          fields.options_mask,
              
          fields.options_override
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "EnhancedStepHue");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedStepHue", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedStepHue", "");
        return;
      }

      uic_mqtt_dotdot_by_group_color_control_enhanced_step_hue_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_color_control_enhanced_step_hue_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("StepMode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::EnhancedStepHue: Missing command-argument: StepMode\n");
        return;
      }
      if (jsn.find("StepSize") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::EnhancedStepHue: Missing command-argument: StepSize\n");
        return;
      }
      if (jsn.find("TransitionTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::EnhancedStepHue: Missing command-argument: TransitionTime\n");
        return;
      }
      if (jsn.find("OptionsMask") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::EnhancedStepHue: Missing command-argument: OptionsMask\n");
        return;
      }
      if (jsn.find("OptionsOverride") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::EnhancedStepHue: Missing command-argument: OptionsOverride\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "ColorControl",
        "EnhancedStepHue",
        message,
        message_length,
        uic_mqtt_dotdot_on_color_control_enhanced_step_hue);

    } catch (...) {
      sl_log_debug(LOG_TAG, "EnhancedStepHue: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/ColorControl/Commands/EnhancedMoveToHueAndSaturation
static void uic_mqtt_dotdot_on_by_group_color_control_enhanced_move_to_hue_and_saturation(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_color_control_enhanced_move_to_hue_and_saturation_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_color_control_enhanced_move_to_hue_and_saturation_callback != nullptr) {

    
    uic_mqtt_dotdot_color_control_command_enhanced_move_to_hue_and_saturation_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_color_control_enhanced_move_to_hue_and_saturation(
          jsn,
          fields.enhanced_hue,
              
          fields.saturation,
              
          fields.transition_time,
              
          fields.options_mask,
              
          fields.options_override
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "EnhancedMoveToHueAndSaturation");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedMoveToHueAndSaturation", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedMoveToHueAndSaturation", "");
        return;
      }

      uic_mqtt_dotdot_by_group_color_control_enhanced_move_to_hue_and_saturation_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("EnhancedHue") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::EnhancedMoveToHueAndSaturation: Missing command-argument: EnhancedHue\n");
        return;
      }
      if (jsn.find("Saturation") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::EnhancedMoveToHueAndSaturation: Missing command-argument: Saturation\n");
        return;
      }
      if (jsn.find("TransitionTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::EnhancedMoveToHueAndSaturation: Missing command-argument: TransitionTime\n");
        return;
      }
      if (jsn.find("OptionsMask") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::EnhancedMoveToHueAndSaturation: Missing command-argument: OptionsMask\n");
        return;
      }
      if (jsn.find("OptionsOverride") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::EnhancedMoveToHueAndSaturation: Missing command-argument: OptionsOverride\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "ColorControl",
        "EnhancedMoveToHueAndSaturation",
        message,
        message_length,
        uic_mqtt_dotdot_on_color_control_enhanced_move_to_hue_and_saturation);

    } catch (...) {
      sl_log_debug(LOG_TAG, "EnhancedMoveToHueAndSaturation: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/ColorControl/Commands/ColorLoopSet
static void uic_mqtt_dotdot_on_by_group_color_control_color_loop_set(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_color_control_color_loop_set_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_color_control_color_loop_set_callback != nullptr) {

    
    uic_mqtt_dotdot_color_control_command_color_loop_set_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_color_control_color_loop_set(
          jsn,
          fields.update_flags,
              
          fields.action,
              
          fields.direction,
              
          fields.time,
              
          fields.start_hue,
              
          fields.options_mask,
              
          fields.options_override
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "ColorLoopSet");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "ColorLoopSet", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "ColorLoopSet", "");
        return;
      }

      uic_mqtt_dotdot_by_group_color_control_color_loop_set_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_color_control_color_loop_set_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("UpdateFlags") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::ColorLoopSet: Missing command-argument: UpdateFlags\n");
        return;
      }
      if (jsn.find("Action") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::ColorLoopSet: Missing command-argument: Action\n");
        return;
      }
      if (jsn.find("Direction") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::ColorLoopSet: Missing command-argument: Direction\n");
        return;
      }
      if (jsn.find("Time") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::ColorLoopSet: Missing command-argument: Time\n");
        return;
      }
      if (jsn.find("StartHue") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::ColorLoopSet: Missing command-argument: StartHue\n");
        return;
      }
      if (jsn.find("OptionsMask") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::ColorLoopSet: Missing command-argument: OptionsMask\n");
        return;
      }
      if (jsn.find("OptionsOverride") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::ColorLoopSet: Missing command-argument: OptionsOverride\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "ColorControl",
        "ColorLoopSet",
        message,
        message_length,
        uic_mqtt_dotdot_on_color_control_color_loop_set);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ColorLoopSet: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/ColorControl/Commands/StopMoveStep
static void uic_mqtt_dotdot_on_by_group_color_control_stop_move_step(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_color_control_stop_move_step_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_color_control_stop_move_step_callback != nullptr) {

    
    uic_mqtt_dotdot_color_control_command_stop_move_step_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_color_control_stop_move_step(
          jsn,
          fields.options_mask,
              
          fields.options_override
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "StopMoveStep");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StopMoveStep", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StopMoveStep", "");
        return;
      }

      uic_mqtt_dotdot_by_group_color_control_stop_move_step_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_color_control_stop_move_step_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("OptionsMask") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::StopMoveStep: Missing command-argument: OptionsMask\n");
        return;
      }
      if (jsn.find("OptionsOverride") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::StopMoveStep: Missing command-argument: OptionsOverride\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "ColorControl",
        "StopMoveStep",
        message,
        message_length,
        uic_mqtt_dotdot_on_color_control_stop_move_step);

    } catch (...) {
      sl_log_debug(LOG_TAG, "StopMoveStep: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/ColorControl/Commands/MoveColorTemperature
static void uic_mqtt_dotdot_on_by_group_color_control_move_color_temperature(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_color_control_move_color_temperature_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_color_control_move_color_temperature_callback != nullptr) {

    
    uic_mqtt_dotdot_color_control_command_move_color_temperature_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_color_control_move_color_temperature(
          jsn,
          fields.move_mode,
              
          fields.rate,
              
          fields.color_temperature_minimum_mireds,
              
          fields.color_temperature_maximum_mireds,
              
          fields.options_mask,
              
          fields.options_override
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveColorTemperature");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveColorTemperature", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveColorTemperature", "");
        return;
      }

      uic_mqtt_dotdot_by_group_color_control_move_color_temperature_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_color_control_move_color_temperature_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("MoveMode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveColorTemperature: Missing command-argument: MoveMode\n");
        return;
      }
      if (jsn.find("Rate") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveColorTemperature: Missing command-argument: Rate\n");
        return;
      }
      if (jsn.find("ColorTemperatureMinimumMireds") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveColorTemperature: Missing command-argument: ColorTemperatureMinimumMireds\n");
        return;
      }
      if (jsn.find("ColorTemperatureMaximumMireds") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveColorTemperature: Missing command-argument: ColorTemperatureMaximumMireds\n");
        return;
      }
      if (jsn.find("OptionsMask") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveColorTemperature: Missing command-argument: OptionsMask\n");
        return;
      }
      if (jsn.find("OptionsOverride") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::MoveColorTemperature: Missing command-argument: OptionsOverride\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "ColorControl",
        "MoveColorTemperature",
        message,
        message_length,
        uic_mqtt_dotdot_on_color_control_move_color_temperature);

    } catch (...) {
      sl_log_debug(LOG_TAG, "MoveColorTemperature: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/ColorControl/Commands/StepColorTemperature
static void uic_mqtt_dotdot_on_by_group_color_control_step_color_temperature(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_color_control_step_color_temperature_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_color_control_step_color_temperature_callback != nullptr) {

    
    uic_mqtt_dotdot_color_control_command_step_color_temperature_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_color_control_step_color_temperature(
          jsn,
          fields.step_mode,
              
          fields.step_size,
              
          fields.transition_time,
              
          fields.color_temperature_minimum_mireds,
              
          fields.color_temperature_maximum_mireds,
              
          fields.options_mask,
              
          fields.options_override
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "StepColorTemperature");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepColorTemperature", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepColorTemperature", "");
        return;
      }

      uic_mqtt_dotdot_by_group_color_control_step_color_temperature_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_color_control_step_color_temperature_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("StepMode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::StepColorTemperature: Missing command-argument: StepMode\n");
        return;
      }
      if (jsn.find("StepSize") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::StepColorTemperature: Missing command-argument: StepSize\n");
        return;
      }
      if (jsn.find("TransitionTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::StepColorTemperature: Missing command-argument: TransitionTime\n");
        return;
      }
      if (jsn.find("ColorTemperatureMinimumMireds") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::StepColorTemperature: Missing command-argument: ColorTemperatureMinimumMireds\n");
        return;
      }
      if (jsn.find("ColorTemperatureMaximumMireds") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::StepColorTemperature: Missing command-argument: ColorTemperatureMaximumMireds\n");
        return;
      }
      if (jsn.find("OptionsMask") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::StepColorTemperature: Missing command-argument: OptionsMask\n");
        return;
      }
      if (jsn.find("OptionsOverride") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::StepColorTemperature: Missing command-argument: OptionsOverride\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "ColorControl",
        "StepColorTemperature",
        message,
        message_length,
        uic_mqtt_dotdot_on_color_control_step_color_temperature);

    } catch (...) {
      sl_log_debug(LOG_TAG, "StepColorTemperature: Unable to parse JSON payload.\n");
      return;
    }
  }

}

static void uic_mqtt_dotdot_on_by_group_color_control_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_color_control_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_color_control_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "ColorControl",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_color_control_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ColorControl: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_color_control_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_color_control_state_t new_state = {};
    uic_mqtt_dotdot_color_control_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_color_control_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_color_control_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_color_control_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_color_control_write_attributes_callback) {
    subscription_topic = topic_bygroup + "ColorControl/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_color_control_WriteAttributes);
  }
  if (uic_mqtt_dotdot_by_group_color_control_move_to_hue_callback) {
    subscription_topic = topic_bygroup + "ColorControl/Commands/MoveToHue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_color_control_move_to_hue);
  }
  if (uic_mqtt_dotdot_by_group_color_control_move_hue_callback) {
    subscription_topic = topic_bygroup + "ColorControl/Commands/MoveHue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_color_control_move_hue);
  }
  if (uic_mqtt_dotdot_by_group_color_control_step_hue_callback) {
    subscription_topic = topic_bygroup + "ColorControl/Commands/StepHue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_color_control_step_hue);
  }
  if (uic_mqtt_dotdot_by_group_color_control_move_to_saturation_callback) {
    subscription_topic = topic_bygroup + "ColorControl/Commands/MoveToSaturation";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_color_control_move_to_saturation);
  }
  if (uic_mqtt_dotdot_by_group_color_control_move_saturation_callback) {
    subscription_topic = topic_bygroup + "ColorControl/Commands/MoveSaturation";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_color_control_move_saturation);
  }
  if (uic_mqtt_dotdot_by_group_color_control_step_saturation_callback) {
    subscription_topic = topic_bygroup + "ColorControl/Commands/StepSaturation";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_color_control_step_saturation);
  }
  if (uic_mqtt_dotdot_by_group_color_control_move_to_hue_and_saturation_callback) {
    subscription_topic = topic_bygroup + "ColorControl/Commands/MoveToHueAndSaturation";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_color_control_move_to_hue_and_saturation);
  }
  if (uic_mqtt_dotdot_by_group_color_control_move_to_color_callback) {
    subscription_topic = topic_bygroup + "ColorControl/Commands/MoveToColor";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_color_control_move_to_color);
  }
  if (uic_mqtt_dotdot_by_group_color_control_move_color_callback) {
    subscription_topic = topic_bygroup + "ColorControl/Commands/MoveColor";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_color_control_move_color);
  }
  if (uic_mqtt_dotdot_by_group_color_control_step_color_callback) {
    subscription_topic = topic_bygroup + "ColorControl/Commands/StepColor";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_color_control_step_color);
  }
  if (uic_mqtt_dotdot_by_group_color_control_move_to_color_temperature_callback) {
    subscription_topic = topic_bygroup + "ColorControl/Commands/MoveToColorTemperature";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_color_control_move_to_color_temperature);
  }
  if (uic_mqtt_dotdot_by_group_color_control_enhanced_move_to_hue_callback) {
    subscription_topic = topic_bygroup + "ColorControl/Commands/EnhancedMoveToHue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_color_control_enhanced_move_to_hue);
  }
  if (uic_mqtt_dotdot_by_group_color_control_enhanced_move_hue_callback) {
    subscription_topic = topic_bygroup + "ColorControl/Commands/EnhancedMoveHue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_color_control_enhanced_move_hue);
  }
  if (uic_mqtt_dotdot_by_group_color_control_enhanced_step_hue_callback) {
    subscription_topic = topic_bygroup + "ColorControl/Commands/EnhancedStepHue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_color_control_enhanced_step_hue);
  }
  if (uic_mqtt_dotdot_by_group_color_control_enhanced_move_to_hue_and_saturation_callback) {
    subscription_topic = topic_bygroup + "ColorControl/Commands/EnhancedMoveToHueAndSaturation";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_color_control_enhanced_move_to_hue_and_saturation);
  }
  if (uic_mqtt_dotdot_by_group_color_control_color_loop_set_callback) {
    subscription_topic = topic_bygroup + "ColorControl/Commands/ColorLoopSet";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_color_control_color_loop_set);
  }
  if (uic_mqtt_dotdot_by_group_color_control_stop_move_step_callback) {
    subscription_topic = topic_bygroup + "ColorControl/Commands/StopMoveStep";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_color_control_stop_move_step);
  }
  if (uic_mqtt_dotdot_by_group_color_control_move_color_temperature_callback) {
    subscription_topic = topic_bygroup + "ColorControl/Commands/MoveColorTemperature";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_color_control_move_color_temperature);
  }
  if (uic_mqtt_dotdot_by_group_color_control_step_color_temperature_callback) {
    subscription_topic = topic_bygroup + "ColorControl/Commands/StepColorTemperature";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_color_control_step_color_temperature);
  }

  return SL_STATUS_OK;
}




static void uic_mqtt_dotdot_on_by_group_ballast_configuration_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_ballast_configuration_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_ballast_configuration_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "BallastConfiguration",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_ballast_configuration_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "BallastConfiguration: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_ballast_configuration_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_ballast_configuration_state_t new_state = {};
    uic_mqtt_dotdot_ballast_configuration_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_ballast_configuration_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "BallastConfiguration", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_ballast_configuration_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_ballast_configuration_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_ballast_configuration_write_attributes_callback) {
    subscription_topic = topic_bygroup + "BallastConfiguration/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_ballast_configuration_WriteAttributes);
  }

  return SL_STATUS_OK;
}




static void uic_mqtt_dotdot_on_by_group_illuminance_measurement_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_illuminance_measurement_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_illuminance_measurement_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "IlluminanceMeasurement",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_illuminance_measurement_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "IlluminanceMeasurement: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_illuminance_measurement_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_illuminance_measurement_state_t new_state = {};
    uic_mqtt_dotdot_illuminance_measurement_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_illuminance_measurement_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IlluminanceMeasurement", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IlluminanceMeasurement", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IlluminanceMeasurement", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_illuminance_measurement_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_illuminance_measurement_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_illuminance_measurement_write_attributes_callback) {
    subscription_topic = topic_bygroup + "IlluminanceMeasurement/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_illuminance_measurement_WriteAttributes);
  }

  return SL_STATUS_OK;
}




static void uic_mqtt_dotdot_on_by_group_illuminance_level_sensing_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_illuminance_level_sensing_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_illuminance_level_sensing_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "IlluminanceLevelSensing",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_illuminance_level_sensing_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "IlluminanceLevelSensing: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_illuminance_level_sensing_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_illuminance_level_sensing_state_t new_state = {};
    uic_mqtt_dotdot_illuminance_level_sensing_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_illuminance_level_sensing_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IlluminanceLevelSensing", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IlluminanceLevelSensing", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IlluminanceLevelSensing", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_illuminance_level_sensing_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_illuminance_level_sensing_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_illuminance_level_sensing_write_attributes_callback) {
    subscription_topic = topic_bygroup + "IlluminanceLevelSensing/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_illuminance_level_sensing_WriteAttributes);
  }

  return SL_STATUS_OK;
}




static void uic_mqtt_dotdot_on_by_group_temperature_measurement_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_temperature_measurement_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_temperature_measurement_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "TemperatureMeasurement",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_temperature_measurement_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "TemperatureMeasurement: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_temperature_measurement_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_temperature_measurement_state_t new_state = {};
    uic_mqtt_dotdot_temperature_measurement_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_temperature_measurement_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "TemperatureMeasurement", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "TemperatureMeasurement", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "TemperatureMeasurement", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_temperature_measurement_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_temperature_measurement_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_temperature_measurement_write_attributes_callback) {
    subscription_topic = topic_bygroup + "TemperatureMeasurement/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_temperature_measurement_WriteAttributes);
  }

  return SL_STATUS_OK;
}




static void uic_mqtt_dotdot_on_by_group_pressure_measurement_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_pressure_measurement_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_pressure_measurement_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "PressureMeasurement",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_pressure_measurement_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "PressureMeasurement: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_pressure_measurement_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_pressure_measurement_state_t new_state = {};
    uic_mqtt_dotdot_pressure_measurement_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_pressure_measurement_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PressureMeasurement", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PressureMeasurement", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PressureMeasurement", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_pressure_measurement_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_pressure_measurement_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_pressure_measurement_write_attributes_callback) {
    subscription_topic = topic_bygroup + "PressureMeasurement/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_pressure_measurement_WriteAttributes);
  }

  return SL_STATUS_OK;
}




static void uic_mqtt_dotdot_on_by_group_flow_measurement_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_flow_measurement_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_flow_measurement_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "FlowMeasurement",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_flow_measurement_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "FlowMeasurement: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_flow_measurement_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_flow_measurement_state_t new_state = {};
    uic_mqtt_dotdot_flow_measurement_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_flow_measurement_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "FlowMeasurement", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "FlowMeasurement", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "FlowMeasurement", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_flow_measurement_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_flow_measurement_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_flow_measurement_write_attributes_callback) {
    subscription_topic = topic_bygroup + "FlowMeasurement/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_flow_measurement_WriteAttributes);
  }

  return SL_STATUS_OK;
}




static void uic_mqtt_dotdot_on_by_group_relativity_humidity_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_relativity_humidity_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_relativity_humidity_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "RelativityHumidity",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_relativity_humidity_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "RelativityHumidity: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_relativity_humidity_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_relativity_humidity_state_t new_state = {};
    uic_mqtt_dotdot_relativity_humidity_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_relativity_humidity_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "RelativityHumidity", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "RelativityHumidity", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "RelativityHumidity", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_relativity_humidity_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_relativity_humidity_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_relativity_humidity_write_attributes_callback) {
    subscription_topic = topic_bygroup + "RelativityHumidity/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_relativity_humidity_WriteAttributes);
  }

  return SL_STATUS_OK;
}




static void uic_mqtt_dotdot_on_by_group_occupancy_sensing_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_occupancy_sensing_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_occupancy_sensing_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "OccupancySensing",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_occupancy_sensing_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "OccupancySensing: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_occupancy_sensing_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_occupancy_sensing_state_t new_state = {};
    uic_mqtt_dotdot_occupancy_sensing_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_occupancy_sensing_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OccupancySensing", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OccupancySensing", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OccupancySensing", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_occupancy_sensing_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_occupancy_sensing_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_occupancy_sensing_write_attributes_callback) {
    subscription_topic = topic_bygroup + "OccupancySensing/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_occupancy_sensing_WriteAttributes);
  }

  return SL_STATUS_OK;
}




static void uic_mqtt_dotdot_on_by_group_ph_measurement_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_ph_measurement_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_ph_measurement_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "PhMeasurement",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_ph_measurement_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "PhMeasurement: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_ph_measurement_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_ph_measurement_state_t new_state = {};
    uic_mqtt_dotdot_ph_measurement_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_ph_measurement_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PhMeasurement", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PhMeasurement", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PhMeasurement", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_ph_measurement_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_ph_measurement_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_ph_measurement_write_attributes_callback) {
    subscription_topic = topic_bygroup + "PhMeasurement/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_ph_measurement_WriteAttributes);
  }

  return SL_STATUS_OK;
}




static void uic_mqtt_dotdot_on_by_group_electrical_conductivity_measurement_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_electrical_conductivity_measurement_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_electrical_conductivity_measurement_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "ElectricalConductivityMeasurement",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_electrical_conductivity_measurement_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ElectricalConductivityMeasurement: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_electrical_conductivity_measurement_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_electrical_conductivity_measurement_state_t new_state = {};
    uic_mqtt_dotdot_electrical_conductivity_measurement_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_electrical_conductivity_measurement_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ElectricalConductivityMeasurement", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalConductivityMeasurement", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalConductivityMeasurement", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_electrical_conductivity_measurement_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_electrical_conductivity_measurement_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_electrical_conductivity_measurement_write_attributes_callback) {
    subscription_topic = topic_bygroup + "ElectricalConductivityMeasurement/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_electrical_conductivity_measurement_WriteAttributes);
  }

  return SL_STATUS_OK;
}




static void uic_mqtt_dotdot_on_by_group_wind_speed_measurement_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_wind_speed_measurement_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_wind_speed_measurement_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "WindSpeedMeasurement",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_wind_speed_measurement_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "WindSpeedMeasurement: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_wind_speed_measurement_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_wind_speed_measurement_state_t new_state = {};
    uic_mqtt_dotdot_wind_speed_measurement_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_wind_speed_measurement_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindSpeedMeasurement", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindSpeedMeasurement", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindSpeedMeasurement", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_wind_speed_measurement_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_wind_speed_measurement_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_wind_speed_measurement_write_attributes_callback) {
    subscription_topic = topic_bygroup + "WindSpeedMeasurement/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_wind_speed_measurement_WriteAttributes);
  }

  return SL_STATUS_OK;
}




static void uic_mqtt_dotdot_on_by_group_carbon_monoxide_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_carbon_monoxide_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_carbon_monoxide_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "CarbonMonoxide",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_carbon_monoxide_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "CarbonMonoxide: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_carbon_monoxide_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_carbon_monoxide_state_t new_state = {};
    uic_mqtt_dotdot_carbon_monoxide_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_carbon_monoxide_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "CarbonMonoxide", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "CarbonMonoxide", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "CarbonMonoxide", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_carbon_monoxide_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_carbon_monoxide_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_carbon_monoxide_write_attributes_callback) {
    subscription_topic = topic_bygroup + "CarbonMonoxide/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_carbon_monoxide_WriteAttributes);
  }

  return SL_STATUS_OK;
}




// Callback function for incoming publications on ucl/by-group/+/IASZone/Commands/ZoneEnrollResponse
static void uic_mqtt_dotdot_on_by_group_ias_zone_zone_enroll_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_ias_zone_zone_enroll_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_ias_zone_zone_enroll_response_callback != nullptr) {

    
    uic_mqtt_dotdot_ias_zone_command_zone_enroll_response_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_ias_zone_zone_enroll_response(
          jsn,
          fields.enroll_response_code,
              
          fields.zoneid
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASZone", "ZoneEnrollResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "ZoneEnrollResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "ZoneEnrollResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_ias_zone_zone_enroll_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("EnrollResponseCode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "IASZone::ZoneEnrollResponse: Missing command-argument: EnrollResponseCode\n");
        return;
      }
      if (jsn.find("ZoneID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "IASZone::ZoneEnrollResponse: Missing command-argument: ZoneID\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "IASZone",
        "ZoneEnrollResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_ias_zone_zone_enroll_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ZoneEnrollResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/IASZone/Commands/ZoneStatusChangeNotification
static void uic_mqtt_dotdot_on_by_group_ias_zone_zone_status_change_notification(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_ias_zone_zone_status_change_notification_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_ias_zone_zone_status_change_notification_callback != nullptr) {

    
    uic_mqtt_dotdot_ias_zone_command_zone_status_change_notification_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_ias_zone_zone_status_change_notification(
          jsn,
          fields.zone_status,
              
          fields.extended_status,
              
          fields.zoneid,
              
          fields.delay
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASZone", "ZoneStatusChangeNotification");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "ZoneStatusChangeNotification", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "ZoneStatusChangeNotification", "");
        return;
      }

      uic_mqtt_dotdot_by_group_ias_zone_zone_status_change_notification_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("ZoneStatus") == jsn.end()) {
        sl_log_debug(LOG_TAG, "IASZone::ZoneStatusChangeNotification: Missing command-argument: ZoneStatus\n");
        return;
      }
      if (jsn.find("ExtendedStatus") == jsn.end()) {
        sl_log_debug(LOG_TAG, "IASZone::ZoneStatusChangeNotification: Missing command-argument: ExtendedStatus\n");
        return;
      }
      if (jsn.find("ZoneID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "IASZone::ZoneStatusChangeNotification: Missing command-argument: ZoneID\n");
        return;
      }
      if (jsn.find("Delay") == jsn.end()) {
        sl_log_debug(LOG_TAG, "IASZone::ZoneStatusChangeNotification: Missing command-argument: Delay\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "IASZone",
        "ZoneStatusChangeNotification",
        message,
        message_length,
        uic_mqtt_dotdot_on_ias_zone_zone_status_change_notification);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ZoneStatusChangeNotification: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/IASZone/Commands/InitiateNormalOperationMode
static void uic_mqtt_dotdot_on_by_group_ias_zone_initiate_normal_operation_mode(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_ias_zone_initiate_normal_operation_mode_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_ias_zone_initiate_normal_operation_mode_callback != nullptr) {

    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASZone", "InitiateNormalOperationMode");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "InitiateNormalOperationMode", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "InitiateNormalOperationMode", "");
        return;
      }

      uic_mqtt_dotdot_by_group_ias_zone_initiate_normal_operation_mode_callback(
        group_id
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));

      group_dispatch_callback(
        group_id,
        "IASZone",
        "InitiateNormalOperationMode",
        message,
        message_length,
        uic_mqtt_dotdot_on_ias_zone_initiate_normal_operation_mode);

    } catch (...) {
      sl_log_debug(LOG_TAG, "InitiateNormalOperationMode: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/IASZone/Commands/ZoneEnrollRequest
static void uic_mqtt_dotdot_on_by_group_ias_zone_zone_enroll_request(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_ias_zone_zone_enroll_request_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_ias_zone_zone_enroll_request_callback != nullptr) {

    
    uic_mqtt_dotdot_ias_zone_command_zone_enroll_request_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_ias_zone_zone_enroll_request(
          jsn,
          fields.zone_type,
              
          fields.manufacturer_code
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASZone", "ZoneEnrollRequest");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "ZoneEnrollRequest", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "ZoneEnrollRequest", "");
        return;
      }

      uic_mqtt_dotdot_by_group_ias_zone_zone_enroll_request_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("ZoneType") == jsn.end()) {
        sl_log_debug(LOG_TAG, "IASZone::ZoneEnrollRequest: Missing command-argument: ZoneType\n");
        return;
      }
      if (jsn.find("ManufacturerCode") == jsn.end()) {
        sl_log_debug(LOG_TAG, "IASZone::ZoneEnrollRequest: Missing command-argument: ManufacturerCode\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "IASZone",
        "ZoneEnrollRequest",
        message,
        message_length,
        uic_mqtt_dotdot_on_ias_zone_zone_enroll_request);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ZoneEnrollRequest: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/IASZone/Commands/InitiateTestMode
static void uic_mqtt_dotdot_on_by_group_ias_zone_initiate_test_mode(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_ias_zone_initiate_test_mode_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_ias_zone_initiate_test_mode_callback != nullptr) {

    
    uic_mqtt_dotdot_ias_zone_command_initiate_test_mode_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_ias_zone_initiate_test_mode(
          jsn,
          fields.test_mode_duration,
              
          fields.current_zone_sensitivity_level
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASZone", "InitiateTestMode");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "InitiateTestMode", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "InitiateTestMode", "");
        return;
      }

      uic_mqtt_dotdot_by_group_ias_zone_initiate_test_mode_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("TestModeDuration") == jsn.end()) {
        sl_log_debug(LOG_TAG, "IASZone::InitiateTestMode: Missing command-argument: TestModeDuration\n");
        return;
      }
      if (jsn.find("CurrentZoneSensitivityLevel") == jsn.end()) {
        sl_log_debug(LOG_TAG, "IASZone::InitiateTestMode: Missing command-argument: CurrentZoneSensitivityLevel\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "IASZone",
        "InitiateTestMode",
        message,
        message_length,
        uic_mqtt_dotdot_on_ias_zone_initiate_test_mode);

    } catch (...) {
      sl_log_debug(LOG_TAG, "InitiateTestMode: Unable to parse JSON payload.\n");
      return;
    }
  }

}

static void uic_mqtt_dotdot_on_by_group_ias_zone_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_ias_zone_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_ias_zone_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "IASZone",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_ias_zone_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "IASZone: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_ias_zone_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_ias_zone_state_t new_state = {};
    uic_mqtt_dotdot_ias_zone_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_ias_zone_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASZone", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_ias_zone_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_ias_zone_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_ias_zone_write_attributes_callback) {
    subscription_topic = topic_bygroup + "IASZone/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_ias_zone_WriteAttributes);
  }
  if (uic_mqtt_dotdot_by_group_ias_zone_zone_enroll_response_callback) {
    subscription_topic = topic_bygroup + "IASZone/Commands/ZoneEnrollResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_ias_zone_zone_enroll_response);
  }
  if (uic_mqtt_dotdot_by_group_ias_zone_zone_status_change_notification_callback) {
    subscription_topic = topic_bygroup + "IASZone/Commands/ZoneStatusChangeNotification";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_ias_zone_zone_status_change_notification);
  }
  if (uic_mqtt_dotdot_by_group_ias_zone_initiate_normal_operation_mode_callback) {
    subscription_topic = topic_bygroup + "IASZone/Commands/InitiateNormalOperationMode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_ias_zone_initiate_normal_operation_mode);
  }
  if (uic_mqtt_dotdot_by_group_ias_zone_zone_enroll_request_callback) {
    subscription_topic = topic_bygroup + "IASZone/Commands/ZoneEnrollRequest";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_ias_zone_zone_enroll_request);
  }
  if (uic_mqtt_dotdot_by_group_ias_zone_initiate_test_mode_callback) {
    subscription_topic = topic_bygroup + "IASZone/Commands/InitiateTestMode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_ias_zone_initiate_test_mode);
  }

  return SL_STATUS_OK;
}




// Callback function for incoming publications on ucl/by-group/+/IASWD/Commands/StartWarning
static void uic_mqtt_dotdot_on_by_group_iaswd_start_warning(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_iaswd_start_warning_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_iaswd_start_warning_callback != nullptr) {

    
    uic_mqtt_dotdot_iaswd_command_start_warning_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_iaswd_start_warning(
          jsn,
          fields.siren_configuration,
              
          fields.warning_duration,
              
          fields.strobe_duty_cycle,
              
          fields.strobe_level
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASWD", "StartWarning");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASWD", "StartWarning", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASWD", "StartWarning", "");
        return;
      }

      uic_mqtt_dotdot_by_group_iaswd_start_warning_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_iaswd_start_warning_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("SirenConfiguration") == jsn.end()) {
        sl_log_debug(LOG_TAG, "IASWD::StartWarning: Missing command-argument: SirenConfiguration\n");
        return;
      }
      if (jsn.find("WarningDuration") == jsn.end()) {
        sl_log_debug(LOG_TAG, "IASWD::StartWarning: Missing command-argument: WarningDuration\n");
        return;
      }
      if (jsn.find("StrobeDutyCycle") == jsn.end()) {
        sl_log_debug(LOG_TAG, "IASWD::StartWarning: Missing command-argument: StrobeDutyCycle\n");
        return;
      }
      if (jsn.find("StrobeLevel") == jsn.end()) {
        sl_log_debug(LOG_TAG, "IASWD::StartWarning: Missing command-argument: StrobeLevel\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "IASWD",
        "StartWarning",
        message,
        message_length,
        uic_mqtt_dotdot_on_iaswd_start_warning);

    } catch (...) {
      sl_log_debug(LOG_TAG, "StartWarning: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/IASWD/Commands/Squawk
static void uic_mqtt_dotdot_on_by_group_iaswd_squawk(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_iaswd_squawk_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_iaswd_squawk_callback != nullptr) {

    
    uic_mqtt_dotdot_iaswd_command_squawk_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_iaswd_squawk(
          jsn,
          fields.squawk_configuration
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASWD", "Squawk");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASWD", "Squawk", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASWD", "Squawk", "");
        return;
      }

      uic_mqtt_dotdot_by_group_iaswd_squawk_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_iaswd_squawk_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("SquawkConfiguration") == jsn.end()) {
        sl_log_debug(LOG_TAG, "IASWD::Squawk: Missing command-argument: SquawkConfiguration\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "IASWD",
        "Squawk",
        message,
        message_length,
        uic_mqtt_dotdot_on_iaswd_squawk);

    } catch (...) {
      sl_log_debug(LOG_TAG, "Squawk: Unable to parse JSON payload.\n");
      return;
    }
  }

}

static void uic_mqtt_dotdot_on_by_group_iaswd_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_iaswd_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_iaswd_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "IASWD",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_iaswd_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "IASWD: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_iaswd_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_iaswd_state_t new_state = {};
    uic_mqtt_dotdot_iaswd_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_iaswd_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASWD", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASWD", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASWD", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_iaswd_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_iaswd_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_iaswd_write_attributes_callback) {
    subscription_topic = topic_bygroup + "IASWD/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_iaswd_WriteAttributes);
  }
  if (uic_mqtt_dotdot_by_group_iaswd_start_warning_callback) {
    subscription_topic = topic_bygroup + "IASWD/Commands/StartWarning";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_iaswd_start_warning);
  }
  if (uic_mqtt_dotdot_by_group_iaswd_squawk_callback) {
    subscription_topic = topic_bygroup + "IASWD/Commands/Squawk";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_iaswd_squawk);
  }

  return SL_STATUS_OK;
}




static void uic_mqtt_dotdot_on_by_group_metering_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_metering_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_metering_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "Metering",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_metering_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "Metering: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_metering_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_metering_state_t new_state = {};
    uic_mqtt_dotdot_metering_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_metering_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Metering", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_metering_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_metering_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_metering_write_attributes_callback) {
    subscription_topic = topic_bygroup + "Metering/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_metering_WriteAttributes);
  }

  return SL_STATUS_OK;
}




// Callback function for incoming publications on ucl/by-group/+/ElectricalMeasurement/Commands/GetProfileInfoResponse
static void uic_mqtt_dotdot_on_by_group_electrical_measurement_get_profile_info_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_electrical_measurement_get_profile_info_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_electrical_measurement_get_profile_info_response_callback != nullptr) {

    
    uic_mqtt_dotdot_electrical_measurement_command_get_profile_info_response_fields_t fields;
      std::vector<uint16_t> list_of_attributes;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_electrical_measurement_get_profile_info_response(
          jsn,
          fields.profile_count,
              
          fields.profile_interval_period,
              
          fields.max_number_of_intervals,
              
          list_of_attributes
      );

      // Populate list fields from vector or string types
      
        fields.list_of_attributes_count = list_of_attributes.size();
        fields.list_of_attributes = list_of_attributes.data();


      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ElectricalMeasurement", "GetProfileInfoResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetProfileInfoResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetProfileInfoResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_electrical_measurement_get_profile_info_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("ProfileCount") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::GetProfileInfoResponse: Missing command-argument: ProfileCount\n");
        return;
      }
      if (jsn.find("ProfileIntervalPeriod") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::GetProfileInfoResponse: Missing command-argument: ProfileIntervalPeriod\n");
        return;
      }
      if (jsn.find("MaxNumberOfIntervals") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::GetProfileInfoResponse: Missing command-argument: MaxNumberOfIntervals\n");
        return;
      }
      if (jsn.find("ListOfAttributes") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::GetProfileInfoResponse: Missing command-argument: ListOfAttributes\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "ElectricalMeasurement",
        "GetProfileInfoResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_electrical_measurement_get_profile_info_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GetProfileInfoResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/ElectricalMeasurement/Commands/GetProfileInfo
static void uic_mqtt_dotdot_on_by_group_electrical_measurement_get_profile_info(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_electrical_measurement_get_profile_info_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_electrical_measurement_get_profile_info_callback != nullptr) {

    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ElectricalMeasurement", "GetProfileInfo");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetProfileInfo", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetProfileInfo", "");
        return;
      }

      uic_mqtt_dotdot_by_group_electrical_measurement_get_profile_info_callback(
        group_id
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));

      group_dispatch_callback(
        group_id,
        "ElectricalMeasurement",
        "GetProfileInfo",
        message,
        message_length,
        uic_mqtt_dotdot_on_electrical_measurement_get_profile_info);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GetProfileInfo: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/ElectricalMeasurement/Commands/GetMeasurementProfileResponse
static void uic_mqtt_dotdot_on_by_group_electrical_measurement_get_measurement_profile_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_electrical_measurement_get_measurement_profile_response_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_electrical_measurement_get_measurement_profile_response_callback != nullptr) {

    
    uic_mqtt_dotdot_electrical_measurement_command_get_measurement_profile_response_fields_t fields;
      std::vector<uint8_t> intervals;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_electrical_measurement_get_measurement_profile_response(
          jsn,
          fields.start_time,
              
          fields.status,
              
          fields.profile_interval_period,
              
          fields.number_of_intervals_delivered,
              
          fields.attribute_id,
              
          intervals
      );

      // Populate list fields from vector or string types
      
        fields.intervals_count = intervals.size();
        fields.intervals = intervals.data();


      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ElectricalMeasurement", "GetMeasurementProfileResponse");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetMeasurementProfileResponse", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetMeasurementProfileResponse", "");
        return;
      }

      uic_mqtt_dotdot_by_group_electrical_measurement_get_measurement_profile_response_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("StartTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::GetMeasurementProfileResponse: Missing command-argument: StartTime\n");
        return;
      }
      if (jsn.find("Status") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::GetMeasurementProfileResponse: Missing command-argument: Status\n");
        return;
      }
      if (jsn.find("ProfileIntervalPeriod") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::GetMeasurementProfileResponse: Missing command-argument: ProfileIntervalPeriod\n");
        return;
      }
      if (jsn.find("NumberOfIntervalsDelivered") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::GetMeasurementProfileResponse: Missing command-argument: NumberOfIntervalsDelivered\n");
        return;
      }
      if (jsn.find("AttributeId") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::GetMeasurementProfileResponse: Missing command-argument: AttributeId\n");
        return;
      }
      if (jsn.find("Intervals") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::GetMeasurementProfileResponse: Missing command-argument: Intervals\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "ElectricalMeasurement",
        "GetMeasurementProfileResponse",
        message,
        message_length,
        uic_mqtt_dotdot_on_electrical_measurement_get_measurement_profile_response);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GetMeasurementProfileResponse: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/ElectricalMeasurement/Commands/GetMeasurementProfile
static void uic_mqtt_dotdot_on_by_group_electrical_measurement_get_measurement_profile(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_electrical_measurement_get_measurement_profile_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_electrical_measurement_get_measurement_profile_callback != nullptr) {

    
    uic_mqtt_dotdot_electrical_measurement_command_get_measurement_profile_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_electrical_measurement_get_measurement_profile(
          jsn,
          fields.attributeid,
              
          fields.start_time,
              
          fields.number_of_intervals
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ElectricalMeasurement", "GetMeasurementProfile");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetMeasurementProfile", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetMeasurementProfile", "");
        return;
      }

      uic_mqtt_dotdot_by_group_electrical_measurement_get_measurement_profile_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("AttributeID") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::GetMeasurementProfile: Missing command-argument: AttributeID\n");
        return;
      }
      if (jsn.find("StartTime") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::GetMeasurementProfile: Missing command-argument: StartTime\n");
        return;
      }
      if (jsn.find("NumberOfIntervals") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::GetMeasurementProfile: Missing command-argument: NumberOfIntervals\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "ElectricalMeasurement",
        "GetMeasurementProfile",
        message,
        message_length,
        uic_mqtt_dotdot_on_electrical_measurement_get_measurement_profile);

    } catch (...) {
      sl_log_debug(LOG_TAG, "GetMeasurementProfile: Unable to parse JSON payload.\n");
      return;
    }
  }

}

static void uic_mqtt_dotdot_on_by_group_electrical_measurement_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_electrical_measurement_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_electrical_measurement_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "ElectricalMeasurement",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_electrical_measurement_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ElectricalMeasurement: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_electrical_measurement_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_electrical_measurement_state_t new_state = {};
    uic_mqtt_dotdot_electrical_measurement_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_electrical_measurement_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ElectricalMeasurement", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_electrical_measurement_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_electrical_measurement_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_electrical_measurement_write_attributes_callback) {
    subscription_topic = topic_bygroup + "ElectricalMeasurement/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_electrical_measurement_WriteAttributes);
  }
  if (uic_mqtt_dotdot_by_group_electrical_measurement_get_profile_info_response_callback) {
    subscription_topic = topic_bygroup + "ElectricalMeasurement/Commands/GetProfileInfoResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_electrical_measurement_get_profile_info_response);
  }
  if (uic_mqtt_dotdot_by_group_electrical_measurement_get_profile_info_callback) {
    subscription_topic = topic_bygroup + "ElectricalMeasurement/Commands/GetProfileInfo";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_electrical_measurement_get_profile_info);
  }
  if (uic_mqtt_dotdot_by_group_electrical_measurement_get_measurement_profile_response_callback) {
    subscription_topic = topic_bygroup + "ElectricalMeasurement/Commands/GetMeasurementProfileResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_electrical_measurement_get_measurement_profile_response);
  }
  if (uic_mqtt_dotdot_by_group_electrical_measurement_get_measurement_profile_callback) {
    subscription_topic = topic_bygroup + "ElectricalMeasurement/Commands/GetMeasurementProfile";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_electrical_measurement_get_measurement_profile);
  }

  return SL_STATUS_OK;
}




static void uic_mqtt_dotdot_on_by_group_diagnostics_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_diagnostics_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_diagnostics_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "Diagnostics",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_diagnostics_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "Diagnostics: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_diagnostics_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_diagnostics_state_t new_state = {};
    uic_mqtt_dotdot_diagnostics_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_diagnostics_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Diagnostics", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_diagnostics_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_diagnostics_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_diagnostics_write_attributes_callback) {
    subscription_topic = topic_bygroup + "Diagnostics/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_diagnostics_WriteAttributes);
  }

  return SL_STATUS_OK;
}




// Callback function for incoming publications on ucl/by-group/+/Binding/Commands/Bind
static void uic_mqtt_dotdot_on_by_group_binding_bind(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_binding_bind_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_binding_bind_callback != nullptr) {

    
    uic_mqtt_dotdot_binding_command_bind_fields_t fields;
      std::string cluster_name;
          std::string destination_unid;
    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_binding_bind(
          jsn,
          cluster_name,
      
          destination_unid,
      
          fields.destination_ep
              );

      // Populate list fields from vector or string types
              fields.cluster_name = cluster_name.c_str();
              fields.destination_unid = destination_unid.c_str();
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Binding", "Bind");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "Bind", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "Bind", "");
        return;
      }

      uic_mqtt_dotdot_by_group_binding_bind_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_binding_bind_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("ClusterName") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Binding::Bind: Missing command-argument: ClusterName\n");
        return;
      }
      if (jsn.find("DestinationUnid") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Binding::Bind: Missing command-argument: DestinationUnid\n");
        return;
      }
      if (jsn.find("DestinationEp") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Binding::Bind: Missing command-argument: DestinationEp\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Binding",
        "Bind",
        message,
        message_length,
        uic_mqtt_dotdot_on_binding_bind);

    } catch (...) {
      sl_log_debug(LOG_TAG, "Bind: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Binding/Commands/Unbind
static void uic_mqtt_dotdot_on_by_group_binding_unbind(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_binding_unbind_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_binding_unbind_callback != nullptr) {

    
    uic_mqtt_dotdot_binding_command_unbind_fields_t fields;
      std::string cluster_name;
          std::string destination_unid;
    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_binding_unbind(
          jsn,
          cluster_name,
      
          destination_unid,
      
          fields.destination_ep
              );

      // Populate list fields from vector or string types
              fields.cluster_name = cluster_name.c_str();
              fields.destination_unid = destination_unid.c_str();
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Binding", "Unbind");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "Unbind", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "Unbind", "");
        return;
      }

      uic_mqtt_dotdot_by_group_binding_unbind_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_binding_unbind_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("ClusterName") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Binding::Unbind: Missing command-argument: ClusterName\n");
        return;
      }
      if (jsn.find("DestinationUnid") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Binding::Unbind: Missing command-argument: DestinationUnid\n");
        return;
      }
      if (jsn.find("DestinationEp") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Binding::Unbind: Missing command-argument: DestinationEp\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Binding",
        "Unbind",
        message,
        message_length,
        uic_mqtt_dotdot_on_binding_unbind);

    } catch (...) {
      sl_log_debug(LOG_TAG, "Unbind: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Binding/Commands/BindToProtocolController
static void uic_mqtt_dotdot_on_by_group_binding_bind_to_protocol_controller(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_binding_bind_to_protocol_controller_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_binding_bind_to_protocol_controller_callback != nullptr) {

    
    uic_mqtt_dotdot_binding_command_bind_to_protocol_controller_fields_t fields;
      std::string cluster_name;
    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_binding_bind_to_protocol_controller(
          jsn,
          cluster_name
      );

      // Populate list fields from vector or string types
              fields.cluster_name = cluster_name.c_str();
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Binding", "BindToProtocolController");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "BindToProtocolController", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "BindToProtocolController", "");
        return;
      }

      uic_mqtt_dotdot_by_group_binding_bind_to_protocol_controller_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_binding_bind_to_protocol_controller_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("ClusterName") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Binding::BindToProtocolController: Missing command-argument: ClusterName\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Binding",
        "BindToProtocolController",
        message,
        message_length,
        uic_mqtt_dotdot_on_binding_bind_to_protocol_controller);

    } catch (...) {
      sl_log_debug(LOG_TAG, "BindToProtocolController: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/Binding/Commands/UnbindFromProtocolController
static void uic_mqtt_dotdot_on_by_group_binding_unbind_from_protocol_controller(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_binding_unbind_from_protocol_controller_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_binding_unbind_from_protocol_controller_callback != nullptr) {

    
    uic_mqtt_dotdot_binding_command_unbind_from_protocol_controller_fields_t fields;
      std::string cluster_name;
    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_binding_unbind_from_protocol_controller(
          jsn,
          cluster_name
      );

      // Populate list fields from vector or string types
              fields.cluster_name = cluster_name.c_str();
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Binding", "UnbindFromProtocolController");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "UnbindFromProtocolController", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "UnbindFromProtocolController", "");
        return;
      }

      uic_mqtt_dotdot_by_group_binding_unbind_from_protocol_controller_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_binding_unbind_from_protocol_controller_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("ClusterName") == jsn.end()) {
        sl_log_debug(LOG_TAG, "Binding::UnbindFromProtocolController: Missing command-argument: ClusterName\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "Binding",
        "UnbindFromProtocolController",
        message,
        message_length,
        uic_mqtt_dotdot_on_binding_unbind_from_protocol_controller);

    } catch (...) {
      sl_log_debug(LOG_TAG, "UnbindFromProtocolController: Unable to parse JSON payload.\n");
      return;
    }
  }

}

static void uic_mqtt_dotdot_on_by_group_binding_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_binding_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_binding_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "Binding",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_binding_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "Binding: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_binding_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_binding_state_t new_state = {};
    uic_mqtt_dotdot_binding_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_binding_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Binding", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_binding_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_binding_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_binding_write_attributes_callback) {
    subscription_topic = topic_bygroup + "Binding/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_binding_WriteAttributes);
  }
  if (uic_mqtt_dotdot_by_group_binding_bind_callback) {
    subscription_topic = topic_bygroup + "Binding/Commands/Bind";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_binding_bind);
  }
  if (uic_mqtt_dotdot_by_group_binding_unbind_callback) {
    subscription_topic = topic_bygroup + "Binding/Commands/Unbind";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_binding_unbind);
  }
  if (uic_mqtt_dotdot_by_group_binding_bind_to_protocol_controller_callback) {
    subscription_topic = topic_bygroup + "Binding/Commands/BindToProtocolController";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_binding_bind_to_protocol_controller);
  }
  if (uic_mqtt_dotdot_by_group_binding_unbind_from_protocol_controller_callback) {
    subscription_topic = topic_bygroup + "Binding/Commands/UnbindFromProtocolController";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_binding_unbind_from_protocol_controller);
  }

  return SL_STATUS_OK;
}




static void uic_mqtt_dotdot_on_by_group_name_and_location_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_name_and_location_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_name_and_location_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "NameAndLocation",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_name_and_location_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "NameAndLocation: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_name_and_location_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_name_and_location_state_t new_state = {};
    uic_mqtt_dotdot_name_and_location_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_name_and_location_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "NameAndLocation", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "NameAndLocation", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "NameAndLocation", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_name_and_location_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_name_and_location_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_name_and_location_write_attributes_callback) {
    subscription_topic = topic_bygroup + "NameAndLocation/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_name_and_location_WriteAttributes);
  }

  return SL_STATUS_OK;
}




// Callback function for incoming publications on ucl/by-group/+/ConfigurationParameters/Commands/DiscoverParameter
static void uic_mqtt_dotdot_on_by_group_configuration_parameters_discover_parameter(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_configuration_parameters_discover_parameter_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_configuration_parameters_discover_parameter_callback != nullptr) {

    
    uic_mqtt_dotdot_configuration_parameters_command_discover_parameter_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_configuration_parameters_discover_parameter(
          jsn,
          fields.parameter_id
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ConfigurationParameters", "DiscoverParameter");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "DiscoverParameter", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "DiscoverParameter", "");
        return;
      }

      uic_mqtt_dotdot_by_group_configuration_parameters_discover_parameter_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_configuration_parameters_discover_parameter_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("ParameterId") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ConfigurationParameters::DiscoverParameter: Missing command-argument: ParameterId\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "ConfigurationParameters",
        "DiscoverParameter",
        message,
        message_length,
        uic_mqtt_dotdot_on_configuration_parameters_discover_parameter);

    } catch (...) {
      sl_log_debug(LOG_TAG, "DiscoverParameter: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/ConfigurationParameters/Commands/DefaultResetAllParameters
static void uic_mqtt_dotdot_on_by_group_configuration_parameters_default_reset_all_parameters(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_configuration_parameters_default_reset_all_parameters_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_configuration_parameters_default_reset_all_parameters_callback != nullptr) {

    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ConfigurationParameters", "DefaultResetAllParameters");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "DefaultResetAllParameters", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "DefaultResetAllParameters", "");
        return;
      }

      uic_mqtt_dotdot_by_group_configuration_parameters_default_reset_all_parameters_callback(
        group_id
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));

      group_dispatch_callback(
        group_id,
        "ConfigurationParameters",
        "DefaultResetAllParameters",
        message,
        message_length,
        uic_mqtt_dotdot_on_configuration_parameters_default_reset_all_parameters);

    } catch (...) {
      sl_log_debug(LOG_TAG, "DefaultResetAllParameters: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/ConfigurationParameters/Commands/SetParameter
static void uic_mqtt_dotdot_on_by_group_configuration_parameters_set_parameter(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_configuration_parameters_set_parameter_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_configuration_parameters_set_parameter_callback != nullptr) {

    
    uic_mqtt_dotdot_configuration_parameters_command_set_parameter_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_configuration_parameters_set_parameter(
          jsn,
          fields.parameter_id,
              
          fields.value
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ConfigurationParameters", "SetParameter");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "SetParameter", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "SetParameter", "");
        return;
      }

      uic_mqtt_dotdot_by_group_configuration_parameters_set_parameter_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_configuration_parameters_set_parameter_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("ParameterId") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ConfigurationParameters::SetParameter: Missing command-argument: ParameterId\n");
        return;
      }
      if (jsn.find("Value") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ConfigurationParameters::SetParameter: Missing command-argument: Value\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "ConfigurationParameters",
        "SetParameter",
        message,
        message_length,
        uic_mqtt_dotdot_on_configuration_parameters_set_parameter);

    } catch (...) {
      sl_log_debug(LOG_TAG, "SetParameter: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/ConfigurationParameters/Commands/DiscoverParameterRange
static void uic_mqtt_dotdot_on_by_group_configuration_parameters_discover_parameter_range(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_configuration_parameters_discover_parameter_range_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_configuration_parameters_discover_parameter_range_callback != nullptr) {

    
    uic_mqtt_dotdot_configuration_parameters_command_discover_parameter_range_fields_t fields;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_configuration_parameters_discover_parameter_range(
          jsn,
          fields.first_parameter_id,
              
          fields.last_parameter_id
              );

      // Populate list fields from vector or string types
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ConfigurationParameters", "DiscoverParameterRange");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "DiscoverParameterRange", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "DiscoverParameterRange", "");
        return;
      }

      uic_mqtt_dotdot_by_group_configuration_parameters_discover_parameter_range_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_configuration_parameters_discover_parameter_range_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("FirstParameterId") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ConfigurationParameters::DiscoverParameterRange: Missing command-argument: FirstParameterId\n");
        return;
      }
      if (jsn.find("LastParameterId") == jsn.end()) {
        sl_log_debug(LOG_TAG, "ConfigurationParameters::DiscoverParameterRange: Missing command-argument: LastParameterId\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "ConfigurationParameters",
        "DiscoverParameterRange",
        message,
        message_length,
        uic_mqtt_dotdot_on_configuration_parameters_discover_parameter_range);

    } catch (...) {
      sl_log_debug(LOG_TAG, "DiscoverParameterRange: Unable to parse JSON payload.\n");
      return;
    }
  }

}

static void uic_mqtt_dotdot_on_by_group_configuration_parameters_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_configuration_parameters_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_configuration_parameters_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "ConfigurationParameters",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_configuration_parameters_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "ConfigurationParameters: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_configuration_parameters_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_configuration_parameters_state_t new_state = {};
    uic_mqtt_dotdot_configuration_parameters_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_configuration_parameters_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ConfigurationParameters", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_configuration_parameters_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_configuration_parameters_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_configuration_parameters_write_attributes_callback) {
    subscription_topic = topic_bygroup + "ConfigurationParameters/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_configuration_parameters_WriteAttributes);
  }
  if (uic_mqtt_dotdot_by_group_configuration_parameters_discover_parameter_callback) {
    subscription_topic = topic_bygroup + "ConfigurationParameters/Commands/DiscoverParameter";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_configuration_parameters_discover_parameter);
  }
  if (uic_mqtt_dotdot_by_group_configuration_parameters_default_reset_all_parameters_callback) {
    subscription_topic = topic_bygroup + "ConfigurationParameters/Commands/DefaultResetAllParameters";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_configuration_parameters_default_reset_all_parameters);
  }
  if (uic_mqtt_dotdot_by_group_configuration_parameters_set_parameter_callback) {
    subscription_topic = topic_bygroup + "ConfigurationParameters/Commands/SetParameter";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_configuration_parameters_set_parameter);
  }
  if (uic_mqtt_dotdot_by_group_configuration_parameters_discover_parameter_range_callback) {
    subscription_topic = topic_bygroup + "ConfigurationParameters/Commands/DiscoverParameterRange";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_configuration_parameters_discover_parameter_range);
  }

  return SL_STATUS_OK;
}




// Callback function for incoming publications on ucl/by-group/+/AoXLocator/Commands/IQReport
static void uic_mqtt_dotdot_on_by_group_aox_locator_iq_report(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_aox_locator_iq_report_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_aox_locator_iq_report_callback != nullptr) {

    
    uic_mqtt_dotdot_aox_locator_command_iq_report_fields_t fields;
      std::string tag_unid;
          std::vector<int8_t> samples;


      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_aox_locator_iq_report(
          jsn,
          tag_unid,
      
          fields.channel,
              
          fields.rssi,
              
          samples,
      
          fields.sequence
              );

      // Populate list fields from vector or string types
              fields.tag_unid = tag_unid.c_str();
      
        fields.samples_count = samples.size();
        fields.samples = samples.data();


      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "AoXLocator", "IQReport");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "IQReport", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "IQReport", "");
        return;
      }

      uic_mqtt_dotdot_by_group_aox_locator_iq_report_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_aox_locator_iq_report_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("TagUnid") == jsn.end()) {
        sl_log_debug(LOG_TAG, "AoXLocator::IQReport: Missing command-argument: TagUnid\n");
        return;
      }
      if (jsn.find("Channel") == jsn.end()) {
        sl_log_debug(LOG_TAG, "AoXLocator::IQReport: Missing command-argument: Channel\n");
        return;
      }
      if (jsn.find("RSSI") == jsn.end()) {
        sl_log_debug(LOG_TAG, "AoXLocator::IQReport: Missing command-argument: RSSI\n");
        return;
      }
      if (jsn.find("Samples") == jsn.end()) {
        sl_log_debug(LOG_TAG, "AoXLocator::IQReport: Missing command-argument: Samples\n");
        return;
      }
      if (jsn.find("Sequence") == jsn.end()) {
        sl_log_debug(LOG_TAG, "AoXLocator::IQReport: Missing command-argument: Sequence\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "AoXLocator",
        "IQReport",
        message,
        message_length,
        uic_mqtt_dotdot_on_aox_locator_iq_report);

    } catch (...) {
      sl_log_debug(LOG_TAG, "IQReport: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/AoXLocator/Commands/AngleReport
static void uic_mqtt_dotdot_on_by_group_aox_locator_angle_report(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_aox_locator_angle_report_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_aox_locator_angle_report_callback != nullptr) {

    
    uic_mqtt_dotdot_aox_locator_command_angle_report_fields_t fields;
      std::string tag_unid;
    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_aox_locator_angle_report(
          jsn,
          tag_unid,
      
          fields.direction,
              
          fields.deviation,
              
          fields.sequence
              );

      // Populate list fields from vector or string types
              fields.tag_unid = tag_unid.c_str();
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "AoXLocator", "AngleReport");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "AngleReport", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "AngleReport", "");
        return;
      }

      uic_mqtt_dotdot_by_group_aox_locator_angle_report_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_aox_locator_angle_report_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("TagUnid") == jsn.end()) {
        sl_log_debug(LOG_TAG, "AoXLocator::AngleReport: Missing command-argument: TagUnid\n");
        return;
      }
      if (jsn.find("Direction") == jsn.end()) {
        sl_log_debug(LOG_TAG, "AoXLocator::AngleReport: Missing command-argument: Direction\n");
        return;
      }
      if (jsn.find("Deviation") == jsn.end()) {
        sl_log_debug(LOG_TAG, "AoXLocator::AngleReport: Missing command-argument: Deviation\n");
        return;
      }
      if (jsn.find("Sequence") == jsn.end()) {
        sl_log_debug(LOG_TAG, "AoXLocator::AngleReport: Missing command-argument: Sequence\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "AoXLocator",
        "AngleReport",
        message,
        message_length,
        uic_mqtt_dotdot_on_aox_locator_angle_report);

    } catch (...) {
      sl_log_debug(LOG_TAG, "AngleReport: Unable to parse JSON payload.\n");
      return;
    }
  }

}

// Callback function for incoming publications on ucl/by-group/+/AoXLocator/Commands/AngleCorrection
static void uic_mqtt_dotdot_on_by_group_aox_locator_angle_correction(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_aox_locator_angle_correction_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  // Pass to command-specific callback if set. Otherwise, pass to
  // group-dispatch callback
  if (uic_mqtt_dotdot_by_group_aox_locator_angle_correction_callback != nullptr) {

    
    uic_mqtt_dotdot_aox_locator_command_angle_correction_fields_t fields;
      std::string tag_unid;
    

      nlohmann::json jsn;
      try {
        jsn = nlohmann::json::parse(std::string(message));

      
        uic_mqtt_dotdot_parse_aox_locator_angle_correction(
          jsn,
          tag_unid,
      
          fields.direction,
              
          fields.deviation,
              
          fields.sequence
              );

      // Populate list fields from vector or string types
              fields.tag_unid = tag_unid.c_str();
      

      } catch (const nlohmann::json::parse_error& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "AoXLocator", "AngleCorrection");
        return;
      } catch (const nlohmann::json::exception& e) {
        // Catch JSON object field parsing errors
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "AngleCorrection", e.what());
        return;
      } catch (const std::exception& e) {
        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "AngleCorrection", "");
        return;
      }

      uic_mqtt_dotdot_by_group_aox_locator_angle_correction_callback(
        group_id,
        &fields
      );
  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_aox_locator_angle_correction_callback().empty())) {
    // group-dispatch callback only called if the command-specific by-unid
    // callback is set
    try {
      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      if (jsn.find("TagUnid") == jsn.end()) {
        sl_log_debug(LOG_TAG, "AoXLocator::AngleCorrection: Missing command-argument: TagUnid\n");
        return;
      }
      if (jsn.find("Direction") == jsn.end()) {
        sl_log_debug(LOG_TAG, "AoXLocator::AngleCorrection: Missing command-argument: Direction\n");
        return;
      }
      if (jsn.find("Deviation") == jsn.end()) {
        sl_log_debug(LOG_TAG, "AoXLocator::AngleCorrection: Missing command-argument: Deviation\n");
        return;
      }
      if (jsn.find("Sequence") == jsn.end()) {
        sl_log_debug(LOG_TAG, "AoXLocator::AngleCorrection: Missing command-argument: Sequence\n");
        return;
      }

      group_dispatch_callback(
        group_id,
        "AoXLocator",
        "AngleCorrection",
        message,
        message_length,
        uic_mqtt_dotdot_on_aox_locator_angle_correction);

    } catch (...) {
      sl_log_debug(LOG_TAG, "AngleCorrection: Unable to parse JSON payload.\n");
      return;
    }
  }

}

static void uic_mqtt_dotdot_on_by_group_aox_locator_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_aox_locator_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_aox_locator_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "AoXLocator",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_aox_locator_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "AoXLocator: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_aox_locator_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_aox_locator_state_t new_state = {};
    uic_mqtt_dotdot_aox_locator_updated_state_t new_updated_state = {};
    
      std::vector<MinMaxPair> azimuth_mask;
    
      std::vector<MinMaxPair> elevation_mask;
    
      std::vector<const char*> allow_list;
    
      std::vector<int8_t> antenna_array;
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_aox_locator_write_attributes(
        jsn,
        new_state,
        new_updated_state,
        azimuth_mask,
        elevation_mask,
        allow_list,
        antenna_array
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "AoXLocator", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_aox_locator_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_aox_locator_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_aox_locator_write_attributes_callback) {
    subscription_topic = topic_bygroup + "AoXLocator/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_aox_locator_WriteAttributes);
  }
  if (uic_mqtt_dotdot_by_group_aox_locator_iq_report_callback) {
    subscription_topic = topic_bygroup + "AoXLocator/Commands/IQReport";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_aox_locator_iq_report);
  }
  if (uic_mqtt_dotdot_by_group_aox_locator_angle_report_callback) {
    subscription_topic = topic_bygroup + "AoXLocator/Commands/AngleReport";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_aox_locator_angle_report);
  }
  if (uic_mqtt_dotdot_by_group_aox_locator_angle_correction_callback) {
    subscription_topic = topic_bygroup + "AoXLocator/Commands/AngleCorrection";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_aox_locator_angle_correction);
  }

  return SL_STATUS_OK;
}




static void uic_mqtt_dotdot_on_by_group_aox_position_estimation_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{

  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_aox_position_estimation_write_attributes_callback == nullptr)) {
    return;
  }
  if (message_length == 0) {
    return;
  }

  dotdot_group_id_t group_id = 0U;
  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
    sl_log_debug(LOG_TAG,
                "Failed to parse GroupId from topic %s. Ignoring",
                topic);
    return;
  }

  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_aox_position_estimation_write_attributes_callback().empty())) {
    try {
      group_dispatch_callback(group_id,
                              "AoXPositionEstimation",
                              "WriteAttributes",
                              message,
                              message_length,
                              uic_mqtt_dotdot_on_aox_position_estimation_WriteAttributes);

    } catch (...) {
      sl_log_debug(LOG_TAG, "AoXPositionEstimation: Unable to parse JSON payload.\n");
      return;
    }
  } else if (uic_mqtt_dotdot_by_group_aox_position_estimation_write_attributes_callback != nullptr) {

    uic_mqtt_dotdot_aox_position_estimation_state_t new_state = {};
    uic_mqtt_dotdot_aox_position_estimation_updated_state_t new_updated_state = {};
    

    nlohmann::json jsn;
    try {
      jsn = nlohmann::json::parse(std::string(message));

      uic_mqtt_dotdot_parse_aox_position_estimation_write_attributes(
        jsn,
        new_state,
        new_updated_state
      );
    } catch (const nlohmann::json::parse_error& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "AoXPositionEstimation", "WriteAttributes");
      return;
    } catch (const nlohmann::json::exception& e) {
      // Catch JSON object field parsing errors
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXPositionEstimation", "WriteAttributes", e.what());
      return;
    } catch (const std::exception& e) {
      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXPositionEstimation", "WriteAttributes", "");
      return;
    }

    uic_mqtt_dotdot_by_group_aox_position_estimation_write_attributes_callback(
      group_id,
      new_state,
      new_updated_state
    );
  }
}

sl_status_t uic_mqtt_dotdot_by_group_aox_position_estimation_init()
{
  std::string subscription_topic;
  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
  if(uic_mqtt_dotdot_by_group_aox_position_estimation_write_attributes_callback) {
    subscription_topic = topic_bygroup + "AoXPositionEstimation/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_aox_position_estimation_WriteAttributes);
  }

  return SL_STATUS_OK;
}



void uic_mqtt_dotdot_set_group_dispatch_callback(group_dispatch_t callback)
{
  // Check for uninitialized value in order to subscribe with on_group handlers
  // only once.
  if (group_dispatch_callback == nullptr) {

    uic_mqtt_subscribe("ucl/by-group/+/Basic/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_basic_WriteAttributes);
    uic_mqtt_subscribe("ucl/by-group/+/Basic/Commands/ResetToFactoryDefaults", uic_mqtt_dotdot_on_by_group_basic_reset_to_factory_defaults);

    uic_mqtt_subscribe("ucl/by-group/+/PowerConfiguration/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_power_configuration_WriteAttributes);

    uic_mqtt_subscribe("ucl/by-group/+/DeviceTemperatureConfiguration/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_device_temperature_configuration_WriteAttributes);

    uic_mqtt_subscribe("ucl/by-group/+/Identify/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_identify_WriteAttributes);
    uic_mqtt_subscribe("ucl/by-group/+/Identify/Commands/Identify", uic_mqtt_dotdot_on_by_group_identify_identify);
    uic_mqtt_subscribe("ucl/by-group/+/Identify/Commands/IdentifyQueryResponse", uic_mqtt_dotdot_on_by_group_identify_identify_query_response);
    uic_mqtt_subscribe("ucl/by-group/+/Identify/Commands/IdentifyQuery", uic_mqtt_dotdot_on_by_group_identify_identify_query);
    uic_mqtt_subscribe("ucl/by-group/+/Identify/Commands/TriggerEffect", uic_mqtt_dotdot_on_by_group_identify_trigger_effect);

    uic_mqtt_subscribe("ucl/by-group/+/Groups/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_groups_WriteAttributes);
    uic_mqtt_subscribe("ucl/by-group/+/Groups/Commands/AddGroup", uic_mqtt_dotdot_on_by_group_groups_add_group);
    uic_mqtt_subscribe("ucl/by-group/+/Groups/Commands/AddGroupResponse", uic_mqtt_dotdot_on_by_group_groups_add_group_response);
    uic_mqtt_subscribe("ucl/by-group/+/Groups/Commands/ViewGroup", uic_mqtt_dotdot_on_by_group_groups_view_group);
    uic_mqtt_subscribe("ucl/by-group/+/Groups/Commands/ViewGroupResponse", uic_mqtt_dotdot_on_by_group_groups_view_group_response);
    uic_mqtt_subscribe("ucl/by-group/+/Groups/Commands/GetGroupMembership", uic_mqtt_dotdot_on_by_group_groups_get_group_membership);
    uic_mqtt_subscribe("ucl/by-group/+/Groups/Commands/GetGroupMembershipResponse", uic_mqtt_dotdot_on_by_group_groups_get_group_membership_response);
    uic_mqtt_subscribe("ucl/by-group/+/Groups/Commands/RemoveGroup", uic_mqtt_dotdot_on_by_group_groups_remove_group);
    uic_mqtt_subscribe("ucl/by-group/+/Groups/Commands/RemoveGroupResponse", uic_mqtt_dotdot_on_by_group_groups_remove_group_response);
    uic_mqtt_subscribe("ucl/by-group/+/Groups/Commands/RemoveAllGroups", uic_mqtt_dotdot_on_by_group_groups_remove_all_groups);
    uic_mqtt_subscribe("ucl/by-group/+/Groups/Commands/AddGroupIfIdentifying", uic_mqtt_dotdot_on_by_group_groups_add_group_if_identifying);

    uic_mqtt_subscribe("ucl/by-group/+/Scenes/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_scenes_WriteAttributes);
    uic_mqtt_subscribe("ucl/by-group/+/Scenes/Commands/AddScene", uic_mqtt_dotdot_on_by_group_scenes_add_scene);
    uic_mqtt_subscribe("ucl/by-group/+/Scenes/Commands/AddSceneResponse", uic_mqtt_dotdot_on_by_group_scenes_add_scene_response);
    uic_mqtt_subscribe("ucl/by-group/+/Scenes/Commands/ViewScene", uic_mqtt_dotdot_on_by_group_scenes_view_scene);
    uic_mqtt_subscribe("ucl/by-group/+/Scenes/Commands/ViewSceneResponse", uic_mqtt_dotdot_on_by_group_scenes_view_scene_response);
    uic_mqtt_subscribe("ucl/by-group/+/Scenes/Commands/RemoveScene", uic_mqtt_dotdot_on_by_group_scenes_remove_scene);
    uic_mqtt_subscribe("ucl/by-group/+/Scenes/Commands/RemoveSceneResponse", uic_mqtt_dotdot_on_by_group_scenes_remove_scene_response);
    uic_mqtt_subscribe("ucl/by-group/+/Scenes/Commands/RemoveAllScenes", uic_mqtt_dotdot_on_by_group_scenes_remove_all_scenes);
    uic_mqtt_subscribe("ucl/by-group/+/Scenes/Commands/RemoveAllScenesResponse", uic_mqtt_dotdot_on_by_group_scenes_remove_all_scenes_response);
    uic_mqtt_subscribe("ucl/by-group/+/Scenes/Commands/StoreScene", uic_mqtt_dotdot_on_by_group_scenes_store_scene);
    uic_mqtt_subscribe("ucl/by-group/+/Scenes/Commands/StoreSceneResponse", uic_mqtt_dotdot_on_by_group_scenes_store_scene_response);
    uic_mqtt_subscribe("ucl/by-group/+/Scenes/Commands/RecallScene", uic_mqtt_dotdot_on_by_group_scenes_recall_scene);
    uic_mqtt_subscribe("ucl/by-group/+/Scenes/Commands/GetSceneMembership", uic_mqtt_dotdot_on_by_group_scenes_get_scene_membership);
    uic_mqtt_subscribe("ucl/by-group/+/Scenes/Commands/GetSceneMembershipResponse", uic_mqtt_dotdot_on_by_group_scenes_get_scene_membership_response);
    uic_mqtt_subscribe("ucl/by-group/+/Scenes/Commands/EnhancedAddScene", uic_mqtt_dotdot_on_by_group_scenes_enhanced_add_scene);
    uic_mqtt_subscribe("ucl/by-group/+/Scenes/Commands/EnhancedAddSceneResponse", uic_mqtt_dotdot_on_by_group_scenes_enhanced_add_scene_response);
    uic_mqtt_subscribe("ucl/by-group/+/Scenes/Commands/EnhancedViewScene", uic_mqtt_dotdot_on_by_group_scenes_enhanced_view_scene);
    uic_mqtt_subscribe("ucl/by-group/+/Scenes/Commands/EnhancedViewSceneResponse", uic_mqtt_dotdot_on_by_group_scenes_enhanced_view_scene_response);
    uic_mqtt_subscribe("ucl/by-group/+/Scenes/Commands/CopyScene", uic_mqtt_dotdot_on_by_group_scenes_copy_scene);
    uic_mqtt_subscribe("ucl/by-group/+/Scenes/Commands/CopySceneResponse", uic_mqtt_dotdot_on_by_group_scenes_copy_scene_response);

    uic_mqtt_subscribe("ucl/by-group/+/OnOff/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_on_off_WriteAttributes);
    uic_mqtt_subscribe("ucl/by-group/+/OnOff/Commands/Off", uic_mqtt_dotdot_on_by_group_on_off_off);
    uic_mqtt_subscribe("ucl/by-group/+/OnOff/Commands/On", uic_mqtt_dotdot_on_by_group_on_off_on);
    uic_mqtt_subscribe("ucl/by-group/+/OnOff/Commands/Toggle", uic_mqtt_dotdot_on_by_group_on_off_toggle);
    uic_mqtt_subscribe("ucl/by-group/+/OnOff/Commands/OffWithEffect", uic_mqtt_dotdot_on_by_group_on_off_off_with_effect);
    uic_mqtt_subscribe("ucl/by-group/+/OnOff/Commands/OnWithRecallGlobalScene", uic_mqtt_dotdot_on_by_group_on_off_on_with_recall_global_scene);
    uic_mqtt_subscribe("ucl/by-group/+/OnOff/Commands/OnWithTimedOff", uic_mqtt_dotdot_on_by_group_on_off_on_with_timed_off);

    uic_mqtt_subscribe("ucl/by-group/+/Level/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_level_WriteAttributes);
    uic_mqtt_subscribe("ucl/by-group/+/Level/Commands/MoveToLevel", uic_mqtt_dotdot_on_by_group_level_move_to_level);
    uic_mqtt_subscribe("ucl/by-group/+/Level/Commands/Move", uic_mqtt_dotdot_on_by_group_level_move);
    uic_mqtt_subscribe("ucl/by-group/+/Level/Commands/Step", uic_mqtt_dotdot_on_by_group_level_step);
    uic_mqtt_subscribe("ucl/by-group/+/Level/Commands/Stop", uic_mqtt_dotdot_on_by_group_level_stop);
    uic_mqtt_subscribe("ucl/by-group/+/Level/Commands/MoveToLevelWithOnOff", uic_mqtt_dotdot_on_by_group_level_move_to_level_with_on_off);
    uic_mqtt_subscribe("ucl/by-group/+/Level/Commands/MoveWithOnOff", uic_mqtt_dotdot_on_by_group_level_move_with_on_off);
    uic_mqtt_subscribe("ucl/by-group/+/Level/Commands/StepWithOnOff", uic_mqtt_dotdot_on_by_group_level_step_with_on_off);
    uic_mqtt_subscribe("ucl/by-group/+/Level/Commands/StopWithOnOff", uic_mqtt_dotdot_on_by_group_level_stop_with_on_off);
    uic_mqtt_subscribe("ucl/by-group/+/Level/Commands/MoveToClosestFrequency", uic_mqtt_dotdot_on_by_group_level_move_to_closest_frequency);

    uic_mqtt_subscribe("ucl/by-group/+/Alarms/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_alarms_WriteAttributes);
    uic_mqtt_subscribe("ucl/by-group/+/Alarms/Commands/ResetAlarm", uic_mqtt_dotdot_on_by_group_alarms_reset_alarm);
    uic_mqtt_subscribe("ucl/by-group/+/Alarms/Commands/Alarm", uic_mqtt_dotdot_on_by_group_alarms_alarm);
    uic_mqtt_subscribe("ucl/by-group/+/Alarms/Commands/ResetAllAlarms", uic_mqtt_dotdot_on_by_group_alarms_reset_all_alarms);
    uic_mqtt_subscribe("ucl/by-group/+/Alarms/Commands/GetAlarmResponse", uic_mqtt_dotdot_on_by_group_alarms_get_alarm_response);
    uic_mqtt_subscribe("ucl/by-group/+/Alarms/Commands/GetAlarm", uic_mqtt_dotdot_on_by_group_alarms_get_alarm);
    uic_mqtt_subscribe("ucl/by-group/+/Alarms/Commands/ResetAlarmLog", uic_mqtt_dotdot_on_by_group_alarms_reset_alarm_log);

    uic_mqtt_subscribe("ucl/by-group/+/Time/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_time_WriteAttributes);

    uic_mqtt_subscribe("ucl/by-group/+/OTAUpgrade/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_ota_upgrade_WriteAttributes);
    uic_mqtt_subscribe("ucl/by-group/+/OTAUpgrade/Commands/ImageNotify", uic_mqtt_dotdot_on_by_group_ota_upgrade_image_notify);
    uic_mqtt_subscribe("ucl/by-group/+/OTAUpgrade/Commands/QueryNextImageRequest", uic_mqtt_dotdot_on_by_group_ota_upgrade_query_next_image_request);
    uic_mqtt_subscribe("ucl/by-group/+/OTAUpgrade/Commands/QueryNextImageResponse", uic_mqtt_dotdot_on_by_group_ota_upgrade_query_next_image_response);
    uic_mqtt_subscribe("ucl/by-group/+/OTAUpgrade/Commands/ImageBlockRequest", uic_mqtt_dotdot_on_by_group_ota_upgrade_image_block_request);
    uic_mqtt_subscribe("ucl/by-group/+/OTAUpgrade/Commands/ImagePageRequest", uic_mqtt_dotdot_on_by_group_ota_upgrade_image_page_request);
    uic_mqtt_subscribe("ucl/by-group/+/OTAUpgrade/Commands/ImageBlockResponse", uic_mqtt_dotdot_on_by_group_ota_upgrade_image_block_response);
    uic_mqtt_subscribe("ucl/by-group/+/OTAUpgrade/Commands/UpgradeEndRequest", uic_mqtt_dotdot_on_by_group_ota_upgrade_upgrade_end_request);
    uic_mqtt_subscribe("ucl/by-group/+/OTAUpgrade/Commands/UpgradeEndResponse", uic_mqtt_dotdot_on_by_group_ota_upgrade_upgrade_end_response);
    uic_mqtt_subscribe("ucl/by-group/+/OTAUpgrade/Commands/QueryDeviceSpecificFileRequest", uic_mqtt_dotdot_on_by_group_ota_upgrade_query_device_specific_file_request);
    uic_mqtt_subscribe("ucl/by-group/+/OTAUpgrade/Commands/QueryDeviceSpecificFileResponse", uic_mqtt_dotdot_on_by_group_ota_upgrade_query_device_specific_file_response);

    uic_mqtt_subscribe("ucl/by-group/+/PollControl/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_poll_control_WriteAttributes);
    uic_mqtt_subscribe("ucl/by-group/+/PollControl/Commands/CheckIn", uic_mqtt_dotdot_on_by_group_poll_control_check_in);
    uic_mqtt_subscribe("ucl/by-group/+/PollControl/Commands/CheckInResponse", uic_mqtt_dotdot_on_by_group_poll_control_check_in_response);
    uic_mqtt_subscribe("ucl/by-group/+/PollControl/Commands/FastPollStop", uic_mqtt_dotdot_on_by_group_poll_control_fast_poll_stop);
    uic_mqtt_subscribe("ucl/by-group/+/PollControl/Commands/SetLongPollInterval", uic_mqtt_dotdot_on_by_group_poll_control_set_long_poll_interval);
    uic_mqtt_subscribe("ucl/by-group/+/PollControl/Commands/SetShortPollInterval", uic_mqtt_dotdot_on_by_group_poll_control_set_short_poll_interval);

    uic_mqtt_subscribe("ucl/by-group/+/ShadeConfiguration/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_shade_configuration_WriteAttributes);

    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_door_lock_WriteAttributes);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/LockDoor", uic_mqtt_dotdot_on_by_group_door_lock_lock_door);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/LockDoorResponse", uic_mqtt_dotdot_on_by_group_door_lock_lock_door_response);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/UnlockDoor", uic_mqtt_dotdot_on_by_group_door_lock_unlock_door);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/UnlockDoorResponse", uic_mqtt_dotdot_on_by_group_door_lock_unlock_door_response);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/Toggle", uic_mqtt_dotdot_on_by_group_door_lock_toggle);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/ToggleResponse", uic_mqtt_dotdot_on_by_group_door_lock_toggle_response);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/UnlockWithTimeout", uic_mqtt_dotdot_on_by_group_door_lock_unlock_with_timeout);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/UnlockWithTimeoutResponse", uic_mqtt_dotdot_on_by_group_door_lock_unlock_with_timeout_response);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/GetLogRecord", uic_mqtt_dotdot_on_by_group_door_lock_get_log_record);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/GetLogRecordResponse", uic_mqtt_dotdot_on_by_group_door_lock_get_log_record_response);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/SetPINCode", uic_mqtt_dotdot_on_by_group_door_lock_setpin_code);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/SetPINCodeResponse", uic_mqtt_dotdot_on_by_group_door_lock_setpin_code_response);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/GetPINCode", uic_mqtt_dotdot_on_by_group_door_lock_getpin_code);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/GetPINCodeResponse", uic_mqtt_dotdot_on_by_group_door_lock_getpin_code_response);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/ClearPINCode", uic_mqtt_dotdot_on_by_group_door_lock_clearpin_code);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/ClearPINCodeResponse", uic_mqtt_dotdot_on_by_group_door_lock_clearpin_code_response);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/ClearAllPINCodes", uic_mqtt_dotdot_on_by_group_door_lock_clear_allpin_codes);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/ClearAllPINCodesResponse", uic_mqtt_dotdot_on_by_group_door_lock_clear_allpin_codes_response);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/SetUserStatus", uic_mqtt_dotdot_on_by_group_door_lock_set_user_status);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/SetUserStatusResponse", uic_mqtt_dotdot_on_by_group_door_lock_set_user_status_response);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/GetUserStatus", uic_mqtt_dotdot_on_by_group_door_lock_get_user_status);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/GetUserStatusResponse", uic_mqtt_dotdot_on_by_group_door_lock_get_user_status_response);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/SetWeekdaySchedule", uic_mqtt_dotdot_on_by_group_door_lock_set_weekday_schedule);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/SetWeekdayScheduleResponse", uic_mqtt_dotdot_on_by_group_door_lock_set_weekday_schedule_response);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/GetWeekdaySchedule", uic_mqtt_dotdot_on_by_group_door_lock_get_weekday_schedule);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/GetWeekdayScheduleResponse", uic_mqtt_dotdot_on_by_group_door_lock_get_weekday_schedule_response);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/ClearWeekdaySchedule", uic_mqtt_dotdot_on_by_group_door_lock_clear_weekday_schedule);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/ClearWeekdayScheduleResponse", uic_mqtt_dotdot_on_by_group_door_lock_clear_weekday_schedule_response);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/SetYearDaySchedule", uic_mqtt_dotdot_on_by_group_door_lock_set_year_day_schedule);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/SetYearDayScheduleResponse", uic_mqtt_dotdot_on_by_group_door_lock_set_year_day_schedule_response);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/GetYearDaySchedule", uic_mqtt_dotdot_on_by_group_door_lock_get_year_day_schedule);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/GetYearDayScheduleResponse", uic_mqtt_dotdot_on_by_group_door_lock_get_year_day_schedule_response);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/ClearYearDaySchedule", uic_mqtt_dotdot_on_by_group_door_lock_clear_year_day_schedule);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/ClearYearDayScheduleResponse", uic_mqtt_dotdot_on_by_group_door_lock_clear_year_day_schedule_response);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/SetHolidaySchedule", uic_mqtt_dotdot_on_by_group_door_lock_set_holiday_schedule);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/SetHolidayScheduleResponse", uic_mqtt_dotdot_on_by_group_door_lock_set_holiday_schedule_response);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/GetHolidaySchedule", uic_mqtt_dotdot_on_by_group_door_lock_get_holiday_schedule);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/GetHolidayScheduleResponse", uic_mqtt_dotdot_on_by_group_door_lock_get_holiday_schedule_response);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/ClearHolidaySchedule", uic_mqtt_dotdot_on_by_group_door_lock_clear_holiday_schedule);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/ClearHolidayScheduleResponse", uic_mqtt_dotdot_on_by_group_door_lock_clear_holiday_schedule_response);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/SetUserType", uic_mqtt_dotdot_on_by_group_door_lock_set_user_type);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/SetUserTypeResponse", uic_mqtt_dotdot_on_by_group_door_lock_set_user_type_response);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/GetUserType", uic_mqtt_dotdot_on_by_group_door_lock_get_user_type);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/GetUserTypeResponse", uic_mqtt_dotdot_on_by_group_door_lock_get_user_type_response);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/SetRFIDCode", uic_mqtt_dotdot_on_by_group_door_lock_setrfid_code);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/SetRFIDCodeResponse", uic_mqtt_dotdot_on_by_group_door_lock_setrfid_code_response);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/GetRFIDCode", uic_mqtt_dotdot_on_by_group_door_lock_getrfid_code);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/GetRFIDCodeResponse", uic_mqtt_dotdot_on_by_group_door_lock_getrfid_code_response);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/ClearRFIDCode", uic_mqtt_dotdot_on_by_group_door_lock_clearrfid_code);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/ClearRFIDCodeResponse", uic_mqtt_dotdot_on_by_group_door_lock_clearrfid_code_response);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/ClearAllRFIDCodes", uic_mqtt_dotdot_on_by_group_door_lock_clear_allrfid_codes);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/ClearAllRFIDCodesResponse", uic_mqtt_dotdot_on_by_group_door_lock_clear_allrfid_codes_response);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/OperatingEventNotification", uic_mqtt_dotdot_on_by_group_door_lock_operating_event_notification);
    uic_mqtt_subscribe("ucl/by-group/+/DoorLock/Commands/ProgrammingEventNotification", uic_mqtt_dotdot_on_by_group_door_lock_programming_event_notification);

    uic_mqtt_subscribe("ucl/by-group/+/WindowCovering/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_window_covering_WriteAttributes);
    uic_mqtt_subscribe("ucl/by-group/+/WindowCovering/Commands/UpOrOpen", uic_mqtt_dotdot_on_by_group_window_covering_up_or_open);
    uic_mqtt_subscribe("ucl/by-group/+/WindowCovering/Commands/DownOrClose", uic_mqtt_dotdot_on_by_group_window_covering_down_or_close);
    uic_mqtt_subscribe("ucl/by-group/+/WindowCovering/Commands/Stop", uic_mqtt_dotdot_on_by_group_window_covering_stop);
    uic_mqtt_subscribe("ucl/by-group/+/WindowCovering/Commands/GoToLiftValue", uic_mqtt_dotdot_on_by_group_window_covering_go_to_lift_value);
    uic_mqtt_subscribe("ucl/by-group/+/WindowCovering/Commands/GoToLiftPercentage", uic_mqtt_dotdot_on_by_group_window_covering_go_to_lift_percentage);
    uic_mqtt_subscribe("ucl/by-group/+/WindowCovering/Commands/GoToTiltValue", uic_mqtt_dotdot_on_by_group_window_covering_go_to_tilt_value);
    uic_mqtt_subscribe("ucl/by-group/+/WindowCovering/Commands/GoToTiltPercentage", uic_mqtt_dotdot_on_by_group_window_covering_go_to_tilt_percentage);

    uic_mqtt_subscribe("ucl/by-group/+/BarrierControl/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_barrier_control_WriteAttributes);
    uic_mqtt_subscribe("ucl/by-group/+/BarrierControl/Commands/GoToPercent", uic_mqtt_dotdot_on_by_group_barrier_control_go_to_percent);
    uic_mqtt_subscribe("ucl/by-group/+/BarrierControl/Commands/Stop", uic_mqtt_dotdot_on_by_group_barrier_control_stop);

    uic_mqtt_subscribe("ucl/by-group/+/PumpConfigurationAndControl/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_pump_configuration_and_control_WriteAttributes);

    uic_mqtt_subscribe("ucl/by-group/+/Thermostat/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_thermostat_WriteAttributes);
    uic_mqtt_subscribe("ucl/by-group/+/Thermostat/Commands/SetpointRaiseOrLower", uic_mqtt_dotdot_on_by_group_thermostat_setpoint_raise_or_lower);
    uic_mqtt_subscribe("ucl/by-group/+/Thermostat/Commands/GetWeeklyScheduleResponse", uic_mqtt_dotdot_on_by_group_thermostat_get_weekly_schedule_response);
    uic_mqtt_subscribe("ucl/by-group/+/Thermostat/Commands/SetWeeklySchedule", uic_mqtt_dotdot_on_by_group_thermostat_set_weekly_schedule);
    uic_mqtt_subscribe("ucl/by-group/+/Thermostat/Commands/GetRelayStatusLogResponse", uic_mqtt_dotdot_on_by_group_thermostat_get_relay_status_log_response);
    uic_mqtt_subscribe("ucl/by-group/+/Thermostat/Commands/GetWeeklySchedule", uic_mqtt_dotdot_on_by_group_thermostat_get_weekly_schedule);
    uic_mqtt_subscribe("ucl/by-group/+/Thermostat/Commands/ClearWeeklySchedule", uic_mqtt_dotdot_on_by_group_thermostat_clear_weekly_schedule);
    uic_mqtt_subscribe("ucl/by-group/+/Thermostat/Commands/GetRelayStatusLog", uic_mqtt_dotdot_on_by_group_thermostat_get_relay_status_log);

    uic_mqtt_subscribe("ucl/by-group/+/FanControl/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_fan_control_WriteAttributes);

    uic_mqtt_subscribe("ucl/by-group/+/DehumidificationControl/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_dehumidification_control_WriteAttributes);

    uic_mqtt_subscribe("ucl/by-group/+/ThermostatUserInterfaceConfiguration/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_thermostat_user_interface_configuration_WriteAttributes);

    uic_mqtt_subscribe("ucl/by-group/+/ColorControl/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_color_control_WriteAttributes);
    uic_mqtt_subscribe("ucl/by-group/+/ColorControl/Commands/MoveToHue", uic_mqtt_dotdot_on_by_group_color_control_move_to_hue);
    uic_mqtt_subscribe("ucl/by-group/+/ColorControl/Commands/MoveHue", uic_mqtt_dotdot_on_by_group_color_control_move_hue);
    uic_mqtt_subscribe("ucl/by-group/+/ColorControl/Commands/StepHue", uic_mqtt_dotdot_on_by_group_color_control_step_hue);
    uic_mqtt_subscribe("ucl/by-group/+/ColorControl/Commands/MoveToSaturation", uic_mqtt_dotdot_on_by_group_color_control_move_to_saturation);
    uic_mqtt_subscribe("ucl/by-group/+/ColorControl/Commands/MoveSaturation", uic_mqtt_dotdot_on_by_group_color_control_move_saturation);
    uic_mqtt_subscribe("ucl/by-group/+/ColorControl/Commands/StepSaturation", uic_mqtt_dotdot_on_by_group_color_control_step_saturation);
    uic_mqtt_subscribe("ucl/by-group/+/ColorControl/Commands/MoveToHueAndSaturation", uic_mqtt_dotdot_on_by_group_color_control_move_to_hue_and_saturation);
    uic_mqtt_subscribe("ucl/by-group/+/ColorControl/Commands/MoveToColor", uic_mqtt_dotdot_on_by_group_color_control_move_to_color);
    uic_mqtt_subscribe("ucl/by-group/+/ColorControl/Commands/MoveColor", uic_mqtt_dotdot_on_by_group_color_control_move_color);
    uic_mqtt_subscribe("ucl/by-group/+/ColorControl/Commands/StepColor", uic_mqtt_dotdot_on_by_group_color_control_step_color);
    uic_mqtt_subscribe("ucl/by-group/+/ColorControl/Commands/MoveToColorTemperature", uic_mqtt_dotdot_on_by_group_color_control_move_to_color_temperature);
    uic_mqtt_subscribe("ucl/by-group/+/ColorControl/Commands/EnhancedMoveToHue", uic_mqtt_dotdot_on_by_group_color_control_enhanced_move_to_hue);
    uic_mqtt_subscribe("ucl/by-group/+/ColorControl/Commands/EnhancedMoveHue", uic_mqtt_dotdot_on_by_group_color_control_enhanced_move_hue);
    uic_mqtt_subscribe("ucl/by-group/+/ColorControl/Commands/EnhancedStepHue", uic_mqtt_dotdot_on_by_group_color_control_enhanced_step_hue);
    uic_mqtt_subscribe("ucl/by-group/+/ColorControl/Commands/EnhancedMoveToHueAndSaturation", uic_mqtt_dotdot_on_by_group_color_control_enhanced_move_to_hue_and_saturation);
    uic_mqtt_subscribe("ucl/by-group/+/ColorControl/Commands/ColorLoopSet", uic_mqtt_dotdot_on_by_group_color_control_color_loop_set);
    uic_mqtt_subscribe("ucl/by-group/+/ColorControl/Commands/StopMoveStep", uic_mqtt_dotdot_on_by_group_color_control_stop_move_step);
    uic_mqtt_subscribe("ucl/by-group/+/ColorControl/Commands/MoveColorTemperature", uic_mqtt_dotdot_on_by_group_color_control_move_color_temperature);
    uic_mqtt_subscribe("ucl/by-group/+/ColorControl/Commands/StepColorTemperature", uic_mqtt_dotdot_on_by_group_color_control_step_color_temperature);

    uic_mqtt_subscribe("ucl/by-group/+/BallastConfiguration/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_ballast_configuration_WriteAttributes);

    uic_mqtt_subscribe("ucl/by-group/+/IlluminanceMeasurement/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_illuminance_measurement_WriteAttributes);

    uic_mqtt_subscribe("ucl/by-group/+/IlluminanceLevelSensing/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_illuminance_level_sensing_WriteAttributes);

    uic_mqtt_subscribe("ucl/by-group/+/TemperatureMeasurement/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_temperature_measurement_WriteAttributes);

    uic_mqtt_subscribe("ucl/by-group/+/PressureMeasurement/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_pressure_measurement_WriteAttributes);

    uic_mqtt_subscribe("ucl/by-group/+/FlowMeasurement/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_flow_measurement_WriteAttributes);

    uic_mqtt_subscribe("ucl/by-group/+/RelativityHumidity/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_relativity_humidity_WriteAttributes);

    uic_mqtt_subscribe("ucl/by-group/+/OccupancySensing/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_occupancy_sensing_WriteAttributes);

    uic_mqtt_subscribe("ucl/by-group/+/PhMeasurement/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_ph_measurement_WriteAttributes);

    uic_mqtt_subscribe("ucl/by-group/+/ElectricalConductivityMeasurement/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_electrical_conductivity_measurement_WriteAttributes);

    uic_mqtt_subscribe("ucl/by-group/+/WindSpeedMeasurement/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_wind_speed_measurement_WriteAttributes);

    uic_mqtt_subscribe("ucl/by-group/+/CarbonMonoxide/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_carbon_monoxide_WriteAttributes);

    uic_mqtt_subscribe("ucl/by-group/+/IASZone/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_ias_zone_WriteAttributes);
    uic_mqtt_subscribe("ucl/by-group/+/IASZone/Commands/ZoneEnrollResponse", uic_mqtt_dotdot_on_by_group_ias_zone_zone_enroll_response);
    uic_mqtt_subscribe("ucl/by-group/+/IASZone/Commands/ZoneStatusChangeNotification", uic_mqtt_dotdot_on_by_group_ias_zone_zone_status_change_notification);
    uic_mqtt_subscribe("ucl/by-group/+/IASZone/Commands/InitiateNormalOperationMode", uic_mqtt_dotdot_on_by_group_ias_zone_initiate_normal_operation_mode);
    uic_mqtt_subscribe("ucl/by-group/+/IASZone/Commands/ZoneEnrollRequest", uic_mqtt_dotdot_on_by_group_ias_zone_zone_enroll_request);
    uic_mqtt_subscribe("ucl/by-group/+/IASZone/Commands/InitiateTestMode", uic_mqtt_dotdot_on_by_group_ias_zone_initiate_test_mode);

    uic_mqtt_subscribe("ucl/by-group/+/IASWD/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_iaswd_WriteAttributes);
    uic_mqtt_subscribe("ucl/by-group/+/IASWD/Commands/StartWarning", uic_mqtt_dotdot_on_by_group_iaswd_start_warning);
    uic_mqtt_subscribe("ucl/by-group/+/IASWD/Commands/Squawk", uic_mqtt_dotdot_on_by_group_iaswd_squawk);

    uic_mqtt_subscribe("ucl/by-group/+/Metering/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_metering_WriteAttributes);

    uic_mqtt_subscribe("ucl/by-group/+/ElectricalMeasurement/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_electrical_measurement_WriteAttributes);
    uic_mqtt_subscribe("ucl/by-group/+/ElectricalMeasurement/Commands/GetProfileInfoResponse", uic_mqtt_dotdot_on_by_group_electrical_measurement_get_profile_info_response);
    uic_mqtt_subscribe("ucl/by-group/+/ElectricalMeasurement/Commands/GetProfileInfo", uic_mqtt_dotdot_on_by_group_electrical_measurement_get_profile_info);
    uic_mqtt_subscribe("ucl/by-group/+/ElectricalMeasurement/Commands/GetMeasurementProfileResponse", uic_mqtt_dotdot_on_by_group_electrical_measurement_get_measurement_profile_response);
    uic_mqtt_subscribe("ucl/by-group/+/ElectricalMeasurement/Commands/GetMeasurementProfile", uic_mqtt_dotdot_on_by_group_electrical_measurement_get_measurement_profile);

    uic_mqtt_subscribe("ucl/by-group/+/Diagnostics/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_diagnostics_WriteAttributes);

    uic_mqtt_subscribe("ucl/by-group/+/Binding/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_binding_WriteAttributes);
    uic_mqtt_subscribe("ucl/by-group/+/Binding/Commands/Bind", uic_mqtt_dotdot_on_by_group_binding_bind);
    uic_mqtt_subscribe("ucl/by-group/+/Binding/Commands/Unbind", uic_mqtt_dotdot_on_by_group_binding_unbind);
    uic_mqtt_subscribe("ucl/by-group/+/Binding/Commands/BindToProtocolController", uic_mqtt_dotdot_on_by_group_binding_bind_to_protocol_controller);
    uic_mqtt_subscribe("ucl/by-group/+/Binding/Commands/UnbindFromProtocolController", uic_mqtt_dotdot_on_by_group_binding_unbind_from_protocol_controller);

    uic_mqtt_subscribe("ucl/by-group/+/NameAndLocation/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_name_and_location_WriteAttributes);

    uic_mqtt_subscribe("ucl/by-group/+/ConfigurationParameters/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_configuration_parameters_WriteAttributes);
    uic_mqtt_subscribe("ucl/by-group/+/ConfigurationParameters/Commands/DiscoverParameter", uic_mqtt_dotdot_on_by_group_configuration_parameters_discover_parameter);
    uic_mqtt_subscribe("ucl/by-group/+/ConfigurationParameters/Commands/DefaultResetAllParameters", uic_mqtt_dotdot_on_by_group_configuration_parameters_default_reset_all_parameters);
    uic_mqtt_subscribe("ucl/by-group/+/ConfigurationParameters/Commands/SetParameter", uic_mqtt_dotdot_on_by_group_configuration_parameters_set_parameter);
    uic_mqtt_subscribe("ucl/by-group/+/ConfigurationParameters/Commands/DiscoverParameterRange", uic_mqtt_dotdot_on_by_group_configuration_parameters_discover_parameter_range);

    uic_mqtt_subscribe("ucl/by-group/+/AoXLocator/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_aox_locator_WriteAttributes);
    uic_mqtt_subscribe("ucl/by-group/+/AoXLocator/Commands/IQReport", uic_mqtt_dotdot_on_by_group_aox_locator_iq_report);
    uic_mqtt_subscribe("ucl/by-group/+/AoXLocator/Commands/AngleReport", uic_mqtt_dotdot_on_by_group_aox_locator_angle_report);
    uic_mqtt_subscribe("ucl/by-group/+/AoXLocator/Commands/AngleCorrection", uic_mqtt_dotdot_on_by_group_aox_locator_angle_correction);

    uic_mqtt_subscribe("ucl/by-group/+/AoXPositionEstimation/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_aox_position_estimation_WriteAttributes);

  }

  group_dispatch_callback = callback;

}
