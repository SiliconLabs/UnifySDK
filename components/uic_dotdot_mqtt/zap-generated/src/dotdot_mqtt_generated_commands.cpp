/******************************************************************************
 * # License
 * <b>Copyright 2021 Silicon Laboratories Inc. www.silabs.com</b>
 ******************************************************************************
 * The licensor of this software is Silicon Laboratories Inc. Your use of this
 * software is governed by the terms of Silicon Labs Master Software License
 * Agreement (MSLA) available at
 * www.silabs.com/about-us/legal/master-software-license-agreement. This
 * software is distributed to you in Source Code format and is governed by the
 * sections of the MSLA applicable to Source Code.
 *
 *****************************************************************************/

// This file is generated by ZCL Advanced Platform generator. Please don't edit manually.

#include "uic_mqtt.h"
#include "json_helpers.hpp"

#include "dotdot_mqtt.hpp"
#include "dotdot_mqtt_generated_commands.h"
#include "dotdot_mqtt_command_helpers.hpp"

////////////////////////////////////////////////////////////////////////////////
// Generated Commands publications functions
////////////////////////////////////////////////////////////////////////////////
/**
 * @brief Publishes an incoming/generated ResetToFactoryDefaults command for
 * the Basic cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Basic/GeneratedCommands/ResetToFactoryDefaults
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_basic_publish_generated_reset_to_factory_defaults_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Basic/GeneratedCommands/ResetToFactoryDefaults";

  std::string payload =
    get_json_payload_for_basic_reset_to_factory_defaults_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}


/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the Basic cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Basic/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_basic_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_basic_state_t attribute_values,
  uic_mqtt_dotdot_basic_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Basic/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  if (attribute_list.location_description == true) {

  // This is a single value

  json_object["LocationDescription"] = std::string(attribute_values.location_description);


  }


  if (attribute_list.physical_environment == true) {

  // This is a single value

  #ifdef BASIC_PHYSICAL_ENVIRONMENT_ENUM_NAME_AVAILABLE
  json_object["PhysicalEnvironment"] = basic_physical_environment_get_enum_value_name((uint32_t)attribute_values.physical_environment);
  #else
  json_object["PhysicalEnvironment"] = static_cast<BasicPhysicalEnvironment>(attribute_values.physical_environment);
  #endif


  }


  if (attribute_list.device_enabled == true) {

  // This is a single value

  json_object["DeviceEnabled"] = attribute_values.device_enabled;


  }


  if (attribute_list.alarm_mask == true) {

  // This is a single value

  nlohmann::json bitmap_values = BasicAlarmMask.get_bitmap_values_as_json_tree((uint32_t)attribute_values.alarm_mask);
  json_object["AlarmMask"] = bitmap_values;


  }


  if (attribute_list.disable_local_config == true) {

  // This is a single value

  nlohmann::json bitmap_values = BasicDisableLocalConfig.get_bitmap_values_as_json_tree((uint32_t)attribute_values.disable_local_config);
  json_object["DisableLocalConfig"] = bitmap_values;


  }


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}



/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the PowerConfiguration cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/PowerConfiguration/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_power_configuration_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_power_configuration_state_t attribute_values,
  uic_mqtt_dotdot_power_configuration_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "PowerConfiguration/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  if (attribute_list.mains_alarm_mask == true) {

  // This is a single value

  nlohmann::json bitmap_values = PowerConfigurationMainsAlarmMask.get_bitmap_values_as_json_tree((uint32_t)attribute_values.mains_alarm_mask);
  json_object["MainsAlarmMask"] = bitmap_values;


  }


  if (attribute_list.mains_voltage_min_threshold == true) {

  // This is a single value

  json_object["MainsVoltageMinThreshold"] = attribute_values.mains_voltage_min_threshold;


  }


  if (attribute_list.mains_voltage_max_threshold == true) {

  // This is a single value

  json_object["MainsVoltageMaxThreshold"] = attribute_values.mains_voltage_max_threshold;


  }


  if (attribute_list.mains_voltage_dwell_trip_point == true) {

  // This is a single value

  json_object["MainsVoltageDwellTripPoint"] = attribute_values.mains_voltage_dwell_trip_point;


  }


  if (attribute_list.battery_manufacturer == true) {

  // This is a single value

  json_object["BatteryManufacturer"] = std::string(attribute_values.battery_manufacturer);


  }


  if (attribute_list.battery_size == true) {

  // This is a single value

  #ifdef POWER_CONFIGURATION_BATTERY_SIZE_ENUM_NAME_AVAILABLE
  json_object["BatterySize"] = power_configuration_battery_size_get_enum_value_name((uint32_t)attribute_values.battery_size);
  #else
  json_object["BatterySize"] = static_cast<BatterySize>(attribute_values.battery_size);
  #endif


  }


  if (attribute_list.batterya_hr_rating == true) {

  // This is a single value

  json_object["BatteryAHrRating"] = attribute_values.batterya_hr_rating;


  }


  if (attribute_list.battery_quantity == true) {

  // This is a single value

  json_object["BatteryQuantity"] = attribute_values.battery_quantity;


  }


  if (attribute_list.battery_rated_voltage == true) {

  // This is a single value

  json_object["BatteryRatedVoltage"] = attribute_values.battery_rated_voltage;


  }


  if (attribute_list.battery_alarm_mask == true) {

  // This is a single value

  nlohmann::json bitmap_values = BatteryAlarmMask.get_bitmap_values_as_json_tree((uint32_t)attribute_values.battery_alarm_mask);
  json_object["BatteryAlarmMask"] = bitmap_values;


  }


  if (attribute_list.battery_voltage_min_threshold == true) {

  // This is a single value

  json_object["BatteryVoltageMinThreshold"] = attribute_values.battery_voltage_min_threshold;


  }


  if (attribute_list.battery_voltage_threshold1 == true) {

  // This is a single value

  json_object["BatteryVoltageThreshold1"] = attribute_values.battery_voltage_threshold1;


  }


  if (attribute_list.battery_voltage_threshold2 == true) {

  // This is a single value

  json_object["BatteryVoltageThreshold2"] = attribute_values.battery_voltage_threshold2;


  }


  if (attribute_list.battery_voltage_threshold3 == true) {

  // This is a single value

  json_object["BatteryVoltageThreshold3"] = attribute_values.battery_voltage_threshold3;


  }


  if (attribute_list.battery_percentage_min_threshold == true) {

  // This is a single value

  json_object["BatteryPercentageMinThreshold"] = attribute_values.battery_percentage_min_threshold;


  }


  if (attribute_list.battery_percentage_threshold1 == true) {

  // This is a single value

  json_object["BatteryPercentageThreshold1"] = attribute_values.battery_percentage_threshold1;


  }


  if (attribute_list.battery_percentage_threshold2 == true) {

  // This is a single value

  json_object["BatteryPercentageThreshold2"] = attribute_values.battery_percentage_threshold2;


  }


  if (attribute_list.battery_percentage_threshold3 == true) {

  // This is a single value

  json_object["BatteryPercentageThreshold3"] = attribute_values.battery_percentage_threshold3;


  }


  if (attribute_list.battery2_manufacturer == true) {

  // This is a single value

  json_object["Battery2Manufacturer"] = std::string(attribute_values.battery2_manufacturer);


  }


  if (attribute_list.battery2_size == true) {

  // This is a single value

  #ifdef POWER_CONFIGURATION_BATTERY2_SIZE_ENUM_NAME_AVAILABLE
  json_object["Battery2Size"] = power_configuration_battery2_size_get_enum_value_name((uint32_t)attribute_values.battery2_size);
  #else
  json_object["Battery2Size"] = static_cast<BatterySize>(attribute_values.battery2_size);
  #endif


  }


  if (attribute_list.battery2a_hr_rating == true) {

  // This is a single value

  json_object["Battery2AHrRating"] = attribute_values.battery2a_hr_rating;


  }


  if (attribute_list.battery2_quantity == true) {

  // This is a single value

  json_object["Battery2Quantity"] = attribute_values.battery2_quantity;


  }


  if (attribute_list.battery2_rated_voltage == true) {

  // This is a single value

  json_object["Battery2RatedVoltage"] = attribute_values.battery2_rated_voltage;


  }


  if (attribute_list.battery2_alarm_mask == true) {

  // This is a single value

  nlohmann::json bitmap_values = BatteryAlarmMask.get_bitmap_values_as_json_tree((uint32_t)attribute_values.battery2_alarm_mask);
  json_object["Battery2AlarmMask"] = bitmap_values;


  }


  if (attribute_list.battery2_voltage_min_threshold == true) {

  // This is a single value

  json_object["Battery2VoltageMinThreshold"] = attribute_values.battery2_voltage_min_threshold;


  }


  if (attribute_list.battery2_voltage_threshold1 == true) {

  // This is a single value

  json_object["Battery2VoltageThreshold1"] = attribute_values.battery2_voltage_threshold1;


  }


  if (attribute_list.battery2_voltage_threshold2 == true) {

  // This is a single value

  json_object["Battery2VoltageThreshold2"] = attribute_values.battery2_voltage_threshold2;


  }


  if (attribute_list.battery2_voltage_threshold3 == true) {

  // This is a single value

  json_object["Battery2VoltageThreshold3"] = attribute_values.battery2_voltage_threshold3;


  }


  if (attribute_list.battery2_percentage_min_threshold == true) {

  // This is a single value

  json_object["Battery2PercentageMinThreshold"] = attribute_values.battery2_percentage_min_threshold;


  }


  if (attribute_list.battery2_percentage_threshold1 == true) {

  // This is a single value

  json_object["Battery2PercentageThreshold1"] = attribute_values.battery2_percentage_threshold1;


  }


  if (attribute_list.battery2_percentage_threshold2 == true) {

  // This is a single value

  json_object["Battery2PercentageThreshold2"] = attribute_values.battery2_percentage_threshold2;


  }


  if (attribute_list.battery2_percentage_threshold3 == true) {

  // This is a single value

  json_object["Battery2PercentageThreshold3"] = attribute_values.battery2_percentage_threshold3;


  }


  if (attribute_list.battery3_manufacturer == true) {

  // This is a single value

  json_object["Battery3Manufacturer"] = std::string(attribute_values.battery3_manufacturer);


  }


  if (attribute_list.battery3_size == true) {

  // This is a single value

  #ifdef POWER_CONFIGURATION_BATTERY3_SIZE_ENUM_NAME_AVAILABLE
  json_object["Battery3Size"] = power_configuration_battery3_size_get_enum_value_name((uint32_t)attribute_values.battery3_size);
  #else
  json_object["Battery3Size"] = static_cast<BatterySize>(attribute_values.battery3_size);
  #endif


  }


  if (attribute_list.battery3a_hr_rating == true) {

  // This is a single value

  json_object["Battery3AHrRating"] = attribute_values.battery3a_hr_rating;


  }


  if (attribute_list.battery3_quantity == true) {

  // This is a single value

  json_object["Battery3Quantity"] = attribute_values.battery3_quantity;


  }


  if (attribute_list.battery3_rated_voltage == true) {

  // This is a single value

  json_object["Battery3RatedVoltage"] = attribute_values.battery3_rated_voltage;


  }


  if (attribute_list.battery3_alarm_mask == true) {

  // This is a single value

  nlohmann::json bitmap_values = BatteryAlarmMask.get_bitmap_values_as_json_tree((uint32_t)attribute_values.battery3_alarm_mask);
  json_object["Battery3AlarmMask"] = bitmap_values;


  }


  if (attribute_list.battery3_voltage_min_threshold == true) {

  // This is a single value

  json_object["Battery3VoltageMinThreshold"] = attribute_values.battery3_voltage_min_threshold;


  }


  if (attribute_list.battery3_voltage_threshold1 == true) {

  // This is a single value

  json_object["Battery3VoltageThreshold1"] = attribute_values.battery3_voltage_threshold1;


  }


  if (attribute_list.battery3_voltage_threshold2 == true) {

  // This is a single value

  json_object["Battery3VoltageThreshold2"] = attribute_values.battery3_voltage_threshold2;


  }


  if (attribute_list.battery3_voltage_threshold3 == true) {

  // This is a single value

  json_object["Battery3VoltageThreshold3"] = attribute_values.battery3_voltage_threshold3;


  }


  if (attribute_list.battery3_percentage_min_threshold == true) {

  // This is a single value

  json_object["Battery3PercentageMinThreshold"] = attribute_values.battery3_percentage_min_threshold;


  }


  if (attribute_list.battery3_percentage_threshold1 == true) {

  // This is a single value

  json_object["Battery3PercentageThreshold1"] = attribute_values.battery3_percentage_threshold1;


  }


  if (attribute_list.battery3_percentage_threshold2 == true) {

  // This is a single value

  json_object["Battery3PercentageThreshold2"] = attribute_values.battery3_percentage_threshold2;


  }


  if (attribute_list.battery3_percentage_threshold3 == true) {

  // This is a single value

  json_object["Battery3PercentageThreshold3"] = attribute_values.battery3_percentage_threshold3;


  }


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}



/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the DeviceTemperatureConfiguration cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DeviceTemperatureConfiguration/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_device_temperature_configuration_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_device_temperature_configuration_state_t attribute_values,
  uic_mqtt_dotdot_device_temperature_configuration_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DeviceTemperatureConfiguration/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  if (attribute_list.device_temp_alarm_mask == true) {

  // This is a single value

  nlohmann::json bitmap_values = DeviceTemperatureConfigurationDeviceTempAlarmMask.get_bitmap_values_as_json_tree((uint32_t)attribute_values.device_temp_alarm_mask);
  json_object["DeviceTempAlarmMask"] = bitmap_values;


  }


  if (attribute_list.low_temp_threshold == true) {

  // This is a single value

  json_object["LowTempThreshold"] = attribute_values.low_temp_threshold;


  }


  if (attribute_list.high_temp_threshold == true) {

  // This is a single value

  json_object["HighTempThreshold"] = attribute_values.high_temp_threshold;


  }


  if (attribute_list.low_temp_dwell_trip_point == true) {

  // This is a single value

  json_object["LowTempDwellTripPoint"] = attribute_values.low_temp_dwell_trip_point;


  }


  if (attribute_list.high_temp_dwell_trip_point == true) {

  // This is a single value

  json_object["HighTempDwellTripPoint"] = attribute_values.high_temp_dwell_trip_point;


  }


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Publishes an incoming/generated Identify command for
 * the Identify cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Identify/GeneratedCommands/Identify
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_identify_publish_generated_identify_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_identify_command_identify_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Identify/GeneratedCommands/Identify";

  std::string payload =
    get_json_payload_for_identify_identify_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated IdentifyQueryResponse command for
 * the Identify cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Identify/GeneratedCommands/IdentifyQueryResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_identify_publish_generated_identify_query_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_identify_command_identify_query_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Identify/GeneratedCommands/IdentifyQueryResponse";

  std::string payload =
    get_json_payload_for_identify_identify_query_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated IdentifyQuery command for
 * the Identify cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Identify/GeneratedCommands/IdentifyQuery
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_identify_publish_generated_identify_query_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Identify/GeneratedCommands/IdentifyQuery";

  std::string payload =
    get_json_payload_for_identify_identify_query_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated TriggerEffect command for
 * the Identify cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Identify/GeneratedCommands/TriggerEffect
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_identify_publish_generated_trigger_effect_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_identify_command_trigger_effect_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Identify/GeneratedCommands/TriggerEffect";

  std::string payload =
    get_json_payload_for_identify_trigger_effect_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}


/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the Identify cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Identify/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_identify_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_identify_state_t attribute_values,
  uic_mqtt_dotdot_identify_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Identify/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  if (attribute_list.identify_time == true) {

  // This is a single value

  json_object["IdentifyTime"] = attribute_values.identify_time;


  }


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Publishes an incoming/generated AddGroup command for
 * the Groups cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/GeneratedCommands/AddGroup
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_generated_add_group_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_groups_command_add_group_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Groups/GeneratedCommands/AddGroup";

  std::string payload =
    get_json_payload_for_groups_add_group_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated AddGroupResponse command for
 * the Groups cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/GeneratedCommands/AddGroupResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_generated_add_group_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_groups_command_add_group_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Groups/GeneratedCommands/AddGroupResponse";

  std::string payload =
    get_json_payload_for_groups_add_group_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ViewGroup command for
 * the Groups cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/GeneratedCommands/ViewGroup
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_generated_view_group_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_groups_command_view_group_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Groups/GeneratedCommands/ViewGroup";

  std::string payload =
    get_json_payload_for_groups_view_group_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ViewGroupResponse command for
 * the Groups cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/GeneratedCommands/ViewGroupResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_generated_view_group_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_groups_command_view_group_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Groups/GeneratedCommands/ViewGroupResponse";

  std::string payload =
    get_json_payload_for_groups_view_group_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetGroupMembership command for
 * the Groups cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/GeneratedCommands/GetGroupMembership
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_generated_get_group_membership_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_groups_command_get_group_membership_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Groups/GeneratedCommands/GetGroupMembership";

  std::string payload =
    get_json_payload_for_groups_get_group_membership_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetGroupMembershipResponse command for
 * the Groups cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/GeneratedCommands/GetGroupMembershipResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_generated_get_group_membership_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_groups_command_get_group_membership_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Groups/GeneratedCommands/GetGroupMembershipResponse";

  std::string payload =
    get_json_payload_for_groups_get_group_membership_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated RemoveGroup command for
 * the Groups cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/GeneratedCommands/RemoveGroup
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_generated_remove_group_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_groups_command_remove_group_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Groups/GeneratedCommands/RemoveGroup";

  std::string payload =
    get_json_payload_for_groups_remove_group_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated RemoveGroupResponse command for
 * the Groups cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/GeneratedCommands/RemoveGroupResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_generated_remove_group_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_groups_command_remove_group_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Groups/GeneratedCommands/RemoveGroupResponse";

  std::string payload =
    get_json_payload_for_groups_remove_group_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated RemoveAllGroups command for
 * the Groups cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/GeneratedCommands/RemoveAllGroups
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_groups_publish_generated_remove_all_groups_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Groups/GeneratedCommands/RemoveAllGroups";

  std::string payload =
    get_json_payload_for_groups_remove_all_groups_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated AddGroupIfIdentifying command for
 * the Groups cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/GeneratedCommands/AddGroupIfIdentifying
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_generated_add_group_if_identifying_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_groups_command_add_group_if_identifying_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Groups/GeneratedCommands/AddGroupIfIdentifying";

  std::string payload =
    get_json_payload_for_groups_add_group_if_identifying_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}


/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the Groups cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_groups_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_groups_state_t attribute_values,
  uic_mqtt_dotdot_groups_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Groups/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Publishes an incoming/generated AddScene command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/AddScene
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_add_scene_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_add_scene_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/AddScene";

  std::string payload =
    get_json_payload_for_scenes_add_scene_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated AddSceneResponse command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/AddSceneResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_add_scene_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_add_scene_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/AddSceneResponse";

  std::string payload =
    get_json_payload_for_scenes_add_scene_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ViewScene command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/ViewScene
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_view_scene_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_view_scene_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/ViewScene";

  std::string payload =
    get_json_payload_for_scenes_view_scene_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ViewSceneResponse command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/ViewSceneResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_view_scene_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_view_scene_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/ViewSceneResponse";

  std::string payload =
    get_json_payload_for_scenes_view_scene_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated RemoveScene command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/RemoveScene
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_remove_scene_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_remove_scene_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/RemoveScene";

  std::string payload =
    get_json_payload_for_scenes_remove_scene_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated RemoveSceneResponse command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/RemoveSceneResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_remove_scene_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_remove_scene_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/RemoveSceneResponse";

  std::string payload =
    get_json_payload_for_scenes_remove_scene_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated RemoveAllScenes command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/RemoveAllScenes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_remove_all_scenes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_remove_all_scenes_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/RemoveAllScenes";

  std::string payload =
    get_json_payload_for_scenes_remove_all_scenes_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated RemoveAllScenesResponse command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/RemoveAllScenesResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_remove_all_scenes_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_remove_all_scenes_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/RemoveAllScenesResponse";

  std::string payload =
    get_json_payload_for_scenes_remove_all_scenes_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated StoreScene command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/StoreScene
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_store_scene_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_store_scene_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/StoreScene";

  std::string payload =
    get_json_payload_for_scenes_store_scene_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated StoreSceneResponse command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/StoreSceneResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_store_scene_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_store_scene_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/StoreSceneResponse";

  std::string payload =
    get_json_payload_for_scenes_store_scene_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated RecallScene command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/RecallScene
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_recall_scene_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_recall_scene_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/RecallScene";

  std::string payload =
    get_json_payload_for_scenes_recall_scene_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetSceneMembership command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/GetSceneMembership
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_get_scene_membership_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_get_scene_membership_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/GetSceneMembership";

  std::string payload =
    get_json_payload_for_scenes_get_scene_membership_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetSceneMembershipResponse command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/GetSceneMembershipResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_get_scene_membership_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_get_scene_membership_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/GetSceneMembershipResponse";

  std::string payload =
    get_json_payload_for_scenes_get_scene_membership_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated EnhancedAddScene command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/EnhancedAddScene
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_enhanced_add_scene_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_enhanced_add_scene_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/EnhancedAddScene";

  std::string payload =
    get_json_payload_for_scenes_enhanced_add_scene_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated EnhancedAddSceneResponse command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/EnhancedAddSceneResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_enhanced_add_scene_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_enhanced_add_scene_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/EnhancedAddSceneResponse";

  std::string payload =
    get_json_payload_for_scenes_enhanced_add_scene_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated EnhancedViewScene command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/EnhancedViewScene
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_enhanced_view_scene_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_enhanced_view_scene_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/EnhancedViewScene";

  std::string payload =
    get_json_payload_for_scenes_enhanced_view_scene_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated EnhancedViewSceneResponse command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/EnhancedViewSceneResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_enhanced_view_scene_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_enhanced_view_scene_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/EnhancedViewSceneResponse";

  std::string payload =
    get_json_payload_for_scenes_enhanced_view_scene_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated CopyScene command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/CopyScene
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_copy_scene_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_copy_scene_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/CopyScene";

  std::string payload =
    get_json_payload_for_scenes_copy_scene_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated CopySceneResponse command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/CopySceneResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_copy_scene_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_copy_scene_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/CopySceneResponse";

  std::string payload =
    get_json_payload_for_scenes_copy_scene_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}


/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_scenes_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_scenes_state_t attribute_values,
  uic_mqtt_dotdot_scenes_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Publishes an incoming/generated Off command for
 * the OnOff cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OnOff/GeneratedCommands/Off
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_on_off_publish_generated_off_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "OnOff/GeneratedCommands/Off";

  std::string payload =
    get_json_payload_for_on_off_off_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated On command for
 * the OnOff cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OnOff/GeneratedCommands/On
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_on_off_publish_generated_on_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "OnOff/GeneratedCommands/On";

  std::string payload =
    get_json_payload_for_on_off_on_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Toggle command for
 * the OnOff cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OnOff/GeneratedCommands/Toggle
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_on_off_publish_generated_toggle_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "OnOff/GeneratedCommands/Toggle";

  std::string payload =
    get_json_payload_for_on_off_toggle_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated OffWithEffect command for
 * the OnOff cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OnOff/GeneratedCommands/OffWithEffect
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_on_off_publish_generated_off_with_effect_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_on_off_command_off_with_effect_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "OnOff/GeneratedCommands/OffWithEffect";

  std::string payload =
    get_json_payload_for_on_off_off_with_effect_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated OnWithRecallGlobalScene command for
 * the OnOff cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OnOff/GeneratedCommands/OnWithRecallGlobalScene
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_on_off_publish_generated_on_with_recall_global_scene_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "OnOff/GeneratedCommands/OnWithRecallGlobalScene";

  std::string payload =
    get_json_payload_for_on_off_on_with_recall_global_scene_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated OnWithTimedOff command for
 * the OnOff cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OnOff/GeneratedCommands/OnWithTimedOff
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_on_off_publish_generated_on_with_timed_off_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_on_off_command_on_with_timed_off_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "OnOff/GeneratedCommands/OnWithTimedOff";

  std::string payload =
    get_json_payload_for_on_off_on_with_timed_off_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}


/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the OnOff cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OnOff/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_on_off_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_on_off_state_t attribute_values,
  uic_mqtt_dotdot_on_off_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "OnOff/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  if (attribute_list.on_time == true) {

  // This is a single value

  json_object["OnTime"] = attribute_values.on_time;


  }


  if (attribute_list.off_wait_time == true) {

  // This is a single value

  json_object["OffWaitTime"] = attribute_values.off_wait_time;


  }


  if (attribute_list.start_up_on_off == true) {

  // This is a single value

  #ifdef ON_OFF_START_UP_ON_OFF_ENUM_NAME_AVAILABLE
  json_object["StartUpOnOff"] = on_off_start_up_on_off_get_enum_value_name((uint32_t)attribute_values.start_up_on_off);
  #else
  json_object["StartUpOnOff"] = static_cast<OnOffStartUpOnOff>(attribute_values.start_up_on_off);
  #endif


  }


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Publishes an incoming/generated MoveToLevel command for
 * the Level cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/GeneratedCommands/MoveToLevel
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_generated_move_to_level_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_level_command_move_to_level_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Level/GeneratedCommands/MoveToLevel";

  std::string payload =
    get_json_payload_for_level_move_to_level_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Move command for
 * the Level cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/GeneratedCommands/Move
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_generated_move_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_level_command_move_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Level/GeneratedCommands/Move";

  std::string payload =
    get_json_payload_for_level_move_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Step command for
 * the Level cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/GeneratedCommands/Step
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_generated_step_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_level_command_step_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Level/GeneratedCommands/Step";

  std::string payload =
    get_json_payload_for_level_step_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Stop command for
 * the Level cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/GeneratedCommands/Stop
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_generated_stop_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_level_command_stop_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Level/GeneratedCommands/Stop";

  std::string payload =
    get_json_payload_for_level_stop_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveToLevelWithOnOff command for
 * the Level cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/GeneratedCommands/MoveToLevelWithOnOff
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_generated_move_to_level_with_on_off_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_level_command_move_to_level_with_on_off_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Level/GeneratedCommands/MoveToLevelWithOnOff";

  std::string payload =
    get_json_payload_for_level_move_to_level_with_on_off_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveWithOnOff command for
 * the Level cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/GeneratedCommands/MoveWithOnOff
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_generated_move_with_on_off_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_level_command_move_with_on_off_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Level/GeneratedCommands/MoveWithOnOff";

  std::string payload =
    get_json_payload_for_level_move_with_on_off_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated StepWithOnOff command for
 * the Level cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/GeneratedCommands/StepWithOnOff
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_generated_step_with_on_off_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_level_command_step_with_on_off_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Level/GeneratedCommands/StepWithOnOff";

  std::string payload =
    get_json_payload_for_level_step_with_on_off_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated StopWithOnOff command for
 * the Level cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/GeneratedCommands/StopWithOnOff
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_generated_stop_with_on_off_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_level_command_stop_with_on_off_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Level/GeneratedCommands/StopWithOnOff";

  std::string payload =
    get_json_payload_for_level_stop_with_on_off_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveToClosestFrequency command for
 * the Level cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/GeneratedCommands/MoveToClosestFrequency
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_generated_move_to_closest_frequency_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_level_command_move_to_closest_frequency_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Level/GeneratedCommands/MoveToClosestFrequency";

  std::string payload =
    get_json_payload_for_level_move_to_closest_frequency_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}


/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the Level cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_level_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_level_state_t attribute_values,
  uic_mqtt_dotdot_level_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Level/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  if (attribute_list.options == true) {

  // This is a single value

  nlohmann::json bitmap_values = LevelOptions.get_bitmap_values_as_json_tree((uint32_t)attribute_values.options);
  json_object["Options"] = bitmap_values;


  }


  if (attribute_list.on_off_transition_time == true) {

  // This is a single value

  json_object["OnOffTransitionTime"] = attribute_values.on_off_transition_time;


  }


  if (attribute_list.on_level == true) {

  // This is a single value

  json_object["OnLevel"] = attribute_values.on_level;


  }


  if (attribute_list.on_transition_time == true) {

  // This is a single value

  json_object["OnTransitionTime"] = attribute_values.on_transition_time;


  }


  if (attribute_list.off_transition_time == true) {

  // This is a single value

  json_object["OffTransitionTime"] = attribute_values.off_transition_time;


  }


  if (attribute_list.default_move_rate == true) {

  // This is a single value

  json_object["DefaultMoveRate"] = attribute_values.default_move_rate;


  }


  if (attribute_list.start_up_current_level == true) {

  // This is a single value

  json_object["StartUpCurrentLevel"] = attribute_values.start_up_current_level;


  }


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Publishes an incoming/generated ResetAlarm command for
 * the Alarms cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Alarms/GeneratedCommands/ResetAlarm
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_alarms_publish_generated_reset_alarm_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_alarms_command_reset_alarm_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Alarms/GeneratedCommands/ResetAlarm";

  std::string payload =
    get_json_payload_for_alarms_reset_alarm_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Alarm command for
 * the Alarms cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Alarms/GeneratedCommands/Alarm
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_alarms_publish_generated_alarm_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_alarms_command_alarm_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Alarms/GeneratedCommands/Alarm";

  std::string payload =
    get_json_payload_for_alarms_alarm_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ResetAllAlarms command for
 * the Alarms cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Alarms/GeneratedCommands/ResetAllAlarms
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_alarms_publish_generated_reset_all_alarms_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Alarms/GeneratedCommands/ResetAllAlarms";

  std::string payload =
    get_json_payload_for_alarms_reset_all_alarms_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetAlarmResponse command for
 * the Alarms cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Alarms/GeneratedCommands/GetAlarmResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_alarms_publish_generated_get_alarm_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_alarms_command_get_alarm_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Alarms/GeneratedCommands/GetAlarmResponse";

  std::string payload =
    get_json_payload_for_alarms_get_alarm_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetAlarm command for
 * the Alarms cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Alarms/GeneratedCommands/GetAlarm
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_alarms_publish_generated_get_alarm_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Alarms/GeneratedCommands/GetAlarm";

  std::string payload =
    get_json_payload_for_alarms_get_alarm_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ResetAlarmLog command for
 * the Alarms cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Alarms/GeneratedCommands/ResetAlarmLog
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_alarms_publish_generated_reset_alarm_log_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Alarms/GeneratedCommands/ResetAlarmLog";

  std::string payload =
    get_json_payload_for_alarms_reset_alarm_log_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}


/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the Alarms cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Alarms/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_alarms_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_alarms_state_t attribute_values,
  uic_mqtt_dotdot_alarms_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Alarms/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}



/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the Time cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Time/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_time_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_time_state_t attribute_values,
  uic_mqtt_dotdot_time_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Time/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  if (attribute_list.time == true) {

  // This is a single value

  json_object["Time"] = attribute_values.time;


  }


  if (attribute_list.time_status == true) {

  // This is a single value

  nlohmann::json bitmap_values = TimeTimeStatus.get_bitmap_values_as_json_tree((uint32_t)attribute_values.time_status);
  json_object["TimeStatus"] = bitmap_values;


  }


  if (attribute_list.time_zone == true) {

  // This is a single value

  json_object["TimeZone"] = attribute_values.time_zone;


  }


  if (attribute_list.dst_start == true) {

  // This is a single value

  json_object["DstStart"] = attribute_values.dst_start;


  }


  if (attribute_list.dst_end == true) {

  // This is a single value

  json_object["DstEnd"] = attribute_values.dst_end;


  }


  if (attribute_list.dst_shift == true) {

  // This is a single value

  json_object["DstShift"] = attribute_values.dst_shift;


  }


  if (attribute_list.valid_until_time == true) {

  // This is a single value

  json_object["ValidUntilTime"] = attribute_values.valid_until_time;


  }


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Publishes an incoming/generated CheckIn command for
 * the PollControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/PollControl/GeneratedCommands/CheckIn
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_poll_control_publish_generated_check_in_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "PollControl/GeneratedCommands/CheckIn";

  std::string payload =
    get_json_payload_for_poll_control_check_in_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated CheckInResponse command for
 * the PollControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/PollControl/GeneratedCommands/CheckInResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_poll_control_publish_generated_check_in_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_poll_control_command_check_in_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "PollControl/GeneratedCommands/CheckInResponse";

  std::string payload =
    get_json_payload_for_poll_control_check_in_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated FastPollStop command for
 * the PollControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/PollControl/GeneratedCommands/FastPollStop
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_poll_control_publish_generated_fast_poll_stop_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "PollControl/GeneratedCommands/FastPollStop";

  std::string payload =
    get_json_payload_for_poll_control_fast_poll_stop_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetLongPollInterval command for
 * the PollControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/PollControl/GeneratedCommands/SetLongPollInterval
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_poll_control_publish_generated_set_long_poll_interval_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_poll_control_command_set_long_poll_interval_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "PollControl/GeneratedCommands/SetLongPollInterval";

  std::string payload =
    get_json_payload_for_poll_control_set_long_poll_interval_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetShortPollInterval command for
 * the PollControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/PollControl/GeneratedCommands/SetShortPollInterval
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_poll_control_publish_generated_set_short_poll_interval_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_poll_control_command_set_short_poll_interval_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "PollControl/GeneratedCommands/SetShortPollInterval";

  std::string payload =
    get_json_payload_for_poll_control_set_short_poll_interval_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}


/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the PollControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/PollControl/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_poll_control_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_poll_control_state_t attribute_values,
  uic_mqtt_dotdot_poll_control_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "PollControl/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  if (attribute_list.check_in_interval == true) {

  // This is a single value

  json_object["CheckInInterval"] = attribute_values.check_in_interval;


  }


  if (attribute_list.fast_poll_timeout == true) {

  // This is a single value

  json_object["FastPollTimeout"] = attribute_values.fast_poll_timeout;


  }


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}



/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the ShadeConfiguration cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ShadeConfiguration/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_shade_configuration_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_shade_configuration_state_t attribute_values,
  uic_mqtt_dotdot_shade_configuration_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ShadeConfiguration/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  if (attribute_list.status == true) {

  // This is a single value

  nlohmann::json bitmap_values = ShadeConfigurationStatus.get_bitmap_values_as_json_tree((uint32_t)attribute_values.status);
  json_object["Status"] = bitmap_values;


  }


  if (attribute_list.closed_limit == true) {

  // This is a single value

  json_object["ClosedLimit"] = attribute_values.closed_limit;


  }


  if (attribute_list.mode == true) {

  // This is a single value

  #ifdef SHADE_CONFIGURATION_MODE_ENUM_NAME_AVAILABLE
  json_object["Mode"] = shade_configuration_mode_get_enum_value_name((uint32_t)attribute_values.mode);
  #else
  json_object["Mode"] = static_cast<ShadeConfigurationMode>(attribute_values.mode);
  #endif


  }


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Publishes an incoming/generated LockDoor command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/LockDoor
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_lock_door_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_lock_door_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/LockDoor";

  std::string payload =
    get_json_payload_for_door_lock_lock_door_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated LockDoorResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/LockDoorResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_lock_door_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_lock_door_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/LockDoorResponse";

  std::string payload =
    get_json_payload_for_door_lock_lock_door_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated UnlockDoor command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/UnlockDoor
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_unlock_door_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_unlock_door_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/UnlockDoor";

  std::string payload =
    get_json_payload_for_door_lock_unlock_door_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated UnlockDoorResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/UnlockDoorResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_unlock_door_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_unlock_door_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/UnlockDoorResponse";

  std::string payload =
    get_json_payload_for_door_lock_unlock_door_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Toggle command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/Toggle
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_toggle_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_toggle_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/Toggle";

  std::string payload =
    get_json_payload_for_door_lock_toggle_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ToggleResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ToggleResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_toggle_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_toggle_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ToggleResponse";

  std::string payload =
    get_json_payload_for_door_lock_toggle_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated UnlockWithTimeout command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/UnlockWithTimeout
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_unlock_with_timeout_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_unlock_with_timeout_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/UnlockWithTimeout";

  std::string payload =
    get_json_payload_for_door_lock_unlock_with_timeout_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated UnlockWithTimeoutResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/UnlockWithTimeoutResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_unlock_with_timeout_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_unlock_with_timeout_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/UnlockWithTimeoutResponse";

  std::string payload =
    get_json_payload_for_door_lock_unlock_with_timeout_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetLogRecord command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetLogRecord
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_log_record_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_log_record_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetLogRecord";

  std::string payload =
    get_json_payload_for_door_lock_get_log_record_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetLogRecordResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetLogRecordResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_log_record_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_log_record_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetLogRecordResponse";

  std::string payload =
    get_json_payload_for_door_lock_get_log_record_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetPINCode command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetPINCode
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_setpin_code_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_setpin_code_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetPINCode";

  std::string payload =
    get_json_payload_for_door_lock_setpin_code_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetPINCodeResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetPINCodeResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_setpin_code_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_setpin_code_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetPINCodeResponse";

  std::string payload =
    get_json_payload_for_door_lock_setpin_code_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetPINCode command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetPINCode
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_getpin_code_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_getpin_code_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetPINCode";

  std::string payload =
    get_json_payload_for_door_lock_getpin_code_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetPINCodeResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetPINCodeResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_pin_code_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_pin_code_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetPINCodeResponse";

  std::string payload =
    get_json_payload_for_door_lock_getpin_code_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearPINCode command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearPINCode
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clearpin_code_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clearpin_code_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearPINCode";

  std::string payload =
    get_json_payload_for_door_lock_clearpin_code_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearPINCodeResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearPINCodeResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clearpin_code_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clearpin_code_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearPINCodeResponse";

  std::string payload =
    get_json_payload_for_door_lock_clearpin_code_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearAllPINCodes command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearAllPINCodes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_allpin_codes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearAllPINCodes";

  std::string payload =
    get_json_payload_for_door_lock_clear_allpin_codes_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearAllPINCodesResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearAllPINCodesResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_allpin_codes_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_allpin_codes_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearAllPINCodesResponse";

  std::string payload =
    get_json_payload_for_door_lock_clear_allpin_codes_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetUserStatus command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetUserStatus
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_user_status_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_user_status_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetUserStatus";

  std::string payload =
    get_json_payload_for_door_lock_set_user_status_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetUserStatusResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetUserStatusResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_user_status_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_user_status_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetUserStatusResponse";

  std::string payload =
    get_json_payload_for_door_lock_set_user_status_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetUserStatus command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetUserStatus
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_user_status_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_user_status_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetUserStatus";

  std::string payload =
    get_json_payload_for_door_lock_get_user_status_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetUserStatusResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetUserStatusResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_user_status_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_user_status_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetUserStatusResponse";

  std::string payload =
    get_json_payload_for_door_lock_get_user_status_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetWeekdaySchedule command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetWeekdaySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_weekday_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_weekday_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetWeekdaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_set_weekday_schedule_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetWeekdayScheduleResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetWeekdayScheduleResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_weekday_schedule_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_weekday_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetWeekdayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_set_weekday_schedule_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetWeekdaySchedule command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetWeekdaySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_weekday_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_weekday_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetWeekdaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_get_weekday_schedule_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetWeekdayScheduleResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetWeekdayScheduleResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_weekday_schedule_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_weekday_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetWeekdayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_get_weekday_schedule_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearWeekdaySchedule command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearWeekdaySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_weekday_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_weekday_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearWeekdaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_clear_weekday_schedule_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearWeekdayScheduleResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearWeekdayScheduleResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_weekday_schedule_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_weekday_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearWeekdayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_clear_weekday_schedule_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetYearDaySchedule command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetYearDaySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_year_day_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_year_day_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetYearDaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_set_year_day_schedule_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetYearDayScheduleResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetYearDayScheduleResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_year_day_schedule_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_year_day_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetYearDayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_set_year_day_schedule_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetYearDaySchedule command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetYearDaySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_year_day_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_year_day_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetYearDaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_get_year_day_schedule_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetYearDayScheduleResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetYearDayScheduleResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_year_day_schedule_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_year_day_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetYearDayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_get_year_day_schedule_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearYearDaySchedule command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearYearDaySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_year_day_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_year_day_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearYearDaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_clear_year_day_schedule_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearYearDayScheduleResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearYearDayScheduleResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_year_day_schedule_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_year_day_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearYearDayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_clear_year_day_schedule_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetHolidaySchedule command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetHolidaySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_holiday_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_holiday_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetHolidaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_set_holiday_schedule_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetHolidayScheduleResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetHolidayScheduleResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_holiday_schedule_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_holiday_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetHolidayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_set_holiday_schedule_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetHolidaySchedule command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetHolidaySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_holiday_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_holiday_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetHolidaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_get_holiday_schedule_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetHolidayScheduleResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetHolidayScheduleResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_holiday_schedule_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_holiday_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetHolidayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_get_holiday_schedule_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearHolidaySchedule command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearHolidaySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_holiday_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_holiday_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearHolidaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_clear_holiday_schedule_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearHolidayScheduleResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearHolidayScheduleResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_holiday_schedule_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_holiday_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearHolidayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_clear_holiday_schedule_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetUserType command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetUserType
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_user_type_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_user_type_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetUserType";

  std::string payload =
    get_json_payload_for_door_lock_set_user_type_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetUserTypeResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetUserTypeResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_user_type_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_user_type_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetUserTypeResponse";

  std::string payload =
    get_json_payload_for_door_lock_set_user_type_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetUserType command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetUserType
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_user_type_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_user_type_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetUserType";

  std::string payload =
    get_json_payload_for_door_lock_get_user_type_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetUserTypeResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetUserTypeResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_user_type_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_user_type_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetUserTypeResponse";

  std::string payload =
    get_json_payload_for_door_lock_get_user_type_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetRFIDCode command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetRFIDCode
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_setrfid_code_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_setrfid_code_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetRFIDCode";

  std::string payload =
    get_json_payload_for_door_lock_setrfid_code_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetRFIDCodeResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetRFIDCodeResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_setrfid_code_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_setrfid_code_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetRFIDCodeResponse";

  std::string payload =
    get_json_payload_for_door_lock_setrfid_code_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetRFIDCode command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetRFIDCode
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_getrfid_code_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_getrfid_code_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetRFIDCode";

  std::string payload =
    get_json_payload_for_door_lock_getrfid_code_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetRFIDCodeResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetRFIDCodeResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_getrfid_code_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_getrfid_code_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetRFIDCodeResponse";

  std::string payload =
    get_json_payload_for_door_lock_getrfid_code_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearRFIDCode command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearRFIDCode
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clearrfid_code_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clearrfid_code_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearRFIDCode";

  std::string payload =
    get_json_payload_for_door_lock_clearrfid_code_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearRFIDCodeResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearRFIDCodeResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clearrfid_code_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clearrfid_code_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearRFIDCodeResponse";

  std::string payload =
    get_json_payload_for_door_lock_clearrfid_code_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearAllRFIDCodes command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearAllRFIDCodes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_allrfid_codes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearAllRFIDCodes";

  std::string payload =
    get_json_payload_for_door_lock_clear_allrfid_codes_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearAllRFIDCodesResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearAllRFIDCodesResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_allrfid_codes_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_allrfid_codes_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearAllRFIDCodesResponse";

  std::string payload =
    get_json_payload_for_door_lock_clear_allrfid_codes_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated OperatingEventNotification command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/OperatingEventNotification
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_operating_event_notification_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_operating_event_notification_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/OperatingEventNotification";

  std::string payload =
    get_json_payload_for_door_lock_operating_event_notification_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ProgrammingEventNotification command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ProgrammingEventNotification
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_programming_event_notification_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_programming_event_notification_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ProgrammingEventNotification";

  std::string payload =
    get_json_payload_for_door_lock_programming_event_notification_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetAllPINCodes command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetAllPINCodes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_all_pin_codes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetAllPINCodes";

  std::string payload =
    get_json_payload_for_door_lock_get_all_pin_codes_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}


/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_door_lock_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_door_lock_state_t attribute_values,
  uic_mqtt_dotdot_door_lock_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  if (attribute_list.door_open_events == true) {

  // This is a single value

  json_object["DoorOpenEvents"] = attribute_values.door_open_events;


  }


  if (attribute_list.door_closed_events == true) {

  // This is a single value

  json_object["DoorClosedEvents"] = attribute_values.door_closed_events;


  }


  if (attribute_list.open_period == true) {

  // This is a single value

  json_object["OpenPeriod"] = attribute_values.open_period;


  }


  if (attribute_list.enable_logging == true) {

  // This is a single value

  json_object["EnableLogging"] = attribute_values.enable_logging;


  }


  if (attribute_list.language == true) {

  // This is a single value

  json_object["Language"] = std::string(attribute_values.language);


  }


  if (attribute_list.led_settings == true) {

  // This is a single value

  json_object["LEDSettings"] = attribute_values.led_settings;


  }


  if (attribute_list.auto_relock_time == true) {

  // This is a single value

  json_object["AutoRelockTime"] = attribute_values.auto_relock_time;


  }


  if (attribute_list.sound_volume == true) {

  // This is a single value

  json_object["SoundVolume"] = attribute_values.sound_volume;


  }


  if (attribute_list.operating_mode == true) {

  // This is a single value

  #ifdef DOOR_LOCK_OPERATING_MODE_ENUM_NAME_AVAILABLE
  json_object["OperatingMode"] = door_lock_operating_mode_get_enum_value_name((uint32_t)attribute_values.operating_mode);
  #else
  json_object["OperatingMode"] = static_cast<DrlkOperMode>(attribute_values.operating_mode);
  #endif


  }


  if (attribute_list.enable_local_programming == true) {

  // This is a single value

  json_object["EnableLocalProgramming"] = attribute_values.enable_local_programming;


  }


  if (attribute_list.enable_one_touch_locking == true) {

  // This is a single value

  json_object["EnableOneTouchLocking"] = attribute_values.enable_one_touch_locking;


  }


  if (attribute_list.enable_inside_statusled == true) {

  // This is a single value

  json_object["EnableInsideStatusLED"] = attribute_values.enable_inside_statusled;


  }


  if (attribute_list.enable_privacy_mode_button == true) {

  // This is a single value

  json_object["EnablePrivacyModeButton"] = attribute_values.enable_privacy_mode_button;


  }


  if (attribute_list.wrong_code_entry_limit == true) {

  // This is a single value

  json_object["WrongCodeEntryLimit"] = attribute_values.wrong_code_entry_limit;


  }


  if (attribute_list.user_code_temporary_disable_time == true) {

  // This is a single value

  json_object["UserCodeTemporaryDisableTime"] = attribute_values.user_code_temporary_disable_time;


  }


  if (attribute_list.sendpin_over_the_air == true) {

  // This is a single value

  json_object["SendPINOverTheAir"] = attribute_values.sendpin_over_the_air;


  }


  if (attribute_list.requirepi_nforrf_operation == true) {

  // This is a single value

  json_object["RequirePINforRFOperation"] = attribute_values.requirepi_nforrf_operation;


  }


  if (attribute_list.alarm_mask == true) {

  // This is a single value

  nlohmann::json bitmap_values = DoorLockAlarmMask.get_bitmap_values_as_json_tree((uint32_t)attribute_values.alarm_mask);
  json_object["AlarmMask"] = bitmap_values;


  }


  if (attribute_list.keypad_operation_event_mask == true) {

  // This is a single value

  nlohmann::json bitmap_values = DoorLockKeypadOperationEventMask.get_bitmap_values_as_json_tree((uint32_t)attribute_values.keypad_operation_event_mask);
  json_object["KeypadOperationEventMask"] = bitmap_values;


  }


  if (attribute_list.rf_operation_event_mask == true) {

  // This is a single value

  nlohmann::json bitmap_values = DoorLockRFOperationEventMask.get_bitmap_values_as_json_tree((uint32_t)attribute_values.rf_operation_event_mask);
  json_object["RFOperationEventMask"] = bitmap_values;


  }


  if (attribute_list.manual_operation_event_mask == true) {

  // This is a single value

  nlohmann::json bitmap_values = DoorLockManualOperationEventMask.get_bitmap_values_as_json_tree((uint32_t)attribute_values.manual_operation_event_mask);
  json_object["ManualOperationEventMask"] = bitmap_values;


  }


  if (attribute_list.rfid_operation_event_mask == true) {

  // This is a single value

  nlohmann::json bitmap_values = DoorLockRFIDOperationEventMask.get_bitmap_values_as_json_tree((uint32_t)attribute_values.rfid_operation_event_mask);
  json_object["RFIDOperationEventMask"] = bitmap_values;


  }


  if (attribute_list.keypad_programming_event_mask == true) {

  // This is a single value

  nlohmann::json bitmap_values = DoorLockKeypadProgrammingEventMask.get_bitmap_values_as_json_tree((uint32_t)attribute_values.keypad_programming_event_mask);
  json_object["KeypadProgrammingEventMask"] = bitmap_values;


  }


  if (attribute_list.rf_programming_event_mask == true) {

  // This is a single value

  nlohmann::json bitmap_values = DoorLockRFProgrammingEventMask.get_bitmap_values_as_json_tree((uint32_t)attribute_values.rf_programming_event_mask);
  json_object["RFProgrammingEventMask"] = bitmap_values;


  }


  if (attribute_list.rfid_programming_event_mask == true) {

  // This is a single value

  nlohmann::json bitmap_values = DoorLockRFIDProgrammingEventMask.get_bitmap_values_as_json_tree((uint32_t)attribute_values.rfid_programming_event_mask);
  json_object["RFIDProgrammingEventMask"] = bitmap_values;


  }


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Publishes an incoming/generated UpOrOpen command for
 * the WindowCovering cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/WindowCovering/GeneratedCommands/UpOrOpen
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_generated_up_or_open_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "WindowCovering/GeneratedCommands/UpOrOpen";

  std::string payload =
    get_json_payload_for_window_covering_up_or_open_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated DownOrClose command for
 * the WindowCovering cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/WindowCovering/GeneratedCommands/DownOrClose
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_generated_down_or_close_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "WindowCovering/GeneratedCommands/DownOrClose";

  std::string payload =
    get_json_payload_for_window_covering_down_or_close_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Stop command for
 * the WindowCovering cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/WindowCovering/GeneratedCommands/Stop
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_generated_stop_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "WindowCovering/GeneratedCommands/Stop";

  std::string payload =
    get_json_payload_for_window_covering_stop_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GoToLiftValue command for
 * the WindowCovering cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/WindowCovering/GeneratedCommands/GoToLiftValue
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_generated_go_to_lift_value_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_window_covering_command_go_to_lift_value_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "WindowCovering/GeneratedCommands/GoToLiftValue";

  std::string payload =
    get_json_payload_for_window_covering_go_to_lift_value_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GoToLiftPercentage command for
 * the WindowCovering cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/WindowCovering/GeneratedCommands/GoToLiftPercentage
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_generated_go_to_lift_percentage_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_window_covering_command_go_to_lift_percentage_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "WindowCovering/GeneratedCommands/GoToLiftPercentage";

  std::string payload =
    get_json_payload_for_window_covering_go_to_lift_percentage_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GoToTiltValue command for
 * the WindowCovering cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/WindowCovering/GeneratedCommands/GoToTiltValue
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_generated_go_to_tilt_value_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_window_covering_command_go_to_tilt_value_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "WindowCovering/GeneratedCommands/GoToTiltValue";

  std::string payload =
    get_json_payload_for_window_covering_go_to_tilt_value_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GoToTiltPercentage command for
 * the WindowCovering cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/WindowCovering/GeneratedCommands/GoToTiltPercentage
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_generated_go_to_tilt_percentage_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_window_covering_command_go_to_tilt_percentage_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "WindowCovering/GeneratedCommands/GoToTiltPercentage";

  std::string payload =
    get_json_payload_for_window_covering_go_to_tilt_percentage_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}


/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the WindowCovering cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/WindowCovering/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_window_covering_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_window_covering_state_t attribute_values,
  uic_mqtt_dotdot_window_covering_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "WindowCovering/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  if (attribute_list.velocity_lift == true) {

  // This is a single value

  json_object["VelocityLift"] = attribute_values.velocity_lift;


  }


  if (attribute_list.acceleration_time_lift == true) {

  // This is a single value

  json_object["AccelerationTimeLift"] = attribute_values.acceleration_time_lift;


  }


  if (attribute_list.deceleration_time_lift == true) {

  // This is a single value

  json_object["DecelerationTimeLift"] = attribute_values.deceleration_time_lift;


  }


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Publishes an incoming/generated GoToPercent command for
 * the BarrierControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/BarrierControl/GeneratedCommands/GoToPercent
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_barrier_control_publish_generated_go_to_percent_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_barrier_control_command_go_to_percent_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "BarrierControl/GeneratedCommands/GoToPercent";

  std::string payload =
    get_json_payload_for_barrier_control_go_to_percent_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Stop command for
 * the BarrierControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/BarrierControl/GeneratedCommands/Stop
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_barrier_control_publish_generated_stop_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "BarrierControl/GeneratedCommands/Stop";

  std::string payload =
    get_json_payload_for_barrier_control_stop_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}


/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the BarrierControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/BarrierControl/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_barrier_control_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_barrier_control_state_t attribute_values,
  uic_mqtt_dotdot_barrier_control_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "BarrierControl/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  if (attribute_list.open_events == true) {

  // This is a single value

  json_object["OpenEvents"] = attribute_values.open_events;


  }


  if (attribute_list.close_events == true) {

  // This is a single value

  json_object["CloseEvents"] = attribute_values.close_events;


  }


  if (attribute_list.command_open_events == true) {

  // This is a single value

  json_object["CommandOpenEvents"] = attribute_values.command_open_events;


  }


  if (attribute_list.command_close_events == true) {

  // This is a single value

  json_object["CommandCloseEvents"] = attribute_values.command_close_events;


  }


  if (attribute_list.open_period == true) {

  // This is a single value

  json_object["OpenPeriod"] = attribute_values.open_period;


  }


  if (attribute_list.close_period == true) {

  // This is a single value

  json_object["ClosePeriod"] = attribute_values.close_period;


  }


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}



/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the PumpConfigurationAndControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/PumpConfigurationAndControl/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_pump_configuration_and_control_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_pump_configuration_and_control_state_t attribute_values,
  uic_mqtt_dotdot_pump_configuration_and_control_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "PumpConfigurationAndControl/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  if (attribute_list.lifetime_running_hours == true) {

  // This is a single value

  json_object["LifetimeRunningHours"] = attribute_values.lifetime_running_hours;


  }


  if (attribute_list.power == true) {

  // This is a single value

  json_object["Power"] = attribute_values.power;


  }


  if (attribute_list.operation_mode == true) {

  // This is a single value

  #ifdef PUMP_CONFIGURATION_AND_CONTROL_OPERATION_MODE_ENUM_NAME_AVAILABLE
  json_object["OperationMode"] = pump_configuration_and_control_operation_mode_get_enum_value_name((uint32_t)attribute_values.operation_mode);
  #else
  json_object["OperationMode"] = static_cast<PumpOperationMode>(attribute_values.operation_mode);
  #endif


  }


  if (attribute_list.control_mode == true) {

  // This is a single value

  #ifdef PUMP_CONFIGURATION_AND_CONTROL_CONTROL_MODE_ENUM_NAME_AVAILABLE
  json_object["ControlMode"] = pump_configuration_and_control_control_mode_get_enum_value_name((uint32_t)attribute_values.control_mode);
  #else
  json_object["ControlMode"] = static_cast<PumpControlMode>(attribute_values.control_mode);
  #endif


  }


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Publishes an incoming/generated SetpointRaiseOrLower command for
 * the Thermostat cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Thermostat/GeneratedCommands/SetpointRaiseOrLower
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_generated_setpoint_raise_or_lower_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_thermostat_command_setpoint_raise_or_lower_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Thermostat/GeneratedCommands/SetpointRaiseOrLower";

  std::string payload =
    get_json_payload_for_thermostat_setpoint_raise_or_lower_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetWeeklyScheduleResponse command for
 * the Thermostat cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Thermostat/GeneratedCommands/GetWeeklyScheduleResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_generated_get_weekly_schedule_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_thermostat_command_get_weekly_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Thermostat/GeneratedCommands/GetWeeklyScheduleResponse";

  std::string payload =
    get_json_payload_for_thermostat_get_weekly_schedule_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetWeeklySchedule command for
 * the Thermostat cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Thermostat/GeneratedCommands/SetWeeklySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_generated_set_weekly_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_thermostat_command_set_weekly_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Thermostat/GeneratedCommands/SetWeeklySchedule";

  std::string payload =
    get_json_payload_for_thermostat_set_weekly_schedule_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetRelayStatusLogResponse command for
 * the Thermostat cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Thermostat/GeneratedCommands/GetRelayStatusLogResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_generated_get_relay_status_log_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_thermostat_command_get_relay_status_log_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Thermostat/GeneratedCommands/GetRelayStatusLogResponse";

  std::string payload =
    get_json_payload_for_thermostat_get_relay_status_log_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetWeeklySchedule command for
 * the Thermostat cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Thermostat/GeneratedCommands/GetWeeklySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_generated_get_weekly_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_thermostat_command_get_weekly_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Thermostat/GeneratedCommands/GetWeeklySchedule";

  std::string payload =
    get_json_payload_for_thermostat_get_weekly_schedule_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearWeeklySchedule command for
 * the Thermostat cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Thermostat/GeneratedCommands/ClearWeeklySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_generated_clear_weekly_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Thermostat/GeneratedCommands/ClearWeeklySchedule";

  std::string payload =
    get_json_payload_for_thermostat_clear_weekly_schedule_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetRelayStatusLog command for
 * the Thermostat cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Thermostat/GeneratedCommands/GetRelayStatusLog
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_generated_get_relay_status_log_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Thermostat/GeneratedCommands/GetRelayStatusLog";

  std::string payload =
    get_json_payload_for_thermostat_get_relay_status_log_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}


/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the Thermostat cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Thermostat/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_thermostat_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_thermostat_state_t attribute_values,
  uic_mqtt_dotdot_thermostat_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Thermostat/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  if (attribute_list.hvac_system_type_configuration == true) {

  // This is a single value

  nlohmann::json bitmap_values = ThermostatHVACSystemTypeConfiguration.get_bitmap_values_as_json_tree((uint32_t)attribute_values.hvac_system_type_configuration);
  json_object["HVACSystemTypeConfiguration"] = bitmap_values;


  }


  if (attribute_list.local_temperature_calibration == true) {

  // This is a single value

  json_object["LocalTemperatureCalibration"] = attribute_values.local_temperature_calibration;


  }


  if (attribute_list.occupied_cooling_setpoint == true) {

  // This is a single value

  json_object["OccupiedCoolingSetpoint"] = attribute_values.occupied_cooling_setpoint;


  }


  if (attribute_list.occupied_heating_setpoint == true) {

  // This is a single value

  json_object["OccupiedHeatingSetpoint"] = attribute_values.occupied_heating_setpoint;


  }


  if (attribute_list.unoccupied_cooling_setpoint == true) {

  // This is a single value

  json_object["UnoccupiedCoolingSetpoint"] = attribute_values.unoccupied_cooling_setpoint;


  }


  if (attribute_list.unoccupied_heating_setpoint == true) {

  // This is a single value

  json_object["UnoccupiedHeatingSetpoint"] = attribute_values.unoccupied_heating_setpoint;


  }


  if (attribute_list.min_heat_setpoint_limit == true) {

  // This is a single value

  json_object["MinHeatSetpointLimit"] = attribute_values.min_heat_setpoint_limit;


  }


  if (attribute_list.max_heat_setpoint_limit == true) {

  // This is a single value

  json_object["MaxHeatSetpointLimit"] = attribute_values.max_heat_setpoint_limit;


  }


  if (attribute_list.min_cool_setpoint_limit == true) {

  // This is a single value

  json_object["MinCoolSetpointLimit"] = attribute_values.min_cool_setpoint_limit;


  }


  if (attribute_list.max_cool_setpoint_limit == true) {

  // This is a single value

  json_object["MaxCoolSetpointLimit"] = attribute_values.max_cool_setpoint_limit;


  }


  if (attribute_list.min_setpoint_dead_band == true) {

  // This is a single value

  json_object["MinSetpointDeadBand"] = attribute_values.min_setpoint_dead_band;


  }


  if (attribute_list.remote_sensing == true) {

  // This is a single value

  nlohmann::json bitmap_values = ThermostatRemoteSensing.get_bitmap_values_as_json_tree((uint32_t)attribute_values.remote_sensing);
  json_object["RemoteSensing"] = bitmap_values;


  }


  if (attribute_list.control_sequence_of_operation == true) {

  // This is a single value

  #ifdef THERMOSTAT_CONTROL_SEQUENCE_OF_OPERATION_ENUM_NAME_AVAILABLE
  json_object["ControlSequenceOfOperation"] = thermostat_control_sequence_of_operation_get_enum_value_name((uint32_t)attribute_values.control_sequence_of_operation);
  #else
  json_object["ControlSequenceOfOperation"] = static_cast<ThermostatControlSequenceOfOperation>(attribute_values.control_sequence_of_operation);
  #endif


  }


  if (attribute_list.system_mode == true) {

  // This is a single value

  #ifdef THERMOSTAT_SYSTEM_MODE_ENUM_NAME_AVAILABLE
  json_object["SystemMode"] = thermostat_system_mode_get_enum_value_name((uint32_t)attribute_values.system_mode);
  #else
  json_object["SystemMode"] = static_cast<ThermostatSystemMode>(attribute_values.system_mode);
  #endif


  }


  if (attribute_list.temperature_setpoint_hold == true) {

  // This is a single value

  #ifdef THERMOSTAT_TEMPERATURE_SETPOINT_HOLD_ENUM_NAME_AVAILABLE
  json_object["TemperatureSetpointHold"] = thermostat_temperature_setpoint_hold_get_enum_value_name((uint32_t)attribute_values.temperature_setpoint_hold);
  #else
  json_object["TemperatureSetpointHold"] = static_cast<ThermostatTemperatureSetpointHold>(attribute_values.temperature_setpoint_hold);
  #endif


  }


  if (attribute_list.temperature_setpoint_hold_duration == true) {

  // This is a single value

  json_object["TemperatureSetpointHoldDuration"] = attribute_values.temperature_setpoint_hold_duration;


  }


  if (attribute_list.thermostat_programming_operation_mode == true) {

  // This is a single value

  nlohmann::json bitmap_values = ThermostatThermostatProgrammingOperationMode.get_bitmap_values_as_json_tree((uint32_t)attribute_values.thermostat_programming_operation_mode);
  json_object["ThermostatProgrammingOperationMode"] = bitmap_values;


  }


  if (attribute_list.occupied_setback == true) {

  // This is a single value

  json_object["OccupiedSetback"] = attribute_values.occupied_setback;


  }


  if (attribute_list.unoccupied_setback == true) {

  // This is a single value

  json_object["UnoccupiedSetback"] = attribute_values.unoccupied_setback;


  }


  if (attribute_list.emergency_heat_delta == true) {

  // This is a single value

  json_object["EmergencyHeatDelta"] = attribute_values.emergency_heat_delta;


  }


  if (attribute_list.ac_type == true) {

  // This is a single value

  #ifdef THERMOSTAT_AC_TYPE_ENUM_NAME_AVAILABLE
  json_object["ACType"] = thermostat_ac_type_get_enum_value_name((uint32_t)attribute_values.ac_type);
  #else
  json_object["ACType"] = static_cast<ThermostatACType>(attribute_values.ac_type);
  #endif


  }


  if (attribute_list.ac_capacity == true) {

  // This is a single value

  json_object["ACCapacity"] = attribute_values.ac_capacity;


  }


  if (attribute_list.ac_refrigerant_type == true) {

  // This is a single value

  #ifdef THERMOSTAT_AC_REFRIGERANT_TYPE_ENUM_NAME_AVAILABLE
  json_object["ACRefrigerantType"] = thermostat_ac_refrigerant_type_get_enum_value_name((uint32_t)attribute_values.ac_refrigerant_type);
  #else
  json_object["ACRefrigerantType"] = static_cast<ThermostatACRefrigerantType>(attribute_values.ac_refrigerant_type);
  #endif


  }


  if (attribute_list.ac_compressor_type == true) {

  // This is a single value

  #ifdef THERMOSTAT_AC_COMPRESSOR_TYPE_ENUM_NAME_AVAILABLE
  json_object["ACCompressorType"] = thermostat_ac_compressor_type_get_enum_value_name((uint32_t)attribute_values.ac_compressor_type);
  #else
  json_object["ACCompressorType"] = static_cast<ThermostatACCompressorType>(attribute_values.ac_compressor_type);
  #endif


  }


  if (attribute_list.ac_error_code == true) {

  // This is a single value

  nlohmann::json bitmap_values = ThermostatACErrorCode.get_bitmap_values_as_json_tree((uint32_t)attribute_values.ac_error_code);
  json_object["ACErrorCode"] = bitmap_values;


  }


  if (attribute_list.ac_louver_position == true) {

  // This is a single value

  #ifdef THERMOSTAT_AC_LOUVER_POSITION_ENUM_NAME_AVAILABLE
  json_object["ACLouverPosition"] = thermostat_ac_louver_position_get_enum_value_name((uint32_t)attribute_values.ac_louver_position);
  #else
  json_object["ACLouverPosition"] = static_cast<ThermostatACLouverPosition>(attribute_values.ac_louver_position);
  #endif


  }


  if (attribute_list.ac_capacity_format == true) {

  // This is a single value

  #ifdef THERMOSTAT_AC_CAPACITY_FORMAT_ENUM_NAME_AVAILABLE
  json_object["ACCapacityFormat"] = thermostat_ac_capacity_format_get_enum_value_name((uint32_t)attribute_values.ac_capacity_format);
  #else
  json_object["ACCapacityFormat"] = static_cast<ThermostatACCapacityFormat>(attribute_values.ac_capacity_format);
  #endif


  }


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}



/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the FanControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/FanControl/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_fan_control_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_fan_control_state_t attribute_values,
  uic_mqtt_dotdot_fan_control_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "FanControl/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  if (attribute_list.fan_mode == true) {

  // This is a single value

  #ifdef FAN_CONTROL_FAN_MODE_ENUM_NAME_AVAILABLE
  json_object["FanMode"] = fan_control_fan_mode_get_enum_value_name((uint32_t)attribute_values.fan_mode);
  #else
  json_object["FanMode"] = static_cast<FanControlFanMode>(attribute_values.fan_mode);
  #endif


  }


  if (attribute_list.fan_mode_sequence == true) {

  // This is a single value

  #ifdef FAN_CONTROL_FAN_MODE_SEQUENCE_ENUM_NAME_AVAILABLE
  json_object["FanModeSequence"] = fan_control_fan_mode_sequence_get_enum_value_name((uint32_t)attribute_values.fan_mode_sequence);
  #else
  json_object["FanModeSequence"] = static_cast<FanControlFanModeSequence>(attribute_values.fan_mode_sequence);
  #endif


  }


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}



/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the DehumidificationControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DehumidificationControl/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_dehumidification_control_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_dehumidification_control_state_t attribute_values,
  uic_mqtt_dotdot_dehumidification_control_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DehumidificationControl/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  if (attribute_list.rh_dehumidification_setpoint == true) {

  // This is a single value

  json_object["RHDehumidificationSetpoint"] = attribute_values.rh_dehumidification_setpoint;


  }


  if (attribute_list.relative_humidity_mode == true) {

  // This is a single value

  #ifdef DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_MODE_ENUM_NAME_AVAILABLE
  json_object["RelativeHumidityMode"] = dehumidification_control_relative_humidity_mode_get_enum_value_name((uint32_t)attribute_values.relative_humidity_mode);
  #else
  json_object["RelativeHumidityMode"] = static_cast<DehumidificationControlRelativeHumidityMode>(attribute_values.relative_humidity_mode);
  #endif


  }


  if (attribute_list.dehumidification_lockout == true) {

  // This is a single value

  #ifdef DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_LOCKOUT_ENUM_NAME_AVAILABLE
  json_object["DehumidificationLockout"] = dehumidification_control_dehumidification_lockout_get_enum_value_name((uint32_t)attribute_values.dehumidification_lockout);
  #else
  json_object["DehumidificationLockout"] = static_cast<DehumidificationControlDehumidificationLockout>(attribute_values.dehumidification_lockout);
  #endif


  }


  if (attribute_list.dehumidification_hysteresis == true) {

  // This is a single value

  json_object["DehumidificationHysteresis"] = attribute_values.dehumidification_hysteresis;


  }


  if (attribute_list.dehumidification_max_cool == true) {

  // This is a single value

  json_object["DehumidificationMaxCool"] = attribute_values.dehumidification_max_cool;


  }


  if (attribute_list.relative_humidity_display == true) {

  // This is a single value

  #ifdef DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_DISPLAY_ENUM_NAME_AVAILABLE
  json_object["RelativeHumidityDisplay"] = dehumidification_control_relative_humidity_display_get_enum_value_name((uint32_t)attribute_values.relative_humidity_display);
  #else
  json_object["RelativeHumidityDisplay"] = static_cast<DehumidificationControlRelativeHumidityDisplay>(attribute_values.relative_humidity_display);
  #endif


  }


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}



/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the ThermostatUserInterfaceConfiguration cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ThermostatUserInterfaceConfiguration/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_thermostat_user_interface_configuration_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_thermostat_user_interface_configuration_state_t attribute_values,
  uic_mqtt_dotdot_thermostat_user_interface_configuration_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ThermostatUserInterfaceConfiguration/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  if (attribute_list.temperature_display_mode == true) {

  // This is a single value

  #ifdef THERMOSTAT_USER_INTERFACE_CONFIGURATION_TEMPERATURE_DISPLAY_MODE_ENUM_NAME_AVAILABLE
  json_object["TemperatureDisplayMode"] = thermostat_user_interface_configuration_temperature_display_mode_get_enum_value_name((uint32_t)attribute_values.temperature_display_mode);
  #else
  json_object["TemperatureDisplayMode"] = static_cast<ThermostatUserInterfaceConfigurationTemperatureDisplayMode>(attribute_values.temperature_display_mode);
  #endif


  }


  if (attribute_list.keypad_lockout == true) {

  // This is a single value

  #ifdef THERMOSTAT_USER_INTERFACE_CONFIGURATION_KEYPAD_LOCKOUT_ENUM_NAME_AVAILABLE
  json_object["KeypadLockout"] = thermostat_user_interface_configuration_keypad_lockout_get_enum_value_name((uint32_t)attribute_values.keypad_lockout);
  #else
  json_object["KeypadLockout"] = static_cast<ThermostatUserInterfaceConfigurationKeypadLockout>(attribute_values.keypad_lockout);
  #endif


  }


  if (attribute_list.schedule_programming_visibility == true) {

  // This is a single value

  #ifdef THERMOSTAT_USER_INTERFACE_CONFIGURATION_SCHEDULE_PROGRAMMING_VISIBILITY_ENUM_NAME_AVAILABLE
  json_object["ScheduleProgrammingVisibility"] = thermostat_user_interface_configuration_schedule_programming_visibility_get_enum_value_name((uint32_t)attribute_values.schedule_programming_visibility);
  #else
  json_object["ScheduleProgrammingVisibility"] = static_cast<ThermostatUserInterfaceConfigurationScheduleProgrammingVisibility>(attribute_values.schedule_programming_visibility);
  #endif


  }


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Publishes an incoming/generated MoveToHue command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/MoveToHue
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_move_to_hue_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_move_to_hue_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/MoveToHue";

  std::string payload =
    get_json_payload_for_color_control_move_to_hue_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveHue command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/MoveHue
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_move_hue_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_move_hue_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/MoveHue";

  std::string payload =
    get_json_payload_for_color_control_move_hue_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated StepHue command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/StepHue
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_step_hue_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_step_hue_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/StepHue";

  std::string payload =
    get_json_payload_for_color_control_step_hue_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveToSaturation command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/MoveToSaturation
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_move_to_saturation_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_move_to_saturation_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/MoveToSaturation";

  std::string payload =
    get_json_payload_for_color_control_move_to_saturation_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveSaturation command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/MoveSaturation
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_move_saturation_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_move_saturation_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/MoveSaturation";

  std::string payload =
    get_json_payload_for_color_control_move_saturation_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated StepSaturation command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/StepSaturation
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_step_saturation_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_step_saturation_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/StepSaturation";

  std::string payload =
    get_json_payload_for_color_control_step_saturation_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveToHueAndSaturation command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/MoveToHueAndSaturation
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_move_to_hue_and_saturation_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_move_to_hue_and_saturation_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/MoveToHueAndSaturation";

  std::string payload =
    get_json_payload_for_color_control_move_to_hue_and_saturation_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveToColor command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/MoveToColor
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_move_to_color_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_move_to_color_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/MoveToColor";

  std::string payload =
    get_json_payload_for_color_control_move_to_color_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveColor command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/MoveColor
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_move_color_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_move_color_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/MoveColor";

  std::string payload =
    get_json_payload_for_color_control_move_color_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated StepColor command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/StepColor
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_step_color_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_step_color_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/StepColor";

  std::string payload =
    get_json_payload_for_color_control_step_color_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveToColorTemperature command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/MoveToColorTemperature
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_move_to_color_temperature_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_move_to_color_temperature_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/MoveToColorTemperature";

  std::string payload =
    get_json_payload_for_color_control_move_to_color_temperature_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated EnhancedMoveToHue command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/EnhancedMoveToHue
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_enhanced_move_to_hue_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_enhanced_move_to_hue_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/EnhancedMoveToHue";

  std::string payload =
    get_json_payload_for_color_control_enhanced_move_to_hue_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated EnhancedMoveHue command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/EnhancedMoveHue
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_enhanced_move_hue_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_enhanced_move_hue_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/EnhancedMoveHue";

  std::string payload =
    get_json_payload_for_color_control_enhanced_move_hue_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated EnhancedStepHue command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/EnhancedStepHue
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_enhanced_step_hue_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_enhanced_step_hue_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/EnhancedStepHue";

  std::string payload =
    get_json_payload_for_color_control_enhanced_step_hue_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated EnhancedMoveToHueAndSaturation command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/EnhancedMoveToHueAndSaturation
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_enhanced_move_to_hue_and_saturation_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_enhanced_move_to_hue_and_saturation_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/EnhancedMoveToHueAndSaturation";

  std::string payload =
    get_json_payload_for_color_control_enhanced_move_to_hue_and_saturation_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ColorLoopSet command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/ColorLoopSet
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_color_loop_set_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_color_loop_set_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/ColorLoopSet";

  std::string payload =
    get_json_payload_for_color_control_color_loop_set_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated StopMoveStep command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/StopMoveStep
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_stop_move_step_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_stop_move_step_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/StopMoveStep";

  std::string payload =
    get_json_payload_for_color_control_stop_move_step_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveColorTemperature command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/MoveColorTemperature
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_move_color_temperature_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_move_color_temperature_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/MoveColorTemperature";

  std::string payload =
    get_json_payload_for_color_control_move_color_temperature_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated StepColorTemperature command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/StepColorTemperature
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_step_color_temperature_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_step_color_temperature_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/StepColorTemperature";

  std::string payload =
    get_json_payload_for_color_control_step_color_temperature_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}


/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_color_control_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_color_control_state_t attribute_values,
  uic_mqtt_dotdot_color_control_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  if (attribute_list.options == true) {

  // This is a single value

  nlohmann::json bitmap_values = CCColorOptions.get_bitmap_values_as_json_tree((uint32_t)attribute_values.options);
  json_object["Options"] = bitmap_values;


  }


  if (attribute_list.white_pointx == true) {

  // This is a single value

  json_object["WhitePointX"] = attribute_values.white_pointx;


  }


  if (attribute_list.white_pointy == true) {

  // This is a single value

  json_object["WhitePointY"] = attribute_values.white_pointy;


  }


  if (attribute_list.color_pointrx == true) {

  // This is a single value

  json_object["ColorPointRX"] = attribute_values.color_pointrx;


  }


  if (attribute_list.color_pointry == true) {

  // This is a single value

  json_object["ColorPointRY"] = attribute_values.color_pointry;


  }


  if (attribute_list.color_pointr_intensity == true) {

  // This is a single value

  json_object["ColorPointRIntensity"] = attribute_values.color_pointr_intensity;


  }


  if (attribute_list.color_pointgx == true) {

  // This is a single value

  json_object["ColorPointGX"] = attribute_values.color_pointgx;


  }


  if (attribute_list.color_pointgy == true) {

  // This is a single value

  json_object["ColorPointGY"] = attribute_values.color_pointgy;


  }


  if (attribute_list.color_pointg_intensity == true) {

  // This is a single value

  json_object["ColorPointGIntensity"] = attribute_values.color_pointg_intensity;


  }


  if (attribute_list.color_pointbx == true) {

  // This is a single value

  json_object["ColorPointBX"] = attribute_values.color_pointbx;


  }


  if (attribute_list.color_pointby == true) {

  // This is a single value

  json_object["ColorPointBY"] = attribute_values.color_pointby;


  }


  if (attribute_list.color_pointb_intensity == true) {

  // This is a single value

  json_object["ColorPointBIntensity"] = attribute_values.color_pointb_intensity;


  }


  if (attribute_list.start_up_color_temperature_mireds == true) {

  // This is a single value

  json_object["StartUpColorTemperatureMireds"] = attribute_values.start_up_color_temperature_mireds;


  }


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}



/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the BallastConfiguration cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/BallastConfiguration/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_ballast_configuration_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_ballast_configuration_state_t attribute_values,
  uic_mqtt_dotdot_ballast_configuration_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "BallastConfiguration/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  if (attribute_list.min_level == true) {

  // This is a single value

  json_object["MinLevel"] = attribute_values.min_level;


  }


  if (attribute_list.max_level == true) {

  // This is a single value

  json_object["MaxLevel"] = attribute_values.max_level;


  }


  if (attribute_list.power_on_level == true) {

  // This is a single value

  json_object["PowerOnLevel"] = attribute_values.power_on_level;


  }


  if (attribute_list.power_on_fade_time == true) {

  // This is a single value

  json_object["PowerOnFadeTime"] = attribute_values.power_on_fade_time;


  }


  if (attribute_list.intrinsic_ballast_factor == true) {

  // This is a single value

  json_object["IntrinsicBallastFactor"] = attribute_values.intrinsic_ballast_factor;


  }


  if (attribute_list.ballast_factor_adjustment == true) {

  // This is a single value

  json_object["BallastFactorAdjustment"] = attribute_values.ballast_factor_adjustment;


  }


  if (attribute_list.lamp_type == true) {

  // This is a single value

  json_object["LampType"] = std::string(attribute_values.lamp_type);


  }


  if (attribute_list.lamp_manufacturer == true) {

  // This is a single value

  json_object["LampManufacturer"] = std::string(attribute_values.lamp_manufacturer);


  }


  if (attribute_list.lamp_rated_hours == true) {

  // This is a single value

  json_object["LampRatedHours"] = attribute_values.lamp_rated_hours;


  }


  if (attribute_list.lamp_burn_hours == true) {

  // This is a single value

  json_object["LampBurnHours"] = attribute_values.lamp_burn_hours;


  }


  if (attribute_list.lamp_alarm_mode == true) {

  // This is a single value

  nlohmann::json bitmap_values = BallastConfigurationLampAlarmMode.get_bitmap_values_as_json_tree((uint32_t)attribute_values.lamp_alarm_mode);
  json_object["LampAlarmMode"] = bitmap_values;


  }


  if (attribute_list.lamp_burn_hours_trip_point == true) {

  // This is a single value

  json_object["LampBurnHoursTripPoint"] = attribute_values.lamp_burn_hours_trip_point;


  }


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}



/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the IlluminanceMeasurement cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IlluminanceMeasurement/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_illuminance_measurement_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_illuminance_measurement_state_t attribute_values,
  uic_mqtt_dotdot_illuminance_measurement_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "IlluminanceMeasurement/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}



/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the IlluminanceLevelSensing cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IlluminanceLevelSensing/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_illuminance_level_sensing_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_illuminance_level_sensing_state_t attribute_values,
  uic_mqtt_dotdot_illuminance_level_sensing_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "IlluminanceLevelSensing/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  if (attribute_list.illuminance_target_level == true) {

  // This is a single value

  json_object["IlluminanceTargetLevel"] = attribute_values.illuminance_target_level;


  }


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}



/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the TemperatureMeasurement cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/TemperatureMeasurement/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_temperature_measurement_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_temperature_measurement_state_t attribute_values,
  uic_mqtt_dotdot_temperature_measurement_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "TemperatureMeasurement/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}



/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the PressureMeasurement cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/PressureMeasurement/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_pressure_measurement_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_pressure_measurement_state_t attribute_values,
  uic_mqtt_dotdot_pressure_measurement_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "PressureMeasurement/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}



/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the FlowMeasurement cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/FlowMeasurement/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_flow_measurement_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_flow_measurement_state_t attribute_values,
  uic_mqtt_dotdot_flow_measurement_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "FlowMeasurement/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}



/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the RelativityHumidity cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/RelativityHumidity/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_relativity_humidity_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_relativity_humidity_state_t attribute_values,
  uic_mqtt_dotdot_relativity_humidity_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "RelativityHumidity/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}



/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the OccupancySensing cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OccupancySensing/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_occupancy_sensing_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_occupancy_sensing_state_t attribute_values,
  uic_mqtt_dotdot_occupancy_sensing_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "OccupancySensing/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  if (attribute_list.pir_occupied_to_unoccupied_delay == true) {

  // This is a single value

  json_object["PIROccupiedToUnoccupiedDelay"] = attribute_values.pir_occupied_to_unoccupied_delay;


  }


  if (attribute_list.pir_unoccupied_to_occupied_delay == true) {

  // This is a single value

  json_object["PIRUnoccupiedToOccupiedDelay"] = attribute_values.pir_unoccupied_to_occupied_delay;


  }


  if (attribute_list.pir_unoccupied_to_occupied_threshold == true) {

  // This is a single value

  json_object["PIRUnoccupiedToOccupiedThreshold"] = attribute_values.pir_unoccupied_to_occupied_threshold;


  }


  if (attribute_list.ultrasonic_occupied_to_unoccupied_delay == true) {

  // This is a single value

  json_object["UltrasonicOccupiedToUnoccupiedDelay"] = attribute_values.ultrasonic_occupied_to_unoccupied_delay;


  }


  if (attribute_list.ultrasonic_unoccupied_to_occupied_delay == true) {

  // This is a single value

  json_object["UltrasonicUnoccupiedToOccupiedDelay"] = attribute_values.ultrasonic_unoccupied_to_occupied_delay;


  }


  if (attribute_list.ultrasonic_unoccupied_to_occupied_threshold == true) {

  // This is a single value

  json_object["UltrasonicUnoccupiedToOccupiedThreshold"] = attribute_values.ultrasonic_unoccupied_to_occupied_threshold;


  }


  if (attribute_list.physical_contact_occupied_to_unoccupied_delay == true) {

  // This is a single value

  json_object["PhysicalContactOccupiedToUnoccupiedDelay"] = attribute_values.physical_contact_occupied_to_unoccupied_delay;


  }


  if (attribute_list.physical_contact_unoccupied_to_occupied_delay == true) {

  // This is a single value

  json_object["PhysicalContactUnoccupiedToOccupiedDelay"] = attribute_values.physical_contact_unoccupied_to_occupied_delay;


  }


  if (attribute_list.physical_contact_unoccupied_to_occupied_threshold == true) {

  // This is a single value

  json_object["PhysicalContactUnoccupiedToOccupiedThreshold"] = attribute_values.physical_contact_unoccupied_to_occupied_threshold;


  }


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}



/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the SoilMoisture cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/SoilMoisture/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_soil_moisture_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_soil_moisture_state_t attribute_values,
  uic_mqtt_dotdot_soil_moisture_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "SoilMoisture/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}



/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the PhMeasurement cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/PhMeasurement/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_ph_measurement_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_ph_measurement_state_t attribute_values,
  uic_mqtt_dotdot_ph_measurement_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "PhMeasurement/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}



/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the ElectricalConductivityMeasurement cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ElectricalConductivityMeasurement/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_electrical_conductivity_measurement_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_electrical_conductivity_measurement_state_t attribute_values,
  uic_mqtt_dotdot_electrical_conductivity_measurement_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ElectricalConductivityMeasurement/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}



/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the WindSpeedMeasurement cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/WindSpeedMeasurement/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_wind_speed_measurement_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_wind_speed_measurement_state_t attribute_values,
  uic_mqtt_dotdot_wind_speed_measurement_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "WindSpeedMeasurement/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}



/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the CarbonMonoxide cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/CarbonMonoxide/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_carbon_monoxide_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_carbon_monoxide_state_t attribute_values,
  uic_mqtt_dotdot_carbon_monoxide_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "CarbonMonoxide/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}



/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the CarbonDioxide cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/CarbonDioxide/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_carbon_dioxide_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_carbon_dioxide_state_t attribute_values,
  uic_mqtt_dotdot_carbon_dioxide_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "CarbonDioxide/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}



/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the PM25 cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/PM25/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_pm25_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_pm25_state_t attribute_values,
  uic_mqtt_dotdot_pm25_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "PM25/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Publishes an incoming/generated ZoneEnrollResponse command for
 * the IASZone cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IASZone/GeneratedCommands/ZoneEnrollResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ias_zone_publish_generated_zone_enroll_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_ias_zone_command_zone_enroll_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "IASZone/GeneratedCommands/ZoneEnrollResponse";

  std::string payload =
    get_json_payload_for_ias_zone_zone_enroll_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ZoneStatusChangeNotification command for
 * the IASZone cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IASZone/GeneratedCommands/ZoneStatusChangeNotification
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ias_zone_publish_generated_zone_status_change_notification_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_ias_zone_command_zone_status_change_notification_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "IASZone/GeneratedCommands/ZoneStatusChangeNotification";

  std::string payload =
    get_json_payload_for_ias_zone_zone_status_change_notification_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated InitiateNormalOperationMode command for
 * the IASZone cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IASZone/GeneratedCommands/InitiateNormalOperationMode
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_ias_zone_publish_generated_initiate_normal_operation_mode_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "IASZone/GeneratedCommands/InitiateNormalOperationMode";

  std::string payload =
    get_json_payload_for_ias_zone_initiate_normal_operation_mode_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ZoneEnrollRequest command for
 * the IASZone cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IASZone/GeneratedCommands/ZoneEnrollRequest
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ias_zone_publish_generated_zone_enroll_request_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_ias_zone_command_zone_enroll_request_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "IASZone/GeneratedCommands/ZoneEnrollRequest";

  std::string payload =
    get_json_payload_for_ias_zone_zone_enroll_request_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated InitiateTestMode command for
 * the IASZone cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IASZone/GeneratedCommands/InitiateTestMode
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ias_zone_publish_generated_initiate_test_mode_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_ias_zone_command_initiate_test_mode_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "IASZone/GeneratedCommands/InitiateTestMode";

  std::string payload =
    get_json_payload_for_ias_zone_initiate_test_mode_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}


/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the IASZone cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IASZone/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_ias_zone_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_ias_zone_state_t attribute_values,
  uic_mqtt_dotdot_ias_zone_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "IASZone/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  if (attribute_list.iascie_address == true) {

  // This is a single value

  json_object["IASCIEAddress"] = attribute_values.iascie_address;


  }


  if (attribute_list.current_zone_sensitivity_level == true) {

  // This is a single value

  json_object["CurrentZoneSensitivityLevel"] = attribute_values.current_zone_sensitivity_level;


  }


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Publishes an incoming/generated StartWarning command for
 * the IASWD cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IASWD/GeneratedCommands/StartWarning
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_iaswd_publish_generated_start_warning_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_iaswd_command_start_warning_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "IASWD/GeneratedCommands/StartWarning";

  std::string payload =
    get_json_payload_for_iaswd_start_warning_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Squawk command for
 * the IASWD cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IASWD/GeneratedCommands/Squawk
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_iaswd_publish_generated_squawk_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_iaswd_command_squawk_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "IASWD/GeneratedCommands/Squawk";

  std::string payload =
    get_json_payload_for_iaswd_squawk_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}


/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the IASWD cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IASWD/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_iaswd_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_iaswd_state_t attribute_values,
  uic_mqtt_dotdot_iaswd_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "IASWD/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  if (attribute_list.max_duration == true) {

  // This is a single value

  json_object["MaxDuration"] = attribute_values.max_duration;


  }


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}



/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the Metering cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Metering/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_metering_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_metering_state_t attribute_values,
  uic_mqtt_dotdot_metering_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Metering/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Publishes an incoming/generated GetProfileInfoResponse command for
 * the ElectricalMeasurement cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ElectricalMeasurement/GeneratedCommands/GetProfileInfoResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_electrical_measurement_publish_generated_get_profile_info_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_electrical_measurement_command_get_profile_info_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ElectricalMeasurement/GeneratedCommands/GetProfileInfoResponse";

  std::string payload =
    get_json_payload_for_electrical_measurement_get_profile_info_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetProfileInfo command for
 * the ElectricalMeasurement cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ElectricalMeasurement/GeneratedCommands/GetProfileInfo
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_electrical_measurement_publish_generated_get_profile_info_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ElectricalMeasurement/GeneratedCommands/GetProfileInfo";

  std::string payload =
    get_json_payload_for_electrical_measurement_get_profile_info_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetMeasurementProfileResponse command for
 * the ElectricalMeasurement cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ElectricalMeasurement/GeneratedCommands/GetMeasurementProfileResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_electrical_measurement_publish_generated_get_measurement_profile_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_electrical_measurement_command_get_measurement_profile_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ElectricalMeasurement/GeneratedCommands/GetMeasurementProfileResponse";

  std::string payload =
    get_json_payload_for_electrical_measurement_get_measurement_profile_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetMeasurementProfile command for
 * the ElectricalMeasurement cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ElectricalMeasurement/GeneratedCommands/GetMeasurementProfile
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_electrical_measurement_publish_generated_get_measurement_profile_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_electrical_measurement_command_get_measurement_profile_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ElectricalMeasurement/GeneratedCommands/GetMeasurementProfile";

  std::string payload =
    get_json_payload_for_electrical_measurement_get_measurement_profile_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}


/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the ElectricalMeasurement cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ElectricalMeasurement/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_electrical_measurement_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_electrical_measurement_state_t attribute_values,
  uic_mqtt_dotdot_electrical_measurement_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ElectricalMeasurement/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  if (attribute_list.averagerms_voltage_measurement_period == true) {

  // This is a single value

  json_object["AverageRMSVoltageMeasurementPeriod"] = attribute_values.averagerms_voltage_measurement_period;


  }


  if (attribute_list.averagerms_over_voltage_counter == true) {

  // This is a single value

  json_object["AverageRMSOverVoltageCounter"] = attribute_values.averagerms_over_voltage_counter;


  }


  if (attribute_list.averagerms_under_voltage_counter == true) {

  // This is a single value

  json_object["AverageRMSUnderVoltageCounter"] = attribute_values.averagerms_under_voltage_counter;


  }


  if (attribute_list.rms_extreme_over_voltage_period == true) {

  // This is a single value

  json_object["RMSExtremeOverVoltagePeriod"] = attribute_values.rms_extreme_over_voltage_period;


  }


  if (attribute_list.rms_extreme_under_voltage_period == true) {

  // This is a single value

  json_object["RMSExtremeUnderVoltagePeriod"] = attribute_values.rms_extreme_under_voltage_period;


  }


  if (attribute_list.rms_voltage_sag_period == true) {

  // This is a single value

  json_object["RMSVoltageSagPeriod"] = attribute_values.rms_voltage_sag_period;


  }


  if (attribute_list.rms_voltage_swell_period == true) {

  // This is a single value

  json_object["RMSVoltageSwellPeriod"] = attribute_values.rms_voltage_swell_period;


  }


  if (attribute_list.dc_overload_alarms_mask == true) {

  // This is a single value

  nlohmann::json bitmap_values = ElectricalMeasurementDCOverloadAlarmsMask.get_bitmap_values_as_json_tree((uint32_t)attribute_values.dc_overload_alarms_mask);
  json_object["DCOverloadAlarmsMask"] = bitmap_values;


  }


  if (attribute_list.ac_alarms_mask == true) {

  // This is a single value

  nlohmann::json bitmap_values = ElectricalMeasurementACAlarmsMask.get_bitmap_values_as_json_tree((uint32_t)attribute_values.ac_alarms_mask);
  json_object["ACAlarmsMask"] = bitmap_values;


  }


  if (attribute_list.rms_extreme_over_voltage == true) {

  // This is a single value

  json_object["RMSExtremeOverVoltage"] = attribute_values.rms_extreme_over_voltage;


  }


  if (attribute_list.rms_extreme_under_voltage == true) {

  // This is a single value

  json_object["RMSExtremeUnderVoltage"] = attribute_values.rms_extreme_under_voltage;


  }


  if (attribute_list.rms_voltage_sag == true) {

  // This is a single value

  json_object["RMSVoltageSag"] = attribute_values.rms_voltage_sag;


  }


  if (attribute_list.rms_voltage_swell == true) {

  // This is a single value

  json_object["RMSVoltageSwell"] = attribute_values.rms_voltage_swell;


  }


  if (attribute_list.averagerms_voltage_measurement_period_phb == true) {

  // This is a single value

  json_object["AverageRMSVoltageMeasurementPeriodPhB"] = attribute_values.averagerms_voltage_measurement_period_phb;


  }


  if (attribute_list.averagerms_over_voltage_counter_phb == true) {

  // This is a single value

  json_object["AverageRMSOverVoltageCounterPhB"] = attribute_values.averagerms_over_voltage_counter_phb;


  }


  if (attribute_list.averagerms_under_voltage_counter_phb == true) {

  // This is a single value

  json_object["AverageRMSUnderVoltageCounterPhB"] = attribute_values.averagerms_under_voltage_counter_phb;


  }


  if (attribute_list.rms_extreme_over_voltage_period_phb == true) {

  // This is a single value

  json_object["RMSExtremeOverVoltagePeriodPhB"] = attribute_values.rms_extreme_over_voltage_period_phb;


  }


  if (attribute_list.rms_extreme_under_voltage_period_phb == true) {

  // This is a single value

  json_object["RMSExtremeUnderVoltagePeriodPhB"] = attribute_values.rms_extreme_under_voltage_period_phb;


  }


  if (attribute_list.rms_voltage_sag_period_phb == true) {

  // This is a single value

  json_object["RMSVoltageSagPeriodPhB"] = attribute_values.rms_voltage_sag_period_phb;


  }


  if (attribute_list.rms_voltage_swell_period_phb == true) {

  // This is a single value

  json_object["RMSVoltageSwellPeriodPhB"] = attribute_values.rms_voltage_swell_period_phb;


  }


  if (attribute_list.averagerms_voltage_measurement_period_phc == true) {

  // This is a single value

  json_object["AverageRMSVoltageMeasurementPeriodPhC"] = attribute_values.averagerms_voltage_measurement_period_phc;


  }


  if (attribute_list.averagerms_over_voltage_counter_phc == true) {

  // This is a single value

  json_object["AverageRMSOverVoltageCounterPhC"] = attribute_values.averagerms_over_voltage_counter_phc;


  }


  if (attribute_list.averagerms_under_voltage_counter_phc == true) {

  // This is a single value

  json_object["AverageRMSUnderVoltageCounterPhC"] = attribute_values.averagerms_under_voltage_counter_phc;


  }


  if (attribute_list.rms_extreme_over_voltage_period_phc == true) {

  // This is a single value

  json_object["RMSExtremeOverVoltagePeriodPhC"] = attribute_values.rms_extreme_over_voltage_period_phc;


  }


  if (attribute_list.rms_extreme_under_voltage_period_phc == true) {

  // This is a single value

  json_object["RMSExtremeUnderVoltagePeriodPhC"] = attribute_values.rms_extreme_under_voltage_period_phc;


  }


  if (attribute_list.rms_voltage_sag_period_phc == true) {

  // This is a single value

  json_object["RMSVoltageSagPeriodPhC"] = attribute_values.rms_voltage_sag_period_phc;


  }


  if (attribute_list.rms_voltage_swell_period_phc == true) {

  // This is a single value

  json_object["RMSVoltageSwellPeriodPhC"] = attribute_values.rms_voltage_swell_period_phc;


  }


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}



/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the Diagnostics cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Diagnostics/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_diagnostics_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_diagnostics_state_t attribute_values,
  uic_mqtt_dotdot_diagnostics_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Diagnostics/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Publishes an incoming/generated TxReport command for
 * the ProtocolController-RFTelemetry cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/ProtocolController/RFTelemetry/GeneratedCommands/TxReport
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_protocol_controller_rf_telemetry_publish_generated_tx_report_command(
  const dotdot_unid_t unid,
  const uic_mqtt_dotdot_protocol_controller_rf_telemetry_command_tx_report_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(unid) + "/";
  topic += "ProtocolController/RFTelemetry/GeneratedCommands/TxReport";

  std::string payload =
    get_json_payload_for_protocol_controller_rf_telemetry_tx_report_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}


/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the ProtocolController-RFTelemetry cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/ProtocolController/RFTelemetry/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_protocol_controller_rf_telemetry_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  uic_mqtt_dotdot_protocol_controller_rf_telemetry_state_t attribute_values,
  uic_mqtt_dotdot_protocol_controller_rf_telemetry_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(unid) + "/";
  topic += "ProtocolController/RFTelemetry/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  if (attribute_list.tx_report_enabled == true) {

  // This is a single value

  json_object["TxReportEnabled"] = attribute_values.tx_report_enabled;


  }


  if (attribute_list.pti_enabled == true) {

  // This is a single value

  json_object["PTIEnabled"] = attribute_values.pti_enabled;


  }


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Publishes an incoming/generated Remove command for
 * the State cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/State/GeneratedCommands/Remove
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_state_publish_generated_remove_command(
  const dotdot_unid_t unid
) {
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(unid) + "/";
  topic += "State/GeneratedCommands/Remove";

  std::string payload =
    get_json_payload_for_state_remove_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated RemoveOffline command for
 * the State cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/State/GeneratedCommands/RemoveOffline
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_state_publish_generated_remove_offline_command(
  const dotdot_unid_t unid
) {
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(unid) + "/";
  topic += "State/GeneratedCommands/RemoveOffline";

  std::string payload =
    get_json_payload_for_state_remove_offline_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated DiscoverNeighbors command for
 * the State cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/State/GeneratedCommands/DiscoverNeighbors
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_state_publish_generated_discover_neighbors_command(
  const dotdot_unid_t unid
) {
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(unid) + "/";
  topic += "State/GeneratedCommands/DiscoverNeighbors";

  std::string payload =
    get_json_payload_for_state_discover_neighbors_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Interview command for
 * the State cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/State/GeneratedCommands/Interview
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_state_publish_generated_interview_command(
  const dotdot_unid_t unid
) {
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(unid) + "/";
  topic += "State/GeneratedCommands/Interview";

  std::string payload =
    get_json_payload_for_state_interview_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated DiscoverSecurity command for
 * the State cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/State/GeneratedCommands/DiscoverSecurity
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_state_publish_generated_discover_security_command(
  const dotdot_unid_t unid
) {
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(unid) + "/";
  topic += "State/GeneratedCommands/DiscoverSecurity";

  std::string payload =
    get_json_payload_for_state_discover_security_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}


/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the State cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/State/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_state_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  uic_mqtt_dotdot_state_state_t attribute_values,
  uic_mqtt_dotdot_state_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(unid) + "/";
  topic += "State/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Publishes an incoming/generated Bind command for
 * the Binding cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Binding/GeneratedCommands/Bind
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_binding_publish_generated_bind_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_binding_command_bind_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Binding/GeneratedCommands/Bind";

  std::string payload =
    get_json_payload_for_binding_bind_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Unbind command for
 * the Binding cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Binding/GeneratedCommands/Unbind
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_binding_publish_generated_unbind_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_binding_command_unbind_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Binding/GeneratedCommands/Unbind";

  std::string payload =
    get_json_payload_for_binding_unbind_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated BindToProtocolController command for
 * the Binding cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Binding/GeneratedCommands/BindToProtocolController
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_binding_publish_generated_bind_to_protocol_controller_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_binding_command_bind_to_protocol_controller_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Binding/GeneratedCommands/BindToProtocolController";

  std::string payload =
    get_json_payload_for_binding_bind_to_protocol_controller_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated UnbindFromProtocolController command for
 * the Binding cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Binding/GeneratedCommands/UnbindFromProtocolController
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_binding_publish_generated_unbind_from_protocol_controller_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_binding_command_unbind_from_protocol_controller_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Binding/GeneratedCommands/UnbindFromProtocolController";

  std::string payload =
    get_json_payload_for_binding_unbind_from_protocol_controller_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}


/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the Binding cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Binding/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_binding_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_binding_state_t attribute_values,
  uic_mqtt_dotdot_binding_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Binding/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}



/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the SystemMetrics cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/SystemMetrics/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_system_metrics_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  uic_mqtt_dotdot_system_metrics_state_t attribute_values,
  uic_mqtt_dotdot_system_metrics_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(unid) + "/";
  topic += "SystemMetrics/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  if (attribute_list.reporting_interval_seconds == true) {

  // This is a single value

  json_object["ReportingIntervalSeconds"] = attribute_values.reporting_interval_seconds;


  }


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Publishes an incoming/generated LogEntry command for
 * the ApplicationMonitoring cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/ApplicationMonitoring/GeneratedCommands/LogEntry
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_application_monitoring_publish_generated_log_entry_command(
  const dotdot_unid_t unid,
  const uic_mqtt_dotdot_application_monitoring_command_log_entry_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(unid) + "/";
  topic += "ApplicationMonitoring/GeneratedCommands/LogEntry";

  std::string payload =
    get_json_payload_for_application_monitoring_log_entry_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}


/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the ApplicationMonitoring cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/ApplicationMonitoring/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_application_monitoring_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  uic_mqtt_dotdot_application_monitoring_state_t attribute_values,
  uic_mqtt_dotdot_application_monitoring_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(unid) + "/";
  topic += "ApplicationMonitoring/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  if (attribute_list.mqtt_logging_enabled == true) {

  // This is a single value

  json_object["MQTTLoggingEnabled"] = attribute_values.mqtt_logging_enabled;


  }


  if (attribute_list.mqtt_logging_level == true) {

  // This is a single value

  #ifdef APPLICATION_MONITORING_MQTT_LOGGING_LEVEL_ENUM_NAME_AVAILABLE
  json_object["MQTTLoggingLevel"] = application_monitoring_mqtt_logging_level_get_enum_value_name((uint32_t)attribute_values.mqtt_logging_level);
  #else
  json_object["MQTTLoggingLevel"] = static_cast<LoggingLevelEnum>(attribute_values.mqtt_logging_level);
  #endif


  }


  if (attribute_list.mqtt_statistics_reporting_interval_seconds == true) {

  // This is a single value

  json_object["MQTTStatisticsReportingIntervalSeconds"] = attribute_values.mqtt_statistics_reporting_interval_seconds;


  }


  if (attribute_list.application_statistics_reporting_interval_seconds == true) {

  // This is a single value

  json_object["ApplicationStatisticsReportingIntervalSeconds"] = attribute_values.application_statistics_reporting_interval_seconds;


  }


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}



/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the NameAndLocation cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/NameAndLocation/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_name_and_location_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_name_and_location_state_t attribute_values,
  uic_mqtt_dotdot_name_and_location_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "NameAndLocation/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  if (attribute_list.name == true) {

  // This is a single value

  json_object["Name"] = std::string(attribute_values.name);


  }


  if (attribute_list.location == true) {

  // This is a single value

  json_object["Location"] = std::string(attribute_values.location);


  }


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Publishes an incoming/generated DiscoverParameter command for
 * the ConfigurationParameters cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ConfigurationParameters/GeneratedCommands/DiscoverParameter
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_configuration_parameters_publish_generated_discover_parameter_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_configuration_parameters_command_discover_parameter_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ConfigurationParameters/GeneratedCommands/DiscoverParameter";

  std::string payload =
    get_json_payload_for_configuration_parameters_discover_parameter_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated DefaultResetAllParameters command for
 * the ConfigurationParameters cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ConfigurationParameters/GeneratedCommands/DefaultResetAllParameters
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_configuration_parameters_publish_generated_default_reset_all_parameters_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ConfigurationParameters/GeneratedCommands/DefaultResetAllParameters";

  std::string payload =
    get_json_payload_for_configuration_parameters_default_reset_all_parameters_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetParameter command for
 * the ConfigurationParameters cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ConfigurationParameters/GeneratedCommands/SetParameter
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_configuration_parameters_publish_generated_set_parameter_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_configuration_parameters_command_set_parameter_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ConfigurationParameters/GeneratedCommands/SetParameter";

  std::string payload =
    get_json_payload_for_configuration_parameters_set_parameter_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated DiscoverParameterRange command for
 * the ConfigurationParameters cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ConfigurationParameters/GeneratedCommands/DiscoverParameterRange
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_configuration_parameters_publish_generated_discover_parameter_range_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_configuration_parameters_command_discover_parameter_range_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ConfigurationParameters/GeneratedCommands/DiscoverParameterRange";

  std::string payload =
    get_json_payload_for_configuration_parameters_discover_parameter_range_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}


/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the ConfigurationParameters cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ConfigurationParameters/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_configuration_parameters_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_configuration_parameters_state_t attribute_values,
  uic_mqtt_dotdot_configuration_parameters_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ConfigurationParameters/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Publishes an incoming/generated IQReport command for
 * the AoXLocator cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/AoXLocator/GeneratedCommands/IQReport
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_aox_locator_publish_generated_iq_report_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_aox_locator_command_iq_report_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "AoXLocator/GeneratedCommands/IQReport";

  std::string payload =
    get_json_payload_for_aox_locator_iq_report_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated AngleReport command for
 * the AoXLocator cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/AoXLocator/GeneratedCommands/AngleReport
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_aox_locator_publish_generated_angle_report_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_aox_locator_command_angle_report_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "AoXLocator/GeneratedCommands/AngleReport";

  std::string payload =
    get_json_payload_for_aox_locator_angle_report_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated AngleCorrection command for
 * the AoXLocator cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/AoXLocator/GeneratedCommands/AngleCorrection
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_aox_locator_publish_generated_angle_correction_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_aox_locator_command_angle_correction_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "AoXLocator/GeneratedCommands/AngleCorrection";

  std::string payload =
    get_json_payload_for_aox_locator_angle_correction_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}


/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the AoXLocator cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/AoXLocator/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_aox_locator_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_aox_locator_state_t attribute_values,
  uic_mqtt_dotdot_aox_locator_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "AoXLocator/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  if (attribute_list.reporting_mode == true) {

  // This is a single value

  #ifdef AOX_LOCATOR_REPORTING_MODE_ENUM_NAME_AVAILABLE
  json_object["ReportingMode"] = aox_locator_reporting_mode_get_enum_value_name((uint32_t)attribute_values.reporting_mode);
  #else
  json_object["ReportingMode"] = static_cast<AoXLocatorReportingMode>(attribute_values.reporting_mode);
  #endif


  }


  if (attribute_list.position_and_orientation_valid == true) {

  // This is a single value

  json_object["PositionAndOrientationValid"] = attribute_values.position_and_orientation_valid;


  }


  if (attribute_list.position_and_orientation == true) {

  // This is a single value

  nlohmann::json json_sub_object = nlohmann::json::object();
   json_sub_object["CoordinateX"] = attribute_values.position_and_orientation.CoordinateX;
   json_sub_object["CoordinateY"] = attribute_values.position_and_orientation.CoordinateY;
   json_sub_object["CoordinateZ"] = attribute_values.position_and_orientation.CoordinateZ;
   json_sub_object["OrientationX"] = attribute_values.position_and_orientation.OrientationX;
   json_sub_object["OrientationY"] = attribute_values.position_and_orientation.OrientationY;
   json_sub_object["OrientationZ"] = attribute_values.position_and_orientation.OrientationZ;
  json_object["PositionAndOrientation"] = json_sub_object;


  }


  if (attribute_list.azimuth_mask == true) {

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  json_object["AzimuthMask"] = nlohmann::json::array();

  for (size_t i = 0; i<attribute_values.azimuth_mask_count;i++) {
    // Struct type
    nlohmann::json json_sub_object = nlohmann::json::object();
    json_sub_object["Min"] = attribute_values.azimuth_mask[i].Min;
    json_sub_object["Max"] = attribute_values.azimuth_mask[i].Max;
    json_object["AzimuthMask"].push_back(json_sub_object);
  }


  }


  if (attribute_list.elevation_mask == true) {

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  json_object["ElevationMask"] = nlohmann::json::array();

  for (size_t i = 0; i<attribute_values.elevation_mask_count;i++) {
    // Struct type
    nlohmann::json json_sub_object = nlohmann::json::object();
    json_sub_object["Min"] = attribute_values.elevation_mask[i].Min;
    json_sub_object["Max"] = attribute_values.elevation_mask[i].Max;
    json_object["ElevationMask"].push_back(json_sub_object);
  }


  }


  if (attribute_list.allow_list == true) {

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  json_object["AllowList"] = nlohmann::json::array();

  for (size_t i = 0; i<attribute_values.allow_list_count;i++) {
    // String type
    json_object["AllowList"].push_back(std::string(attribute_values.allow_list[i]));
  }


  }


  if (attribute_list.aox_mode == true) {

  // This is a single value

  #ifdef AOX_LOCATOR_AOX_MODE_ENUM_NAME_AVAILABLE
  json_object["AoXMode"] = aox_locator_aox_mode_get_enum_value_name((uint32_t)attribute_values.aox_mode);
  #else
  json_object["AoXMode"] = static_cast<AoXLocatorAoXMode>(attribute_values.aox_mode);
  #endif


  }


  if (attribute_list.antenna_mode == true) {

  // This is a single value

  #ifdef AOX_LOCATOR_ANTENNA_MODE_ENUM_NAME_AVAILABLE
  json_object["AntennaMode"] = aox_locator_antenna_mode_get_enum_value_name((uint32_t)attribute_values.antenna_mode);
  #else
  json_object["AntennaMode"] = static_cast<AoXLocatorAntennaMode>(attribute_values.antenna_mode);
  #endif


  }


  if (attribute_list.antenna_array == true) {

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  json_object["AntennaArray"] = nlohmann::json::array();

  for (size_t i = 0; i<attribute_values.antenna_array_count;i++) {
    json_object["AntennaArray"].push_back(attribute_values.antenna_array[i]);
  }


  }


  if (attribute_list.period_samples == true) {

  // This is a single value

  json_object["PeriodSamples"] = attribute_values.period_samples;


  }


  if (attribute_list.angle_filtering == true) {

  // This is a single value

  json_object["AngleFiltering"] = attribute_values.angle_filtering;


  }


  if (attribute_list.angle_filtering_weight == true) {

  // This is a single value

  json_object["AngleFilteringWeight"] = attribute_values.angle_filtering_weight;


  }


  if (attribute_list.angle_correction_timeout == true) {

  // This is a single value

  json_object["AngleCorrectionTimeout"] = attribute_values.angle_correction_timeout;


  }


  if (attribute_list.angle_correction_delay == true) {

  // This is a single value

  json_object["AngleCorrectionDelay"] = attribute_values.angle_correction_delay;


  }


  if (attribute_list.cte_mode == true) {

  // This is a single value

  #ifdef AOX_LOCATOR_CTE_MODE_ENUM_NAME_AVAILABLE
  json_object["CTEMode"] = aox_locator_cte_mode_get_enum_value_name((uint32_t)attribute_values.cte_mode);
  #else
  json_object["CTEMode"] = static_cast<AoXLocatorCTEMode>(attribute_values.cte_mode);
  #endif


  }


  if (attribute_list.cte_sampling_interval == true) {

  // This is a single value

  json_object["CTESamplingInterval"] = attribute_values.cte_sampling_interval;


  }


  if (attribute_list.cte_length == true) {

  // This is a single value

  json_object["CTELength"] = attribute_values.cte_length;


  }


  if (attribute_list.slot_duration == true) {

  // This is a single value

  json_object["SlotDuration"] = attribute_values.slot_duration;


  }


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}



/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the AoXPositionEstimation cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/AoXPositionEstimation/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_aox_position_estimation_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_aox_position_estimation_state_t attribute_values,
  uic_mqtt_dotdot_aox_position_estimation_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "AoXPositionEstimation/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Publishes an incoming/generated Write command for
 * the ProtocolController-NetworkManagement cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/ProtocolController/NetworkManagement/GeneratedCommands/Write
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_protocol_controller_network_management_publish_generated_write_command(
  const dotdot_unid_t unid
) {
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(unid) + "/";
  topic += "ProtocolController/NetworkManagement/GeneratedCommands/Write";

  std::string payload =
    get_json_payload_for_protocol_controller_network_management_write_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}


/**
 * @brief Publishes an incoming/generated WriteAttributes command for
 * the ProtocolController-NetworkManagement cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/ProtocolController/NetworkManagement/GeneratedCommands/WriteAttributes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param attribute_values  Values to assign to the attributes
 * @param attribute_list    List of attributes that are written
 */
void uic_mqtt_dotdot_protocol_controller_network_management_publish_generated_write_attributes_command(
  const dotdot_unid_t unid,
  uic_mqtt_dotdot_protocol_controller_network_management_state_t attribute_values,
  uic_mqtt_dotdot_protocol_controller_network_management_updated_state_t attribute_list
){
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(unid) + "/";
  topic += "ProtocolController/NetworkManagement/GeneratedCommands/WriteAttributes";

  nlohmann::json json_object = nlohmann::json::object();


  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

