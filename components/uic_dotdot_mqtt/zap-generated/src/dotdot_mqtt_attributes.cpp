/******************************************************************************
 * # License
 * <b>Copyright 2021 Silicon Laboratories Inc. www.silabs.com</b>
 ******************************************************************************
 * The licensor of this software is Silicon Laboratories Inc. Your use of this
 * software is governed by the terms of Silicon Labs Master Software License
 * Agreement (MSLA) available at
 * www.silabs.com/about-us/legal/master-software-license-agreement. This
 * software is distributed to you in Source Code format and is governed by the
 * sections of the MSLA applicable to Source Code.
 *
 *****************************************************************************/

// This file is generated by ZCL Advanced Platform generator. Please don't edit manually.
#include "uic_mqtt.h"
#include "sl_log.h"
#include "sl_status.h"
#include "dotdot_bitmap.hpp"
#include "json_helpers.hpp"

#include <string>
#include <vector>
#include <inttypes.h>

#include <boost/algorithm/string.hpp>

#include "dotdot_mqtt.h"
#include "dotdot_mqtt.hpp"
#include "dotdot_mqtt_parsing_helpers.hpp"
#include "dotdot_mqtt_attributes.h"
#include "dotdot_mqtt_translators.h"

#include <nlohmann/json.hpp>

static constexpr char LOG_TAG[] = "dotdot_mqtt_attributes";
static constexpr char LOG_FMT_JSON_ERROR[] = "%s: Unable to parse JSON payload: %s";

// Use std namespace to allow extending to_string methods below
using namespace std;


template<typename Type>
Type get_enum_decimal_value(const std::string &key, nlohmann::json &jsn)
{
  if (jsn[key].is_number_integer()) {
    return jsn[key].get<Type>();
  } else if (jsn[key].is_string()) {
    try {
      std::string payload_value = jsn[key].get<std::string>();
      boost::replace_all(payload_value, "\"", "");
      Type value = static_cast<Type>(std::stoi(payload_value, nullptr, 0));
      sl_log_warning(LOG_TAG,
                     "Accepted a decimal value '%s' as enum argument.",
                     payload_value.c_str());
      return value;
    } catch (std::invalid_argument &e) {
      return std::numeric_limits<Type>::max();
    }
  } else {
    sl_log_error(LOG_TAG, "Failed to parse JSON message, invalid Json value");
    return std::numeric_limits<Type>::max();
  }
}


///////////////////////////////////////////////////////////////////////////////
// Callback pointers for Basic
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_basic_attribute_zcl_version_callback_t uic_mqtt_dotdot_basic_attribute_zcl_version_callback = nullptr;
static uic_mqtt_dotdot_basic_attribute_application_version_callback_t uic_mqtt_dotdot_basic_attribute_application_version_callback = nullptr;
static uic_mqtt_dotdot_basic_attribute_stack_version_callback_t uic_mqtt_dotdot_basic_attribute_stack_version_callback = nullptr;
static uic_mqtt_dotdot_basic_attribute_hw_version_callback_t uic_mqtt_dotdot_basic_attribute_hw_version_callback = nullptr;
static uic_mqtt_dotdot_basic_attribute_manufacturer_name_callback_t uic_mqtt_dotdot_basic_attribute_manufacturer_name_callback = nullptr;
static uic_mqtt_dotdot_basic_attribute_model_identifier_callback_t uic_mqtt_dotdot_basic_attribute_model_identifier_callback = nullptr;
static uic_mqtt_dotdot_basic_attribute_date_code_callback_t uic_mqtt_dotdot_basic_attribute_date_code_callback = nullptr;
static uic_mqtt_dotdot_basic_attribute_power_source_callback_t uic_mqtt_dotdot_basic_attribute_power_source_callback = nullptr;
static uic_mqtt_dotdot_basic_attribute_generic_device_class_callback_t uic_mqtt_dotdot_basic_attribute_generic_device_class_callback = nullptr;
static uic_mqtt_dotdot_basic_attribute_generic_device_type_callback_t uic_mqtt_dotdot_basic_attribute_generic_device_type_callback = nullptr;
static uic_mqtt_dotdot_basic_attribute_product_code_callback_t uic_mqtt_dotdot_basic_attribute_product_code_callback = nullptr;
static uic_mqtt_dotdot_basic_attribute_producturl_callback_t uic_mqtt_dotdot_basic_attribute_producturl_callback = nullptr;
static uic_mqtt_dotdot_basic_attribute_manufacturer_version_details_callback_t uic_mqtt_dotdot_basic_attribute_manufacturer_version_details_callback = nullptr;
static uic_mqtt_dotdot_basic_attribute_serial_number_callback_t uic_mqtt_dotdot_basic_attribute_serial_number_callback = nullptr;
static uic_mqtt_dotdot_basic_attribute_product_label_callback_t uic_mqtt_dotdot_basic_attribute_product_label_callback = nullptr;
static uic_mqtt_dotdot_basic_attribute_location_description_callback_t uic_mqtt_dotdot_basic_attribute_location_description_callback = nullptr;
static uic_mqtt_dotdot_basic_attribute_physical_environment_callback_t uic_mqtt_dotdot_basic_attribute_physical_environment_callback = nullptr;
static uic_mqtt_dotdot_basic_attribute_device_enabled_callback_t uic_mqtt_dotdot_basic_attribute_device_enabled_callback = nullptr;
static uic_mqtt_dotdot_basic_attribute_alarm_mask_callback_t uic_mqtt_dotdot_basic_attribute_alarm_mask_callback = nullptr;
static uic_mqtt_dotdot_basic_attribute_disable_local_config_callback_t uic_mqtt_dotdot_basic_attribute_disable_local_config_callback = nullptr;
static uic_mqtt_dotdot_basic_attribute_sw_buildid_callback_t uic_mqtt_dotdot_basic_attribute_sw_buildid_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for Basic
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_basic_zcl_version_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_basic_attribute_zcl_version_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t zcl_version = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Basic::ZCLVersion: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      zcl_version = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_basic_attribute_zcl_version_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    zcl_version
  );

}
static void uic_mqtt_dotdot_on_basic_application_version_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_basic_attribute_application_version_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t application_version = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Basic::ApplicationVersion: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      application_version = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_basic_attribute_application_version_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    application_version
  );

}
static void uic_mqtt_dotdot_on_basic_stack_version_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_basic_attribute_stack_version_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t stack_version = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Basic::StackVersion: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      stack_version = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_basic_attribute_stack_version_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    stack_version
  );

}
static void uic_mqtt_dotdot_on_basic_hw_version_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_basic_attribute_hw_version_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t hw_version = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Basic::HWVersion: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      hw_version = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_basic_attribute_hw_version_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    hw_version
  );

}
static void uic_mqtt_dotdot_on_basic_manufacturer_name_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_basic_attribute_manufacturer_name_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  const char* manufacturer_name = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Basic::ManufacturerName: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      manufacturer_name = json_payload.at("value").get_ptr<const std::string*>()->c_str();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_basic_attribute_manufacturer_name_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    manufacturer_name
  );

}
static void uic_mqtt_dotdot_on_basic_model_identifier_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_basic_attribute_model_identifier_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  const char* model_identifier = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Basic::ModelIdentifier: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      model_identifier = json_payload.at("value").get_ptr<const std::string*>()->c_str();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_basic_attribute_model_identifier_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    model_identifier
  );

}
static void uic_mqtt_dotdot_on_basic_date_code_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_basic_attribute_date_code_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  const char* date_code = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Basic::DateCode: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      date_code = json_payload.at("value").get_ptr<const std::string*>()->c_str();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_basic_attribute_date_code_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    date_code
  );

}
static void uic_mqtt_dotdot_on_basic_power_source_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_basic_attribute_power_source_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t power_source = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Basic::PowerSource: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<BasicPowerSource>("value", json_payload);
      if (tmp == numeric_limits<BasicPowerSource>::max()) {
      #ifdef BASIC_POWER_SOURCE_ENUM_NAME_AVAILABLE
        tmp = basic_power_source_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(POWER_SOURCE_ENUM_NAME_AVAILABLE)
        tmp = power_source_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      power_source = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_basic_attribute_power_source_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    power_source
  );

}
static void uic_mqtt_dotdot_on_basic_generic_device_class_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_basic_attribute_generic_device_class_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t generic_device_class = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Basic::GenericDevice-Class: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<BasicGenericDeviceClass>("value", json_payload);
      if (tmp == numeric_limits<BasicGenericDeviceClass>::max()) {
      #ifdef BASIC_GENERIC_DEVICE_CLASS_ENUM_NAME_AVAILABLE
        tmp = basic_generic_device_class_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(GENERIC_DEVICE_CLASS_ENUM_NAME_AVAILABLE)
        tmp = generic_device_class_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      generic_device_class = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_basic_attribute_generic_device_class_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    generic_device_class
  );

}
static void uic_mqtt_dotdot_on_basic_generic_device_type_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_basic_attribute_generic_device_type_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t generic_device_type = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Basic::GenericDevice-Type: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<BasicGenericDeviceType>("value", json_payload);
      if (tmp == numeric_limits<BasicGenericDeviceType>::max()) {
      #ifdef BASIC_GENERIC_DEVICE_TYPE_ENUM_NAME_AVAILABLE
        tmp = basic_generic_device_type_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(GENERIC_DEVICE_TYPE_ENUM_NAME_AVAILABLE)
        tmp = generic_device_type_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      generic_device_type = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_basic_attribute_generic_device_type_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    generic_device_type
  );

}
static void uic_mqtt_dotdot_on_basic_product_code_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_basic_attribute_product_code_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  const char* product_code = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Basic::ProductCode: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      product_code = json_payload.at("value").get_ptr<const std::string*>()->c_str();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_basic_attribute_product_code_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    product_code
  );

}
static void uic_mqtt_dotdot_on_basic_producturl_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_basic_attribute_producturl_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  const char* producturl = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Basic::ProductURL: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      producturl = json_payload.at("value").get_ptr<const std::string*>()->c_str();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_basic_attribute_producturl_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    producturl
  );

}
static void uic_mqtt_dotdot_on_basic_manufacturer_version_details_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_basic_attribute_manufacturer_version_details_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  const char* manufacturer_version_details = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Basic::ManufacturerVersionDetails: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      manufacturer_version_details = json_payload.at("value").get_ptr<const std::string*>()->c_str();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_basic_attribute_manufacturer_version_details_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    manufacturer_version_details
  );

}
static void uic_mqtt_dotdot_on_basic_serial_number_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_basic_attribute_serial_number_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  const char* serial_number = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Basic::SerialNumber: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      serial_number = json_payload.at("value").get_ptr<const std::string*>()->c_str();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_basic_attribute_serial_number_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    serial_number
  );

}
static void uic_mqtt_dotdot_on_basic_product_label_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_basic_attribute_product_label_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  const char* product_label = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Basic::ProductLabel: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      product_label = json_payload.at("value").get_ptr<const std::string*>()->c_str();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_basic_attribute_product_label_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    product_label
  );

}
static void uic_mqtt_dotdot_on_basic_location_description_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_basic_attribute_location_description_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  const char* location_description = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Basic::LocationDescription: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      location_description = json_payload.at("value").get_ptr<const std::string*>()->c_str();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_basic_attribute_location_description_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    location_description
  );

}
static void uic_mqtt_dotdot_on_basic_physical_environment_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_basic_attribute_physical_environment_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t physical_environment = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Basic::PhysicalEnvironment: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<BasicPhysicalEnvironment>("value", json_payload);
      if (tmp == numeric_limits<BasicPhysicalEnvironment>::max()) {
      #ifdef BASIC_PHYSICAL_ENVIRONMENT_ENUM_NAME_AVAILABLE
        tmp = basic_physical_environment_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(PHYSICAL_ENVIRONMENT_ENUM_NAME_AVAILABLE)
        tmp = physical_environment_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      physical_environment = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_basic_attribute_physical_environment_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    physical_environment
  );

}
static void uic_mqtt_dotdot_on_basic_device_enabled_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_basic_attribute_device_enabled_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  bool device_enabled = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Basic::DeviceEnabled: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      device_enabled = get_bool_from_json(json_payload, "value");

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_basic_attribute_device_enabled_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    device_enabled
  );

}
static void uic_mqtt_dotdot_on_basic_alarm_mask_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_basic_attribute_alarm_mask_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t alarm_mask = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Basic::AlarmMask: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      alarm_mask = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, BasicAlarmMask);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_basic_attribute_alarm_mask_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    alarm_mask
  );

}
static void uic_mqtt_dotdot_on_basic_disable_local_config_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_basic_attribute_disable_local_config_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t disable_local_config = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Basic::DisableLocalConfig: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      disable_local_config = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, BasicDisableLocalConfig);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_basic_attribute_disable_local_config_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    disable_local_config
  );

}
static void uic_mqtt_dotdot_on_basic_sw_buildid_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_basic_attribute_sw_buildid_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  const char* sw_buildid = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Basic::SWBuildID: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      sw_buildid = json_payload.at("value").get_ptr<const std::string*>()->c_str();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_basic_attribute_sw_buildid_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    sw_buildid
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for Basic
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_basic_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_basic_attribute_zcl_version_callback) {
    subscription_topic = base_topic + "Basic/Attributes/ZCLVersion/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_basic_zcl_version_attribute_update);
  }
  if(uic_mqtt_dotdot_basic_attribute_application_version_callback) {
    subscription_topic = base_topic + "Basic/Attributes/ApplicationVersion/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_basic_application_version_attribute_update);
  }
  if(uic_mqtt_dotdot_basic_attribute_stack_version_callback) {
    subscription_topic = base_topic + "Basic/Attributes/StackVersion/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_basic_stack_version_attribute_update);
  }
  if(uic_mqtt_dotdot_basic_attribute_hw_version_callback) {
    subscription_topic = base_topic + "Basic/Attributes/HWVersion/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_basic_hw_version_attribute_update);
  }
  if(uic_mqtt_dotdot_basic_attribute_manufacturer_name_callback) {
    subscription_topic = base_topic + "Basic/Attributes/ManufacturerName/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_basic_manufacturer_name_attribute_update);
  }
  if(uic_mqtt_dotdot_basic_attribute_model_identifier_callback) {
    subscription_topic = base_topic + "Basic/Attributes/ModelIdentifier/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_basic_model_identifier_attribute_update);
  }
  if(uic_mqtt_dotdot_basic_attribute_date_code_callback) {
    subscription_topic = base_topic + "Basic/Attributes/DateCode/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_basic_date_code_attribute_update);
  }
  if(uic_mqtt_dotdot_basic_attribute_power_source_callback) {
    subscription_topic = base_topic + "Basic/Attributes/PowerSource/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_basic_power_source_attribute_update);
  }
  if(uic_mqtt_dotdot_basic_attribute_generic_device_class_callback) {
    subscription_topic = base_topic + "Basic/Attributes/GenericDevice-Class/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_basic_generic_device_class_attribute_update);
  }
  if(uic_mqtt_dotdot_basic_attribute_generic_device_type_callback) {
    subscription_topic = base_topic + "Basic/Attributes/GenericDevice-Type/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_basic_generic_device_type_attribute_update);
  }
  if(uic_mqtt_dotdot_basic_attribute_product_code_callback) {
    subscription_topic = base_topic + "Basic/Attributes/ProductCode/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_basic_product_code_attribute_update);
  }
  if(uic_mqtt_dotdot_basic_attribute_producturl_callback) {
    subscription_topic = base_topic + "Basic/Attributes/ProductURL/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_basic_producturl_attribute_update);
  }
  if(uic_mqtt_dotdot_basic_attribute_manufacturer_version_details_callback) {
    subscription_topic = base_topic + "Basic/Attributes/ManufacturerVersionDetails/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_basic_manufacturer_version_details_attribute_update);
  }
  if(uic_mqtt_dotdot_basic_attribute_serial_number_callback) {
    subscription_topic = base_topic + "Basic/Attributes/SerialNumber/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_basic_serial_number_attribute_update);
  }
  if(uic_mqtt_dotdot_basic_attribute_product_label_callback) {
    subscription_topic = base_topic + "Basic/Attributes/ProductLabel/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_basic_product_label_attribute_update);
  }
  if(uic_mqtt_dotdot_basic_attribute_location_description_callback) {
    subscription_topic = base_topic + "Basic/Attributes/LocationDescription/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_basic_location_description_attribute_update);
  }
  if(uic_mqtt_dotdot_basic_attribute_physical_environment_callback) {
    subscription_topic = base_topic + "Basic/Attributes/PhysicalEnvironment/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_basic_physical_environment_attribute_update);
  }
  if(uic_mqtt_dotdot_basic_attribute_device_enabled_callback) {
    subscription_topic = base_topic + "Basic/Attributes/DeviceEnabled/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_basic_device_enabled_attribute_update);
  }
  if(uic_mqtt_dotdot_basic_attribute_alarm_mask_callback) {
    subscription_topic = base_topic + "Basic/Attributes/AlarmMask/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_basic_alarm_mask_attribute_update);
  }
  if(uic_mqtt_dotdot_basic_attribute_disable_local_config_callback) {
    subscription_topic = base_topic + "Basic/Attributes/DisableLocalConfig/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_basic_disable_local_config_attribute_update);
  }
  if(uic_mqtt_dotdot_basic_attribute_sw_buildid_callback) {
    subscription_topic = base_topic + "Basic/Attributes/SWBuildID/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_basic_sw_buildid_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for Basic
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_basic_attribute_zcl_version_callback_set(const uic_mqtt_dotdot_basic_attribute_zcl_version_callback_t callback)
{
  uic_mqtt_dotdot_basic_attribute_zcl_version_callback = callback;
}
void uic_mqtt_dotdot_basic_attribute_application_version_callback_set(const uic_mqtt_dotdot_basic_attribute_application_version_callback_t callback)
{
  uic_mqtt_dotdot_basic_attribute_application_version_callback = callback;
}
void uic_mqtt_dotdot_basic_attribute_stack_version_callback_set(const uic_mqtt_dotdot_basic_attribute_stack_version_callback_t callback)
{
  uic_mqtt_dotdot_basic_attribute_stack_version_callback = callback;
}
void uic_mqtt_dotdot_basic_attribute_hw_version_callback_set(const uic_mqtt_dotdot_basic_attribute_hw_version_callback_t callback)
{
  uic_mqtt_dotdot_basic_attribute_hw_version_callback = callback;
}
void uic_mqtt_dotdot_basic_attribute_manufacturer_name_callback_set(const uic_mqtt_dotdot_basic_attribute_manufacturer_name_callback_t callback)
{
  uic_mqtt_dotdot_basic_attribute_manufacturer_name_callback = callback;
}
void uic_mqtt_dotdot_basic_attribute_model_identifier_callback_set(const uic_mqtt_dotdot_basic_attribute_model_identifier_callback_t callback)
{
  uic_mqtt_dotdot_basic_attribute_model_identifier_callback = callback;
}
void uic_mqtt_dotdot_basic_attribute_date_code_callback_set(const uic_mqtt_dotdot_basic_attribute_date_code_callback_t callback)
{
  uic_mqtt_dotdot_basic_attribute_date_code_callback = callback;
}
void uic_mqtt_dotdot_basic_attribute_power_source_callback_set(const uic_mqtt_dotdot_basic_attribute_power_source_callback_t callback)
{
  uic_mqtt_dotdot_basic_attribute_power_source_callback = callback;
}
void uic_mqtt_dotdot_basic_attribute_generic_device_class_callback_set(const uic_mqtt_dotdot_basic_attribute_generic_device_class_callback_t callback)
{
  uic_mqtt_dotdot_basic_attribute_generic_device_class_callback = callback;
}
void uic_mqtt_dotdot_basic_attribute_generic_device_type_callback_set(const uic_mqtt_dotdot_basic_attribute_generic_device_type_callback_t callback)
{
  uic_mqtt_dotdot_basic_attribute_generic_device_type_callback = callback;
}
void uic_mqtt_dotdot_basic_attribute_product_code_callback_set(const uic_mqtt_dotdot_basic_attribute_product_code_callback_t callback)
{
  uic_mqtt_dotdot_basic_attribute_product_code_callback = callback;
}
void uic_mqtt_dotdot_basic_attribute_producturl_callback_set(const uic_mqtt_dotdot_basic_attribute_producturl_callback_t callback)
{
  uic_mqtt_dotdot_basic_attribute_producturl_callback = callback;
}
void uic_mqtt_dotdot_basic_attribute_manufacturer_version_details_callback_set(const uic_mqtt_dotdot_basic_attribute_manufacturer_version_details_callback_t callback)
{
  uic_mqtt_dotdot_basic_attribute_manufacturer_version_details_callback = callback;
}
void uic_mqtt_dotdot_basic_attribute_serial_number_callback_set(const uic_mqtt_dotdot_basic_attribute_serial_number_callback_t callback)
{
  uic_mqtt_dotdot_basic_attribute_serial_number_callback = callback;
}
void uic_mqtt_dotdot_basic_attribute_product_label_callback_set(const uic_mqtt_dotdot_basic_attribute_product_label_callback_t callback)
{
  uic_mqtt_dotdot_basic_attribute_product_label_callback = callback;
}
void uic_mqtt_dotdot_basic_attribute_location_description_callback_set(const uic_mqtt_dotdot_basic_attribute_location_description_callback_t callback)
{
  uic_mqtt_dotdot_basic_attribute_location_description_callback = callback;
}
void uic_mqtt_dotdot_basic_attribute_physical_environment_callback_set(const uic_mqtt_dotdot_basic_attribute_physical_environment_callback_t callback)
{
  uic_mqtt_dotdot_basic_attribute_physical_environment_callback = callback;
}
void uic_mqtt_dotdot_basic_attribute_device_enabled_callback_set(const uic_mqtt_dotdot_basic_attribute_device_enabled_callback_t callback)
{
  uic_mqtt_dotdot_basic_attribute_device_enabled_callback = callback;
}
void uic_mqtt_dotdot_basic_attribute_alarm_mask_callback_set(const uic_mqtt_dotdot_basic_attribute_alarm_mask_callback_t callback)
{
  uic_mqtt_dotdot_basic_attribute_alarm_mask_callback = callback;
}
void uic_mqtt_dotdot_basic_attribute_disable_local_config_callback_set(const uic_mqtt_dotdot_basic_attribute_disable_local_config_callback_t callback)
{
  uic_mqtt_dotdot_basic_attribute_disable_local_config_callback = callback;
}
void uic_mqtt_dotdot_basic_attribute_sw_buildid_callback_set(const uic_mqtt_dotdot_basic_attribute_sw_buildid_callback_t callback)
{
  uic_mqtt_dotdot_basic_attribute_sw_buildid_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for PowerConfiguration
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_power_configuration_attribute_mains_voltage_callback_t uic_mqtt_dotdot_power_configuration_attribute_mains_voltage_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_mains_frequency_callback_t uic_mqtt_dotdot_power_configuration_attribute_mains_frequency_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_mains_alarm_mask_callback_t uic_mqtt_dotdot_power_configuration_attribute_mains_alarm_mask_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_mains_voltage_min_threshold_callback_t uic_mqtt_dotdot_power_configuration_attribute_mains_voltage_min_threshold_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_mains_voltage_max_threshold_callback_t uic_mqtt_dotdot_power_configuration_attribute_mains_voltage_max_threshold_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_mains_voltage_dwell_trip_point_callback_t uic_mqtt_dotdot_power_configuration_attribute_mains_voltage_dwell_trip_point_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_remaining_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_remaining_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery_manufacturer_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery_manufacturer_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery_size_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery_size_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_batterya_hr_rating_callback_t uic_mqtt_dotdot_power_configuration_attribute_batterya_hr_rating_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery_quantity_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery_quantity_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery_rated_voltage_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery_rated_voltage_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery_alarm_mask_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery_alarm_mask_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_min_threshold_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_min_threshold_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_threshold1_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_threshold1_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_threshold2_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_threshold2_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_threshold3_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_threshold3_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_min_threshold_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_min_threshold_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_threshold1_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_threshold1_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_threshold2_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_threshold2_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_threshold3_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_threshold3_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery_alarm_state_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery_alarm_state_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_remaining_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_remaining_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery2_manufacturer_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery2_manufacturer_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery2_size_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery2_size_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery2a_hr_rating_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery2a_hr_rating_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery2_quantity_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery2_quantity_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery2_rated_voltage_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery2_rated_voltage_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery2_alarm_mask_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery2_alarm_mask_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_min_threshold_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_min_threshold_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_threshold1_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_threshold1_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_threshold2_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_threshold2_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_threshold3_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_threshold3_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_min_threshold_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_min_threshold_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_threshold1_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_threshold1_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_threshold2_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_threshold2_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_threshold3_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_threshold3_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery2_alarm_state_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery2_alarm_state_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_remaining_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_remaining_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery3_manufacturer_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery3_manufacturer_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery3_size_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery3_size_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery3a_hr_rating_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery3a_hr_rating_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery3_quantity_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery3_quantity_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery3_rated_voltage_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery3_rated_voltage_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery3_alarm_mask_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery3_alarm_mask_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_min_threshold_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_min_threshold_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_threshold1_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_threshold1_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_threshold2_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_threshold2_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_threshold3_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_threshold3_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_min_threshold_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_min_threshold_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_threshold1_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_threshold1_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_threshold2_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_threshold2_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_threshold3_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_threshold3_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_attribute_battery3_alarm_state_callback_t uic_mqtt_dotdot_power_configuration_attribute_battery3_alarm_state_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for PowerConfiguration
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_power_configuration_mains_voltage_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_mains_voltage_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t mains_voltage = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::MainsVoltage: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      mains_voltage = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_mains_voltage_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    mains_voltage
  );

}
static void uic_mqtt_dotdot_on_power_configuration_mains_frequency_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_mains_frequency_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t mains_frequency = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::MainsFrequency: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      mains_frequency = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_mains_frequency_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    mains_frequency
  );

}
static void uic_mqtt_dotdot_on_power_configuration_mains_alarm_mask_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_mains_alarm_mask_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t mains_alarm_mask = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::MainsAlarmMask: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      mains_alarm_mask = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, PowerConfigurationMainsAlarmMask);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_mains_alarm_mask_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    mains_alarm_mask
  );

}
static void uic_mqtt_dotdot_on_power_configuration_mains_voltage_min_threshold_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_mains_voltage_min_threshold_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t mains_voltage_min_threshold = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::MainsVoltageMinThreshold: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      mains_voltage_min_threshold = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_mains_voltage_min_threshold_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    mains_voltage_min_threshold
  );

}
static void uic_mqtt_dotdot_on_power_configuration_mains_voltage_max_threshold_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_mains_voltage_max_threshold_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t mains_voltage_max_threshold = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::MainsVoltageMaxThreshold: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      mains_voltage_max_threshold = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_mains_voltage_max_threshold_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    mains_voltage_max_threshold
  );

}
static void uic_mqtt_dotdot_on_power_configuration_mains_voltage_dwell_trip_point_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_mains_voltage_dwell_trip_point_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t mains_voltage_dwell_trip_point = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::MainsVoltageDwellTripPoint: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      mains_voltage_dwell_trip_point = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_mains_voltage_dwell_trip_point_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    mains_voltage_dwell_trip_point
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery_voltage_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery_voltage = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::BatteryVoltage: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery_voltage = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery_voltage
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery_percentage_remaining_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_remaining_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery_percentage_remaining = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::BatteryPercentageRemaining: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery_percentage_remaining = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_remaining_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery_percentage_remaining
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery_manufacturer_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery_manufacturer_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  const char* battery_manufacturer = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::BatteryManufacturer: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery_manufacturer = json_payload.at("value").get_ptr<const std::string*>()->c_str();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery_manufacturer_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery_manufacturer
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery_size_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery_size_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  BatterySize battery_size = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::BatterySize: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<BatterySize>("value", json_payload);
      if (tmp == numeric_limits<BatterySize>::max()) {
      #ifdef POWER_CONFIGURATION_BATTERY_SIZE_ENUM_NAME_AVAILABLE
        tmp = power_configuration_battery_size_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(BATTERY_SIZE_ENUM_NAME_AVAILABLE)
        tmp = battery_size_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      battery_size = static_cast<BatterySize>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery_size_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery_size
  );

}
static void uic_mqtt_dotdot_on_power_configuration_batterya_hr_rating_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_batterya_hr_rating_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t batterya_hr_rating = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::BatteryAHrRating: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      batterya_hr_rating = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_batterya_hr_rating_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    batterya_hr_rating
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery_quantity_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery_quantity_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery_quantity = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::BatteryQuantity: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery_quantity = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery_quantity_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery_quantity
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery_rated_voltage_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery_rated_voltage_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery_rated_voltage = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::BatteryRatedVoltage: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery_rated_voltage = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery_rated_voltage_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery_rated_voltage
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery_alarm_mask_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery_alarm_mask_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery_alarm_mask = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::BatteryAlarmMask: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery_alarm_mask = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, BatteryAlarmMask);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery_alarm_mask_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery_alarm_mask
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery_voltage_min_threshold_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_min_threshold_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery_voltage_min_threshold = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::BatteryVoltageMinThreshold: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery_voltage_min_threshold = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_min_threshold_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery_voltage_min_threshold
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery_voltage_threshold1_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_threshold1_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery_voltage_threshold1 = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::BatteryVoltageThreshold1: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery_voltage_threshold1 = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_threshold1_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery_voltage_threshold1
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery_voltage_threshold2_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_threshold2_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery_voltage_threshold2 = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::BatteryVoltageThreshold2: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery_voltage_threshold2 = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_threshold2_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery_voltage_threshold2
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery_voltage_threshold3_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_threshold3_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery_voltage_threshold3 = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::BatteryVoltageThreshold3: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery_voltage_threshold3 = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_threshold3_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery_voltage_threshold3
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery_percentage_min_threshold_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_min_threshold_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery_percentage_min_threshold = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::BatteryPercentageMinThreshold: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery_percentage_min_threshold = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_min_threshold_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery_percentage_min_threshold
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery_percentage_threshold1_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_threshold1_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery_percentage_threshold1 = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::BatteryPercentageThreshold1: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery_percentage_threshold1 = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_threshold1_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery_percentage_threshold1
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery_percentage_threshold2_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_threshold2_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery_percentage_threshold2 = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::BatteryPercentageThreshold2: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery_percentage_threshold2 = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_threshold2_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery_percentage_threshold2
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery_percentage_threshold3_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_threshold3_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery_percentage_threshold3 = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::BatteryPercentageThreshold3: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery_percentage_threshold3 = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_threshold3_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery_percentage_threshold3
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery_alarm_state_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery_alarm_state_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t battery_alarm_state = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::BatteryAlarmState: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery_alarm_state = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, BatteryAlarmState);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery_alarm_state_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery_alarm_state
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery2_voltage_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery2_voltage = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::Battery2Voltage: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery2_voltage = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery2_voltage
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery2_percentage_remaining_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_remaining_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery2_percentage_remaining = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::Battery2PercentageRemaining: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery2_percentage_remaining = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_remaining_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery2_percentage_remaining
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery2_manufacturer_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery2_manufacturer_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  const char* battery2_manufacturer = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::Battery2Manufacturer: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery2_manufacturer = json_payload.at("value").get_ptr<const std::string*>()->c_str();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery2_manufacturer_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery2_manufacturer
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery2_size_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery2_size_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  BatterySize battery2_size = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::Battery2Size: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<BatterySize>("value", json_payload);
      if (tmp == numeric_limits<BatterySize>::max()) {
      #ifdef POWER_CONFIGURATION_BATTERY2_SIZE_ENUM_NAME_AVAILABLE
        tmp = power_configuration_battery2_size_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(BATTERY2_SIZE_ENUM_NAME_AVAILABLE)
        tmp = battery2_size_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      battery2_size = static_cast<BatterySize>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery2_size_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery2_size
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery2a_hr_rating_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery2a_hr_rating_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t battery2a_hr_rating = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::Battery2AHrRating: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery2a_hr_rating = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery2a_hr_rating_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery2a_hr_rating
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery2_quantity_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery2_quantity_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery2_quantity = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::Battery2Quantity: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery2_quantity = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery2_quantity_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery2_quantity
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery2_rated_voltage_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery2_rated_voltage_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery2_rated_voltage = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::Battery2RatedVoltage: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery2_rated_voltage = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery2_rated_voltage_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery2_rated_voltage
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery2_alarm_mask_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery2_alarm_mask_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery2_alarm_mask = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::Battery2AlarmMask: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery2_alarm_mask = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, BatteryAlarmMask);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery2_alarm_mask_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery2_alarm_mask
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery2_voltage_min_threshold_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_min_threshold_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery2_voltage_min_threshold = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::Battery2VoltageMinThreshold: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery2_voltage_min_threshold = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_min_threshold_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery2_voltage_min_threshold
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery2_voltage_threshold1_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_threshold1_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery2_voltage_threshold1 = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::Battery2VoltageThreshold1: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery2_voltage_threshold1 = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_threshold1_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery2_voltage_threshold1
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery2_voltage_threshold2_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_threshold2_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery2_voltage_threshold2 = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::Battery2VoltageThreshold2: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery2_voltage_threshold2 = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_threshold2_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery2_voltage_threshold2
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery2_voltage_threshold3_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_threshold3_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery2_voltage_threshold3 = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::Battery2VoltageThreshold3: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery2_voltage_threshold3 = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_threshold3_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery2_voltage_threshold3
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery2_percentage_min_threshold_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_min_threshold_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery2_percentage_min_threshold = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::Battery2PercentageMinThreshold: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery2_percentage_min_threshold = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_min_threshold_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery2_percentage_min_threshold
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery2_percentage_threshold1_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_threshold1_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery2_percentage_threshold1 = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::Battery2PercentageThreshold1: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery2_percentage_threshold1 = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_threshold1_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery2_percentage_threshold1
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery2_percentage_threshold2_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_threshold2_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery2_percentage_threshold2 = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::Battery2PercentageThreshold2: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery2_percentage_threshold2 = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_threshold2_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery2_percentage_threshold2
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery2_percentage_threshold3_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_threshold3_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery2_percentage_threshold3 = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::Battery2PercentageThreshold3: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery2_percentage_threshold3 = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_threshold3_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery2_percentage_threshold3
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery2_alarm_state_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery2_alarm_state_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t battery2_alarm_state = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::Battery2AlarmState: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery2_alarm_state = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, BatteryAlarmState);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery2_alarm_state_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery2_alarm_state
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery3_voltage_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery3_voltage = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::Battery3Voltage: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery3_voltage = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery3_voltage
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery3_percentage_remaining_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_remaining_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery3_percentage_remaining = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::Battery3PercentageRemaining: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery3_percentage_remaining = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_remaining_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery3_percentage_remaining
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery3_manufacturer_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery3_manufacturer_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  const char* battery3_manufacturer = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::Battery3Manufacturer: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery3_manufacturer = json_payload.at("value").get_ptr<const std::string*>()->c_str();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery3_manufacturer_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery3_manufacturer
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery3_size_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery3_size_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  BatterySize battery3_size = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::Battery3Size: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<BatterySize>("value", json_payload);
      if (tmp == numeric_limits<BatterySize>::max()) {
      #ifdef POWER_CONFIGURATION_BATTERY3_SIZE_ENUM_NAME_AVAILABLE
        tmp = power_configuration_battery3_size_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(BATTERY3_SIZE_ENUM_NAME_AVAILABLE)
        tmp = battery3_size_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      battery3_size = static_cast<BatterySize>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery3_size_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery3_size
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery3a_hr_rating_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery3a_hr_rating_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t battery3a_hr_rating = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::Battery3AHrRating: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery3a_hr_rating = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery3a_hr_rating_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery3a_hr_rating
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery3_quantity_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery3_quantity_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery3_quantity = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::Battery3Quantity: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery3_quantity = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery3_quantity_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery3_quantity
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery3_rated_voltage_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery3_rated_voltage_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery3_rated_voltage = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::Battery3RatedVoltage: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery3_rated_voltage = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery3_rated_voltage_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery3_rated_voltage
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery3_alarm_mask_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery3_alarm_mask_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery3_alarm_mask = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::Battery3AlarmMask: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery3_alarm_mask = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, BatteryAlarmMask);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery3_alarm_mask_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery3_alarm_mask
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery3_voltage_min_threshold_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_min_threshold_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery3_voltage_min_threshold = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::Battery3VoltageMinThreshold: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery3_voltage_min_threshold = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_min_threshold_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery3_voltage_min_threshold
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery3_voltage_threshold1_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_threshold1_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery3_voltage_threshold1 = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::Battery3VoltageThreshold1: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery3_voltage_threshold1 = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_threshold1_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery3_voltage_threshold1
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery3_voltage_threshold2_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_threshold2_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery3_voltage_threshold2 = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::Battery3VoltageThreshold2: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery3_voltage_threshold2 = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_threshold2_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery3_voltage_threshold2
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery3_voltage_threshold3_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_threshold3_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery3_voltage_threshold3 = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::Battery3VoltageThreshold3: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery3_voltage_threshold3 = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_threshold3_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery3_voltage_threshold3
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery3_percentage_min_threshold_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_min_threshold_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery3_percentage_min_threshold = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::Battery3PercentageMinThreshold: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery3_percentage_min_threshold = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_min_threshold_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery3_percentage_min_threshold
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery3_percentage_threshold1_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_threshold1_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery3_percentage_threshold1 = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::Battery3PercentageThreshold1: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery3_percentage_threshold1 = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_threshold1_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery3_percentage_threshold1
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery3_percentage_threshold2_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_threshold2_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery3_percentage_threshold2 = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::Battery3PercentageThreshold2: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery3_percentage_threshold2 = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_threshold2_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery3_percentage_threshold2
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery3_percentage_threshold3_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_threshold3_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t battery3_percentage_threshold3 = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::Battery3PercentageThreshold3: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery3_percentage_threshold3 = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_threshold3_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery3_percentage_threshold3
  );

}
static void uic_mqtt_dotdot_on_power_configuration_battery3_alarm_state_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_power_configuration_attribute_battery3_alarm_state_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t battery3_alarm_state = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PowerConfiguration::Battery3AlarmState: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery3_alarm_state = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, BatteryAlarmState);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_power_configuration_attribute_battery3_alarm_state_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery3_alarm_state
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for PowerConfiguration
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_power_configuration_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_power_configuration_attribute_mains_voltage_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/MainsVoltage/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_mains_voltage_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_mains_frequency_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/MainsFrequency/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_mains_frequency_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_mains_alarm_mask_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/MainsAlarmMask/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_mains_alarm_mask_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_mains_voltage_min_threshold_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/MainsVoltageMinThreshold/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_mains_voltage_min_threshold_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_mains_voltage_max_threshold_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/MainsVoltageMaxThreshold/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_mains_voltage_max_threshold_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_mains_voltage_dwell_trip_point_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/MainsVoltageDwellTripPoint/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_mains_voltage_dwell_trip_point_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/BatteryVoltage/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery_voltage_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_remaining_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/BatteryPercentageRemaining/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery_percentage_remaining_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery_manufacturer_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/BatteryManufacturer/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery_manufacturer_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery_size_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/BatterySize/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery_size_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_batterya_hr_rating_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/BatteryAHrRating/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_batterya_hr_rating_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery_quantity_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/BatteryQuantity/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery_quantity_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery_rated_voltage_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/BatteryRatedVoltage/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery_rated_voltage_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery_alarm_mask_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/BatteryAlarmMask/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery_alarm_mask_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_min_threshold_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/BatteryVoltageMinThreshold/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery_voltage_min_threshold_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_threshold1_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/BatteryVoltageThreshold1/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery_voltage_threshold1_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_threshold2_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/BatteryVoltageThreshold2/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery_voltage_threshold2_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_threshold3_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/BatteryVoltageThreshold3/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery_voltage_threshold3_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_min_threshold_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/BatteryPercentageMinThreshold/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery_percentage_min_threshold_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_threshold1_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/BatteryPercentageThreshold1/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery_percentage_threshold1_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_threshold2_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/BatteryPercentageThreshold2/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery_percentage_threshold2_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_threshold3_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/BatteryPercentageThreshold3/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery_percentage_threshold3_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery_alarm_state_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/BatteryAlarmState/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery_alarm_state_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/Battery2Voltage/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery2_voltage_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_remaining_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/Battery2PercentageRemaining/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery2_percentage_remaining_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery2_manufacturer_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/Battery2Manufacturer/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery2_manufacturer_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery2_size_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/Battery2Size/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery2_size_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery2a_hr_rating_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/Battery2AHrRating/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery2a_hr_rating_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery2_quantity_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/Battery2Quantity/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery2_quantity_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery2_rated_voltage_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/Battery2RatedVoltage/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery2_rated_voltage_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery2_alarm_mask_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/Battery2AlarmMask/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery2_alarm_mask_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_min_threshold_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/Battery2VoltageMinThreshold/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery2_voltage_min_threshold_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_threshold1_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/Battery2VoltageThreshold1/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery2_voltage_threshold1_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_threshold2_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/Battery2VoltageThreshold2/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery2_voltage_threshold2_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_threshold3_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/Battery2VoltageThreshold3/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery2_voltage_threshold3_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_min_threshold_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/Battery2PercentageMinThreshold/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery2_percentage_min_threshold_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_threshold1_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/Battery2PercentageThreshold1/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery2_percentage_threshold1_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_threshold2_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/Battery2PercentageThreshold2/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery2_percentage_threshold2_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_threshold3_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/Battery2PercentageThreshold3/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery2_percentage_threshold3_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery2_alarm_state_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/Battery2AlarmState/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery2_alarm_state_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/Battery3Voltage/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery3_voltage_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_remaining_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/Battery3PercentageRemaining/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery3_percentage_remaining_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery3_manufacturer_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/Battery3Manufacturer/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery3_manufacturer_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery3_size_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/Battery3Size/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery3_size_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery3a_hr_rating_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/Battery3AHrRating/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery3a_hr_rating_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery3_quantity_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/Battery3Quantity/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery3_quantity_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery3_rated_voltage_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/Battery3RatedVoltage/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery3_rated_voltage_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery3_alarm_mask_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/Battery3AlarmMask/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery3_alarm_mask_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_min_threshold_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/Battery3VoltageMinThreshold/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery3_voltage_min_threshold_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_threshold1_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/Battery3VoltageThreshold1/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery3_voltage_threshold1_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_threshold2_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/Battery3VoltageThreshold2/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery3_voltage_threshold2_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_threshold3_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/Battery3VoltageThreshold3/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery3_voltage_threshold3_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_min_threshold_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/Battery3PercentageMinThreshold/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery3_percentage_min_threshold_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_threshold1_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/Battery3PercentageThreshold1/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery3_percentage_threshold1_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_threshold2_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/Battery3PercentageThreshold2/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery3_percentage_threshold2_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_threshold3_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/Battery3PercentageThreshold3/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery3_percentage_threshold3_attribute_update);
  }
  if(uic_mqtt_dotdot_power_configuration_attribute_battery3_alarm_state_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Attributes/Battery3AlarmState/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_power_configuration_battery3_alarm_state_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for PowerConfiguration
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_power_configuration_attribute_mains_voltage_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_mains_voltage_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_mains_voltage_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_mains_frequency_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_mains_frequency_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_mains_frequency_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_mains_alarm_mask_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_mains_alarm_mask_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_mains_alarm_mask_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_mains_voltage_min_threshold_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_mains_voltage_min_threshold_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_mains_voltage_min_threshold_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_mains_voltage_max_threshold_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_mains_voltage_max_threshold_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_mains_voltage_max_threshold_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_mains_voltage_dwell_trip_point_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_mains_voltage_dwell_trip_point_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_mains_voltage_dwell_trip_point_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_remaining_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_remaining_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_remaining_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery_manufacturer_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery_manufacturer_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery_manufacturer_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery_size_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery_size_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery_size_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_batterya_hr_rating_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_batterya_hr_rating_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_batterya_hr_rating_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery_quantity_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery_quantity_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery_quantity_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery_rated_voltage_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery_rated_voltage_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery_rated_voltage_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery_alarm_mask_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery_alarm_mask_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery_alarm_mask_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_min_threshold_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_min_threshold_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_min_threshold_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_threshold1_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_threshold1_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_threshold1_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_threshold2_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_threshold2_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_threshold2_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_threshold3_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_threshold3_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery_voltage_threshold3_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_min_threshold_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_min_threshold_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_min_threshold_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_threshold1_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_threshold1_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_threshold1_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_threshold2_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_threshold2_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_threshold2_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_threshold3_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_threshold3_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery_percentage_threshold3_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery_alarm_state_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery_alarm_state_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery_alarm_state_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_remaining_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_remaining_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_remaining_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery2_manufacturer_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery2_manufacturer_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery2_manufacturer_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery2_size_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery2_size_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery2_size_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery2a_hr_rating_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery2a_hr_rating_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery2a_hr_rating_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery2_quantity_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery2_quantity_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery2_quantity_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery2_rated_voltage_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery2_rated_voltage_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery2_rated_voltage_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery2_alarm_mask_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery2_alarm_mask_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery2_alarm_mask_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_min_threshold_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_min_threshold_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_min_threshold_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_threshold1_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_threshold1_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_threshold1_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_threshold2_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_threshold2_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_threshold2_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_threshold3_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_threshold3_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery2_voltage_threshold3_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_min_threshold_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_min_threshold_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_min_threshold_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_threshold1_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_threshold1_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_threshold1_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_threshold2_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_threshold2_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_threshold2_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_threshold3_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_threshold3_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery2_percentage_threshold3_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery2_alarm_state_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery2_alarm_state_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery2_alarm_state_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_remaining_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_remaining_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_remaining_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery3_manufacturer_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery3_manufacturer_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery3_manufacturer_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery3_size_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery3_size_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery3_size_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery3a_hr_rating_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery3a_hr_rating_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery3a_hr_rating_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery3_quantity_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery3_quantity_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery3_quantity_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery3_rated_voltage_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery3_rated_voltage_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery3_rated_voltage_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery3_alarm_mask_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery3_alarm_mask_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery3_alarm_mask_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_min_threshold_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_min_threshold_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_min_threshold_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_threshold1_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_threshold1_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_threshold1_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_threshold2_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_threshold2_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_threshold2_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_threshold3_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_threshold3_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery3_voltage_threshold3_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_min_threshold_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_min_threshold_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_min_threshold_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_threshold1_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_threshold1_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_threshold1_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_threshold2_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_threshold2_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_threshold2_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_threshold3_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_threshold3_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery3_percentage_threshold3_callback = callback;
}
void uic_mqtt_dotdot_power_configuration_attribute_battery3_alarm_state_callback_set(const uic_mqtt_dotdot_power_configuration_attribute_battery3_alarm_state_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_attribute_battery3_alarm_state_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for DeviceTemperatureConfiguration
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_device_temperature_configuration_attribute_current_temperature_callback_t uic_mqtt_dotdot_device_temperature_configuration_attribute_current_temperature_callback = nullptr;
static uic_mqtt_dotdot_device_temperature_configuration_attribute_min_temp_experienced_callback_t uic_mqtt_dotdot_device_temperature_configuration_attribute_min_temp_experienced_callback = nullptr;
static uic_mqtt_dotdot_device_temperature_configuration_attribute_max_temp_experienced_callback_t uic_mqtt_dotdot_device_temperature_configuration_attribute_max_temp_experienced_callback = nullptr;
static uic_mqtt_dotdot_device_temperature_configuration_attribute_over_temp_total_dwell_callback_t uic_mqtt_dotdot_device_temperature_configuration_attribute_over_temp_total_dwell_callback = nullptr;
static uic_mqtt_dotdot_device_temperature_configuration_attribute_device_temp_alarm_mask_callback_t uic_mqtt_dotdot_device_temperature_configuration_attribute_device_temp_alarm_mask_callback = nullptr;
static uic_mqtt_dotdot_device_temperature_configuration_attribute_low_temp_threshold_callback_t uic_mqtt_dotdot_device_temperature_configuration_attribute_low_temp_threshold_callback = nullptr;
static uic_mqtt_dotdot_device_temperature_configuration_attribute_high_temp_threshold_callback_t uic_mqtt_dotdot_device_temperature_configuration_attribute_high_temp_threshold_callback = nullptr;
static uic_mqtt_dotdot_device_temperature_configuration_attribute_low_temp_dwell_trip_point_callback_t uic_mqtt_dotdot_device_temperature_configuration_attribute_low_temp_dwell_trip_point_callback = nullptr;
static uic_mqtt_dotdot_device_temperature_configuration_attribute_high_temp_dwell_trip_point_callback_t uic_mqtt_dotdot_device_temperature_configuration_attribute_high_temp_dwell_trip_point_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for DeviceTemperatureConfiguration
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_device_temperature_configuration_current_temperature_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_device_temperature_configuration_attribute_current_temperature_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t current_temperature = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DeviceTemperatureConfiguration::CurrentTemperature: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      current_temperature = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_device_temperature_configuration_attribute_current_temperature_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    current_temperature
  );

}
static void uic_mqtt_dotdot_on_device_temperature_configuration_min_temp_experienced_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_device_temperature_configuration_attribute_min_temp_experienced_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t min_temp_experienced = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DeviceTemperatureConfiguration::MinTempExperienced: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      min_temp_experienced = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_device_temperature_configuration_attribute_min_temp_experienced_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    min_temp_experienced
  );

}
static void uic_mqtt_dotdot_on_device_temperature_configuration_max_temp_experienced_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_device_temperature_configuration_attribute_max_temp_experienced_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t max_temp_experienced = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DeviceTemperatureConfiguration::MaxTempExperienced: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      max_temp_experienced = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_device_temperature_configuration_attribute_max_temp_experienced_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    max_temp_experienced
  );

}
static void uic_mqtt_dotdot_on_device_temperature_configuration_over_temp_total_dwell_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_device_temperature_configuration_attribute_over_temp_total_dwell_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t over_temp_total_dwell = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DeviceTemperatureConfiguration::OverTempTotalDwell: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      over_temp_total_dwell = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_device_temperature_configuration_attribute_over_temp_total_dwell_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    over_temp_total_dwell
  );

}
static void uic_mqtt_dotdot_on_device_temperature_configuration_device_temp_alarm_mask_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_device_temperature_configuration_attribute_device_temp_alarm_mask_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t device_temp_alarm_mask = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DeviceTemperatureConfiguration::DeviceTempAlarmMask: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      device_temp_alarm_mask = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, DeviceTemperatureConfigurationDeviceTempAlarmMask);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_device_temperature_configuration_attribute_device_temp_alarm_mask_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    device_temp_alarm_mask
  );

}
static void uic_mqtt_dotdot_on_device_temperature_configuration_low_temp_threshold_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_device_temperature_configuration_attribute_low_temp_threshold_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t low_temp_threshold = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DeviceTemperatureConfiguration::LowTempThreshold: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      low_temp_threshold = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_device_temperature_configuration_attribute_low_temp_threshold_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    low_temp_threshold
  );

}
static void uic_mqtt_dotdot_on_device_temperature_configuration_high_temp_threshold_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_device_temperature_configuration_attribute_high_temp_threshold_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t high_temp_threshold = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DeviceTemperatureConfiguration::HighTempThreshold: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      high_temp_threshold = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_device_temperature_configuration_attribute_high_temp_threshold_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    high_temp_threshold
  );

}
static void uic_mqtt_dotdot_on_device_temperature_configuration_low_temp_dwell_trip_point_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_device_temperature_configuration_attribute_low_temp_dwell_trip_point_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t low_temp_dwell_trip_point = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DeviceTemperatureConfiguration::LowTempDwellTripPoint: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      low_temp_dwell_trip_point = json_payload.at("value").get<uint32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_device_temperature_configuration_attribute_low_temp_dwell_trip_point_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    low_temp_dwell_trip_point
  );

}
static void uic_mqtt_dotdot_on_device_temperature_configuration_high_temp_dwell_trip_point_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_device_temperature_configuration_attribute_high_temp_dwell_trip_point_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t high_temp_dwell_trip_point = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DeviceTemperatureConfiguration::HighTempDwellTripPoint: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      high_temp_dwell_trip_point = json_payload.at("value").get<uint32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_device_temperature_configuration_attribute_high_temp_dwell_trip_point_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    high_temp_dwell_trip_point
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for DeviceTemperatureConfiguration
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_device_temperature_configuration_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_device_temperature_configuration_attribute_current_temperature_callback) {
    subscription_topic = base_topic + "DeviceTemperatureConfiguration/Attributes/CurrentTemperature/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_device_temperature_configuration_current_temperature_attribute_update);
  }
  if(uic_mqtt_dotdot_device_temperature_configuration_attribute_min_temp_experienced_callback) {
    subscription_topic = base_topic + "DeviceTemperatureConfiguration/Attributes/MinTempExperienced/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_device_temperature_configuration_min_temp_experienced_attribute_update);
  }
  if(uic_mqtt_dotdot_device_temperature_configuration_attribute_max_temp_experienced_callback) {
    subscription_topic = base_topic + "DeviceTemperatureConfiguration/Attributes/MaxTempExperienced/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_device_temperature_configuration_max_temp_experienced_attribute_update);
  }
  if(uic_mqtt_dotdot_device_temperature_configuration_attribute_over_temp_total_dwell_callback) {
    subscription_topic = base_topic + "DeviceTemperatureConfiguration/Attributes/OverTempTotalDwell/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_device_temperature_configuration_over_temp_total_dwell_attribute_update);
  }
  if(uic_mqtt_dotdot_device_temperature_configuration_attribute_device_temp_alarm_mask_callback) {
    subscription_topic = base_topic + "DeviceTemperatureConfiguration/Attributes/DeviceTempAlarmMask/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_device_temperature_configuration_device_temp_alarm_mask_attribute_update);
  }
  if(uic_mqtt_dotdot_device_temperature_configuration_attribute_low_temp_threshold_callback) {
    subscription_topic = base_topic + "DeviceTemperatureConfiguration/Attributes/LowTempThreshold/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_device_temperature_configuration_low_temp_threshold_attribute_update);
  }
  if(uic_mqtt_dotdot_device_temperature_configuration_attribute_high_temp_threshold_callback) {
    subscription_topic = base_topic + "DeviceTemperatureConfiguration/Attributes/HighTempThreshold/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_device_temperature_configuration_high_temp_threshold_attribute_update);
  }
  if(uic_mqtt_dotdot_device_temperature_configuration_attribute_low_temp_dwell_trip_point_callback) {
    subscription_topic = base_topic + "DeviceTemperatureConfiguration/Attributes/LowTempDwellTripPoint/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_device_temperature_configuration_low_temp_dwell_trip_point_attribute_update);
  }
  if(uic_mqtt_dotdot_device_temperature_configuration_attribute_high_temp_dwell_trip_point_callback) {
    subscription_topic = base_topic + "DeviceTemperatureConfiguration/Attributes/HighTempDwellTripPoint/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_device_temperature_configuration_high_temp_dwell_trip_point_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for DeviceTemperatureConfiguration
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_device_temperature_configuration_attribute_current_temperature_callback_set(const uic_mqtt_dotdot_device_temperature_configuration_attribute_current_temperature_callback_t callback)
{
  uic_mqtt_dotdot_device_temperature_configuration_attribute_current_temperature_callback = callback;
}
void uic_mqtt_dotdot_device_temperature_configuration_attribute_min_temp_experienced_callback_set(const uic_mqtt_dotdot_device_temperature_configuration_attribute_min_temp_experienced_callback_t callback)
{
  uic_mqtt_dotdot_device_temperature_configuration_attribute_min_temp_experienced_callback = callback;
}
void uic_mqtt_dotdot_device_temperature_configuration_attribute_max_temp_experienced_callback_set(const uic_mqtt_dotdot_device_temperature_configuration_attribute_max_temp_experienced_callback_t callback)
{
  uic_mqtt_dotdot_device_temperature_configuration_attribute_max_temp_experienced_callback = callback;
}
void uic_mqtt_dotdot_device_temperature_configuration_attribute_over_temp_total_dwell_callback_set(const uic_mqtt_dotdot_device_temperature_configuration_attribute_over_temp_total_dwell_callback_t callback)
{
  uic_mqtt_dotdot_device_temperature_configuration_attribute_over_temp_total_dwell_callback = callback;
}
void uic_mqtt_dotdot_device_temperature_configuration_attribute_device_temp_alarm_mask_callback_set(const uic_mqtt_dotdot_device_temperature_configuration_attribute_device_temp_alarm_mask_callback_t callback)
{
  uic_mqtt_dotdot_device_temperature_configuration_attribute_device_temp_alarm_mask_callback = callback;
}
void uic_mqtt_dotdot_device_temperature_configuration_attribute_low_temp_threshold_callback_set(const uic_mqtt_dotdot_device_temperature_configuration_attribute_low_temp_threshold_callback_t callback)
{
  uic_mqtt_dotdot_device_temperature_configuration_attribute_low_temp_threshold_callback = callback;
}
void uic_mqtt_dotdot_device_temperature_configuration_attribute_high_temp_threshold_callback_set(const uic_mqtt_dotdot_device_temperature_configuration_attribute_high_temp_threshold_callback_t callback)
{
  uic_mqtt_dotdot_device_temperature_configuration_attribute_high_temp_threshold_callback = callback;
}
void uic_mqtt_dotdot_device_temperature_configuration_attribute_low_temp_dwell_trip_point_callback_set(const uic_mqtt_dotdot_device_temperature_configuration_attribute_low_temp_dwell_trip_point_callback_t callback)
{
  uic_mqtt_dotdot_device_temperature_configuration_attribute_low_temp_dwell_trip_point_callback = callback;
}
void uic_mqtt_dotdot_device_temperature_configuration_attribute_high_temp_dwell_trip_point_callback_set(const uic_mqtt_dotdot_device_temperature_configuration_attribute_high_temp_dwell_trip_point_callback_t callback)
{
  uic_mqtt_dotdot_device_temperature_configuration_attribute_high_temp_dwell_trip_point_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for Identify
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_identify_attribute_identify_time_callback_t uic_mqtt_dotdot_identify_attribute_identify_time_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for Identify
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_identify_identify_time_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_identify_attribute_identify_time_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t identify_time = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Identify::IdentifyTime: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      identify_time = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_identify_attribute_identify_time_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    identify_time
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for Identify
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_identify_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_identify_attribute_identify_time_callback) {
    subscription_topic = base_topic + "Identify/Attributes/IdentifyTime/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_identify_identify_time_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for Identify
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_identify_attribute_identify_time_callback_set(const uic_mqtt_dotdot_identify_attribute_identify_time_callback_t callback)
{
  uic_mqtt_dotdot_identify_attribute_identify_time_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for Groups
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_groups_attribute_name_support_callback_t uic_mqtt_dotdot_groups_attribute_name_support_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for Groups
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_groups_name_support_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_groups_attribute_name_support_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t name_support = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Groups::NameSupport: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      name_support = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, GroupsNameSupport);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_groups_attribute_name_support_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    name_support
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for Groups
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_groups_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_groups_attribute_name_support_callback) {
    subscription_topic = base_topic + "Groups/Attributes/NameSupport/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_groups_name_support_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for Groups
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_groups_attribute_name_support_callback_set(const uic_mqtt_dotdot_groups_attribute_name_support_callback_t callback)
{
  uic_mqtt_dotdot_groups_attribute_name_support_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for Scenes
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_scenes_attribute_scene_count_callback_t uic_mqtt_dotdot_scenes_attribute_scene_count_callback = nullptr;
static uic_mqtt_dotdot_scenes_attribute_current_scene_callback_t uic_mqtt_dotdot_scenes_attribute_current_scene_callback = nullptr;
static uic_mqtt_dotdot_scenes_attribute_current_group_callback_t uic_mqtt_dotdot_scenes_attribute_current_group_callback = nullptr;
static uic_mqtt_dotdot_scenes_attribute_scene_valid_callback_t uic_mqtt_dotdot_scenes_attribute_scene_valid_callback = nullptr;
static uic_mqtt_dotdot_scenes_attribute_name_support_callback_t uic_mqtt_dotdot_scenes_attribute_name_support_callback = nullptr;
static uic_mqtt_dotdot_scenes_attribute_last_configured_by_callback_t uic_mqtt_dotdot_scenes_attribute_last_configured_by_callback = nullptr;
static uic_mqtt_dotdot_scenes_attribute_scene_table_callback_t uic_mqtt_dotdot_scenes_attribute_scene_table_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for Scenes
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_scenes_scene_count_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_scenes_attribute_scene_count_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t scene_count = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Scenes::SceneCount: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      scene_count = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_scenes_attribute_scene_count_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    scene_count
  );

}
static void uic_mqtt_dotdot_on_scenes_current_scene_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_scenes_attribute_current_scene_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t current_scene = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Scenes::CurrentScene: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      current_scene = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_scenes_attribute_current_scene_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    current_scene
  );

}
static void uic_mqtt_dotdot_on_scenes_current_group_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_scenes_attribute_current_group_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  SGroupId current_group = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Scenes::CurrentGroup: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      current_group = json_payload.at("value").get<SGroupId>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_scenes_attribute_current_group_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    current_group
  );

}
static void uic_mqtt_dotdot_on_scenes_scene_valid_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_scenes_attribute_scene_valid_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  bool scene_valid = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Scenes::SceneValid: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      scene_valid = get_bool_from_json(json_payload, "value");

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_scenes_attribute_scene_valid_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    scene_valid
  );

}
static void uic_mqtt_dotdot_on_scenes_name_support_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_scenes_attribute_name_support_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t name_support = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Scenes::NameSupport: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      name_support = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, ScenesNameSupport);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_scenes_attribute_name_support_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    name_support
  );

}
static void uic_mqtt_dotdot_on_scenes_last_configured_by_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_scenes_attribute_last_configured_by_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  EUI64 last_configured_by = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Scenes::LastConfiguredBy: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      last_configured_by = json_payload.at("value").get<EUI64>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_scenes_attribute_last_configured_by_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    last_configured_by
  );

}
static void uic_mqtt_dotdot_on_scenes_scene_table_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_scenes_attribute_scene_table_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  std::vector<SSceneTable> scene_table;
  size_t scene_table_count = 0;

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Scenes::SceneTable: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      auto &scene_table_json = json_payload.at("value");
      for (size_t i = 0; i < scene_table_json.size(); i++) {
        SSceneTable element = {};
        element.SceneID = scene_table_json.at(i).at("SceneID").get<uint16_t>();
        element.GroupID = scene_table_json.at(i).at("GroupID").get<uint16_t>();
        element.SceneName = scene_table_json.at(i).at("SceneName").get_ptr<const std::string*>()->c_str();
        element.TransitionTime = scene_table_json.at(i).at("TransitionTime").get<uint16_t>();
        element.TransitionTime100ms = scene_table_json.at(i).at("TransitionTime100ms").get<uint8_t>();
        element.SceneTableExtensions = scene_table_json.at(i).at("SceneTableExtensions").get_ptr<const std::string*>()->c_str();
        scene_table.push_back(element);
      }
      // Take our vector and pack it into the updated state
      scene_table_count = scene_table.size();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_scenes_attribute_scene_table_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    scene_table_count,
    scene_table.data()
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for Scenes
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_scenes_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_scenes_attribute_scene_count_callback) {
    subscription_topic = base_topic + "Scenes/Attributes/SceneCount/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_scenes_scene_count_attribute_update);
  }
  if(uic_mqtt_dotdot_scenes_attribute_current_scene_callback) {
    subscription_topic = base_topic + "Scenes/Attributes/CurrentScene/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_scenes_current_scene_attribute_update);
  }
  if(uic_mqtt_dotdot_scenes_attribute_current_group_callback) {
    subscription_topic = base_topic + "Scenes/Attributes/CurrentGroup/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_scenes_current_group_attribute_update);
  }
  if(uic_mqtt_dotdot_scenes_attribute_scene_valid_callback) {
    subscription_topic = base_topic + "Scenes/Attributes/SceneValid/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_scenes_scene_valid_attribute_update);
  }
  if(uic_mqtt_dotdot_scenes_attribute_name_support_callback) {
    subscription_topic = base_topic + "Scenes/Attributes/NameSupport/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_scenes_name_support_attribute_update);
  }
  if(uic_mqtt_dotdot_scenes_attribute_last_configured_by_callback) {
    subscription_topic = base_topic + "Scenes/Attributes/LastConfiguredBy/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_scenes_last_configured_by_attribute_update);
  }
  if(uic_mqtt_dotdot_scenes_attribute_scene_table_callback) {
    subscription_topic = base_topic + "Scenes/Attributes/SceneTable/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_scenes_scene_table_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for Scenes
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_scenes_attribute_scene_count_callback_set(const uic_mqtt_dotdot_scenes_attribute_scene_count_callback_t callback)
{
  uic_mqtt_dotdot_scenes_attribute_scene_count_callback = callback;
}
void uic_mqtt_dotdot_scenes_attribute_current_scene_callback_set(const uic_mqtt_dotdot_scenes_attribute_current_scene_callback_t callback)
{
  uic_mqtt_dotdot_scenes_attribute_current_scene_callback = callback;
}
void uic_mqtt_dotdot_scenes_attribute_current_group_callback_set(const uic_mqtt_dotdot_scenes_attribute_current_group_callback_t callback)
{
  uic_mqtt_dotdot_scenes_attribute_current_group_callback = callback;
}
void uic_mqtt_dotdot_scenes_attribute_scene_valid_callback_set(const uic_mqtt_dotdot_scenes_attribute_scene_valid_callback_t callback)
{
  uic_mqtt_dotdot_scenes_attribute_scene_valid_callback = callback;
}
void uic_mqtt_dotdot_scenes_attribute_name_support_callback_set(const uic_mqtt_dotdot_scenes_attribute_name_support_callback_t callback)
{
  uic_mqtt_dotdot_scenes_attribute_name_support_callback = callback;
}
void uic_mqtt_dotdot_scenes_attribute_last_configured_by_callback_set(const uic_mqtt_dotdot_scenes_attribute_last_configured_by_callback_t callback)
{
  uic_mqtt_dotdot_scenes_attribute_last_configured_by_callback = callback;
}
void uic_mqtt_dotdot_scenes_attribute_scene_table_callback_set(const uic_mqtt_dotdot_scenes_attribute_scene_table_callback_t callback)
{
  uic_mqtt_dotdot_scenes_attribute_scene_table_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for OnOff
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_on_off_attribute_on_off_callback_t uic_mqtt_dotdot_on_off_attribute_on_off_callback = nullptr;
static uic_mqtt_dotdot_on_off_attribute_global_scene_control_callback_t uic_mqtt_dotdot_on_off_attribute_global_scene_control_callback = nullptr;
static uic_mqtt_dotdot_on_off_attribute_on_time_callback_t uic_mqtt_dotdot_on_off_attribute_on_time_callback = nullptr;
static uic_mqtt_dotdot_on_off_attribute_off_wait_time_callback_t uic_mqtt_dotdot_on_off_attribute_off_wait_time_callback = nullptr;
static uic_mqtt_dotdot_on_off_attribute_start_up_on_off_callback_t uic_mqtt_dotdot_on_off_attribute_start_up_on_off_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for OnOff
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_on_off_on_off_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_on_off_attribute_on_off_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  bool on_off = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "OnOff::OnOff: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      on_off = get_bool_from_json(json_payload, "value");

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_on_off_attribute_on_off_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    on_off
  );

}
static void uic_mqtt_dotdot_on_on_off_global_scene_control_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_on_off_attribute_global_scene_control_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  bool global_scene_control = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "OnOff::GlobalSceneControl: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      global_scene_control = get_bool_from_json(json_payload, "value");

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_on_off_attribute_global_scene_control_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    global_scene_control
  );

}
static void uic_mqtt_dotdot_on_on_off_on_time_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_on_off_attribute_on_time_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t on_time = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "OnOff::OnTime: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      on_time = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_on_off_attribute_on_time_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    on_time
  );

}
static void uic_mqtt_dotdot_on_on_off_off_wait_time_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_on_off_attribute_off_wait_time_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t off_wait_time = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "OnOff::OffWaitTime: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      off_wait_time = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_on_off_attribute_off_wait_time_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    off_wait_time
  );

}
static void uic_mqtt_dotdot_on_on_off_start_up_on_off_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_on_off_attribute_start_up_on_off_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t start_up_on_off = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "OnOff::StartUpOnOff: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<OnOffStartUpOnOff>("value", json_payload);
      if (tmp == numeric_limits<OnOffStartUpOnOff>::max()) {
      #ifdef ON_OFF_START_UP_ON_OFF_ENUM_NAME_AVAILABLE
        tmp = on_off_start_up_on_off_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(START_UP_ON_OFF_ENUM_NAME_AVAILABLE)
        tmp = start_up_on_off_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      start_up_on_off = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_on_off_attribute_start_up_on_off_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    start_up_on_off
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for OnOff
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_on_off_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_on_off_attribute_on_off_callback) {
    subscription_topic = base_topic + "OnOff/Attributes/OnOff/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_on_off_on_off_attribute_update);
  }
  if(uic_mqtt_dotdot_on_off_attribute_global_scene_control_callback) {
    subscription_topic = base_topic + "OnOff/Attributes/GlobalSceneControl/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_on_off_global_scene_control_attribute_update);
  }
  if(uic_mqtt_dotdot_on_off_attribute_on_time_callback) {
    subscription_topic = base_topic + "OnOff/Attributes/OnTime/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_on_off_on_time_attribute_update);
  }
  if(uic_mqtt_dotdot_on_off_attribute_off_wait_time_callback) {
    subscription_topic = base_topic + "OnOff/Attributes/OffWaitTime/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_on_off_off_wait_time_attribute_update);
  }
  if(uic_mqtt_dotdot_on_off_attribute_start_up_on_off_callback) {
    subscription_topic = base_topic + "OnOff/Attributes/StartUpOnOff/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_on_off_start_up_on_off_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for OnOff
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_on_off_attribute_on_off_callback_set(const uic_mqtt_dotdot_on_off_attribute_on_off_callback_t callback)
{
  uic_mqtt_dotdot_on_off_attribute_on_off_callback = callback;
}
void uic_mqtt_dotdot_on_off_attribute_global_scene_control_callback_set(const uic_mqtt_dotdot_on_off_attribute_global_scene_control_callback_t callback)
{
  uic_mqtt_dotdot_on_off_attribute_global_scene_control_callback = callback;
}
void uic_mqtt_dotdot_on_off_attribute_on_time_callback_set(const uic_mqtt_dotdot_on_off_attribute_on_time_callback_t callback)
{
  uic_mqtt_dotdot_on_off_attribute_on_time_callback = callback;
}
void uic_mqtt_dotdot_on_off_attribute_off_wait_time_callback_set(const uic_mqtt_dotdot_on_off_attribute_off_wait_time_callback_t callback)
{
  uic_mqtt_dotdot_on_off_attribute_off_wait_time_callback = callback;
}
void uic_mqtt_dotdot_on_off_attribute_start_up_on_off_callback_set(const uic_mqtt_dotdot_on_off_attribute_start_up_on_off_callback_t callback)
{
  uic_mqtt_dotdot_on_off_attribute_start_up_on_off_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for Level
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_level_attribute_current_level_callback_t uic_mqtt_dotdot_level_attribute_current_level_callback = nullptr;
static uic_mqtt_dotdot_level_attribute_remaining_time_callback_t uic_mqtt_dotdot_level_attribute_remaining_time_callback = nullptr;
static uic_mqtt_dotdot_level_attribute_min_level_callback_t uic_mqtt_dotdot_level_attribute_min_level_callback = nullptr;
static uic_mqtt_dotdot_level_attribute_max_level_callback_t uic_mqtt_dotdot_level_attribute_max_level_callback = nullptr;
static uic_mqtt_dotdot_level_attribute_current_frequency_callback_t uic_mqtt_dotdot_level_attribute_current_frequency_callback = nullptr;
static uic_mqtt_dotdot_level_attribute_min_frequency_callback_t uic_mqtt_dotdot_level_attribute_min_frequency_callback = nullptr;
static uic_mqtt_dotdot_level_attribute_max_frequency_callback_t uic_mqtt_dotdot_level_attribute_max_frequency_callback = nullptr;
static uic_mqtt_dotdot_level_attribute_options_callback_t uic_mqtt_dotdot_level_attribute_options_callback = nullptr;
static uic_mqtt_dotdot_level_attribute_on_off_transition_time_callback_t uic_mqtt_dotdot_level_attribute_on_off_transition_time_callback = nullptr;
static uic_mqtt_dotdot_level_attribute_on_level_callback_t uic_mqtt_dotdot_level_attribute_on_level_callback = nullptr;
static uic_mqtt_dotdot_level_attribute_on_transition_time_callback_t uic_mqtt_dotdot_level_attribute_on_transition_time_callback = nullptr;
static uic_mqtt_dotdot_level_attribute_off_transition_time_callback_t uic_mqtt_dotdot_level_attribute_off_transition_time_callback = nullptr;
static uic_mqtt_dotdot_level_attribute_default_move_rate_callback_t uic_mqtt_dotdot_level_attribute_default_move_rate_callback = nullptr;
static uic_mqtt_dotdot_level_attribute_start_up_current_level_callback_t uic_mqtt_dotdot_level_attribute_start_up_current_level_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for Level
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_level_current_level_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_level_attribute_current_level_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t current_level = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Level::CurrentLevel: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      current_level = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_level_attribute_current_level_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    current_level
  );

}
static void uic_mqtt_dotdot_on_level_remaining_time_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_level_attribute_remaining_time_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t remaining_time = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Level::RemainingTime: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      remaining_time = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_level_attribute_remaining_time_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    remaining_time
  );

}
static void uic_mqtt_dotdot_on_level_min_level_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_level_attribute_min_level_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t min_level = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Level::MinLevel: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      min_level = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_level_attribute_min_level_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    min_level
  );

}
static void uic_mqtt_dotdot_on_level_max_level_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_level_attribute_max_level_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t max_level = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Level::MaxLevel: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      max_level = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_level_attribute_max_level_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    max_level
  );

}
static void uic_mqtt_dotdot_on_level_current_frequency_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_level_attribute_current_frequency_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t current_frequency = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Level::CurrentFrequency: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      current_frequency = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_level_attribute_current_frequency_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    current_frequency
  );

}
static void uic_mqtt_dotdot_on_level_min_frequency_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_level_attribute_min_frequency_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t min_frequency = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Level::MinFrequency: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      min_frequency = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_level_attribute_min_frequency_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    min_frequency
  );

}
static void uic_mqtt_dotdot_on_level_max_frequency_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_level_attribute_max_frequency_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t max_frequency = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Level::MaxFrequency: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      max_frequency = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_level_attribute_max_frequency_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    max_frequency
  );

}
static void uic_mqtt_dotdot_on_level_options_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_level_attribute_options_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t options = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Level::Options: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      options = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, LevelOptions);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_level_attribute_options_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    options
  );

}
static void uic_mqtt_dotdot_on_level_on_off_transition_time_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_level_attribute_on_off_transition_time_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t on_off_transition_time = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Level::OnOffTransitionTime: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      on_off_transition_time = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_level_attribute_on_off_transition_time_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    on_off_transition_time
  );

}
static void uic_mqtt_dotdot_on_level_on_level_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_level_attribute_on_level_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t on_level = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Level::OnLevel: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      on_level = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_level_attribute_on_level_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    on_level
  );

}
static void uic_mqtt_dotdot_on_level_on_transition_time_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_level_attribute_on_transition_time_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t on_transition_time = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Level::OnTransitionTime: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      on_transition_time = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_level_attribute_on_transition_time_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    on_transition_time
  );

}
static void uic_mqtt_dotdot_on_level_off_transition_time_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_level_attribute_off_transition_time_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t off_transition_time = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Level::OffTransitionTime: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      off_transition_time = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_level_attribute_off_transition_time_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    off_transition_time
  );

}
static void uic_mqtt_dotdot_on_level_default_move_rate_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_level_attribute_default_move_rate_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t default_move_rate = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Level::DefaultMoveRate: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      default_move_rate = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_level_attribute_default_move_rate_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    default_move_rate
  );

}
static void uic_mqtt_dotdot_on_level_start_up_current_level_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_level_attribute_start_up_current_level_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t start_up_current_level = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Level::StartUpCurrentLevel: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      start_up_current_level = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_level_attribute_start_up_current_level_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    start_up_current_level
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for Level
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_level_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_level_attribute_current_level_callback) {
    subscription_topic = base_topic + "Level/Attributes/CurrentLevel/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_level_current_level_attribute_update);
  }
  if(uic_mqtt_dotdot_level_attribute_remaining_time_callback) {
    subscription_topic = base_topic + "Level/Attributes/RemainingTime/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_level_remaining_time_attribute_update);
  }
  if(uic_mqtt_dotdot_level_attribute_min_level_callback) {
    subscription_topic = base_topic + "Level/Attributes/MinLevel/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_level_min_level_attribute_update);
  }
  if(uic_mqtt_dotdot_level_attribute_max_level_callback) {
    subscription_topic = base_topic + "Level/Attributes/MaxLevel/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_level_max_level_attribute_update);
  }
  if(uic_mqtt_dotdot_level_attribute_current_frequency_callback) {
    subscription_topic = base_topic + "Level/Attributes/CurrentFrequency/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_level_current_frequency_attribute_update);
  }
  if(uic_mqtt_dotdot_level_attribute_min_frequency_callback) {
    subscription_topic = base_topic + "Level/Attributes/MinFrequency/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_level_min_frequency_attribute_update);
  }
  if(uic_mqtt_dotdot_level_attribute_max_frequency_callback) {
    subscription_topic = base_topic + "Level/Attributes/MaxFrequency/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_level_max_frequency_attribute_update);
  }
  if(uic_mqtt_dotdot_level_attribute_options_callback) {
    subscription_topic = base_topic + "Level/Attributes/Options/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_level_options_attribute_update);
  }
  if(uic_mqtt_dotdot_level_attribute_on_off_transition_time_callback) {
    subscription_topic = base_topic + "Level/Attributes/OnOffTransitionTime/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_level_on_off_transition_time_attribute_update);
  }
  if(uic_mqtt_dotdot_level_attribute_on_level_callback) {
    subscription_topic = base_topic + "Level/Attributes/OnLevel/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_level_on_level_attribute_update);
  }
  if(uic_mqtt_dotdot_level_attribute_on_transition_time_callback) {
    subscription_topic = base_topic + "Level/Attributes/OnTransitionTime/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_level_on_transition_time_attribute_update);
  }
  if(uic_mqtt_dotdot_level_attribute_off_transition_time_callback) {
    subscription_topic = base_topic + "Level/Attributes/OffTransitionTime/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_level_off_transition_time_attribute_update);
  }
  if(uic_mqtt_dotdot_level_attribute_default_move_rate_callback) {
    subscription_topic = base_topic + "Level/Attributes/DefaultMoveRate/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_level_default_move_rate_attribute_update);
  }
  if(uic_mqtt_dotdot_level_attribute_start_up_current_level_callback) {
    subscription_topic = base_topic + "Level/Attributes/StartUpCurrentLevel/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_level_start_up_current_level_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for Level
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_level_attribute_current_level_callback_set(const uic_mqtt_dotdot_level_attribute_current_level_callback_t callback)
{
  uic_mqtt_dotdot_level_attribute_current_level_callback = callback;
}
void uic_mqtt_dotdot_level_attribute_remaining_time_callback_set(const uic_mqtt_dotdot_level_attribute_remaining_time_callback_t callback)
{
  uic_mqtt_dotdot_level_attribute_remaining_time_callback = callback;
}
void uic_mqtt_dotdot_level_attribute_min_level_callback_set(const uic_mqtt_dotdot_level_attribute_min_level_callback_t callback)
{
  uic_mqtt_dotdot_level_attribute_min_level_callback = callback;
}
void uic_mqtt_dotdot_level_attribute_max_level_callback_set(const uic_mqtt_dotdot_level_attribute_max_level_callback_t callback)
{
  uic_mqtt_dotdot_level_attribute_max_level_callback = callback;
}
void uic_mqtt_dotdot_level_attribute_current_frequency_callback_set(const uic_mqtt_dotdot_level_attribute_current_frequency_callback_t callback)
{
  uic_mqtt_dotdot_level_attribute_current_frequency_callback = callback;
}
void uic_mqtt_dotdot_level_attribute_min_frequency_callback_set(const uic_mqtt_dotdot_level_attribute_min_frequency_callback_t callback)
{
  uic_mqtt_dotdot_level_attribute_min_frequency_callback = callback;
}
void uic_mqtt_dotdot_level_attribute_max_frequency_callback_set(const uic_mqtt_dotdot_level_attribute_max_frequency_callback_t callback)
{
  uic_mqtt_dotdot_level_attribute_max_frequency_callback = callback;
}
void uic_mqtt_dotdot_level_attribute_options_callback_set(const uic_mqtt_dotdot_level_attribute_options_callback_t callback)
{
  uic_mqtt_dotdot_level_attribute_options_callback = callback;
}
void uic_mqtt_dotdot_level_attribute_on_off_transition_time_callback_set(const uic_mqtt_dotdot_level_attribute_on_off_transition_time_callback_t callback)
{
  uic_mqtt_dotdot_level_attribute_on_off_transition_time_callback = callback;
}
void uic_mqtt_dotdot_level_attribute_on_level_callback_set(const uic_mqtt_dotdot_level_attribute_on_level_callback_t callback)
{
  uic_mqtt_dotdot_level_attribute_on_level_callback = callback;
}
void uic_mqtt_dotdot_level_attribute_on_transition_time_callback_set(const uic_mqtt_dotdot_level_attribute_on_transition_time_callback_t callback)
{
  uic_mqtt_dotdot_level_attribute_on_transition_time_callback = callback;
}
void uic_mqtt_dotdot_level_attribute_off_transition_time_callback_set(const uic_mqtt_dotdot_level_attribute_off_transition_time_callback_t callback)
{
  uic_mqtt_dotdot_level_attribute_off_transition_time_callback = callback;
}
void uic_mqtt_dotdot_level_attribute_default_move_rate_callback_set(const uic_mqtt_dotdot_level_attribute_default_move_rate_callback_t callback)
{
  uic_mqtt_dotdot_level_attribute_default_move_rate_callback = callback;
}
void uic_mqtt_dotdot_level_attribute_start_up_current_level_callback_set(const uic_mqtt_dotdot_level_attribute_start_up_current_level_callback_t callback)
{
  uic_mqtt_dotdot_level_attribute_start_up_current_level_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for Alarms
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_alarms_attribute_alarm_count_callback_t uic_mqtt_dotdot_alarms_attribute_alarm_count_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for Alarms
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_alarms_alarm_count_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_alarms_attribute_alarm_count_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t alarm_count = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Alarms::AlarmCount: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      alarm_count = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_alarms_attribute_alarm_count_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    alarm_count
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for Alarms
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_alarms_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_alarms_attribute_alarm_count_callback) {
    subscription_topic = base_topic + "Alarms/Attributes/AlarmCount/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_alarms_alarm_count_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for Alarms
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_alarms_attribute_alarm_count_callback_set(const uic_mqtt_dotdot_alarms_attribute_alarm_count_callback_t callback)
{
  uic_mqtt_dotdot_alarms_attribute_alarm_count_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for Time
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_time_attribute_time_callback_t uic_mqtt_dotdot_time_attribute_time_callback = nullptr;
static uic_mqtt_dotdot_time_attribute_time_status_callback_t uic_mqtt_dotdot_time_attribute_time_status_callback = nullptr;
static uic_mqtt_dotdot_time_attribute_time_zone_callback_t uic_mqtt_dotdot_time_attribute_time_zone_callback = nullptr;
static uic_mqtt_dotdot_time_attribute_dst_start_callback_t uic_mqtt_dotdot_time_attribute_dst_start_callback = nullptr;
static uic_mqtt_dotdot_time_attribute_dst_end_callback_t uic_mqtt_dotdot_time_attribute_dst_end_callback = nullptr;
static uic_mqtt_dotdot_time_attribute_dst_shift_callback_t uic_mqtt_dotdot_time_attribute_dst_shift_callback = nullptr;
static uic_mqtt_dotdot_time_attribute_standard_time_callback_t uic_mqtt_dotdot_time_attribute_standard_time_callback = nullptr;
static uic_mqtt_dotdot_time_attribute_local_time_callback_t uic_mqtt_dotdot_time_attribute_local_time_callback = nullptr;
static uic_mqtt_dotdot_time_attribute_last_set_time_callback_t uic_mqtt_dotdot_time_attribute_last_set_time_callback = nullptr;
static uic_mqtt_dotdot_time_attribute_valid_until_time_callback_t uic_mqtt_dotdot_time_attribute_valid_until_time_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for Time
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_time_time_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_time_attribute_time_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  UTC time = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Time::Time: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      time = json_payload.at("value").get<UTC>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_time_attribute_time_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    time
  );

}
static void uic_mqtt_dotdot_on_time_time_status_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_time_attribute_time_status_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t time_status = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Time::TimeStatus: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      time_status = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, TimeTimeStatus);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_time_attribute_time_status_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    time_status
  );

}
static void uic_mqtt_dotdot_on_time_time_zone_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_time_attribute_time_zone_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int32_t time_zone = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Time::TimeZone: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      time_zone = json_payload.at("value").get<int32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_time_attribute_time_zone_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    time_zone
  );

}
static void uic_mqtt_dotdot_on_time_dst_start_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_time_attribute_dst_start_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t dst_start = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Time::DstStart: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      dst_start = json_payload.at("value").get<uint32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_time_attribute_dst_start_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    dst_start
  );

}
static void uic_mqtt_dotdot_on_time_dst_end_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_time_attribute_dst_end_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t dst_end = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Time::DstEnd: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      dst_end = json_payload.at("value").get<uint32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_time_attribute_dst_end_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    dst_end
  );

}
static void uic_mqtt_dotdot_on_time_dst_shift_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_time_attribute_dst_shift_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int32_t dst_shift = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Time::DstShift: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      dst_shift = json_payload.at("value").get<int32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_time_attribute_dst_shift_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    dst_shift
  );

}
static void uic_mqtt_dotdot_on_time_standard_time_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_time_attribute_standard_time_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t standard_time = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Time::StandardTime: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      standard_time = json_payload.at("value").get<uint32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_time_attribute_standard_time_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    standard_time
  );

}
static void uic_mqtt_dotdot_on_time_local_time_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_time_attribute_local_time_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t local_time = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Time::LocalTime: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      local_time = json_payload.at("value").get<uint32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_time_attribute_local_time_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    local_time
  );

}
static void uic_mqtt_dotdot_on_time_last_set_time_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_time_attribute_last_set_time_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  UTC last_set_time = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Time::LastSetTime: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      last_set_time = json_payload.at("value").get<UTC>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_time_attribute_last_set_time_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    last_set_time
  );

}
static void uic_mqtt_dotdot_on_time_valid_until_time_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_time_attribute_valid_until_time_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  UTC valid_until_time = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Time::ValidUntilTime: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      valid_until_time = json_payload.at("value").get<UTC>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_time_attribute_valid_until_time_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    valid_until_time
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for Time
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_time_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_time_attribute_time_callback) {
    subscription_topic = base_topic + "Time/Attributes/Time/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_time_time_attribute_update);
  }
  if(uic_mqtt_dotdot_time_attribute_time_status_callback) {
    subscription_topic = base_topic + "Time/Attributes/TimeStatus/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_time_time_status_attribute_update);
  }
  if(uic_mqtt_dotdot_time_attribute_time_zone_callback) {
    subscription_topic = base_topic + "Time/Attributes/TimeZone/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_time_time_zone_attribute_update);
  }
  if(uic_mqtt_dotdot_time_attribute_dst_start_callback) {
    subscription_topic = base_topic + "Time/Attributes/DstStart/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_time_dst_start_attribute_update);
  }
  if(uic_mqtt_dotdot_time_attribute_dst_end_callback) {
    subscription_topic = base_topic + "Time/Attributes/DstEnd/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_time_dst_end_attribute_update);
  }
  if(uic_mqtt_dotdot_time_attribute_dst_shift_callback) {
    subscription_topic = base_topic + "Time/Attributes/DstShift/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_time_dst_shift_attribute_update);
  }
  if(uic_mqtt_dotdot_time_attribute_standard_time_callback) {
    subscription_topic = base_topic + "Time/Attributes/StandardTime/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_time_standard_time_attribute_update);
  }
  if(uic_mqtt_dotdot_time_attribute_local_time_callback) {
    subscription_topic = base_topic + "Time/Attributes/LocalTime/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_time_local_time_attribute_update);
  }
  if(uic_mqtt_dotdot_time_attribute_last_set_time_callback) {
    subscription_topic = base_topic + "Time/Attributes/LastSetTime/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_time_last_set_time_attribute_update);
  }
  if(uic_mqtt_dotdot_time_attribute_valid_until_time_callback) {
    subscription_topic = base_topic + "Time/Attributes/ValidUntilTime/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_time_valid_until_time_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for Time
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_time_attribute_time_callback_set(const uic_mqtt_dotdot_time_attribute_time_callback_t callback)
{
  uic_mqtt_dotdot_time_attribute_time_callback = callback;
}
void uic_mqtt_dotdot_time_attribute_time_status_callback_set(const uic_mqtt_dotdot_time_attribute_time_status_callback_t callback)
{
  uic_mqtt_dotdot_time_attribute_time_status_callback = callback;
}
void uic_mqtt_dotdot_time_attribute_time_zone_callback_set(const uic_mqtt_dotdot_time_attribute_time_zone_callback_t callback)
{
  uic_mqtt_dotdot_time_attribute_time_zone_callback = callback;
}
void uic_mqtt_dotdot_time_attribute_dst_start_callback_set(const uic_mqtt_dotdot_time_attribute_dst_start_callback_t callback)
{
  uic_mqtt_dotdot_time_attribute_dst_start_callback = callback;
}
void uic_mqtt_dotdot_time_attribute_dst_end_callback_set(const uic_mqtt_dotdot_time_attribute_dst_end_callback_t callback)
{
  uic_mqtt_dotdot_time_attribute_dst_end_callback = callback;
}
void uic_mqtt_dotdot_time_attribute_dst_shift_callback_set(const uic_mqtt_dotdot_time_attribute_dst_shift_callback_t callback)
{
  uic_mqtt_dotdot_time_attribute_dst_shift_callback = callback;
}
void uic_mqtt_dotdot_time_attribute_standard_time_callback_set(const uic_mqtt_dotdot_time_attribute_standard_time_callback_t callback)
{
  uic_mqtt_dotdot_time_attribute_standard_time_callback = callback;
}
void uic_mqtt_dotdot_time_attribute_local_time_callback_set(const uic_mqtt_dotdot_time_attribute_local_time_callback_t callback)
{
  uic_mqtt_dotdot_time_attribute_local_time_callback = callback;
}
void uic_mqtt_dotdot_time_attribute_last_set_time_callback_set(const uic_mqtt_dotdot_time_attribute_last_set_time_callback_t callback)
{
  uic_mqtt_dotdot_time_attribute_last_set_time_callback = callback;
}
void uic_mqtt_dotdot_time_attribute_valid_until_time_callback_set(const uic_mqtt_dotdot_time_attribute_valid_until_time_callback_t callback)
{
  uic_mqtt_dotdot_time_attribute_valid_until_time_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for PollControl
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_poll_control_attribute_check_in_interval_callback_t uic_mqtt_dotdot_poll_control_attribute_check_in_interval_callback = nullptr;
static uic_mqtt_dotdot_poll_control_attribute_long_poll_interval_callback_t uic_mqtt_dotdot_poll_control_attribute_long_poll_interval_callback = nullptr;
static uic_mqtt_dotdot_poll_control_attribute_short_poll_interval_callback_t uic_mqtt_dotdot_poll_control_attribute_short_poll_interval_callback = nullptr;
static uic_mqtt_dotdot_poll_control_attribute_fast_poll_timeout_callback_t uic_mqtt_dotdot_poll_control_attribute_fast_poll_timeout_callback = nullptr;
static uic_mqtt_dotdot_poll_control_attribute_check_in_interval_min_callback_t uic_mqtt_dotdot_poll_control_attribute_check_in_interval_min_callback = nullptr;
static uic_mqtt_dotdot_poll_control_attribute_long_poll_interval_min_callback_t uic_mqtt_dotdot_poll_control_attribute_long_poll_interval_min_callback = nullptr;
static uic_mqtt_dotdot_poll_control_attribute_fast_poll_timeout_max_callback_t uic_mqtt_dotdot_poll_control_attribute_fast_poll_timeout_max_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for PollControl
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_poll_control_check_in_interval_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_poll_control_attribute_check_in_interval_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t check_in_interval = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PollControl::CheckInInterval: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      check_in_interval = json_payload.at("value").get<uint32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_poll_control_attribute_check_in_interval_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    check_in_interval
  );

}
static void uic_mqtt_dotdot_on_poll_control_long_poll_interval_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_poll_control_attribute_long_poll_interval_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t long_poll_interval = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PollControl::LongPollInterval: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      long_poll_interval = json_payload.at("value").get<uint32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_poll_control_attribute_long_poll_interval_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    long_poll_interval
  );

}
static void uic_mqtt_dotdot_on_poll_control_short_poll_interval_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_poll_control_attribute_short_poll_interval_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t short_poll_interval = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PollControl::ShortPollInterval: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      short_poll_interval = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_poll_control_attribute_short_poll_interval_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    short_poll_interval
  );

}
static void uic_mqtt_dotdot_on_poll_control_fast_poll_timeout_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_poll_control_attribute_fast_poll_timeout_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t fast_poll_timeout = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PollControl::FastPollTimeout: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      fast_poll_timeout = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_poll_control_attribute_fast_poll_timeout_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    fast_poll_timeout
  );

}
static void uic_mqtt_dotdot_on_poll_control_check_in_interval_min_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_poll_control_attribute_check_in_interval_min_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t check_in_interval_min = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PollControl::CheckInIntervalMin: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      check_in_interval_min = json_payload.at("value").get<uint32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_poll_control_attribute_check_in_interval_min_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    check_in_interval_min
  );

}
static void uic_mqtt_dotdot_on_poll_control_long_poll_interval_min_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_poll_control_attribute_long_poll_interval_min_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t long_poll_interval_min = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PollControl::LongPollIntervalMin: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      long_poll_interval_min = json_payload.at("value").get<uint32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_poll_control_attribute_long_poll_interval_min_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    long_poll_interval_min
  );

}
static void uic_mqtt_dotdot_on_poll_control_fast_poll_timeout_max_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_poll_control_attribute_fast_poll_timeout_max_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t fast_poll_timeout_max = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PollControl::FastPollTimeoutMax: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      fast_poll_timeout_max = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_poll_control_attribute_fast_poll_timeout_max_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    fast_poll_timeout_max
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for PollControl
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_poll_control_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_poll_control_attribute_check_in_interval_callback) {
    subscription_topic = base_topic + "PollControl/Attributes/CheckInInterval/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_poll_control_check_in_interval_attribute_update);
  }
  if(uic_mqtt_dotdot_poll_control_attribute_long_poll_interval_callback) {
    subscription_topic = base_topic + "PollControl/Attributes/LongPollInterval/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_poll_control_long_poll_interval_attribute_update);
  }
  if(uic_mqtt_dotdot_poll_control_attribute_short_poll_interval_callback) {
    subscription_topic = base_topic + "PollControl/Attributes/ShortPollInterval/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_poll_control_short_poll_interval_attribute_update);
  }
  if(uic_mqtt_dotdot_poll_control_attribute_fast_poll_timeout_callback) {
    subscription_topic = base_topic + "PollControl/Attributes/FastPollTimeout/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_poll_control_fast_poll_timeout_attribute_update);
  }
  if(uic_mqtt_dotdot_poll_control_attribute_check_in_interval_min_callback) {
    subscription_topic = base_topic + "PollControl/Attributes/CheckInIntervalMin/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_poll_control_check_in_interval_min_attribute_update);
  }
  if(uic_mqtt_dotdot_poll_control_attribute_long_poll_interval_min_callback) {
    subscription_topic = base_topic + "PollControl/Attributes/LongPollIntervalMin/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_poll_control_long_poll_interval_min_attribute_update);
  }
  if(uic_mqtt_dotdot_poll_control_attribute_fast_poll_timeout_max_callback) {
    subscription_topic = base_topic + "PollControl/Attributes/FastPollTimeoutMax/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_poll_control_fast_poll_timeout_max_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for PollControl
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_poll_control_attribute_check_in_interval_callback_set(const uic_mqtt_dotdot_poll_control_attribute_check_in_interval_callback_t callback)
{
  uic_mqtt_dotdot_poll_control_attribute_check_in_interval_callback = callback;
}
void uic_mqtt_dotdot_poll_control_attribute_long_poll_interval_callback_set(const uic_mqtt_dotdot_poll_control_attribute_long_poll_interval_callback_t callback)
{
  uic_mqtt_dotdot_poll_control_attribute_long_poll_interval_callback = callback;
}
void uic_mqtt_dotdot_poll_control_attribute_short_poll_interval_callback_set(const uic_mqtt_dotdot_poll_control_attribute_short_poll_interval_callback_t callback)
{
  uic_mqtt_dotdot_poll_control_attribute_short_poll_interval_callback = callback;
}
void uic_mqtt_dotdot_poll_control_attribute_fast_poll_timeout_callback_set(const uic_mqtt_dotdot_poll_control_attribute_fast_poll_timeout_callback_t callback)
{
  uic_mqtt_dotdot_poll_control_attribute_fast_poll_timeout_callback = callback;
}
void uic_mqtt_dotdot_poll_control_attribute_check_in_interval_min_callback_set(const uic_mqtt_dotdot_poll_control_attribute_check_in_interval_min_callback_t callback)
{
  uic_mqtt_dotdot_poll_control_attribute_check_in_interval_min_callback = callback;
}
void uic_mqtt_dotdot_poll_control_attribute_long_poll_interval_min_callback_set(const uic_mqtt_dotdot_poll_control_attribute_long_poll_interval_min_callback_t callback)
{
  uic_mqtt_dotdot_poll_control_attribute_long_poll_interval_min_callback = callback;
}
void uic_mqtt_dotdot_poll_control_attribute_fast_poll_timeout_max_callback_set(const uic_mqtt_dotdot_poll_control_attribute_fast_poll_timeout_max_callback_t callback)
{
  uic_mqtt_dotdot_poll_control_attribute_fast_poll_timeout_max_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for ShadeConfiguration
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_shade_configuration_attribute_physical_closed_limit_callback_t uic_mqtt_dotdot_shade_configuration_attribute_physical_closed_limit_callback = nullptr;
static uic_mqtt_dotdot_shade_configuration_attribute_motor_step_size_callback_t uic_mqtt_dotdot_shade_configuration_attribute_motor_step_size_callback = nullptr;
static uic_mqtt_dotdot_shade_configuration_attribute_status_callback_t uic_mqtt_dotdot_shade_configuration_attribute_status_callback = nullptr;
static uic_mqtt_dotdot_shade_configuration_attribute_closed_limit_callback_t uic_mqtt_dotdot_shade_configuration_attribute_closed_limit_callback = nullptr;
static uic_mqtt_dotdot_shade_configuration_attribute_mode_callback_t uic_mqtt_dotdot_shade_configuration_attribute_mode_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for ShadeConfiguration
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_shade_configuration_physical_closed_limit_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_shade_configuration_attribute_physical_closed_limit_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t physical_closed_limit = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ShadeConfiguration::PhysicalClosedLimit: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      physical_closed_limit = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_shade_configuration_attribute_physical_closed_limit_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    physical_closed_limit
  );

}
static void uic_mqtt_dotdot_on_shade_configuration_motor_step_size_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_shade_configuration_attribute_motor_step_size_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t motor_step_size = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ShadeConfiguration::MotorStepSize: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      motor_step_size = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_shade_configuration_attribute_motor_step_size_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    motor_step_size
  );

}
static void uic_mqtt_dotdot_on_shade_configuration_status_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_shade_configuration_attribute_status_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t status = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ShadeConfiguration::Status: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      status = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, ShadeConfigurationStatus);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_shade_configuration_attribute_status_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    status
  );

}
static void uic_mqtt_dotdot_on_shade_configuration_closed_limit_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_shade_configuration_attribute_closed_limit_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t closed_limit = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ShadeConfiguration::ClosedLimit: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      closed_limit = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_shade_configuration_attribute_closed_limit_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    closed_limit
  );

}
static void uic_mqtt_dotdot_on_shade_configuration_mode_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_shade_configuration_attribute_mode_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t mode = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ShadeConfiguration::Mode: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<ShadeConfigurationMode>("value", json_payload);
      if (tmp == numeric_limits<ShadeConfigurationMode>::max()) {
      #ifdef SHADE_CONFIGURATION_MODE_ENUM_NAME_AVAILABLE
        tmp = shade_configuration_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(MODE_ENUM_NAME_AVAILABLE)
        tmp = mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      mode = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_shade_configuration_attribute_mode_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    mode
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for ShadeConfiguration
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_shade_configuration_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_shade_configuration_attribute_physical_closed_limit_callback) {
    subscription_topic = base_topic + "ShadeConfiguration/Attributes/PhysicalClosedLimit/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_shade_configuration_physical_closed_limit_attribute_update);
  }
  if(uic_mqtt_dotdot_shade_configuration_attribute_motor_step_size_callback) {
    subscription_topic = base_topic + "ShadeConfiguration/Attributes/MotorStepSize/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_shade_configuration_motor_step_size_attribute_update);
  }
  if(uic_mqtt_dotdot_shade_configuration_attribute_status_callback) {
    subscription_topic = base_topic + "ShadeConfiguration/Attributes/Status/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_shade_configuration_status_attribute_update);
  }
  if(uic_mqtt_dotdot_shade_configuration_attribute_closed_limit_callback) {
    subscription_topic = base_topic + "ShadeConfiguration/Attributes/ClosedLimit/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_shade_configuration_closed_limit_attribute_update);
  }
  if(uic_mqtt_dotdot_shade_configuration_attribute_mode_callback) {
    subscription_topic = base_topic + "ShadeConfiguration/Attributes/Mode/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_shade_configuration_mode_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for ShadeConfiguration
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_shade_configuration_attribute_physical_closed_limit_callback_set(const uic_mqtt_dotdot_shade_configuration_attribute_physical_closed_limit_callback_t callback)
{
  uic_mqtt_dotdot_shade_configuration_attribute_physical_closed_limit_callback = callback;
}
void uic_mqtt_dotdot_shade_configuration_attribute_motor_step_size_callback_set(const uic_mqtt_dotdot_shade_configuration_attribute_motor_step_size_callback_t callback)
{
  uic_mqtt_dotdot_shade_configuration_attribute_motor_step_size_callback = callback;
}
void uic_mqtt_dotdot_shade_configuration_attribute_status_callback_set(const uic_mqtt_dotdot_shade_configuration_attribute_status_callback_t callback)
{
  uic_mqtt_dotdot_shade_configuration_attribute_status_callback = callback;
}
void uic_mqtt_dotdot_shade_configuration_attribute_closed_limit_callback_set(const uic_mqtt_dotdot_shade_configuration_attribute_closed_limit_callback_t callback)
{
  uic_mqtt_dotdot_shade_configuration_attribute_closed_limit_callback = callback;
}
void uic_mqtt_dotdot_shade_configuration_attribute_mode_callback_set(const uic_mqtt_dotdot_shade_configuration_attribute_mode_callback_t callback)
{
  uic_mqtt_dotdot_shade_configuration_attribute_mode_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for DoorLock
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_door_lock_attribute_lock_state_callback_t uic_mqtt_dotdot_door_lock_attribute_lock_state_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_lock_type_callback_t uic_mqtt_dotdot_door_lock_attribute_lock_type_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_actuator_enabled_callback_t uic_mqtt_dotdot_door_lock_attribute_actuator_enabled_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_door_state_callback_t uic_mqtt_dotdot_door_lock_attribute_door_state_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_door_open_events_callback_t uic_mqtt_dotdot_door_lock_attribute_door_open_events_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_door_closed_events_callback_t uic_mqtt_dotdot_door_lock_attribute_door_closed_events_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_open_period_callback_t uic_mqtt_dotdot_door_lock_attribute_open_period_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_number_of_log_records_supported_callback_t uic_mqtt_dotdot_door_lock_attribute_number_of_log_records_supported_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_number_of_total_users_supported_callback_t uic_mqtt_dotdot_door_lock_attribute_number_of_total_users_supported_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_number_of_pin_users_supported_callback_t uic_mqtt_dotdot_door_lock_attribute_number_of_pin_users_supported_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_number_of_rfid_users_supported_callback_t uic_mqtt_dotdot_door_lock_attribute_number_of_rfid_users_supported_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_number_of_week_day_schedules_supported_per_user_callback_t uic_mqtt_dotdot_door_lock_attribute_number_of_week_day_schedules_supported_per_user_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_number_of_year_day_schedules_supported_per_user_callback_t uic_mqtt_dotdot_door_lock_attribute_number_of_year_day_schedules_supported_per_user_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_number_of_holiday_schedules_supported_callback_t uic_mqtt_dotdot_door_lock_attribute_number_of_holiday_schedules_supported_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_max_pin_code_length_callback_t uic_mqtt_dotdot_door_lock_attribute_max_pin_code_length_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_min_pin_code_length_callback_t uic_mqtt_dotdot_door_lock_attribute_min_pin_code_length_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_max_rfid_code_length_callback_t uic_mqtt_dotdot_door_lock_attribute_max_rfid_code_length_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_min_rfid_code_length_callback_t uic_mqtt_dotdot_door_lock_attribute_min_rfid_code_length_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_credential_rules_support_callback_t uic_mqtt_dotdot_door_lock_attribute_credential_rules_support_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_number_of_credentials_supported_per_user_callback_t uic_mqtt_dotdot_door_lock_attribute_number_of_credentials_supported_per_user_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_enable_logging_callback_t uic_mqtt_dotdot_door_lock_attribute_enable_logging_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_language_callback_t uic_mqtt_dotdot_door_lock_attribute_language_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_led_settings_callback_t uic_mqtt_dotdot_door_lock_attribute_led_settings_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_auto_relock_time_callback_t uic_mqtt_dotdot_door_lock_attribute_auto_relock_time_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_sound_volume_callback_t uic_mqtt_dotdot_door_lock_attribute_sound_volume_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_operating_mode_callback_t uic_mqtt_dotdot_door_lock_attribute_operating_mode_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_supported_operating_modes_callback_t uic_mqtt_dotdot_door_lock_attribute_supported_operating_modes_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_default_configuration_register_callback_t uic_mqtt_dotdot_door_lock_attribute_default_configuration_register_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_enable_local_programming_callback_t uic_mqtt_dotdot_door_lock_attribute_enable_local_programming_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_enable_one_touch_locking_callback_t uic_mqtt_dotdot_door_lock_attribute_enable_one_touch_locking_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_enable_inside_statusled_callback_t uic_mqtt_dotdot_door_lock_attribute_enable_inside_statusled_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_enable_privacy_mode_button_callback_t uic_mqtt_dotdot_door_lock_attribute_enable_privacy_mode_button_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_local_programming_features_callback_t uic_mqtt_dotdot_door_lock_attribute_local_programming_features_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_wrong_code_entry_limit_callback_t uic_mqtt_dotdot_door_lock_attribute_wrong_code_entry_limit_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_user_code_temporary_disable_time_callback_t uic_mqtt_dotdot_door_lock_attribute_user_code_temporary_disable_time_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_send_pin_over_the_air_callback_t uic_mqtt_dotdot_door_lock_attribute_send_pin_over_the_air_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_require_pi_nfor_rf_operation_callback_t uic_mqtt_dotdot_door_lock_attribute_require_pi_nfor_rf_operation_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_security_level_callback_t uic_mqtt_dotdot_door_lock_attribute_security_level_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_expiring_user_timeout_callback_t uic_mqtt_dotdot_door_lock_attribute_expiring_user_timeout_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_alarm_mask_callback_t uic_mqtt_dotdot_door_lock_attribute_alarm_mask_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_keypad_operation_event_mask_callback_t uic_mqtt_dotdot_door_lock_attribute_keypad_operation_event_mask_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_rf_operation_event_mask_callback_t uic_mqtt_dotdot_door_lock_attribute_rf_operation_event_mask_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_manual_operation_event_mask_callback_t uic_mqtt_dotdot_door_lock_attribute_manual_operation_event_mask_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_rfid_operation_event_mask_callback_t uic_mqtt_dotdot_door_lock_attribute_rfid_operation_event_mask_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_keypad_programming_event_mask_callback_t uic_mqtt_dotdot_door_lock_attribute_keypad_programming_event_mask_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_rf_programming_event_mask_callback_t uic_mqtt_dotdot_door_lock_attribute_rf_programming_event_mask_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_rfid_programming_event_mask_callback_t uic_mqtt_dotdot_door_lock_attribute_rfid_programming_event_mask_callback = nullptr;
static uic_mqtt_dotdot_door_lock_attribute_feature_map_callback_t uic_mqtt_dotdot_door_lock_attribute_feature_map_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for DoorLock
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_door_lock_lock_state_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_lock_state_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t lock_state = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::LockState: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<DoorLockLockState>("value", json_payload);
      if (tmp == numeric_limits<DoorLockLockState>::max()) {
      #ifdef DOOR_LOCK_LOCK_STATE_ENUM_NAME_AVAILABLE
        tmp = door_lock_lock_state_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(LOCK_STATE_ENUM_NAME_AVAILABLE)
        tmp = lock_state_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      lock_state = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_lock_state_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    lock_state
  );

}
static void uic_mqtt_dotdot_on_door_lock_lock_type_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_lock_type_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t lock_type = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::LockType: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<DoorLockLockType>("value", json_payload);
      if (tmp == numeric_limits<DoorLockLockType>::max()) {
      #ifdef DOOR_LOCK_LOCK_TYPE_ENUM_NAME_AVAILABLE
        tmp = door_lock_lock_type_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(LOCK_TYPE_ENUM_NAME_AVAILABLE)
        tmp = lock_type_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      lock_type = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_lock_type_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    lock_type
  );

}
static void uic_mqtt_dotdot_on_door_lock_actuator_enabled_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_actuator_enabled_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  bool actuator_enabled = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::ActuatorEnabled: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      actuator_enabled = get_bool_from_json(json_payload, "value");

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_actuator_enabled_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    actuator_enabled
  );

}
static void uic_mqtt_dotdot_on_door_lock_door_state_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_door_state_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t door_state = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::DoorState: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<DoorLockDoorState>("value", json_payload);
      if (tmp == numeric_limits<DoorLockDoorState>::max()) {
      #ifdef DOOR_LOCK_DOOR_STATE_ENUM_NAME_AVAILABLE
        tmp = door_lock_door_state_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(DOOR_STATE_ENUM_NAME_AVAILABLE)
        tmp = door_state_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      door_state = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_door_state_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    door_state
  );

}
static void uic_mqtt_dotdot_on_door_lock_door_open_events_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_door_open_events_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t door_open_events = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::DoorOpenEvents: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      door_open_events = json_payload.at("value").get<uint32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_door_open_events_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    door_open_events
  );

}
static void uic_mqtt_dotdot_on_door_lock_door_closed_events_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_door_closed_events_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t door_closed_events = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::DoorClosedEvents: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      door_closed_events = json_payload.at("value").get<uint32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_door_closed_events_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    door_closed_events
  );

}
static void uic_mqtt_dotdot_on_door_lock_open_period_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_open_period_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t open_period = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::OpenPeriod: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      open_period = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_open_period_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    open_period
  );

}
static void uic_mqtt_dotdot_on_door_lock_number_of_log_records_supported_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_number_of_log_records_supported_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t number_of_log_records_supported = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::NumberOfLogRecordsSupported: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      number_of_log_records_supported = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_number_of_log_records_supported_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    number_of_log_records_supported
  );

}
static void uic_mqtt_dotdot_on_door_lock_number_of_total_users_supported_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_number_of_total_users_supported_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t number_of_total_users_supported = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::NumberOfTotalUsersSupported: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      number_of_total_users_supported = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_number_of_total_users_supported_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    number_of_total_users_supported
  );

}
static void uic_mqtt_dotdot_on_door_lock_number_of_pin_users_supported_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_number_of_pin_users_supported_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t number_of_pin_users_supported = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::NumberOfPINUsersSupported: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      number_of_pin_users_supported = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_number_of_pin_users_supported_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    number_of_pin_users_supported
  );

}
static void uic_mqtt_dotdot_on_door_lock_number_of_rfid_users_supported_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_number_of_rfid_users_supported_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t number_of_rfid_users_supported = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::NumberOfRFIDUsersSupported: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      number_of_rfid_users_supported = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_number_of_rfid_users_supported_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    number_of_rfid_users_supported
  );

}
static void uic_mqtt_dotdot_on_door_lock_number_of_week_day_schedules_supported_per_user_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_number_of_week_day_schedules_supported_per_user_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t number_of_week_day_schedules_supported_per_user = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::NumberOfWeekDaySchedulesSupportedPerUser: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      number_of_week_day_schedules_supported_per_user = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_number_of_week_day_schedules_supported_per_user_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    number_of_week_day_schedules_supported_per_user
  );

}
static void uic_mqtt_dotdot_on_door_lock_number_of_year_day_schedules_supported_per_user_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_number_of_year_day_schedules_supported_per_user_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t number_of_year_day_schedules_supported_per_user = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::NumberOfYearDaySchedulesSupportedPerUser: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      number_of_year_day_schedules_supported_per_user = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_number_of_year_day_schedules_supported_per_user_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    number_of_year_day_schedules_supported_per_user
  );

}
static void uic_mqtt_dotdot_on_door_lock_number_of_holiday_schedules_supported_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_number_of_holiday_schedules_supported_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t number_of_holiday_schedules_supported = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::NumberOfHolidaySchedulesSupported: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      number_of_holiday_schedules_supported = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_number_of_holiday_schedules_supported_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    number_of_holiday_schedules_supported
  );

}
static void uic_mqtt_dotdot_on_door_lock_max_pin_code_length_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_max_pin_code_length_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t max_pin_code_length = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::MaxPINCodeLength: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      max_pin_code_length = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_max_pin_code_length_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    max_pin_code_length
  );

}
static void uic_mqtt_dotdot_on_door_lock_min_pin_code_length_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_min_pin_code_length_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t min_pin_code_length = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::MinPINCodeLength: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      min_pin_code_length = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_min_pin_code_length_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    min_pin_code_length
  );

}
static void uic_mqtt_dotdot_on_door_lock_max_rfid_code_length_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_max_rfid_code_length_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t max_rfid_code_length = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::MaxRFIDCodeLength: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      max_rfid_code_length = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_max_rfid_code_length_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    max_rfid_code_length
  );

}
static void uic_mqtt_dotdot_on_door_lock_min_rfid_code_length_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_min_rfid_code_length_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t min_rfid_code_length = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::MinRFIDCodeLength: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      min_rfid_code_length = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_min_rfid_code_length_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    min_rfid_code_length
  );

}
static void uic_mqtt_dotdot_on_door_lock_credential_rules_support_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_credential_rules_support_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t credential_rules_support = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::CredentialRulesSupport: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      credential_rules_support = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, DoorLockCredentialRulesSupport);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_credential_rules_support_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    credential_rules_support
  );

}
static void uic_mqtt_dotdot_on_door_lock_number_of_credentials_supported_per_user_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_number_of_credentials_supported_per_user_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t number_of_credentials_supported_per_user = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::NumberOfCredentialsSupportedPerUser: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      number_of_credentials_supported_per_user = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_number_of_credentials_supported_per_user_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    number_of_credentials_supported_per_user
  );

}
static void uic_mqtt_dotdot_on_door_lock_enable_logging_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_enable_logging_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  bool enable_logging = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::EnableLogging: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      enable_logging = get_bool_from_json(json_payload, "value");

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_enable_logging_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    enable_logging
  );

}
static void uic_mqtt_dotdot_on_door_lock_language_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_language_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  const char* language = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::Language: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      language = json_payload.at("value").get_ptr<const std::string*>()->c_str();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_language_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    language
  );

}
static void uic_mqtt_dotdot_on_door_lock_led_settings_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_led_settings_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t led_settings = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::LEDSettings: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      led_settings = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_led_settings_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    led_settings
  );

}
static void uic_mqtt_dotdot_on_door_lock_auto_relock_time_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_auto_relock_time_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t auto_relock_time = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::AutoRelockTime: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      auto_relock_time = json_payload.at("value").get<uint32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_auto_relock_time_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    auto_relock_time
  );

}
static void uic_mqtt_dotdot_on_door_lock_sound_volume_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_sound_volume_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t sound_volume = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SoundVolume: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      sound_volume = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_sound_volume_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    sound_volume
  );

}
static void uic_mqtt_dotdot_on_door_lock_operating_mode_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_operating_mode_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  DrlkOperMode operating_mode = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::OperatingMode: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<DrlkOperMode>("value", json_payload);
      if (tmp == numeric_limits<DrlkOperMode>::max()) {
      #ifdef DOOR_LOCK_OPERATING_MODE_ENUM_NAME_AVAILABLE
        tmp = door_lock_operating_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(OPERATING_MODE_ENUM_NAME_AVAILABLE)
        tmp = operating_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      operating_mode = static_cast<DrlkOperMode>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_operating_mode_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    operating_mode
  );

}
static void uic_mqtt_dotdot_on_door_lock_supported_operating_modes_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_supported_operating_modes_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t supported_operating_modes = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SupportedOperatingModes: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      supported_operating_modes = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, DoorLockSupportedOperatingModes);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_supported_operating_modes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    supported_operating_modes
  );

}
static void uic_mqtt_dotdot_on_door_lock_default_configuration_register_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_default_configuration_register_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t default_configuration_register = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::DefaultConfigurationRegister: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      default_configuration_register = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, DoorLockDefaultConfigurationRegister);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_default_configuration_register_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    default_configuration_register
  );

}
static void uic_mqtt_dotdot_on_door_lock_enable_local_programming_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_enable_local_programming_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  bool enable_local_programming = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::EnableLocalProgramming: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      enable_local_programming = get_bool_from_json(json_payload, "value");

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_enable_local_programming_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    enable_local_programming
  );

}
static void uic_mqtt_dotdot_on_door_lock_enable_one_touch_locking_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_enable_one_touch_locking_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  bool enable_one_touch_locking = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::EnableOneTouchLocking: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      enable_one_touch_locking = get_bool_from_json(json_payload, "value");

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_enable_one_touch_locking_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    enable_one_touch_locking
  );

}
static void uic_mqtt_dotdot_on_door_lock_enable_inside_statusled_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_enable_inside_statusled_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  bool enable_inside_statusled = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::EnableInsideStatusLED: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      enable_inside_statusled = get_bool_from_json(json_payload, "value");

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_enable_inside_statusled_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    enable_inside_statusled
  );

}
static void uic_mqtt_dotdot_on_door_lock_enable_privacy_mode_button_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_enable_privacy_mode_button_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  bool enable_privacy_mode_button = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::EnablePrivacyModeButton: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      enable_privacy_mode_button = get_bool_from_json(json_payload, "value");

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_enable_privacy_mode_button_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    enable_privacy_mode_button
  );

}
static void uic_mqtt_dotdot_on_door_lock_local_programming_features_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_local_programming_features_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t local_programming_features = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::LocalProgrammingFeatures: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      local_programming_features = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, DoorLockLocalProgrammingFeatures);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_local_programming_features_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    local_programming_features
  );

}
static void uic_mqtt_dotdot_on_door_lock_wrong_code_entry_limit_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_wrong_code_entry_limit_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t wrong_code_entry_limit = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::WrongCodeEntryLimit: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      wrong_code_entry_limit = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_wrong_code_entry_limit_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    wrong_code_entry_limit
  );

}
static void uic_mqtt_dotdot_on_door_lock_user_code_temporary_disable_time_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_user_code_temporary_disable_time_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t user_code_temporary_disable_time = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::UserCodeTemporaryDisableTime: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      user_code_temporary_disable_time = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_user_code_temporary_disable_time_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    user_code_temporary_disable_time
  );

}
static void uic_mqtt_dotdot_on_door_lock_send_pin_over_the_air_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_send_pin_over_the_air_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  bool send_pin_over_the_air = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SendPINOverTheAir: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      send_pin_over_the_air = get_bool_from_json(json_payload, "value");

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_send_pin_over_the_air_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    send_pin_over_the_air
  );

}
static void uic_mqtt_dotdot_on_door_lock_require_pi_nfor_rf_operation_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_require_pi_nfor_rf_operation_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  bool require_pi_nfor_rf_operation = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::RequirePINforRFOperation: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      require_pi_nfor_rf_operation = get_bool_from_json(json_payload, "value");

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_require_pi_nfor_rf_operation_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    require_pi_nfor_rf_operation
  );

}
static void uic_mqtt_dotdot_on_door_lock_security_level_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_security_level_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t security_level = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::SecurityLevel: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<DoorLockSecurityLevel>("value", json_payload);
      if (tmp == numeric_limits<DoorLockSecurityLevel>::max()) {
      #ifdef DOOR_LOCK_SECURITY_LEVEL_ENUM_NAME_AVAILABLE
        tmp = door_lock_security_level_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(SECURITY_LEVEL_ENUM_NAME_AVAILABLE)
        tmp = security_level_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      security_level = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_security_level_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    security_level
  );

}
static void uic_mqtt_dotdot_on_door_lock_expiring_user_timeout_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_expiring_user_timeout_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t expiring_user_timeout = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::ExpiringUserTimeout: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      expiring_user_timeout = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_expiring_user_timeout_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    expiring_user_timeout
  );

}
static void uic_mqtt_dotdot_on_door_lock_alarm_mask_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_alarm_mask_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t alarm_mask = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::AlarmMask: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      alarm_mask = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, DoorLockAlarmMask);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_alarm_mask_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    alarm_mask
  );

}
static void uic_mqtt_dotdot_on_door_lock_keypad_operation_event_mask_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_keypad_operation_event_mask_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t keypad_operation_event_mask = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::KeypadOperationEventMask: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      keypad_operation_event_mask = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, DoorLockKeypadOperationEventMask);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_keypad_operation_event_mask_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    keypad_operation_event_mask
  );

}
static void uic_mqtt_dotdot_on_door_lock_rf_operation_event_mask_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_rf_operation_event_mask_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t rf_operation_event_mask = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::RFOperationEventMask: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rf_operation_event_mask = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, DoorLockRFOperationEventMask);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_rf_operation_event_mask_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rf_operation_event_mask
  );

}
static void uic_mqtt_dotdot_on_door_lock_manual_operation_event_mask_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_manual_operation_event_mask_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t manual_operation_event_mask = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::ManualOperationEventMask: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      manual_operation_event_mask = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, DoorLockManualOperationEventMask);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_manual_operation_event_mask_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    manual_operation_event_mask
  );

}
static void uic_mqtt_dotdot_on_door_lock_rfid_operation_event_mask_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_rfid_operation_event_mask_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t rfid_operation_event_mask = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::RFIDOperationEventMask: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rfid_operation_event_mask = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, DoorLockRFIDOperationEventMask);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_rfid_operation_event_mask_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rfid_operation_event_mask
  );

}
static void uic_mqtt_dotdot_on_door_lock_keypad_programming_event_mask_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_keypad_programming_event_mask_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t keypad_programming_event_mask = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::KeypadProgrammingEventMask: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      keypad_programming_event_mask = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, DoorLockKeypadProgrammingEventMask);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_keypad_programming_event_mask_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    keypad_programming_event_mask
  );

}
static void uic_mqtt_dotdot_on_door_lock_rf_programming_event_mask_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_rf_programming_event_mask_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t rf_programming_event_mask = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::RFProgrammingEventMask: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rf_programming_event_mask = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, DoorLockRFProgrammingEventMask);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_rf_programming_event_mask_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rf_programming_event_mask
  );

}
static void uic_mqtt_dotdot_on_door_lock_rfid_programming_event_mask_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_rfid_programming_event_mask_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t rfid_programming_event_mask = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::RFIDProgrammingEventMask: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rfid_programming_event_mask = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, DoorLockRFIDProgrammingEventMask);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_rfid_programming_event_mask_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rfid_programming_event_mask
  );

}
static void uic_mqtt_dotdot_on_door_lock_feature_map_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_door_lock_attribute_feature_map_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t feature_map = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DoorLock::FeatureMap: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      feature_map = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, DoorLockFeatureMap);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_door_lock_attribute_feature_map_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    feature_map
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for DoorLock
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_door_lock_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_door_lock_attribute_lock_state_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/LockState/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_lock_state_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_lock_type_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/LockType/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_lock_type_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_actuator_enabled_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/ActuatorEnabled/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_actuator_enabled_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_door_state_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/DoorState/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_door_state_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_door_open_events_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/DoorOpenEvents/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_door_open_events_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_door_closed_events_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/DoorClosedEvents/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_door_closed_events_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_open_period_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/OpenPeriod/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_open_period_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_number_of_log_records_supported_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/NumberOfLogRecordsSupported/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_number_of_log_records_supported_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_number_of_total_users_supported_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/NumberOfTotalUsersSupported/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_number_of_total_users_supported_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_number_of_pin_users_supported_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/NumberOfPINUsersSupported/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_number_of_pin_users_supported_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_number_of_rfid_users_supported_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/NumberOfRFIDUsersSupported/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_number_of_rfid_users_supported_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_number_of_week_day_schedules_supported_per_user_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/NumberOfWeekDaySchedulesSupportedPerUser/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_number_of_week_day_schedules_supported_per_user_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_number_of_year_day_schedules_supported_per_user_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/NumberOfYearDaySchedulesSupportedPerUser/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_number_of_year_day_schedules_supported_per_user_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_number_of_holiday_schedules_supported_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/NumberOfHolidaySchedulesSupported/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_number_of_holiday_schedules_supported_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_max_pin_code_length_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/MaxPINCodeLength/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_max_pin_code_length_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_min_pin_code_length_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/MinPINCodeLength/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_min_pin_code_length_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_max_rfid_code_length_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/MaxRFIDCodeLength/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_max_rfid_code_length_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_min_rfid_code_length_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/MinRFIDCodeLength/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_min_rfid_code_length_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_credential_rules_support_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/CredentialRulesSupport/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_credential_rules_support_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_number_of_credentials_supported_per_user_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/NumberOfCredentialsSupportedPerUser/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_number_of_credentials_supported_per_user_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_enable_logging_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/EnableLogging/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_enable_logging_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_language_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/Language/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_language_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_led_settings_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/LEDSettings/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_led_settings_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_auto_relock_time_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/AutoRelockTime/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_auto_relock_time_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_sound_volume_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/SoundVolume/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_sound_volume_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_operating_mode_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/OperatingMode/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_operating_mode_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_supported_operating_modes_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/SupportedOperatingModes/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_supported_operating_modes_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_default_configuration_register_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/DefaultConfigurationRegister/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_default_configuration_register_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_enable_local_programming_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/EnableLocalProgramming/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_enable_local_programming_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_enable_one_touch_locking_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/EnableOneTouchLocking/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_enable_one_touch_locking_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_enable_inside_statusled_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/EnableInsideStatusLED/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_enable_inside_statusled_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_enable_privacy_mode_button_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/EnablePrivacyModeButton/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_enable_privacy_mode_button_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_local_programming_features_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/LocalProgrammingFeatures/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_local_programming_features_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_wrong_code_entry_limit_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/WrongCodeEntryLimit/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_wrong_code_entry_limit_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_user_code_temporary_disable_time_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/UserCodeTemporaryDisableTime/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_user_code_temporary_disable_time_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_send_pin_over_the_air_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/SendPINOverTheAir/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_send_pin_over_the_air_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_require_pi_nfor_rf_operation_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/RequirePINforRFOperation/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_require_pi_nfor_rf_operation_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_security_level_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/SecurityLevel/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_security_level_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_expiring_user_timeout_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/ExpiringUserTimeout/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_expiring_user_timeout_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_alarm_mask_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/AlarmMask/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_alarm_mask_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_keypad_operation_event_mask_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/KeypadOperationEventMask/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_keypad_operation_event_mask_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_rf_operation_event_mask_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/RFOperationEventMask/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_rf_operation_event_mask_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_manual_operation_event_mask_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/ManualOperationEventMask/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_manual_operation_event_mask_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_rfid_operation_event_mask_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/RFIDOperationEventMask/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_rfid_operation_event_mask_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_keypad_programming_event_mask_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/KeypadProgrammingEventMask/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_keypad_programming_event_mask_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_rf_programming_event_mask_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/RFProgrammingEventMask/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_rf_programming_event_mask_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_rfid_programming_event_mask_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/RFIDProgrammingEventMask/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_rfid_programming_event_mask_attribute_update);
  }
  if(uic_mqtt_dotdot_door_lock_attribute_feature_map_callback) {
    subscription_topic = base_topic + "DoorLock/Attributes/FeatureMap/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_door_lock_feature_map_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for DoorLock
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_door_lock_attribute_lock_state_callback_set(const uic_mqtt_dotdot_door_lock_attribute_lock_state_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_lock_state_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_lock_type_callback_set(const uic_mqtt_dotdot_door_lock_attribute_lock_type_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_lock_type_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_actuator_enabled_callback_set(const uic_mqtt_dotdot_door_lock_attribute_actuator_enabled_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_actuator_enabled_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_door_state_callback_set(const uic_mqtt_dotdot_door_lock_attribute_door_state_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_door_state_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_door_open_events_callback_set(const uic_mqtt_dotdot_door_lock_attribute_door_open_events_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_door_open_events_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_door_closed_events_callback_set(const uic_mqtt_dotdot_door_lock_attribute_door_closed_events_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_door_closed_events_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_open_period_callback_set(const uic_mqtt_dotdot_door_lock_attribute_open_period_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_open_period_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_number_of_log_records_supported_callback_set(const uic_mqtt_dotdot_door_lock_attribute_number_of_log_records_supported_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_number_of_log_records_supported_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_number_of_total_users_supported_callback_set(const uic_mqtt_dotdot_door_lock_attribute_number_of_total_users_supported_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_number_of_total_users_supported_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_number_of_pin_users_supported_callback_set(const uic_mqtt_dotdot_door_lock_attribute_number_of_pin_users_supported_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_number_of_pin_users_supported_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_number_of_rfid_users_supported_callback_set(const uic_mqtt_dotdot_door_lock_attribute_number_of_rfid_users_supported_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_number_of_rfid_users_supported_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_number_of_week_day_schedules_supported_per_user_callback_set(const uic_mqtt_dotdot_door_lock_attribute_number_of_week_day_schedules_supported_per_user_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_number_of_week_day_schedules_supported_per_user_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_number_of_year_day_schedules_supported_per_user_callback_set(const uic_mqtt_dotdot_door_lock_attribute_number_of_year_day_schedules_supported_per_user_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_number_of_year_day_schedules_supported_per_user_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_number_of_holiday_schedules_supported_callback_set(const uic_mqtt_dotdot_door_lock_attribute_number_of_holiday_schedules_supported_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_number_of_holiday_schedules_supported_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_max_pin_code_length_callback_set(const uic_mqtt_dotdot_door_lock_attribute_max_pin_code_length_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_max_pin_code_length_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_min_pin_code_length_callback_set(const uic_mqtt_dotdot_door_lock_attribute_min_pin_code_length_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_min_pin_code_length_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_max_rfid_code_length_callback_set(const uic_mqtt_dotdot_door_lock_attribute_max_rfid_code_length_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_max_rfid_code_length_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_min_rfid_code_length_callback_set(const uic_mqtt_dotdot_door_lock_attribute_min_rfid_code_length_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_min_rfid_code_length_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_credential_rules_support_callback_set(const uic_mqtt_dotdot_door_lock_attribute_credential_rules_support_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_credential_rules_support_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_number_of_credentials_supported_per_user_callback_set(const uic_mqtt_dotdot_door_lock_attribute_number_of_credentials_supported_per_user_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_number_of_credentials_supported_per_user_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_enable_logging_callback_set(const uic_mqtt_dotdot_door_lock_attribute_enable_logging_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_enable_logging_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_language_callback_set(const uic_mqtt_dotdot_door_lock_attribute_language_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_language_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_led_settings_callback_set(const uic_mqtt_dotdot_door_lock_attribute_led_settings_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_led_settings_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_auto_relock_time_callback_set(const uic_mqtt_dotdot_door_lock_attribute_auto_relock_time_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_auto_relock_time_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_sound_volume_callback_set(const uic_mqtt_dotdot_door_lock_attribute_sound_volume_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_sound_volume_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_operating_mode_callback_set(const uic_mqtt_dotdot_door_lock_attribute_operating_mode_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_operating_mode_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_supported_operating_modes_callback_set(const uic_mqtt_dotdot_door_lock_attribute_supported_operating_modes_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_supported_operating_modes_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_default_configuration_register_callback_set(const uic_mqtt_dotdot_door_lock_attribute_default_configuration_register_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_default_configuration_register_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_enable_local_programming_callback_set(const uic_mqtt_dotdot_door_lock_attribute_enable_local_programming_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_enable_local_programming_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_enable_one_touch_locking_callback_set(const uic_mqtt_dotdot_door_lock_attribute_enable_one_touch_locking_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_enable_one_touch_locking_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_enable_inside_statusled_callback_set(const uic_mqtt_dotdot_door_lock_attribute_enable_inside_statusled_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_enable_inside_statusled_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_enable_privacy_mode_button_callback_set(const uic_mqtt_dotdot_door_lock_attribute_enable_privacy_mode_button_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_enable_privacy_mode_button_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_local_programming_features_callback_set(const uic_mqtt_dotdot_door_lock_attribute_local_programming_features_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_local_programming_features_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_wrong_code_entry_limit_callback_set(const uic_mqtt_dotdot_door_lock_attribute_wrong_code_entry_limit_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_wrong_code_entry_limit_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_user_code_temporary_disable_time_callback_set(const uic_mqtt_dotdot_door_lock_attribute_user_code_temporary_disable_time_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_user_code_temporary_disable_time_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_send_pin_over_the_air_callback_set(const uic_mqtt_dotdot_door_lock_attribute_send_pin_over_the_air_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_send_pin_over_the_air_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_require_pi_nfor_rf_operation_callback_set(const uic_mqtt_dotdot_door_lock_attribute_require_pi_nfor_rf_operation_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_require_pi_nfor_rf_operation_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_security_level_callback_set(const uic_mqtt_dotdot_door_lock_attribute_security_level_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_security_level_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_expiring_user_timeout_callback_set(const uic_mqtt_dotdot_door_lock_attribute_expiring_user_timeout_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_expiring_user_timeout_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_alarm_mask_callback_set(const uic_mqtt_dotdot_door_lock_attribute_alarm_mask_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_alarm_mask_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_keypad_operation_event_mask_callback_set(const uic_mqtt_dotdot_door_lock_attribute_keypad_operation_event_mask_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_keypad_operation_event_mask_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_rf_operation_event_mask_callback_set(const uic_mqtt_dotdot_door_lock_attribute_rf_operation_event_mask_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_rf_operation_event_mask_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_manual_operation_event_mask_callback_set(const uic_mqtt_dotdot_door_lock_attribute_manual_operation_event_mask_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_manual_operation_event_mask_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_rfid_operation_event_mask_callback_set(const uic_mqtt_dotdot_door_lock_attribute_rfid_operation_event_mask_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_rfid_operation_event_mask_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_keypad_programming_event_mask_callback_set(const uic_mqtt_dotdot_door_lock_attribute_keypad_programming_event_mask_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_keypad_programming_event_mask_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_rf_programming_event_mask_callback_set(const uic_mqtt_dotdot_door_lock_attribute_rf_programming_event_mask_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_rf_programming_event_mask_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_rfid_programming_event_mask_callback_set(const uic_mqtt_dotdot_door_lock_attribute_rfid_programming_event_mask_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_rfid_programming_event_mask_callback = callback;
}
void uic_mqtt_dotdot_door_lock_attribute_feature_map_callback_set(const uic_mqtt_dotdot_door_lock_attribute_feature_map_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_attribute_feature_map_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for WindowCovering
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_window_covering_attribute_window_covering_type_callback_t uic_mqtt_dotdot_window_covering_attribute_window_covering_type_callback = nullptr;
static uic_mqtt_dotdot_window_covering_attribute_physical_closed_limit_lift_callback_t uic_mqtt_dotdot_window_covering_attribute_physical_closed_limit_lift_callback = nullptr;
static uic_mqtt_dotdot_window_covering_attribute_physical_closed_limit_tilt_callback_t uic_mqtt_dotdot_window_covering_attribute_physical_closed_limit_tilt_callback = nullptr;
static uic_mqtt_dotdot_window_covering_attribute_current_position_lift_callback_t uic_mqtt_dotdot_window_covering_attribute_current_position_lift_callback = nullptr;
static uic_mqtt_dotdot_window_covering_attribute_current_position_tilt_callback_t uic_mqtt_dotdot_window_covering_attribute_current_position_tilt_callback = nullptr;
static uic_mqtt_dotdot_window_covering_attribute_number_of_actuations_lift_callback_t uic_mqtt_dotdot_window_covering_attribute_number_of_actuations_lift_callback = nullptr;
static uic_mqtt_dotdot_window_covering_attribute_number_of_actuations_tilt_callback_t uic_mqtt_dotdot_window_covering_attribute_number_of_actuations_tilt_callback = nullptr;
static uic_mqtt_dotdot_window_covering_attribute_config_or_status_callback_t uic_mqtt_dotdot_window_covering_attribute_config_or_status_callback = nullptr;
static uic_mqtt_dotdot_window_covering_attribute_current_position_lift_percentage_callback_t uic_mqtt_dotdot_window_covering_attribute_current_position_lift_percentage_callback = nullptr;
static uic_mqtt_dotdot_window_covering_attribute_current_position_tilt_percentage_callback_t uic_mqtt_dotdot_window_covering_attribute_current_position_tilt_percentage_callback = nullptr;
static uic_mqtt_dotdot_window_covering_attribute_installed_open_limit_lift_callback_t uic_mqtt_dotdot_window_covering_attribute_installed_open_limit_lift_callback = nullptr;
static uic_mqtt_dotdot_window_covering_attribute_installed_closed_limit_lift_callback_t uic_mqtt_dotdot_window_covering_attribute_installed_closed_limit_lift_callback = nullptr;
static uic_mqtt_dotdot_window_covering_attribute_installed_open_limit_tilt_callback_t uic_mqtt_dotdot_window_covering_attribute_installed_open_limit_tilt_callback = nullptr;
static uic_mqtt_dotdot_window_covering_attribute_installed_closed_limit_tilt_callback_t uic_mqtt_dotdot_window_covering_attribute_installed_closed_limit_tilt_callback = nullptr;
static uic_mqtt_dotdot_window_covering_attribute_velocity_lift_callback_t uic_mqtt_dotdot_window_covering_attribute_velocity_lift_callback = nullptr;
static uic_mqtt_dotdot_window_covering_attribute_acceleration_time_lift_callback_t uic_mqtt_dotdot_window_covering_attribute_acceleration_time_lift_callback = nullptr;
static uic_mqtt_dotdot_window_covering_attribute_deceleration_time_lift_callback_t uic_mqtt_dotdot_window_covering_attribute_deceleration_time_lift_callback = nullptr;
static uic_mqtt_dotdot_window_covering_attribute_mode_callback_t uic_mqtt_dotdot_window_covering_attribute_mode_callback = nullptr;
static uic_mqtt_dotdot_window_covering_attribute_intermediate_setpoints_lift_callback_t uic_mqtt_dotdot_window_covering_attribute_intermediate_setpoints_lift_callback = nullptr;
static uic_mqtt_dotdot_window_covering_attribute_intermediate_setpoints_tilt_callback_t uic_mqtt_dotdot_window_covering_attribute_intermediate_setpoints_tilt_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for WindowCovering
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_window_covering_window_covering_type_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_window_covering_attribute_window_covering_type_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t window_covering_type = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "WindowCovering::WindowCoveringType: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<WindowCoveringWindowCoveringType>("value", json_payload);
      if (tmp == numeric_limits<WindowCoveringWindowCoveringType>::max()) {
      #ifdef WINDOW_COVERING_WINDOW_COVERING_TYPE_ENUM_NAME_AVAILABLE
        tmp = window_covering_window_covering_type_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(WINDOW_COVERING_TYPE_ENUM_NAME_AVAILABLE)
        tmp = window_covering_type_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      window_covering_type = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_window_covering_attribute_window_covering_type_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    window_covering_type
  );

}
static void uic_mqtt_dotdot_on_window_covering_physical_closed_limit_lift_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_window_covering_attribute_physical_closed_limit_lift_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t physical_closed_limit_lift = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "WindowCovering::PhysicalClosedLimitLift: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      physical_closed_limit_lift = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_window_covering_attribute_physical_closed_limit_lift_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    physical_closed_limit_lift
  );

}
static void uic_mqtt_dotdot_on_window_covering_physical_closed_limit_tilt_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_window_covering_attribute_physical_closed_limit_tilt_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t physical_closed_limit_tilt = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "WindowCovering::PhysicalClosedLimitTilt: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      physical_closed_limit_tilt = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_window_covering_attribute_physical_closed_limit_tilt_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    physical_closed_limit_tilt
  );

}
static void uic_mqtt_dotdot_on_window_covering_current_position_lift_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_window_covering_attribute_current_position_lift_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t current_position_lift = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "WindowCovering::CurrentPositionLift: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      current_position_lift = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_window_covering_attribute_current_position_lift_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    current_position_lift
  );

}
static void uic_mqtt_dotdot_on_window_covering_current_position_tilt_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_window_covering_attribute_current_position_tilt_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t current_position_tilt = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "WindowCovering::CurrentPositionTilt: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      current_position_tilt = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_window_covering_attribute_current_position_tilt_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    current_position_tilt
  );

}
static void uic_mqtt_dotdot_on_window_covering_number_of_actuations_lift_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_window_covering_attribute_number_of_actuations_lift_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t number_of_actuations_lift = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "WindowCovering::NumberOfActuationsLift: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      number_of_actuations_lift = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_window_covering_attribute_number_of_actuations_lift_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    number_of_actuations_lift
  );

}
static void uic_mqtt_dotdot_on_window_covering_number_of_actuations_tilt_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_window_covering_attribute_number_of_actuations_tilt_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t number_of_actuations_tilt = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "WindowCovering::NumberOfActuationsTilt: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      number_of_actuations_tilt = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_window_covering_attribute_number_of_actuations_tilt_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    number_of_actuations_tilt
  );

}
static void uic_mqtt_dotdot_on_window_covering_config_or_status_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_window_covering_attribute_config_or_status_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t config_or_status = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "WindowCovering::ConfigOrStatus: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      config_or_status = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, WindowCoveringConfigOrStatus);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_window_covering_attribute_config_or_status_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    config_or_status
  );

}
static void uic_mqtt_dotdot_on_window_covering_current_position_lift_percentage_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_window_covering_attribute_current_position_lift_percentage_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t current_position_lift_percentage = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "WindowCovering::CurrentPositionLiftPercentage: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      current_position_lift_percentage = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_window_covering_attribute_current_position_lift_percentage_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    current_position_lift_percentage
  );

}
static void uic_mqtt_dotdot_on_window_covering_current_position_tilt_percentage_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_window_covering_attribute_current_position_tilt_percentage_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t current_position_tilt_percentage = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "WindowCovering::CurrentPositionTiltPercentage: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      current_position_tilt_percentage = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_window_covering_attribute_current_position_tilt_percentage_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    current_position_tilt_percentage
  );

}
static void uic_mqtt_dotdot_on_window_covering_installed_open_limit_lift_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_window_covering_attribute_installed_open_limit_lift_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t installed_open_limit_lift = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "WindowCovering::InstalledOpenLimitLift: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      installed_open_limit_lift = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_window_covering_attribute_installed_open_limit_lift_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    installed_open_limit_lift
  );

}
static void uic_mqtt_dotdot_on_window_covering_installed_closed_limit_lift_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_window_covering_attribute_installed_closed_limit_lift_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t installed_closed_limit_lift = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "WindowCovering::InstalledClosedLimitLift: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      installed_closed_limit_lift = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_window_covering_attribute_installed_closed_limit_lift_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    installed_closed_limit_lift
  );

}
static void uic_mqtt_dotdot_on_window_covering_installed_open_limit_tilt_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_window_covering_attribute_installed_open_limit_tilt_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t installed_open_limit_tilt = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "WindowCovering::InstalledOpenLimitTilt: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      installed_open_limit_tilt = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_window_covering_attribute_installed_open_limit_tilt_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    installed_open_limit_tilt
  );

}
static void uic_mqtt_dotdot_on_window_covering_installed_closed_limit_tilt_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_window_covering_attribute_installed_closed_limit_tilt_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t installed_closed_limit_tilt = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "WindowCovering::InstalledClosedLimitTilt: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      installed_closed_limit_tilt = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_window_covering_attribute_installed_closed_limit_tilt_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    installed_closed_limit_tilt
  );

}
static void uic_mqtt_dotdot_on_window_covering_velocity_lift_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_window_covering_attribute_velocity_lift_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t velocity_lift = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "WindowCovering::VelocityLift: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      velocity_lift = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_window_covering_attribute_velocity_lift_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    velocity_lift
  );

}
static void uic_mqtt_dotdot_on_window_covering_acceleration_time_lift_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_window_covering_attribute_acceleration_time_lift_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t acceleration_time_lift = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "WindowCovering::AccelerationTimeLift: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      acceleration_time_lift = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_window_covering_attribute_acceleration_time_lift_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    acceleration_time_lift
  );

}
static void uic_mqtt_dotdot_on_window_covering_deceleration_time_lift_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_window_covering_attribute_deceleration_time_lift_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t deceleration_time_lift = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "WindowCovering::DecelerationTimeLift: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      deceleration_time_lift = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_window_covering_attribute_deceleration_time_lift_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    deceleration_time_lift
  );

}
static void uic_mqtt_dotdot_on_window_covering_mode_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_window_covering_attribute_mode_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t mode = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "WindowCovering::Mode: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      mode = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, WindowCoveringMode);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_window_covering_attribute_mode_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    mode
  );

}
static void uic_mqtt_dotdot_on_window_covering_intermediate_setpoints_lift_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_window_covering_attribute_intermediate_setpoints_lift_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  const char* intermediate_setpoints_lift = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "WindowCovering::IntermediateSetpointsLift: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      intermediate_setpoints_lift = json_payload.at("value").get_ptr<const std::string*>()->c_str();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_window_covering_attribute_intermediate_setpoints_lift_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    intermediate_setpoints_lift
  );

}
static void uic_mqtt_dotdot_on_window_covering_intermediate_setpoints_tilt_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_window_covering_attribute_intermediate_setpoints_tilt_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  const char* intermediate_setpoints_tilt = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "WindowCovering::IntermediateSetpointsTilt: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      intermediate_setpoints_tilt = json_payload.at("value").get_ptr<const std::string*>()->c_str();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_window_covering_attribute_intermediate_setpoints_tilt_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    intermediate_setpoints_tilt
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for WindowCovering
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_window_covering_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_window_covering_attribute_window_covering_type_callback) {
    subscription_topic = base_topic + "WindowCovering/Attributes/WindowCoveringType/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_window_covering_window_covering_type_attribute_update);
  }
  if(uic_mqtt_dotdot_window_covering_attribute_physical_closed_limit_lift_callback) {
    subscription_topic = base_topic + "WindowCovering/Attributes/PhysicalClosedLimitLift/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_window_covering_physical_closed_limit_lift_attribute_update);
  }
  if(uic_mqtt_dotdot_window_covering_attribute_physical_closed_limit_tilt_callback) {
    subscription_topic = base_topic + "WindowCovering/Attributes/PhysicalClosedLimitTilt/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_window_covering_physical_closed_limit_tilt_attribute_update);
  }
  if(uic_mqtt_dotdot_window_covering_attribute_current_position_lift_callback) {
    subscription_topic = base_topic + "WindowCovering/Attributes/CurrentPositionLift/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_window_covering_current_position_lift_attribute_update);
  }
  if(uic_mqtt_dotdot_window_covering_attribute_current_position_tilt_callback) {
    subscription_topic = base_topic + "WindowCovering/Attributes/CurrentPositionTilt/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_window_covering_current_position_tilt_attribute_update);
  }
  if(uic_mqtt_dotdot_window_covering_attribute_number_of_actuations_lift_callback) {
    subscription_topic = base_topic + "WindowCovering/Attributes/NumberOfActuationsLift/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_window_covering_number_of_actuations_lift_attribute_update);
  }
  if(uic_mqtt_dotdot_window_covering_attribute_number_of_actuations_tilt_callback) {
    subscription_topic = base_topic + "WindowCovering/Attributes/NumberOfActuationsTilt/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_window_covering_number_of_actuations_tilt_attribute_update);
  }
  if(uic_mqtt_dotdot_window_covering_attribute_config_or_status_callback) {
    subscription_topic = base_topic + "WindowCovering/Attributes/ConfigOrStatus/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_window_covering_config_or_status_attribute_update);
  }
  if(uic_mqtt_dotdot_window_covering_attribute_current_position_lift_percentage_callback) {
    subscription_topic = base_topic + "WindowCovering/Attributes/CurrentPositionLiftPercentage/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_window_covering_current_position_lift_percentage_attribute_update);
  }
  if(uic_mqtt_dotdot_window_covering_attribute_current_position_tilt_percentage_callback) {
    subscription_topic = base_topic + "WindowCovering/Attributes/CurrentPositionTiltPercentage/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_window_covering_current_position_tilt_percentage_attribute_update);
  }
  if(uic_mqtt_dotdot_window_covering_attribute_installed_open_limit_lift_callback) {
    subscription_topic = base_topic + "WindowCovering/Attributes/InstalledOpenLimitLift/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_window_covering_installed_open_limit_lift_attribute_update);
  }
  if(uic_mqtt_dotdot_window_covering_attribute_installed_closed_limit_lift_callback) {
    subscription_topic = base_topic + "WindowCovering/Attributes/InstalledClosedLimitLift/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_window_covering_installed_closed_limit_lift_attribute_update);
  }
  if(uic_mqtt_dotdot_window_covering_attribute_installed_open_limit_tilt_callback) {
    subscription_topic = base_topic + "WindowCovering/Attributes/InstalledOpenLimitTilt/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_window_covering_installed_open_limit_tilt_attribute_update);
  }
  if(uic_mqtt_dotdot_window_covering_attribute_installed_closed_limit_tilt_callback) {
    subscription_topic = base_topic + "WindowCovering/Attributes/InstalledClosedLimitTilt/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_window_covering_installed_closed_limit_tilt_attribute_update);
  }
  if(uic_mqtt_dotdot_window_covering_attribute_velocity_lift_callback) {
    subscription_topic = base_topic + "WindowCovering/Attributes/VelocityLift/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_window_covering_velocity_lift_attribute_update);
  }
  if(uic_mqtt_dotdot_window_covering_attribute_acceleration_time_lift_callback) {
    subscription_topic = base_topic + "WindowCovering/Attributes/AccelerationTimeLift/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_window_covering_acceleration_time_lift_attribute_update);
  }
  if(uic_mqtt_dotdot_window_covering_attribute_deceleration_time_lift_callback) {
    subscription_topic = base_topic + "WindowCovering/Attributes/DecelerationTimeLift/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_window_covering_deceleration_time_lift_attribute_update);
  }
  if(uic_mqtt_dotdot_window_covering_attribute_mode_callback) {
    subscription_topic = base_topic + "WindowCovering/Attributes/Mode/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_window_covering_mode_attribute_update);
  }
  if(uic_mqtt_dotdot_window_covering_attribute_intermediate_setpoints_lift_callback) {
    subscription_topic = base_topic + "WindowCovering/Attributes/IntermediateSetpointsLift/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_window_covering_intermediate_setpoints_lift_attribute_update);
  }
  if(uic_mqtt_dotdot_window_covering_attribute_intermediate_setpoints_tilt_callback) {
    subscription_topic = base_topic + "WindowCovering/Attributes/IntermediateSetpointsTilt/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_window_covering_intermediate_setpoints_tilt_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for WindowCovering
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_window_covering_attribute_window_covering_type_callback_set(const uic_mqtt_dotdot_window_covering_attribute_window_covering_type_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_attribute_window_covering_type_callback = callback;
}
void uic_mqtt_dotdot_window_covering_attribute_physical_closed_limit_lift_callback_set(const uic_mqtt_dotdot_window_covering_attribute_physical_closed_limit_lift_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_attribute_physical_closed_limit_lift_callback = callback;
}
void uic_mqtt_dotdot_window_covering_attribute_physical_closed_limit_tilt_callback_set(const uic_mqtt_dotdot_window_covering_attribute_physical_closed_limit_tilt_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_attribute_physical_closed_limit_tilt_callback = callback;
}
void uic_mqtt_dotdot_window_covering_attribute_current_position_lift_callback_set(const uic_mqtt_dotdot_window_covering_attribute_current_position_lift_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_attribute_current_position_lift_callback = callback;
}
void uic_mqtt_dotdot_window_covering_attribute_current_position_tilt_callback_set(const uic_mqtt_dotdot_window_covering_attribute_current_position_tilt_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_attribute_current_position_tilt_callback = callback;
}
void uic_mqtt_dotdot_window_covering_attribute_number_of_actuations_lift_callback_set(const uic_mqtt_dotdot_window_covering_attribute_number_of_actuations_lift_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_attribute_number_of_actuations_lift_callback = callback;
}
void uic_mqtt_dotdot_window_covering_attribute_number_of_actuations_tilt_callback_set(const uic_mqtt_dotdot_window_covering_attribute_number_of_actuations_tilt_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_attribute_number_of_actuations_tilt_callback = callback;
}
void uic_mqtt_dotdot_window_covering_attribute_config_or_status_callback_set(const uic_mqtt_dotdot_window_covering_attribute_config_or_status_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_attribute_config_or_status_callback = callback;
}
void uic_mqtt_dotdot_window_covering_attribute_current_position_lift_percentage_callback_set(const uic_mqtt_dotdot_window_covering_attribute_current_position_lift_percentage_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_attribute_current_position_lift_percentage_callback = callback;
}
void uic_mqtt_dotdot_window_covering_attribute_current_position_tilt_percentage_callback_set(const uic_mqtt_dotdot_window_covering_attribute_current_position_tilt_percentage_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_attribute_current_position_tilt_percentage_callback = callback;
}
void uic_mqtt_dotdot_window_covering_attribute_installed_open_limit_lift_callback_set(const uic_mqtt_dotdot_window_covering_attribute_installed_open_limit_lift_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_attribute_installed_open_limit_lift_callback = callback;
}
void uic_mqtt_dotdot_window_covering_attribute_installed_closed_limit_lift_callback_set(const uic_mqtt_dotdot_window_covering_attribute_installed_closed_limit_lift_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_attribute_installed_closed_limit_lift_callback = callback;
}
void uic_mqtt_dotdot_window_covering_attribute_installed_open_limit_tilt_callback_set(const uic_mqtt_dotdot_window_covering_attribute_installed_open_limit_tilt_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_attribute_installed_open_limit_tilt_callback = callback;
}
void uic_mqtt_dotdot_window_covering_attribute_installed_closed_limit_tilt_callback_set(const uic_mqtt_dotdot_window_covering_attribute_installed_closed_limit_tilt_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_attribute_installed_closed_limit_tilt_callback = callback;
}
void uic_mqtt_dotdot_window_covering_attribute_velocity_lift_callback_set(const uic_mqtt_dotdot_window_covering_attribute_velocity_lift_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_attribute_velocity_lift_callback = callback;
}
void uic_mqtt_dotdot_window_covering_attribute_acceleration_time_lift_callback_set(const uic_mqtt_dotdot_window_covering_attribute_acceleration_time_lift_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_attribute_acceleration_time_lift_callback = callback;
}
void uic_mqtt_dotdot_window_covering_attribute_deceleration_time_lift_callback_set(const uic_mqtt_dotdot_window_covering_attribute_deceleration_time_lift_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_attribute_deceleration_time_lift_callback = callback;
}
void uic_mqtt_dotdot_window_covering_attribute_mode_callback_set(const uic_mqtt_dotdot_window_covering_attribute_mode_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_attribute_mode_callback = callback;
}
void uic_mqtt_dotdot_window_covering_attribute_intermediate_setpoints_lift_callback_set(const uic_mqtt_dotdot_window_covering_attribute_intermediate_setpoints_lift_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_attribute_intermediate_setpoints_lift_callback = callback;
}
void uic_mqtt_dotdot_window_covering_attribute_intermediate_setpoints_tilt_callback_set(const uic_mqtt_dotdot_window_covering_attribute_intermediate_setpoints_tilt_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_attribute_intermediate_setpoints_tilt_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for BarrierControl
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_barrier_control_attribute_moving_state_callback_t uic_mqtt_dotdot_barrier_control_attribute_moving_state_callback = nullptr;
static uic_mqtt_dotdot_barrier_control_attribute_safety_status_callback_t uic_mqtt_dotdot_barrier_control_attribute_safety_status_callback = nullptr;
static uic_mqtt_dotdot_barrier_control_attribute_capabilities_callback_t uic_mqtt_dotdot_barrier_control_attribute_capabilities_callback = nullptr;
static uic_mqtt_dotdot_barrier_control_attribute_open_events_callback_t uic_mqtt_dotdot_barrier_control_attribute_open_events_callback = nullptr;
static uic_mqtt_dotdot_barrier_control_attribute_close_events_callback_t uic_mqtt_dotdot_barrier_control_attribute_close_events_callback = nullptr;
static uic_mqtt_dotdot_barrier_control_attribute_command_open_events_callback_t uic_mqtt_dotdot_barrier_control_attribute_command_open_events_callback = nullptr;
static uic_mqtt_dotdot_barrier_control_attribute_command_close_events_callback_t uic_mqtt_dotdot_barrier_control_attribute_command_close_events_callback = nullptr;
static uic_mqtt_dotdot_barrier_control_attribute_open_period_callback_t uic_mqtt_dotdot_barrier_control_attribute_open_period_callback = nullptr;
static uic_mqtt_dotdot_barrier_control_attribute_close_period_callback_t uic_mqtt_dotdot_barrier_control_attribute_close_period_callback = nullptr;
static uic_mqtt_dotdot_barrier_control_attribute_barrier_position_callback_t uic_mqtt_dotdot_barrier_control_attribute_barrier_position_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for BarrierControl
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_barrier_control_moving_state_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_barrier_control_attribute_moving_state_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t moving_state = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "BarrierControl::MovingState: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<BarrierControlMovingState>("value", json_payload);
      if (tmp == numeric_limits<BarrierControlMovingState>::max()) {
      #ifdef BARRIER_CONTROL_MOVING_STATE_ENUM_NAME_AVAILABLE
        tmp = barrier_control_moving_state_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(MOVING_STATE_ENUM_NAME_AVAILABLE)
        tmp = moving_state_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      moving_state = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_barrier_control_attribute_moving_state_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    moving_state
  );

}
static void uic_mqtt_dotdot_on_barrier_control_safety_status_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_barrier_control_attribute_safety_status_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t safety_status = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "BarrierControl::SafetyStatus: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      safety_status = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, BarrierControlSafetyStatus);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_barrier_control_attribute_safety_status_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    safety_status
  );

}
static void uic_mqtt_dotdot_on_barrier_control_capabilities_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_barrier_control_attribute_capabilities_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t capabilities = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "BarrierControl::Capabilities: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      capabilities = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, BarrierControlCapabilities);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_barrier_control_attribute_capabilities_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    capabilities
  );

}
static void uic_mqtt_dotdot_on_barrier_control_open_events_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_barrier_control_attribute_open_events_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t open_events = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "BarrierControl::OpenEvents: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      open_events = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_barrier_control_attribute_open_events_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    open_events
  );

}
static void uic_mqtt_dotdot_on_barrier_control_close_events_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_barrier_control_attribute_close_events_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t close_events = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "BarrierControl::CloseEvents: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      close_events = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_barrier_control_attribute_close_events_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    close_events
  );

}
static void uic_mqtt_dotdot_on_barrier_control_command_open_events_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_barrier_control_attribute_command_open_events_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t command_open_events = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "BarrierControl::CommandOpenEvents: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      command_open_events = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_barrier_control_attribute_command_open_events_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    command_open_events
  );

}
static void uic_mqtt_dotdot_on_barrier_control_command_close_events_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_barrier_control_attribute_command_close_events_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t command_close_events = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "BarrierControl::CommandCloseEvents: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      command_close_events = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_barrier_control_attribute_command_close_events_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    command_close_events
  );

}
static void uic_mqtt_dotdot_on_barrier_control_open_period_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_barrier_control_attribute_open_period_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t open_period = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "BarrierControl::OpenPeriod: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      open_period = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_barrier_control_attribute_open_period_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    open_period
  );

}
static void uic_mqtt_dotdot_on_barrier_control_close_period_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_barrier_control_attribute_close_period_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t close_period = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "BarrierControl::ClosePeriod: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      close_period = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_barrier_control_attribute_close_period_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    close_period
  );

}
static void uic_mqtt_dotdot_on_barrier_control_barrier_position_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_barrier_control_attribute_barrier_position_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t barrier_position = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "BarrierControl::BarrierPosition: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      barrier_position = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_barrier_control_attribute_barrier_position_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    barrier_position
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for BarrierControl
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_barrier_control_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_barrier_control_attribute_moving_state_callback) {
    subscription_topic = base_topic + "BarrierControl/Attributes/MovingState/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_barrier_control_moving_state_attribute_update);
  }
  if(uic_mqtt_dotdot_barrier_control_attribute_safety_status_callback) {
    subscription_topic = base_topic + "BarrierControl/Attributes/SafetyStatus/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_barrier_control_safety_status_attribute_update);
  }
  if(uic_mqtt_dotdot_barrier_control_attribute_capabilities_callback) {
    subscription_topic = base_topic + "BarrierControl/Attributes/Capabilities/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_barrier_control_capabilities_attribute_update);
  }
  if(uic_mqtt_dotdot_barrier_control_attribute_open_events_callback) {
    subscription_topic = base_topic + "BarrierControl/Attributes/OpenEvents/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_barrier_control_open_events_attribute_update);
  }
  if(uic_mqtt_dotdot_barrier_control_attribute_close_events_callback) {
    subscription_topic = base_topic + "BarrierControl/Attributes/CloseEvents/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_barrier_control_close_events_attribute_update);
  }
  if(uic_mqtt_dotdot_barrier_control_attribute_command_open_events_callback) {
    subscription_topic = base_topic + "BarrierControl/Attributes/CommandOpenEvents/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_barrier_control_command_open_events_attribute_update);
  }
  if(uic_mqtt_dotdot_barrier_control_attribute_command_close_events_callback) {
    subscription_topic = base_topic + "BarrierControl/Attributes/CommandCloseEvents/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_barrier_control_command_close_events_attribute_update);
  }
  if(uic_mqtt_dotdot_barrier_control_attribute_open_period_callback) {
    subscription_topic = base_topic + "BarrierControl/Attributes/OpenPeriod/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_barrier_control_open_period_attribute_update);
  }
  if(uic_mqtt_dotdot_barrier_control_attribute_close_period_callback) {
    subscription_topic = base_topic + "BarrierControl/Attributes/ClosePeriod/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_barrier_control_close_period_attribute_update);
  }
  if(uic_mqtt_dotdot_barrier_control_attribute_barrier_position_callback) {
    subscription_topic = base_topic + "BarrierControl/Attributes/BarrierPosition/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_barrier_control_barrier_position_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for BarrierControl
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_barrier_control_attribute_moving_state_callback_set(const uic_mqtt_dotdot_barrier_control_attribute_moving_state_callback_t callback)
{
  uic_mqtt_dotdot_barrier_control_attribute_moving_state_callback = callback;
}
void uic_mqtt_dotdot_barrier_control_attribute_safety_status_callback_set(const uic_mqtt_dotdot_barrier_control_attribute_safety_status_callback_t callback)
{
  uic_mqtt_dotdot_barrier_control_attribute_safety_status_callback = callback;
}
void uic_mqtt_dotdot_barrier_control_attribute_capabilities_callback_set(const uic_mqtt_dotdot_barrier_control_attribute_capabilities_callback_t callback)
{
  uic_mqtt_dotdot_barrier_control_attribute_capabilities_callback = callback;
}
void uic_mqtt_dotdot_barrier_control_attribute_open_events_callback_set(const uic_mqtt_dotdot_barrier_control_attribute_open_events_callback_t callback)
{
  uic_mqtt_dotdot_barrier_control_attribute_open_events_callback = callback;
}
void uic_mqtt_dotdot_barrier_control_attribute_close_events_callback_set(const uic_mqtt_dotdot_barrier_control_attribute_close_events_callback_t callback)
{
  uic_mqtt_dotdot_barrier_control_attribute_close_events_callback = callback;
}
void uic_mqtt_dotdot_barrier_control_attribute_command_open_events_callback_set(const uic_mqtt_dotdot_barrier_control_attribute_command_open_events_callback_t callback)
{
  uic_mqtt_dotdot_barrier_control_attribute_command_open_events_callback = callback;
}
void uic_mqtt_dotdot_barrier_control_attribute_command_close_events_callback_set(const uic_mqtt_dotdot_barrier_control_attribute_command_close_events_callback_t callback)
{
  uic_mqtt_dotdot_barrier_control_attribute_command_close_events_callback = callback;
}
void uic_mqtt_dotdot_barrier_control_attribute_open_period_callback_set(const uic_mqtt_dotdot_barrier_control_attribute_open_period_callback_t callback)
{
  uic_mqtt_dotdot_barrier_control_attribute_open_period_callback = callback;
}
void uic_mqtt_dotdot_barrier_control_attribute_close_period_callback_set(const uic_mqtt_dotdot_barrier_control_attribute_close_period_callback_t callback)
{
  uic_mqtt_dotdot_barrier_control_attribute_close_period_callback = callback;
}
void uic_mqtt_dotdot_barrier_control_attribute_barrier_position_callback_set(const uic_mqtt_dotdot_barrier_control_attribute_barrier_position_callback_t callback)
{
  uic_mqtt_dotdot_barrier_control_attribute_barrier_position_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for PumpConfigurationAndControl
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_pressure_callback_t uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_pressure_callback = nullptr;
static uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_speed_callback_t uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_speed_callback = nullptr;
static uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_flow_callback_t uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_flow_callback = nullptr;
static uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_const_pressure_callback_t uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_const_pressure_callback = nullptr;
static uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_const_pressure_callback_t uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_const_pressure_callback = nullptr;
static uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_comp_pressure_callback_t uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_comp_pressure_callback = nullptr;
static uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_comp_pressure_callback_t uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_comp_pressure_callback = nullptr;
static uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_const_speed_callback_t uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_const_speed_callback = nullptr;
static uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_const_speed_callback_t uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_const_speed_callback = nullptr;
static uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_const_flow_callback_t uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_const_flow_callback = nullptr;
static uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_const_flow_callback_t uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_const_flow_callback = nullptr;
static uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_const_temp_callback_t uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_const_temp_callback = nullptr;
static uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_const_temp_callback_t uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_const_temp_callback = nullptr;
static uic_mqtt_dotdot_pump_configuration_and_control_attribute_pump_status_callback_t uic_mqtt_dotdot_pump_configuration_and_control_attribute_pump_status_callback = nullptr;
static uic_mqtt_dotdot_pump_configuration_and_control_attribute_effective_operation_mode_callback_t uic_mqtt_dotdot_pump_configuration_and_control_attribute_effective_operation_mode_callback = nullptr;
static uic_mqtt_dotdot_pump_configuration_and_control_attribute_effective_control_mode_callback_t uic_mqtt_dotdot_pump_configuration_and_control_attribute_effective_control_mode_callback = nullptr;
static uic_mqtt_dotdot_pump_configuration_and_control_attribute_capacity_callback_t uic_mqtt_dotdot_pump_configuration_and_control_attribute_capacity_callback = nullptr;
static uic_mqtt_dotdot_pump_configuration_and_control_attribute_speed_callback_t uic_mqtt_dotdot_pump_configuration_and_control_attribute_speed_callback = nullptr;
static uic_mqtt_dotdot_pump_configuration_and_control_attribute_lifetime_running_hours_callback_t uic_mqtt_dotdot_pump_configuration_and_control_attribute_lifetime_running_hours_callback = nullptr;
static uic_mqtt_dotdot_pump_configuration_and_control_attribute_power_callback_t uic_mqtt_dotdot_pump_configuration_and_control_attribute_power_callback = nullptr;
static uic_mqtt_dotdot_pump_configuration_and_control_attribute_lifetime_energy_consumed_callback_t uic_mqtt_dotdot_pump_configuration_and_control_attribute_lifetime_energy_consumed_callback = nullptr;
static uic_mqtt_dotdot_pump_configuration_and_control_attribute_operation_mode_callback_t uic_mqtt_dotdot_pump_configuration_and_control_attribute_operation_mode_callback = nullptr;
static uic_mqtt_dotdot_pump_configuration_and_control_attribute_control_mode_callback_t uic_mqtt_dotdot_pump_configuration_and_control_attribute_control_mode_callback = nullptr;
static uic_mqtt_dotdot_pump_configuration_and_control_attribute_alarm_mask_callback_t uic_mqtt_dotdot_pump_configuration_and_control_attribute_alarm_mask_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for PumpConfigurationAndControl
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_pump_configuration_and_control_max_pressure_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_pressure_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t max_pressure = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PumpConfigurationAndControl::MaxPressure: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      max_pressure = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_pressure_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    max_pressure
  );

}
static void uic_mqtt_dotdot_on_pump_configuration_and_control_max_speed_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_speed_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t max_speed = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PumpConfigurationAndControl::MaxSpeed: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      max_speed = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_speed_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    max_speed
  );

}
static void uic_mqtt_dotdot_on_pump_configuration_and_control_max_flow_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_flow_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t max_flow = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PumpConfigurationAndControl::MaxFlow: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      max_flow = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_flow_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    max_flow
  );

}
static void uic_mqtt_dotdot_on_pump_configuration_and_control_min_const_pressure_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_const_pressure_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t min_const_pressure = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PumpConfigurationAndControl::MinConstPressure: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      min_const_pressure = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_const_pressure_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    min_const_pressure
  );

}
static void uic_mqtt_dotdot_on_pump_configuration_and_control_max_const_pressure_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_const_pressure_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t max_const_pressure = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PumpConfigurationAndControl::MaxConstPressure: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      max_const_pressure = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_const_pressure_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    max_const_pressure
  );

}
static void uic_mqtt_dotdot_on_pump_configuration_and_control_min_comp_pressure_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_comp_pressure_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t min_comp_pressure = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PumpConfigurationAndControl::MinCompPressure: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      min_comp_pressure = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_comp_pressure_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    min_comp_pressure
  );

}
static void uic_mqtt_dotdot_on_pump_configuration_and_control_max_comp_pressure_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_comp_pressure_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t max_comp_pressure = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PumpConfigurationAndControl::MaxCompPressure: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      max_comp_pressure = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_comp_pressure_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    max_comp_pressure
  );

}
static void uic_mqtt_dotdot_on_pump_configuration_and_control_min_const_speed_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_const_speed_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t min_const_speed = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PumpConfigurationAndControl::MinConstSpeed: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      min_const_speed = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_const_speed_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    min_const_speed
  );

}
static void uic_mqtt_dotdot_on_pump_configuration_and_control_max_const_speed_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_const_speed_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t max_const_speed = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PumpConfigurationAndControl::MaxConstSpeed: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      max_const_speed = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_const_speed_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    max_const_speed
  );

}
static void uic_mqtt_dotdot_on_pump_configuration_and_control_min_const_flow_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_const_flow_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t min_const_flow = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PumpConfigurationAndControl::MinConstFlow: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      min_const_flow = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_const_flow_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    min_const_flow
  );

}
static void uic_mqtt_dotdot_on_pump_configuration_and_control_max_const_flow_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_const_flow_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t max_const_flow = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PumpConfigurationAndControl::MaxConstFlow: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      max_const_flow = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_const_flow_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    max_const_flow
  );

}
static void uic_mqtt_dotdot_on_pump_configuration_and_control_min_const_temp_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_const_temp_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t min_const_temp = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PumpConfigurationAndControl::MinConstTemp: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      min_const_temp = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_const_temp_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    min_const_temp
  );

}
static void uic_mqtt_dotdot_on_pump_configuration_and_control_max_const_temp_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_const_temp_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t max_const_temp = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PumpConfigurationAndControl::MaxConstTemp: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      max_const_temp = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_const_temp_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    max_const_temp
  );

}
static void uic_mqtt_dotdot_on_pump_configuration_and_control_pump_status_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pump_configuration_and_control_attribute_pump_status_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t pump_status = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PumpConfigurationAndControl::PumpStatus: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      pump_status = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, PumpConfigurationAndControlPumpStatus);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pump_configuration_and_control_attribute_pump_status_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    pump_status
  );

}
static void uic_mqtt_dotdot_on_pump_configuration_and_control_effective_operation_mode_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pump_configuration_and_control_attribute_effective_operation_mode_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  PumpOperationMode effective_operation_mode = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PumpConfigurationAndControl::EffectiveOperationMode: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<PumpOperationMode>("value", json_payload);
      if (tmp == numeric_limits<PumpOperationMode>::max()) {
      #ifdef PUMP_CONFIGURATION_AND_CONTROL_EFFECTIVE_OPERATION_MODE_ENUM_NAME_AVAILABLE
        tmp = pump_configuration_and_control_effective_operation_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(EFFECTIVE_OPERATION_MODE_ENUM_NAME_AVAILABLE)
        tmp = effective_operation_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      effective_operation_mode = static_cast<PumpOperationMode>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pump_configuration_and_control_attribute_effective_operation_mode_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    effective_operation_mode
  );

}
static void uic_mqtt_dotdot_on_pump_configuration_and_control_effective_control_mode_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pump_configuration_and_control_attribute_effective_control_mode_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  PumpControlMode effective_control_mode = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PumpConfigurationAndControl::EffectiveControlMode: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<PumpControlMode>("value", json_payload);
      if (tmp == numeric_limits<PumpControlMode>::max()) {
      #ifdef PUMP_CONFIGURATION_AND_CONTROL_EFFECTIVE_CONTROL_MODE_ENUM_NAME_AVAILABLE
        tmp = pump_configuration_and_control_effective_control_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(EFFECTIVE_CONTROL_MODE_ENUM_NAME_AVAILABLE)
        tmp = effective_control_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      effective_control_mode = static_cast<PumpControlMode>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pump_configuration_and_control_attribute_effective_control_mode_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    effective_control_mode
  );

}
static void uic_mqtt_dotdot_on_pump_configuration_and_control_capacity_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pump_configuration_and_control_attribute_capacity_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t capacity = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PumpConfigurationAndControl::Capacity: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      capacity = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pump_configuration_and_control_attribute_capacity_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    capacity
  );

}
static void uic_mqtt_dotdot_on_pump_configuration_and_control_speed_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pump_configuration_and_control_attribute_speed_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t speed = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PumpConfigurationAndControl::Speed: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      speed = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pump_configuration_and_control_attribute_speed_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    speed
  );

}
static void uic_mqtt_dotdot_on_pump_configuration_and_control_lifetime_running_hours_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pump_configuration_and_control_attribute_lifetime_running_hours_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t lifetime_running_hours = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PumpConfigurationAndControl::LifetimeRunningHours: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      lifetime_running_hours = json_payload.at("value").get<uint32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pump_configuration_and_control_attribute_lifetime_running_hours_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    lifetime_running_hours
  );

}
static void uic_mqtt_dotdot_on_pump_configuration_and_control_power_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pump_configuration_and_control_attribute_power_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t power = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PumpConfigurationAndControl::Power: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      power = json_payload.at("value").get<uint32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pump_configuration_and_control_attribute_power_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    power
  );

}
static void uic_mqtt_dotdot_on_pump_configuration_and_control_lifetime_energy_consumed_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pump_configuration_and_control_attribute_lifetime_energy_consumed_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t lifetime_energy_consumed = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PumpConfigurationAndControl::LifetimeEnergyConsumed: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      lifetime_energy_consumed = json_payload.at("value").get<uint32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pump_configuration_and_control_attribute_lifetime_energy_consumed_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    lifetime_energy_consumed
  );

}
static void uic_mqtt_dotdot_on_pump_configuration_and_control_operation_mode_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pump_configuration_and_control_attribute_operation_mode_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  PumpOperationMode operation_mode = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PumpConfigurationAndControl::OperationMode: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<PumpOperationMode>("value", json_payload);
      if (tmp == numeric_limits<PumpOperationMode>::max()) {
      #ifdef PUMP_CONFIGURATION_AND_CONTROL_OPERATION_MODE_ENUM_NAME_AVAILABLE
        tmp = pump_configuration_and_control_operation_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(OPERATION_MODE_ENUM_NAME_AVAILABLE)
        tmp = operation_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      operation_mode = static_cast<PumpOperationMode>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pump_configuration_and_control_attribute_operation_mode_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    operation_mode
  );

}
static void uic_mqtt_dotdot_on_pump_configuration_and_control_control_mode_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pump_configuration_and_control_attribute_control_mode_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  PumpControlMode control_mode = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PumpConfigurationAndControl::ControlMode: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<PumpControlMode>("value", json_payload);
      if (tmp == numeric_limits<PumpControlMode>::max()) {
      #ifdef PUMP_CONFIGURATION_AND_CONTROL_CONTROL_MODE_ENUM_NAME_AVAILABLE
        tmp = pump_configuration_and_control_control_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(CONTROL_MODE_ENUM_NAME_AVAILABLE)
        tmp = control_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      control_mode = static_cast<PumpControlMode>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pump_configuration_and_control_attribute_control_mode_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    control_mode
  );

}
static void uic_mqtt_dotdot_on_pump_configuration_and_control_alarm_mask_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pump_configuration_and_control_attribute_alarm_mask_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t alarm_mask = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PumpConfigurationAndControl::AlarmMask: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      alarm_mask = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, PumpConfigurationAndControlAlarmMask);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pump_configuration_and_control_attribute_alarm_mask_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    alarm_mask
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for PumpConfigurationAndControl
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_pressure_callback) {
    subscription_topic = base_topic + "PumpConfigurationAndControl/Attributes/MaxPressure/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pump_configuration_and_control_max_pressure_attribute_update);
  }
  if(uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_speed_callback) {
    subscription_topic = base_topic + "PumpConfigurationAndControl/Attributes/MaxSpeed/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pump_configuration_and_control_max_speed_attribute_update);
  }
  if(uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_flow_callback) {
    subscription_topic = base_topic + "PumpConfigurationAndControl/Attributes/MaxFlow/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pump_configuration_and_control_max_flow_attribute_update);
  }
  if(uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_const_pressure_callback) {
    subscription_topic = base_topic + "PumpConfigurationAndControl/Attributes/MinConstPressure/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pump_configuration_and_control_min_const_pressure_attribute_update);
  }
  if(uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_const_pressure_callback) {
    subscription_topic = base_topic + "PumpConfigurationAndControl/Attributes/MaxConstPressure/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pump_configuration_and_control_max_const_pressure_attribute_update);
  }
  if(uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_comp_pressure_callback) {
    subscription_topic = base_topic + "PumpConfigurationAndControl/Attributes/MinCompPressure/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pump_configuration_and_control_min_comp_pressure_attribute_update);
  }
  if(uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_comp_pressure_callback) {
    subscription_topic = base_topic + "PumpConfigurationAndControl/Attributes/MaxCompPressure/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pump_configuration_and_control_max_comp_pressure_attribute_update);
  }
  if(uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_const_speed_callback) {
    subscription_topic = base_topic + "PumpConfigurationAndControl/Attributes/MinConstSpeed/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pump_configuration_and_control_min_const_speed_attribute_update);
  }
  if(uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_const_speed_callback) {
    subscription_topic = base_topic + "PumpConfigurationAndControl/Attributes/MaxConstSpeed/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pump_configuration_and_control_max_const_speed_attribute_update);
  }
  if(uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_const_flow_callback) {
    subscription_topic = base_topic + "PumpConfigurationAndControl/Attributes/MinConstFlow/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pump_configuration_and_control_min_const_flow_attribute_update);
  }
  if(uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_const_flow_callback) {
    subscription_topic = base_topic + "PumpConfigurationAndControl/Attributes/MaxConstFlow/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pump_configuration_and_control_max_const_flow_attribute_update);
  }
  if(uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_const_temp_callback) {
    subscription_topic = base_topic + "PumpConfigurationAndControl/Attributes/MinConstTemp/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pump_configuration_and_control_min_const_temp_attribute_update);
  }
  if(uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_const_temp_callback) {
    subscription_topic = base_topic + "PumpConfigurationAndControl/Attributes/MaxConstTemp/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pump_configuration_and_control_max_const_temp_attribute_update);
  }
  if(uic_mqtt_dotdot_pump_configuration_and_control_attribute_pump_status_callback) {
    subscription_topic = base_topic + "PumpConfigurationAndControl/Attributes/PumpStatus/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pump_configuration_and_control_pump_status_attribute_update);
  }
  if(uic_mqtt_dotdot_pump_configuration_and_control_attribute_effective_operation_mode_callback) {
    subscription_topic = base_topic + "PumpConfigurationAndControl/Attributes/EffectiveOperationMode/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pump_configuration_and_control_effective_operation_mode_attribute_update);
  }
  if(uic_mqtt_dotdot_pump_configuration_and_control_attribute_effective_control_mode_callback) {
    subscription_topic = base_topic + "PumpConfigurationAndControl/Attributes/EffectiveControlMode/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pump_configuration_and_control_effective_control_mode_attribute_update);
  }
  if(uic_mqtt_dotdot_pump_configuration_and_control_attribute_capacity_callback) {
    subscription_topic = base_topic + "PumpConfigurationAndControl/Attributes/Capacity/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pump_configuration_and_control_capacity_attribute_update);
  }
  if(uic_mqtt_dotdot_pump_configuration_and_control_attribute_speed_callback) {
    subscription_topic = base_topic + "PumpConfigurationAndControl/Attributes/Speed/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pump_configuration_and_control_speed_attribute_update);
  }
  if(uic_mqtt_dotdot_pump_configuration_and_control_attribute_lifetime_running_hours_callback) {
    subscription_topic = base_topic + "PumpConfigurationAndControl/Attributes/LifetimeRunningHours/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pump_configuration_and_control_lifetime_running_hours_attribute_update);
  }
  if(uic_mqtt_dotdot_pump_configuration_and_control_attribute_power_callback) {
    subscription_topic = base_topic + "PumpConfigurationAndControl/Attributes/Power/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pump_configuration_and_control_power_attribute_update);
  }
  if(uic_mqtt_dotdot_pump_configuration_and_control_attribute_lifetime_energy_consumed_callback) {
    subscription_topic = base_topic + "PumpConfigurationAndControl/Attributes/LifetimeEnergyConsumed/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pump_configuration_and_control_lifetime_energy_consumed_attribute_update);
  }
  if(uic_mqtt_dotdot_pump_configuration_and_control_attribute_operation_mode_callback) {
    subscription_topic = base_topic + "PumpConfigurationAndControl/Attributes/OperationMode/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pump_configuration_and_control_operation_mode_attribute_update);
  }
  if(uic_mqtt_dotdot_pump_configuration_and_control_attribute_control_mode_callback) {
    subscription_topic = base_topic + "PumpConfigurationAndControl/Attributes/ControlMode/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pump_configuration_and_control_control_mode_attribute_update);
  }
  if(uic_mqtt_dotdot_pump_configuration_and_control_attribute_alarm_mask_callback) {
    subscription_topic = base_topic + "PumpConfigurationAndControl/Attributes/AlarmMask/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pump_configuration_and_control_alarm_mask_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for PumpConfigurationAndControl
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_pressure_callback_set(const uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_pressure_callback_t callback)
{
  uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_pressure_callback = callback;
}
void uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_speed_callback_set(const uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_speed_callback_t callback)
{
  uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_speed_callback = callback;
}
void uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_flow_callback_set(const uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_flow_callback_t callback)
{
  uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_flow_callback = callback;
}
void uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_const_pressure_callback_set(const uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_const_pressure_callback_t callback)
{
  uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_const_pressure_callback = callback;
}
void uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_const_pressure_callback_set(const uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_const_pressure_callback_t callback)
{
  uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_const_pressure_callback = callback;
}
void uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_comp_pressure_callback_set(const uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_comp_pressure_callback_t callback)
{
  uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_comp_pressure_callback = callback;
}
void uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_comp_pressure_callback_set(const uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_comp_pressure_callback_t callback)
{
  uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_comp_pressure_callback = callback;
}
void uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_const_speed_callback_set(const uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_const_speed_callback_t callback)
{
  uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_const_speed_callback = callback;
}
void uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_const_speed_callback_set(const uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_const_speed_callback_t callback)
{
  uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_const_speed_callback = callback;
}
void uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_const_flow_callback_set(const uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_const_flow_callback_t callback)
{
  uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_const_flow_callback = callback;
}
void uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_const_flow_callback_set(const uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_const_flow_callback_t callback)
{
  uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_const_flow_callback = callback;
}
void uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_const_temp_callback_set(const uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_const_temp_callback_t callback)
{
  uic_mqtt_dotdot_pump_configuration_and_control_attribute_min_const_temp_callback = callback;
}
void uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_const_temp_callback_set(const uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_const_temp_callback_t callback)
{
  uic_mqtt_dotdot_pump_configuration_and_control_attribute_max_const_temp_callback = callback;
}
void uic_mqtt_dotdot_pump_configuration_and_control_attribute_pump_status_callback_set(const uic_mqtt_dotdot_pump_configuration_and_control_attribute_pump_status_callback_t callback)
{
  uic_mqtt_dotdot_pump_configuration_and_control_attribute_pump_status_callback = callback;
}
void uic_mqtt_dotdot_pump_configuration_and_control_attribute_effective_operation_mode_callback_set(const uic_mqtt_dotdot_pump_configuration_and_control_attribute_effective_operation_mode_callback_t callback)
{
  uic_mqtt_dotdot_pump_configuration_and_control_attribute_effective_operation_mode_callback = callback;
}
void uic_mqtt_dotdot_pump_configuration_and_control_attribute_effective_control_mode_callback_set(const uic_mqtt_dotdot_pump_configuration_and_control_attribute_effective_control_mode_callback_t callback)
{
  uic_mqtt_dotdot_pump_configuration_and_control_attribute_effective_control_mode_callback = callback;
}
void uic_mqtt_dotdot_pump_configuration_and_control_attribute_capacity_callback_set(const uic_mqtt_dotdot_pump_configuration_and_control_attribute_capacity_callback_t callback)
{
  uic_mqtt_dotdot_pump_configuration_and_control_attribute_capacity_callback = callback;
}
void uic_mqtt_dotdot_pump_configuration_and_control_attribute_speed_callback_set(const uic_mqtt_dotdot_pump_configuration_and_control_attribute_speed_callback_t callback)
{
  uic_mqtt_dotdot_pump_configuration_and_control_attribute_speed_callback = callback;
}
void uic_mqtt_dotdot_pump_configuration_and_control_attribute_lifetime_running_hours_callback_set(const uic_mqtt_dotdot_pump_configuration_and_control_attribute_lifetime_running_hours_callback_t callback)
{
  uic_mqtt_dotdot_pump_configuration_and_control_attribute_lifetime_running_hours_callback = callback;
}
void uic_mqtt_dotdot_pump_configuration_and_control_attribute_power_callback_set(const uic_mqtt_dotdot_pump_configuration_and_control_attribute_power_callback_t callback)
{
  uic_mqtt_dotdot_pump_configuration_and_control_attribute_power_callback = callback;
}
void uic_mqtt_dotdot_pump_configuration_and_control_attribute_lifetime_energy_consumed_callback_set(const uic_mqtt_dotdot_pump_configuration_and_control_attribute_lifetime_energy_consumed_callback_t callback)
{
  uic_mqtt_dotdot_pump_configuration_and_control_attribute_lifetime_energy_consumed_callback = callback;
}
void uic_mqtt_dotdot_pump_configuration_and_control_attribute_operation_mode_callback_set(const uic_mqtt_dotdot_pump_configuration_and_control_attribute_operation_mode_callback_t callback)
{
  uic_mqtt_dotdot_pump_configuration_and_control_attribute_operation_mode_callback = callback;
}
void uic_mqtt_dotdot_pump_configuration_and_control_attribute_control_mode_callback_set(const uic_mqtt_dotdot_pump_configuration_and_control_attribute_control_mode_callback_t callback)
{
  uic_mqtt_dotdot_pump_configuration_and_control_attribute_control_mode_callback = callback;
}
void uic_mqtt_dotdot_pump_configuration_and_control_attribute_alarm_mask_callback_set(const uic_mqtt_dotdot_pump_configuration_and_control_attribute_alarm_mask_callback_t callback)
{
  uic_mqtt_dotdot_pump_configuration_and_control_attribute_alarm_mask_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for Thermostat
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_thermostat_attribute_local_temperature_callback_t uic_mqtt_dotdot_thermostat_attribute_local_temperature_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_outdoor_temperature_callback_t uic_mqtt_dotdot_thermostat_attribute_outdoor_temperature_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_occupancy_callback_t uic_mqtt_dotdot_thermostat_attribute_occupancy_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_abs_min_heat_setpoint_limit_callback_t uic_mqtt_dotdot_thermostat_attribute_abs_min_heat_setpoint_limit_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_abs_max_heat_setpoint_limit_callback_t uic_mqtt_dotdot_thermostat_attribute_abs_max_heat_setpoint_limit_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_abs_min_cool_setpoint_limit_callback_t uic_mqtt_dotdot_thermostat_attribute_abs_min_cool_setpoint_limit_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_abs_max_cool_setpoint_limit_callback_t uic_mqtt_dotdot_thermostat_attribute_abs_max_cool_setpoint_limit_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_pi_cooling_demand_callback_t uic_mqtt_dotdot_thermostat_attribute_pi_cooling_demand_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_pi_heating_demand_callback_t uic_mqtt_dotdot_thermostat_attribute_pi_heating_demand_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_hvac_system_type_configuration_callback_t uic_mqtt_dotdot_thermostat_attribute_hvac_system_type_configuration_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_local_temperature_calibration_callback_t uic_mqtt_dotdot_thermostat_attribute_local_temperature_calibration_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_occupied_cooling_setpoint_callback_t uic_mqtt_dotdot_thermostat_attribute_occupied_cooling_setpoint_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_occupied_heating_setpoint_callback_t uic_mqtt_dotdot_thermostat_attribute_occupied_heating_setpoint_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_unoccupied_cooling_setpoint_callback_t uic_mqtt_dotdot_thermostat_attribute_unoccupied_cooling_setpoint_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_unoccupied_heating_setpoint_callback_t uic_mqtt_dotdot_thermostat_attribute_unoccupied_heating_setpoint_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_min_heat_setpoint_limit_callback_t uic_mqtt_dotdot_thermostat_attribute_min_heat_setpoint_limit_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_max_heat_setpoint_limit_callback_t uic_mqtt_dotdot_thermostat_attribute_max_heat_setpoint_limit_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_min_cool_setpoint_limit_callback_t uic_mqtt_dotdot_thermostat_attribute_min_cool_setpoint_limit_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_max_cool_setpoint_limit_callback_t uic_mqtt_dotdot_thermostat_attribute_max_cool_setpoint_limit_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_min_setpoint_dead_band_callback_t uic_mqtt_dotdot_thermostat_attribute_min_setpoint_dead_band_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_remote_sensing_callback_t uic_mqtt_dotdot_thermostat_attribute_remote_sensing_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_control_sequence_of_operation_callback_t uic_mqtt_dotdot_thermostat_attribute_control_sequence_of_operation_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_system_mode_callback_t uic_mqtt_dotdot_thermostat_attribute_system_mode_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_alarm_mask_callback_t uic_mqtt_dotdot_thermostat_attribute_alarm_mask_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_thermostat_running_mode_callback_t uic_mqtt_dotdot_thermostat_attribute_thermostat_running_mode_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_start_of_week_callback_t uic_mqtt_dotdot_thermostat_attribute_start_of_week_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_number_of_weekly_transitions_callback_t uic_mqtt_dotdot_thermostat_attribute_number_of_weekly_transitions_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_number_of_daily_transitions_callback_t uic_mqtt_dotdot_thermostat_attribute_number_of_daily_transitions_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_temperature_setpoint_hold_callback_t uic_mqtt_dotdot_thermostat_attribute_temperature_setpoint_hold_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_temperature_setpoint_hold_duration_callback_t uic_mqtt_dotdot_thermostat_attribute_temperature_setpoint_hold_duration_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_thermostat_programming_operation_mode_callback_t uic_mqtt_dotdot_thermostat_attribute_thermostat_programming_operation_mode_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_thermostat_running_state_callback_t uic_mqtt_dotdot_thermostat_attribute_thermostat_running_state_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_setpoint_change_source_callback_t uic_mqtt_dotdot_thermostat_attribute_setpoint_change_source_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_setpoint_change_amount_callback_t uic_mqtt_dotdot_thermostat_attribute_setpoint_change_amount_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_setpoint_change_source_timestamp_callback_t uic_mqtt_dotdot_thermostat_attribute_setpoint_change_source_timestamp_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_occupied_setback_callback_t uic_mqtt_dotdot_thermostat_attribute_occupied_setback_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_occupied_setback_min_callback_t uic_mqtt_dotdot_thermostat_attribute_occupied_setback_min_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_occupied_setback_max_callback_t uic_mqtt_dotdot_thermostat_attribute_occupied_setback_max_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_unoccupied_setback_callback_t uic_mqtt_dotdot_thermostat_attribute_unoccupied_setback_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_unoccupied_setback_min_callback_t uic_mqtt_dotdot_thermostat_attribute_unoccupied_setback_min_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_unoccupied_setback_max_callback_t uic_mqtt_dotdot_thermostat_attribute_unoccupied_setback_max_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_emergency_heat_delta_callback_t uic_mqtt_dotdot_thermostat_attribute_emergency_heat_delta_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_ac_type_callback_t uic_mqtt_dotdot_thermostat_attribute_ac_type_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_ac_capacity_callback_t uic_mqtt_dotdot_thermostat_attribute_ac_capacity_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_ac_refrigerant_type_callback_t uic_mqtt_dotdot_thermostat_attribute_ac_refrigerant_type_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_ac_compressor_type_callback_t uic_mqtt_dotdot_thermostat_attribute_ac_compressor_type_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_ac_error_code_callback_t uic_mqtt_dotdot_thermostat_attribute_ac_error_code_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_ac_louver_position_callback_t uic_mqtt_dotdot_thermostat_attribute_ac_louver_position_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_ac_coil_temperature_callback_t uic_mqtt_dotdot_thermostat_attribute_ac_coil_temperature_callback = nullptr;
static uic_mqtt_dotdot_thermostat_attribute_ac_capacity_format_callback_t uic_mqtt_dotdot_thermostat_attribute_ac_capacity_format_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for Thermostat
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_thermostat_local_temperature_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_local_temperature_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t local_temperature = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::LocalTemperature: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      local_temperature = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_local_temperature_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    local_temperature
  );

}
static void uic_mqtt_dotdot_on_thermostat_outdoor_temperature_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_outdoor_temperature_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t outdoor_temperature = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::OutdoorTemperature: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      outdoor_temperature = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_outdoor_temperature_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    outdoor_temperature
  );

}
static void uic_mqtt_dotdot_on_thermostat_occupancy_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_occupancy_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t occupancy = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::Occupancy: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      occupancy = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, ThermostatOccupancy);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_occupancy_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    occupancy
  );

}
static void uic_mqtt_dotdot_on_thermostat_abs_min_heat_setpoint_limit_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_abs_min_heat_setpoint_limit_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t abs_min_heat_setpoint_limit = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::AbsMinHeatSetpointLimit: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      abs_min_heat_setpoint_limit = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_abs_min_heat_setpoint_limit_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    abs_min_heat_setpoint_limit
  );

}
static void uic_mqtt_dotdot_on_thermostat_abs_max_heat_setpoint_limit_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_abs_max_heat_setpoint_limit_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t abs_max_heat_setpoint_limit = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::AbsMaxHeatSetpointLimit: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      abs_max_heat_setpoint_limit = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_abs_max_heat_setpoint_limit_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    abs_max_heat_setpoint_limit
  );

}
static void uic_mqtt_dotdot_on_thermostat_abs_min_cool_setpoint_limit_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_abs_min_cool_setpoint_limit_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t abs_min_cool_setpoint_limit = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::AbsMinCoolSetpointLimit: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      abs_min_cool_setpoint_limit = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_abs_min_cool_setpoint_limit_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    abs_min_cool_setpoint_limit
  );

}
static void uic_mqtt_dotdot_on_thermostat_abs_max_cool_setpoint_limit_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_abs_max_cool_setpoint_limit_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t abs_max_cool_setpoint_limit = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::AbsMaxCoolSetpointLimit: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      abs_max_cool_setpoint_limit = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_abs_max_cool_setpoint_limit_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    abs_max_cool_setpoint_limit
  );

}
static void uic_mqtt_dotdot_on_thermostat_pi_cooling_demand_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_pi_cooling_demand_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t pi_cooling_demand = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::PICoolingDemand: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      pi_cooling_demand = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_pi_cooling_demand_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    pi_cooling_demand
  );

}
static void uic_mqtt_dotdot_on_thermostat_pi_heating_demand_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_pi_heating_demand_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t pi_heating_demand = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::PIHeatingDemand: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      pi_heating_demand = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_pi_heating_demand_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    pi_heating_demand
  );

}
static void uic_mqtt_dotdot_on_thermostat_hvac_system_type_configuration_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_hvac_system_type_configuration_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t hvac_system_type_configuration = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::HVACSystemTypeConfiguration: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      hvac_system_type_configuration = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, ThermostatHVACSystemTypeConfiguration);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_hvac_system_type_configuration_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    hvac_system_type_configuration
  );

}
static void uic_mqtt_dotdot_on_thermostat_local_temperature_calibration_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_local_temperature_calibration_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int8_t local_temperature_calibration = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::LocalTemperatureCalibration: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      local_temperature_calibration = json_payload.at("value").get<int8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_local_temperature_calibration_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    local_temperature_calibration
  );

}
static void uic_mqtt_dotdot_on_thermostat_occupied_cooling_setpoint_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_occupied_cooling_setpoint_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t occupied_cooling_setpoint = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::OccupiedCoolingSetpoint: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      occupied_cooling_setpoint = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_occupied_cooling_setpoint_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    occupied_cooling_setpoint
  );

}
static void uic_mqtt_dotdot_on_thermostat_occupied_heating_setpoint_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_occupied_heating_setpoint_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t occupied_heating_setpoint = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::OccupiedHeatingSetpoint: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      occupied_heating_setpoint = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_occupied_heating_setpoint_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    occupied_heating_setpoint
  );

}
static void uic_mqtt_dotdot_on_thermostat_unoccupied_cooling_setpoint_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_unoccupied_cooling_setpoint_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t unoccupied_cooling_setpoint = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::UnoccupiedCoolingSetpoint: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      unoccupied_cooling_setpoint = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_unoccupied_cooling_setpoint_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    unoccupied_cooling_setpoint
  );

}
static void uic_mqtt_dotdot_on_thermostat_unoccupied_heating_setpoint_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_unoccupied_heating_setpoint_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t unoccupied_heating_setpoint = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::UnoccupiedHeatingSetpoint: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      unoccupied_heating_setpoint = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_unoccupied_heating_setpoint_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    unoccupied_heating_setpoint
  );

}
static void uic_mqtt_dotdot_on_thermostat_min_heat_setpoint_limit_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_min_heat_setpoint_limit_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t min_heat_setpoint_limit = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::MinHeatSetpointLimit: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      min_heat_setpoint_limit = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_min_heat_setpoint_limit_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    min_heat_setpoint_limit
  );

}
static void uic_mqtt_dotdot_on_thermostat_max_heat_setpoint_limit_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_max_heat_setpoint_limit_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t max_heat_setpoint_limit = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::MaxHeatSetpointLimit: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      max_heat_setpoint_limit = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_max_heat_setpoint_limit_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    max_heat_setpoint_limit
  );

}
static void uic_mqtt_dotdot_on_thermostat_min_cool_setpoint_limit_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_min_cool_setpoint_limit_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t min_cool_setpoint_limit = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::MinCoolSetpointLimit: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      min_cool_setpoint_limit = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_min_cool_setpoint_limit_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    min_cool_setpoint_limit
  );

}
static void uic_mqtt_dotdot_on_thermostat_max_cool_setpoint_limit_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_max_cool_setpoint_limit_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t max_cool_setpoint_limit = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::MaxCoolSetpointLimit: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      max_cool_setpoint_limit = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_max_cool_setpoint_limit_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    max_cool_setpoint_limit
  );

}
static void uic_mqtt_dotdot_on_thermostat_min_setpoint_dead_band_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_min_setpoint_dead_band_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int8_t min_setpoint_dead_band = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::MinSetpointDeadBand: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      min_setpoint_dead_band = json_payload.at("value").get<int8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_min_setpoint_dead_band_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    min_setpoint_dead_band
  );

}
static void uic_mqtt_dotdot_on_thermostat_remote_sensing_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_remote_sensing_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t remote_sensing = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::RemoteSensing: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      remote_sensing = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, ThermostatRemoteSensing);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_remote_sensing_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    remote_sensing
  );

}
static void uic_mqtt_dotdot_on_thermostat_control_sequence_of_operation_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_control_sequence_of_operation_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t control_sequence_of_operation = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::ControlSequenceOfOperation: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<ThermostatControlSequenceOfOperation>("value", json_payload);
      if (tmp == numeric_limits<ThermostatControlSequenceOfOperation>::max()) {
      #ifdef THERMOSTAT_CONTROL_SEQUENCE_OF_OPERATION_ENUM_NAME_AVAILABLE
        tmp = thermostat_control_sequence_of_operation_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(CONTROL_SEQUENCE_OF_OPERATION_ENUM_NAME_AVAILABLE)
        tmp = control_sequence_of_operation_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      control_sequence_of_operation = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_control_sequence_of_operation_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    control_sequence_of_operation
  );

}
static void uic_mqtt_dotdot_on_thermostat_system_mode_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_system_mode_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t system_mode = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::SystemMode: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<ThermostatSystemMode>("value", json_payload);
      if (tmp == numeric_limits<ThermostatSystemMode>::max()) {
      #ifdef THERMOSTAT_SYSTEM_MODE_ENUM_NAME_AVAILABLE
        tmp = thermostat_system_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(SYSTEM_MODE_ENUM_NAME_AVAILABLE)
        tmp = system_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      system_mode = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_system_mode_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    system_mode
  );

}
static void uic_mqtt_dotdot_on_thermostat_alarm_mask_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_alarm_mask_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t alarm_mask = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::AlarmMask: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      alarm_mask = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, ThermostatAlarmMask);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_alarm_mask_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    alarm_mask
  );

}
static void uic_mqtt_dotdot_on_thermostat_thermostat_running_mode_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_thermostat_running_mode_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t thermostat_running_mode = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::ThermostatRunningMode: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<ThermostatThermostatRunningMode>("value", json_payload);
      if (tmp == numeric_limits<ThermostatThermostatRunningMode>::max()) {
      #ifdef THERMOSTAT_THERMOSTAT_RUNNING_MODE_ENUM_NAME_AVAILABLE
        tmp = thermostat_thermostat_running_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(THERMOSTAT_RUNNING_MODE_ENUM_NAME_AVAILABLE)
        tmp = thermostat_running_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      thermostat_running_mode = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_thermostat_running_mode_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    thermostat_running_mode
  );

}
static void uic_mqtt_dotdot_on_thermostat_start_of_week_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_start_of_week_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t start_of_week = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::StartOfWeek: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<ThermostatStartOfWeek>("value", json_payload);
      if (tmp == numeric_limits<ThermostatStartOfWeek>::max()) {
      #ifdef THERMOSTAT_START_OF_WEEK_ENUM_NAME_AVAILABLE
        tmp = thermostat_start_of_week_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(START_OF_WEEK_ENUM_NAME_AVAILABLE)
        tmp = start_of_week_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      start_of_week = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_start_of_week_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    start_of_week
  );

}
static void uic_mqtt_dotdot_on_thermostat_number_of_weekly_transitions_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_number_of_weekly_transitions_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t number_of_weekly_transitions = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::NumberOfWeeklyTransitions: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      number_of_weekly_transitions = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_number_of_weekly_transitions_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    number_of_weekly_transitions
  );

}
static void uic_mqtt_dotdot_on_thermostat_number_of_daily_transitions_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_number_of_daily_transitions_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t number_of_daily_transitions = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::NumberOfDailyTransitions: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      number_of_daily_transitions = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_number_of_daily_transitions_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    number_of_daily_transitions
  );

}
static void uic_mqtt_dotdot_on_thermostat_temperature_setpoint_hold_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_temperature_setpoint_hold_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t temperature_setpoint_hold = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::TemperatureSetpointHold: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<ThermostatTemperatureSetpointHold>("value", json_payload);
      if (tmp == numeric_limits<ThermostatTemperatureSetpointHold>::max()) {
      #ifdef THERMOSTAT_TEMPERATURE_SETPOINT_HOLD_ENUM_NAME_AVAILABLE
        tmp = thermostat_temperature_setpoint_hold_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(TEMPERATURE_SETPOINT_HOLD_ENUM_NAME_AVAILABLE)
        tmp = temperature_setpoint_hold_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      temperature_setpoint_hold = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_temperature_setpoint_hold_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    temperature_setpoint_hold
  );

}
static void uic_mqtt_dotdot_on_thermostat_temperature_setpoint_hold_duration_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_temperature_setpoint_hold_duration_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t temperature_setpoint_hold_duration = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::TemperatureSetpointHoldDuration: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      temperature_setpoint_hold_duration = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_temperature_setpoint_hold_duration_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    temperature_setpoint_hold_duration
  );

}
static void uic_mqtt_dotdot_on_thermostat_thermostat_programming_operation_mode_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_thermostat_programming_operation_mode_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t thermostat_programming_operation_mode = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::ThermostatProgrammingOperationMode: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      thermostat_programming_operation_mode = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, ThermostatThermostatProgrammingOperationMode);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_thermostat_programming_operation_mode_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    thermostat_programming_operation_mode
  );

}
static void uic_mqtt_dotdot_on_thermostat_thermostat_running_state_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_thermostat_running_state_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t thermostat_running_state = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::ThermostatRunningState: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      thermostat_running_state = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, ThermostatThermostatRunningState);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_thermostat_running_state_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    thermostat_running_state
  );

}
static void uic_mqtt_dotdot_on_thermostat_setpoint_change_source_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_setpoint_change_source_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t setpoint_change_source = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::SetpointChangeSource: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<ThermostatSetpointChangeSource>("value", json_payload);
      if (tmp == numeric_limits<ThermostatSetpointChangeSource>::max()) {
      #ifdef THERMOSTAT_SETPOINT_CHANGE_SOURCE_ENUM_NAME_AVAILABLE
        tmp = thermostat_setpoint_change_source_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(SETPOINT_CHANGE_SOURCE_ENUM_NAME_AVAILABLE)
        tmp = setpoint_change_source_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      setpoint_change_source = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_setpoint_change_source_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    setpoint_change_source
  );

}
static void uic_mqtt_dotdot_on_thermostat_setpoint_change_amount_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_setpoint_change_amount_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t setpoint_change_amount = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::SetpointChangeAmount: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      setpoint_change_amount = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_setpoint_change_amount_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    setpoint_change_amount
  );

}
static void uic_mqtt_dotdot_on_thermostat_setpoint_change_source_timestamp_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_setpoint_change_source_timestamp_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  UTC setpoint_change_source_timestamp = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::SetpointChangeSourceTimestamp: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      setpoint_change_source_timestamp = json_payload.at("value").get<UTC>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_setpoint_change_source_timestamp_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    setpoint_change_source_timestamp
  );

}
static void uic_mqtt_dotdot_on_thermostat_occupied_setback_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_occupied_setback_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t occupied_setback = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::OccupiedSetback: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      occupied_setback = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_occupied_setback_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    occupied_setback
  );

}
static void uic_mqtt_dotdot_on_thermostat_occupied_setback_min_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_occupied_setback_min_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t occupied_setback_min = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::OccupiedSetbackMin: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      occupied_setback_min = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_occupied_setback_min_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    occupied_setback_min
  );

}
static void uic_mqtt_dotdot_on_thermostat_occupied_setback_max_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_occupied_setback_max_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t occupied_setback_max = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::OccupiedSetbackMax: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      occupied_setback_max = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_occupied_setback_max_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    occupied_setback_max
  );

}
static void uic_mqtt_dotdot_on_thermostat_unoccupied_setback_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_unoccupied_setback_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t unoccupied_setback = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::UnoccupiedSetback: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      unoccupied_setback = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_unoccupied_setback_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    unoccupied_setback
  );

}
static void uic_mqtt_dotdot_on_thermostat_unoccupied_setback_min_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_unoccupied_setback_min_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t unoccupied_setback_min = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::UnoccupiedSetbackMin: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      unoccupied_setback_min = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_unoccupied_setback_min_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    unoccupied_setback_min
  );

}
static void uic_mqtt_dotdot_on_thermostat_unoccupied_setback_max_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_unoccupied_setback_max_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t unoccupied_setback_max = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::UnoccupiedSetbackMax: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      unoccupied_setback_max = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_unoccupied_setback_max_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    unoccupied_setback_max
  );

}
static void uic_mqtt_dotdot_on_thermostat_emergency_heat_delta_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_emergency_heat_delta_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t emergency_heat_delta = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::EmergencyHeatDelta: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      emergency_heat_delta = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_emergency_heat_delta_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    emergency_heat_delta
  );

}
static void uic_mqtt_dotdot_on_thermostat_ac_type_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_ac_type_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t ac_type = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::ACType: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<ThermostatACType>("value", json_payload);
      if (tmp == numeric_limits<ThermostatACType>::max()) {
      #ifdef THERMOSTAT_AC_TYPE_ENUM_NAME_AVAILABLE
        tmp = thermostat_ac_type_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(AC_TYPE_ENUM_NAME_AVAILABLE)
        tmp = ac_type_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      ac_type = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_ac_type_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    ac_type
  );

}
static void uic_mqtt_dotdot_on_thermostat_ac_capacity_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_ac_capacity_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t ac_capacity = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::ACCapacity: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      ac_capacity = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_ac_capacity_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    ac_capacity
  );

}
static void uic_mqtt_dotdot_on_thermostat_ac_refrigerant_type_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_ac_refrigerant_type_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t ac_refrigerant_type = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::ACRefrigerantType: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<ThermostatACRefrigerantType>("value", json_payload);
      if (tmp == numeric_limits<ThermostatACRefrigerantType>::max()) {
      #ifdef THERMOSTAT_AC_REFRIGERANT_TYPE_ENUM_NAME_AVAILABLE
        tmp = thermostat_ac_refrigerant_type_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(AC_REFRIGERANT_TYPE_ENUM_NAME_AVAILABLE)
        tmp = ac_refrigerant_type_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      ac_refrigerant_type = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_ac_refrigerant_type_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    ac_refrigerant_type
  );

}
static void uic_mqtt_dotdot_on_thermostat_ac_compressor_type_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_ac_compressor_type_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t ac_compressor_type = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::ACCompressorType: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<ThermostatACCompressorType>("value", json_payload);
      if (tmp == numeric_limits<ThermostatACCompressorType>::max()) {
      #ifdef THERMOSTAT_AC_COMPRESSOR_TYPE_ENUM_NAME_AVAILABLE
        tmp = thermostat_ac_compressor_type_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(AC_COMPRESSOR_TYPE_ENUM_NAME_AVAILABLE)
        tmp = ac_compressor_type_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      ac_compressor_type = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_ac_compressor_type_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    ac_compressor_type
  );

}
static void uic_mqtt_dotdot_on_thermostat_ac_error_code_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_ac_error_code_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t ac_error_code = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::ACErrorCode: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      ac_error_code = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, ThermostatACErrorCode);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_ac_error_code_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    ac_error_code
  );

}
static void uic_mqtt_dotdot_on_thermostat_ac_louver_position_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_ac_louver_position_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t ac_louver_position = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::ACLouverPosition: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<ThermostatACLouverPosition>("value", json_payload);
      if (tmp == numeric_limits<ThermostatACLouverPosition>::max()) {
      #ifdef THERMOSTAT_AC_LOUVER_POSITION_ENUM_NAME_AVAILABLE
        tmp = thermostat_ac_louver_position_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(AC_LOUVER_POSITION_ENUM_NAME_AVAILABLE)
        tmp = ac_louver_position_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      ac_louver_position = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_ac_louver_position_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    ac_louver_position
  );

}
static void uic_mqtt_dotdot_on_thermostat_ac_coil_temperature_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_ac_coil_temperature_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t ac_coil_temperature = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::ACCoilTemperature: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      ac_coil_temperature = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_ac_coil_temperature_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    ac_coil_temperature
  );

}
static void uic_mqtt_dotdot_on_thermostat_ac_capacity_format_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_attribute_ac_capacity_format_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t ac_capacity_format = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Thermostat::ACCapacityFormat: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<ThermostatACCapacityFormat>("value", json_payload);
      if (tmp == numeric_limits<ThermostatACCapacityFormat>::max()) {
      #ifdef THERMOSTAT_AC_CAPACITY_FORMAT_ENUM_NAME_AVAILABLE
        tmp = thermostat_ac_capacity_format_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(AC_CAPACITY_FORMAT_ENUM_NAME_AVAILABLE)
        tmp = ac_capacity_format_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      ac_capacity_format = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_attribute_ac_capacity_format_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    ac_capacity_format
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for Thermostat
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_thermostat_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_thermostat_attribute_local_temperature_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/LocalTemperature/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_local_temperature_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_outdoor_temperature_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/OutdoorTemperature/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_outdoor_temperature_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_occupancy_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/Occupancy/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_occupancy_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_abs_min_heat_setpoint_limit_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/AbsMinHeatSetpointLimit/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_abs_min_heat_setpoint_limit_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_abs_max_heat_setpoint_limit_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/AbsMaxHeatSetpointLimit/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_abs_max_heat_setpoint_limit_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_abs_min_cool_setpoint_limit_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/AbsMinCoolSetpointLimit/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_abs_min_cool_setpoint_limit_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_abs_max_cool_setpoint_limit_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/AbsMaxCoolSetpointLimit/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_abs_max_cool_setpoint_limit_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_pi_cooling_demand_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/PICoolingDemand/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_pi_cooling_demand_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_pi_heating_demand_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/PIHeatingDemand/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_pi_heating_demand_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_hvac_system_type_configuration_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/HVACSystemTypeConfiguration/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_hvac_system_type_configuration_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_local_temperature_calibration_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/LocalTemperatureCalibration/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_local_temperature_calibration_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_occupied_cooling_setpoint_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/OccupiedCoolingSetpoint/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_occupied_cooling_setpoint_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_occupied_heating_setpoint_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/OccupiedHeatingSetpoint/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_occupied_heating_setpoint_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_unoccupied_cooling_setpoint_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/UnoccupiedCoolingSetpoint/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_unoccupied_cooling_setpoint_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_unoccupied_heating_setpoint_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/UnoccupiedHeatingSetpoint/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_unoccupied_heating_setpoint_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_min_heat_setpoint_limit_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/MinHeatSetpointLimit/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_min_heat_setpoint_limit_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_max_heat_setpoint_limit_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/MaxHeatSetpointLimit/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_max_heat_setpoint_limit_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_min_cool_setpoint_limit_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/MinCoolSetpointLimit/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_min_cool_setpoint_limit_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_max_cool_setpoint_limit_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/MaxCoolSetpointLimit/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_max_cool_setpoint_limit_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_min_setpoint_dead_band_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/MinSetpointDeadBand/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_min_setpoint_dead_band_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_remote_sensing_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/RemoteSensing/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_remote_sensing_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_control_sequence_of_operation_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/ControlSequenceOfOperation/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_control_sequence_of_operation_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_system_mode_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/SystemMode/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_system_mode_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_alarm_mask_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/AlarmMask/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_alarm_mask_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_thermostat_running_mode_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/ThermostatRunningMode/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_thermostat_running_mode_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_start_of_week_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/StartOfWeek/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_start_of_week_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_number_of_weekly_transitions_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/NumberOfWeeklyTransitions/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_number_of_weekly_transitions_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_number_of_daily_transitions_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/NumberOfDailyTransitions/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_number_of_daily_transitions_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_temperature_setpoint_hold_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/TemperatureSetpointHold/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_temperature_setpoint_hold_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_temperature_setpoint_hold_duration_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/TemperatureSetpointHoldDuration/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_temperature_setpoint_hold_duration_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_thermostat_programming_operation_mode_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/ThermostatProgrammingOperationMode/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_thermostat_programming_operation_mode_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_thermostat_running_state_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/ThermostatRunningState/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_thermostat_running_state_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_setpoint_change_source_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/SetpointChangeSource/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_setpoint_change_source_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_setpoint_change_amount_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/SetpointChangeAmount/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_setpoint_change_amount_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_setpoint_change_source_timestamp_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/SetpointChangeSourceTimestamp/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_setpoint_change_source_timestamp_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_occupied_setback_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/OccupiedSetback/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_occupied_setback_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_occupied_setback_min_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/OccupiedSetbackMin/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_occupied_setback_min_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_occupied_setback_max_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/OccupiedSetbackMax/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_occupied_setback_max_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_unoccupied_setback_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/UnoccupiedSetback/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_unoccupied_setback_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_unoccupied_setback_min_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/UnoccupiedSetbackMin/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_unoccupied_setback_min_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_unoccupied_setback_max_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/UnoccupiedSetbackMax/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_unoccupied_setback_max_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_emergency_heat_delta_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/EmergencyHeatDelta/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_emergency_heat_delta_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_ac_type_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/ACType/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_ac_type_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_ac_capacity_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/ACCapacity/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_ac_capacity_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_ac_refrigerant_type_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/ACRefrigerantType/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_ac_refrigerant_type_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_ac_compressor_type_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/ACCompressorType/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_ac_compressor_type_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_ac_error_code_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/ACErrorCode/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_ac_error_code_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_ac_louver_position_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/ACLouverPosition/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_ac_louver_position_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_ac_coil_temperature_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/ACCoilTemperature/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_ac_coil_temperature_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_attribute_ac_capacity_format_callback) {
    subscription_topic = base_topic + "Thermostat/Attributes/ACCapacityFormat/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_ac_capacity_format_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for Thermostat
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_thermostat_attribute_local_temperature_callback_set(const uic_mqtt_dotdot_thermostat_attribute_local_temperature_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_local_temperature_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_outdoor_temperature_callback_set(const uic_mqtt_dotdot_thermostat_attribute_outdoor_temperature_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_outdoor_temperature_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_occupancy_callback_set(const uic_mqtt_dotdot_thermostat_attribute_occupancy_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_occupancy_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_abs_min_heat_setpoint_limit_callback_set(const uic_mqtt_dotdot_thermostat_attribute_abs_min_heat_setpoint_limit_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_abs_min_heat_setpoint_limit_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_abs_max_heat_setpoint_limit_callback_set(const uic_mqtt_dotdot_thermostat_attribute_abs_max_heat_setpoint_limit_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_abs_max_heat_setpoint_limit_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_abs_min_cool_setpoint_limit_callback_set(const uic_mqtt_dotdot_thermostat_attribute_abs_min_cool_setpoint_limit_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_abs_min_cool_setpoint_limit_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_abs_max_cool_setpoint_limit_callback_set(const uic_mqtt_dotdot_thermostat_attribute_abs_max_cool_setpoint_limit_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_abs_max_cool_setpoint_limit_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_pi_cooling_demand_callback_set(const uic_mqtt_dotdot_thermostat_attribute_pi_cooling_demand_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_pi_cooling_demand_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_pi_heating_demand_callback_set(const uic_mqtt_dotdot_thermostat_attribute_pi_heating_demand_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_pi_heating_demand_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_hvac_system_type_configuration_callback_set(const uic_mqtt_dotdot_thermostat_attribute_hvac_system_type_configuration_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_hvac_system_type_configuration_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_local_temperature_calibration_callback_set(const uic_mqtt_dotdot_thermostat_attribute_local_temperature_calibration_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_local_temperature_calibration_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_occupied_cooling_setpoint_callback_set(const uic_mqtt_dotdot_thermostat_attribute_occupied_cooling_setpoint_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_occupied_cooling_setpoint_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_occupied_heating_setpoint_callback_set(const uic_mqtt_dotdot_thermostat_attribute_occupied_heating_setpoint_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_occupied_heating_setpoint_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_unoccupied_cooling_setpoint_callback_set(const uic_mqtt_dotdot_thermostat_attribute_unoccupied_cooling_setpoint_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_unoccupied_cooling_setpoint_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_unoccupied_heating_setpoint_callback_set(const uic_mqtt_dotdot_thermostat_attribute_unoccupied_heating_setpoint_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_unoccupied_heating_setpoint_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_min_heat_setpoint_limit_callback_set(const uic_mqtt_dotdot_thermostat_attribute_min_heat_setpoint_limit_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_min_heat_setpoint_limit_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_max_heat_setpoint_limit_callback_set(const uic_mqtt_dotdot_thermostat_attribute_max_heat_setpoint_limit_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_max_heat_setpoint_limit_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_min_cool_setpoint_limit_callback_set(const uic_mqtt_dotdot_thermostat_attribute_min_cool_setpoint_limit_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_min_cool_setpoint_limit_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_max_cool_setpoint_limit_callback_set(const uic_mqtt_dotdot_thermostat_attribute_max_cool_setpoint_limit_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_max_cool_setpoint_limit_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_min_setpoint_dead_band_callback_set(const uic_mqtt_dotdot_thermostat_attribute_min_setpoint_dead_band_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_min_setpoint_dead_band_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_remote_sensing_callback_set(const uic_mqtt_dotdot_thermostat_attribute_remote_sensing_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_remote_sensing_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_control_sequence_of_operation_callback_set(const uic_mqtt_dotdot_thermostat_attribute_control_sequence_of_operation_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_control_sequence_of_operation_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_system_mode_callback_set(const uic_mqtt_dotdot_thermostat_attribute_system_mode_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_system_mode_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_alarm_mask_callback_set(const uic_mqtt_dotdot_thermostat_attribute_alarm_mask_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_alarm_mask_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_thermostat_running_mode_callback_set(const uic_mqtt_dotdot_thermostat_attribute_thermostat_running_mode_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_thermostat_running_mode_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_start_of_week_callback_set(const uic_mqtt_dotdot_thermostat_attribute_start_of_week_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_start_of_week_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_number_of_weekly_transitions_callback_set(const uic_mqtt_dotdot_thermostat_attribute_number_of_weekly_transitions_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_number_of_weekly_transitions_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_number_of_daily_transitions_callback_set(const uic_mqtt_dotdot_thermostat_attribute_number_of_daily_transitions_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_number_of_daily_transitions_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_temperature_setpoint_hold_callback_set(const uic_mqtt_dotdot_thermostat_attribute_temperature_setpoint_hold_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_temperature_setpoint_hold_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_temperature_setpoint_hold_duration_callback_set(const uic_mqtt_dotdot_thermostat_attribute_temperature_setpoint_hold_duration_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_temperature_setpoint_hold_duration_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_thermostat_programming_operation_mode_callback_set(const uic_mqtt_dotdot_thermostat_attribute_thermostat_programming_operation_mode_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_thermostat_programming_operation_mode_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_thermostat_running_state_callback_set(const uic_mqtt_dotdot_thermostat_attribute_thermostat_running_state_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_thermostat_running_state_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_setpoint_change_source_callback_set(const uic_mqtt_dotdot_thermostat_attribute_setpoint_change_source_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_setpoint_change_source_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_setpoint_change_amount_callback_set(const uic_mqtt_dotdot_thermostat_attribute_setpoint_change_amount_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_setpoint_change_amount_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_setpoint_change_source_timestamp_callback_set(const uic_mqtt_dotdot_thermostat_attribute_setpoint_change_source_timestamp_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_setpoint_change_source_timestamp_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_occupied_setback_callback_set(const uic_mqtt_dotdot_thermostat_attribute_occupied_setback_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_occupied_setback_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_occupied_setback_min_callback_set(const uic_mqtt_dotdot_thermostat_attribute_occupied_setback_min_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_occupied_setback_min_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_occupied_setback_max_callback_set(const uic_mqtt_dotdot_thermostat_attribute_occupied_setback_max_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_occupied_setback_max_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_unoccupied_setback_callback_set(const uic_mqtt_dotdot_thermostat_attribute_unoccupied_setback_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_unoccupied_setback_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_unoccupied_setback_min_callback_set(const uic_mqtt_dotdot_thermostat_attribute_unoccupied_setback_min_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_unoccupied_setback_min_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_unoccupied_setback_max_callback_set(const uic_mqtt_dotdot_thermostat_attribute_unoccupied_setback_max_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_unoccupied_setback_max_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_emergency_heat_delta_callback_set(const uic_mqtt_dotdot_thermostat_attribute_emergency_heat_delta_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_emergency_heat_delta_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_ac_type_callback_set(const uic_mqtt_dotdot_thermostat_attribute_ac_type_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_ac_type_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_ac_capacity_callback_set(const uic_mqtt_dotdot_thermostat_attribute_ac_capacity_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_ac_capacity_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_ac_refrigerant_type_callback_set(const uic_mqtt_dotdot_thermostat_attribute_ac_refrigerant_type_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_ac_refrigerant_type_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_ac_compressor_type_callback_set(const uic_mqtt_dotdot_thermostat_attribute_ac_compressor_type_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_ac_compressor_type_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_ac_error_code_callback_set(const uic_mqtt_dotdot_thermostat_attribute_ac_error_code_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_ac_error_code_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_ac_louver_position_callback_set(const uic_mqtt_dotdot_thermostat_attribute_ac_louver_position_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_ac_louver_position_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_ac_coil_temperature_callback_set(const uic_mqtt_dotdot_thermostat_attribute_ac_coil_temperature_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_ac_coil_temperature_callback = callback;
}
void uic_mqtt_dotdot_thermostat_attribute_ac_capacity_format_callback_set(const uic_mqtt_dotdot_thermostat_attribute_ac_capacity_format_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_attribute_ac_capacity_format_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for FanControl
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_fan_control_attribute_fan_mode_callback_t uic_mqtt_dotdot_fan_control_attribute_fan_mode_callback = nullptr;
static uic_mqtt_dotdot_fan_control_attribute_fan_mode_sequence_callback_t uic_mqtt_dotdot_fan_control_attribute_fan_mode_sequence_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for FanControl
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_fan_control_fan_mode_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_fan_control_attribute_fan_mode_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t fan_mode = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "FanControl::FanMode: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<FanControlFanMode>("value", json_payload);
      if (tmp == numeric_limits<FanControlFanMode>::max()) {
      #ifdef FAN_CONTROL_FAN_MODE_ENUM_NAME_AVAILABLE
        tmp = fan_control_fan_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(FAN_MODE_ENUM_NAME_AVAILABLE)
        tmp = fan_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      fan_mode = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_fan_control_attribute_fan_mode_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    fan_mode
  );

}
static void uic_mqtt_dotdot_on_fan_control_fan_mode_sequence_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_fan_control_attribute_fan_mode_sequence_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t fan_mode_sequence = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "FanControl::FanModeSequence: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<FanControlFanModeSequence>("value", json_payload);
      if (tmp == numeric_limits<FanControlFanModeSequence>::max()) {
      #ifdef FAN_CONTROL_FAN_MODE_SEQUENCE_ENUM_NAME_AVAILABLE
        tmp = fan_control_fan_mode_sequence_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(FAN_MODE_SEQUENCE_ENUM_NAME_AVAILABLE)
        tmp = fan_mode_sequence_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      fan_mode_sequence = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_fan_control_attribute_fan_mode_sequence_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    fan_mode_sequence
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for FanControl
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_fan_control_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_fan_control_attribute_fan_mode_callback) {
    subscription_topic = base_topic + "FanControl/Attributes/FanMode/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_fan_control_fan_mode_attribute_update);
  }
  if(uic_mqtt_dotdot_fan_control_attribute_fan_mode_sequence_callback) {
    subscription_topic = base_topic + "FanControl/Attributes/FanModeSequence/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_fan_control_fan_mode_sequence_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for FanControl
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_fan_control_attribute_fan_mode_callback_set(const uic_mqtt_dotdot_fan_control_attribute_fan_mode_callback_t callback)
{
  uic_mqtt_dotdot_fan_control_attribute_fan_mode_callback = callback;
}
void uic_mqtt_dotdot_fan_control_attribute_fan_mode_sequence_callback_set(const uic_mqtt_dotdot_fan_control_attribute_fan_mode_sequence_callback_t callback)
{
  uic_mqtt_dotdot_fan_control_attribute_fan_mode_sequence_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for DehumidificationControl
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_dehumidification_control_attribute_relative_humidity_callback_t uic_mqtt_dotdot_dehumidification_control_attribute_relative_humidity_callback = nullptr;
static uic_mqtt_dotdot_dehumidification_control_attribute_dehumidification_cooling_callback_t uic_mqtt_dotdot_dehumidification_control_attribute_dehumidification_cooling_callback = nullptr;
static uic_mqtt_dotdot_dehumidification_control_attribute_rh_dehumidification_setpoint_callback_t uic_mqtt_dotdot_dehumidification_control_attribute_rh_dehumidification_setpoint_callback = nullptr;
static uic_mqtt_dotdot_dehumidification_control_attribute_relative_humidity_mode_callback_t uic_mqtt_dotdot_dehumidification_control_attribute_relative_humidity_mode_callback = nullptr;
static uic_mqtt_dotdot_dehumidification_control_attribute_dehumidification_lockout_callback_t uic_mqtt_dotdot_dehumidification_control_attribute_dehumidification_lockout_callback = nullptr;
static uic_mqtt_dotdot_dehumidification_control_attribute_dehumidification_hysteresis_callback_t uic_mqtt_dotdot_dehumidification_control_attribute_dehumidification_hysteresis_callback = nullptr;
static uic_mqtt_dotdot_dehumidification_control_attribute_dehumidification_max_cool_callback_t uic_mqtt_dotdot_dehumidification_control_attribute_dehumidification_max_cool_callback = nullptr;
static uic_mqtt_dotdot_dehumidification_control_attribute_relative_humidity_display_callback_t uic_mqtt_dotdot_dehumidification_control_attribute_relative_humidity_display_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for DehumidificationControl
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_dehumidification_control_relative_humidity_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_dehumidification_control_attribute_relative_humidity_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t relative_humidity = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DehumidificationControl::RelativeHumidity: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      relative_humidity = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_dehumidification_control_attribute_relative_humidity_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    relative_humidity
  );

}
static void uic_mqtt_dotdot_on_dehumidification_control_dehumidification_cooling_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_dehumidification_control_attribute_dehumidification_cooling_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t dehumidification_cooling = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DehumidificationControl::DehumidificationCooling: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      dehumidification_cooling = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_dehumidification_control_attribute_dehumidification_cooling_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    dehumidification_cooling
  );

}
static void uic_mqtt_dotdot_on_dehumidification_control_rh_dehumidification_setpoint_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_dehumidification_control_attribute_rh_dehumidification_setpoint_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t rh_dehumidification_setpoint = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DehumidificationControl::RHDehumidificationSetpoint: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rh_dehumidification_setpoint = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_dehumidification_control_attribute_rh_dehumidification_setpoint_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rh_dehumidification_setpoint
  );

}
static void uic_mqtt_dotdot_on_dehumidification_control_relative_humidity_mode_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_dehumidification_control_attribute_relative_humidity_mode_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t relative_humidity_mode = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DehumidificationControl::RelativeHumidityMode: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<DehumidificationControlRelativeHumidityMode>("value", json_payload);
      if (tmp == numeric_limits<DehumidificationControlRelativeHumidityMode>::max()) {
      #ifdef DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_MODE_ENUM_NAME_AVAILABLE
        tmp = dehumidification_control_relative_humidity_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(RELATIVE_HUMIDITY_MODE_ENUM_NAME_AVAILABLE)
        tmp = relative_humidity_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      relative_humidity_mode = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_dehumidification_control_attribute_relative_humidity_mode_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    relative_humidity_mode
  );

}
static void uic_mqtt_dotdot_on_dehumidification_control_dehumidification_lockout_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_dehumidification_control_attribute_dehumidification_lockout_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t dehumidification_lockout = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DehumidificationControl::DehumidificationLockout: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<DehumidificationControlDehumidificationLockout>("value", json_payload);
      if (tmp == numeric_limits<DehumidificationControlDehumidificationLockout>::max()) {
      #ifdef DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_LOCKOUT_ENUM_NAME_AVAILABLE
        tmp = dehumidification_control_dehumidification_lockout_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(DEHUMIDIFICATION_LOCKOUT_ENUM_NAME_AVAILABLE)
        tmp = dehumidification_lockout_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      dehumidification_lockout = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_dehumidification_control_attribute_dehumidification_lockout_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    dehumidification_lockout
  );

}
static void uic_mqtt_dotdot_on_dehumidification_control_dehumidification_hysteresis_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_dehumidification_control_attribute_dehumidification_hysteresis_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t dehumidification_hysteresis = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DehumidificationControl::DehumidificationHysteresis: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      dehumidification_hysteresis = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_dehumidification_control_attribute_dehumidification_hysteresis_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    dehumidification_hysteresis
  );

}
static void uic_mqtt_dotdot_on_dehumidification_control_dehumidification_max_cool_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_dehumidification_control_attribute_dehumidification_max_cool_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t dehumidification_max_cool = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DehumidificationControl::DehumidificationMaxCool: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      dehumidification_max_cool = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_dehumidification_control_attribute_dehumidification_max_cool_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    dehumidification_max_cool
  );

}
static void uic_mqtt_dotdot_on_dehumidification_control_relative_humidity_display_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_dehumidification_control_attribute_relative_humidity_display_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t relative_humidity_display = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "DehumidificationControl::RelativeHumidityDisplay: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<DehumidificationControlRelativeHumidityDisplay>("value", json_payload);
      if (tmp == numeric_limits<DehumidificationControlRelativeHumidityDisplay>::max()) {
      #ifdef DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_DISPLAY_ENUM_NAME_AVAILABLE
        tmp = dehumidification_control_relative_humidity_display_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(RELATIVE_HUMIDITY_DISPLAY_ENUM_NAME_AVAILABLE)
        tmp = relative_humidity_display_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      relative_humidity_display = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_dehumidification_control_attribute_relative_humidity_display_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    relative_humidity_display
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for DehumidificationControl
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_dehumidification_control_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_dehumidification_control_attribute_relative_humidity_callback) {
    subscription_topic = base_topic + "DehumidificationControl/Attributes/RelativeHumidity/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_dehumidification_control_relative_humidity_attribute_update);
  }
  if(uic_mqtt_dotdot_dehumidification_control_attribute_dehumidification_cooling_callback) {
    subscription_topic = base_topic + "DehumidificationControl/Attributes/DehumidificationCooling/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_dehumidification_control_dehumidification_cooling_attribute_update);
  }
  if(uic_mqtt_dotdot_dehumidification_control_attribute_rh_dehumidification_setpoint_callback) {
    subscription_topic = base_topic + "DehumidificationControl/Attributes/RHDehumidificationSetpoint/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_dehumidification_control_rh_dehumidification_setpoint_attribute_update);
  }
  if(uic_mqtt_dotdot_dehumidification_control_attribute_relative_humidity_mode_callback) {
    subscription_topic = base_topic + "DehumidificationControl/Attributes/RelativeHumidityMode/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_dehumidification_control_relative_humidity_mode_attribute_update);
  }
  if(uic_mqtt_dotdot_dehumidification_control_attribute_dehumidification_lockout_callback) {
    subscription_topic = base_topic + "DehumidificationControl/Attributes/DehumidificationLockout/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_dehumidification_control_dehumidification_lockout_attribute_update);
  }
  if(uic_mqtt_dotdot_dehumidification_control_attribute_dehumidification_hysteresis_callback) {
    subscription_topic = base_topic + "DehumidificationControl/Attributes/DehumidificationHysteresis/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_dehumidification_control_dehumidification_hysteresis_attribute_update);
  }
  if(uic_mqtt_dotdot_dehumidification_control_attribute_dehumidification_max_cool_callback) {
    subscription_topic = base_topic + "DehumidificationControl/Attributes/DehumidificationMaxCool/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_dehumidification_control_dehumidification_max_cool_attribute_update);
  }
  if(uic_mqtt_dotdot_dehumidification_control_attribute_relative_humidity_display_callback) {
    subscription_topic = base_topic + "DehumidificationControl/Attributes/RelativeHumidityDisplay/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_dehumidification_control_relative_humidity_display_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for DehumidificationControl
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_dehumidification_control_attribute_relative_humidity_callback_set(const uic_mqtt_dotdot_dehumidification_control_attribute_relative_humidity_callback_t callback)
{
  uic_mqtt_dotdot_dehumidification_control_attribute_relative_humidity_callback = callback;
}
void uic_mqtt_dotdot_dehumidification_control_attribute_dehumidification_cooling_callback_set(const uic_mqtt_dotdot_dehumidification_control_attribute_dehumidification_cooling_callback_t callback)
{
  uic_mqtt_dotdot_dehumidification_control_attribute_dehumidification_cooling_callback = callback;
}
void uic_mqtt_dotdot_dehumidification_control_attribute_rh_dehumidification_setpoint_callback_set(const uic_mqtt_dotdot_dehumidification_control_attribute_rh_dehumidification_setpoint_callback_t callback)
{
  uic_mqtt_dotdot_dehumidification_control_attribute_rh_dehumidification_setpoint_callback = callback;
}
void uic_mqtt_dotdot_dehumidification_control_attribute_relative_humidity_mode_callback_set(const uic_mqtt_dotdot_dehumidification_control_attribute_relative_humidity_mode_callback_t callback)
{
  uic_mqtt_dotdot_dehumidification_control_attribute_relative_humidity_mode_callback = callback;
}
void uic_mqtt_dotdot_dehumidification_control_attribute_dehumidification_lockout_callback_set(const uic_mqtt_dotdot_dehumidification_control_attribute_dehumidification_lockout_callback_t callback)
{
  uic_mqtt_dotdot_dehumidification_control_attribute_dehumidification_lockout_callback = callback;
}
void uic_mqtt_dotdot_dehumidification_control_attribute_dehumidification_hysteresis_callback_set(const uic_mqtt_dotdot_dehumidification_control_attribute_dehumidification_hysteresis_callback_t callback)
{
  uic_mqtt_dotdot_dehumidification_control_attribute_dehumidification_hysteresis_callback = callback;
}
void uic_mqtt_dotdot_dehumidification_control_attribute_dehumidification_max_cool_callback_set(const uic_mqtt_dotdot_dehumidification_control_attribute_dehumidification_max_cool_callback_t callback)
{
  uic_mqtt_dotdot_dehumidification_control_attribute_dehumidification_max_cool_callback = callback;
}
void uic_mqtt_dotdot_dehumidification_control_attribute_relative_humidity_display_callback_set(const uic_mqtt_dotdot_dehumidification_control_attribute_relative_humidity_display_callback_t callback)
{
  uic_mqtt_dotdot_dehumidification_control_attribute_relative_humidity_display_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for ThermostatUserInterfaceConfiguration
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_thermostat_user_interface_configuration_attribute_temperature_display_mode_callback_t uic_mqtt_dotdot_thermostat_user_interface_configuration_attribute_temperature_display_mode_callback = nullptr;
static uic_mqtt_dotdot_thermostat_user_interface_configuration_attribute_keypad_lockout_callback_t uic_mqtt_dotdot_thermostat_user_interface_configuration_attribute_keypad_lockout_callback = nullptr;
static uic_mqtt_dotdot_thermostat_user_interface_configuration_attribute_schedule_programming_visibility_callback_t uic_mqtt_dotdot_thermostat_user_interface_configuration_attribute_schedule_programming_visibility_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for ThermostatUserInterfaceConfiguration
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_thermostat_user_interface_configuration_temperature_display_mode_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_user_interface_configuration_attribute_temperature_display_mode_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t temperature_display_mode = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ThermostatUserInterfaceConfiguration::TemperatureDisplayMode: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<ThermostatUserInterfaceConfigurationTemperatureDisplayMode>("value", json_payload);
      if (tmp == numeric_limits<ThermostatUserInterfaceConfigurationTemperatureDisplayMode>::max()) {
      #ifdef THERMOSTAT_USER_INTERFACE_CONFIGURATION_TEMPERATURE_DISPLAY_MODE_ENUM_NAME_AVAILABLE
        tmp = thermostat_user_interface_configuration_temperature_display_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(TEMPERATURE_DISPLAY_MODE_ENUM_NAME_AVAILABLE)
        tmp = temperature_display_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      temperature_display_mode = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_user_interface_configuration_attribute_temperature_display_mode_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    temperature_display_mode
  );

}
static void uic_mqtt_dotdot_on_thermostat_user_interface_configuration_keypad_lockout_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_user_interface_configuration_attribute_keypad_lockout_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t keypad_lockout = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ThermostatUserInterfaceConfiguration::KeypadLockout: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<ThermostatUserInterfaceConfigurationKeypadLockout>("value", json_payload);
      if (tmp == numeric_limits<ThermostatUserInterfaceConfigurationKeypadLockout>::max()) {
      #ifdef THERMOSTAT_USER_INTERFACE_CONFIGURATION_KEYPAD_LOCKOUT_ENUM_NAME_AVAILABLE
        tmp = thermostat_user_interface_configuration_keypad_lockout_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(KEYPAD_LOCKOUT_ENUM_NAME_AVAILABLE)
        tmp = keypad_lockout_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      keypad_lockout = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_user_interface_configuration_attribute_keypad_lockout_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    keypad_lockout
  );

}
static void uic_mqtt_dotdot_on_thermostat_user_interface_configuration_schedule_programming_visibility_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_thermostat_user_interface_configuration_attribute_schedule_programming_visibility_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t schedule_programming_visibility = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ThermostatUserInterfaceConfiguration::ScheduleProgrammingVisibility: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<ThermostatUserInterfaceConfigurationScheduleProgrammingVisibility>("value", json_payload);
      if (tmp == numeric_limits<ThermostatUserInterfaceConfigurationScheduleProgrammingVisibility>::max()) {
      #ifdef THERMOSTAT_USER_INTERFACE_CONFIGURATION_SCHEDULE_PROGRAMMING_VISIBILITY_ENUM_NAME_AVAILABLE
        tmp = thermostat_user_interface_configuration_schedule_programming_visibility_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(SCHEDULE_PROGRAMMING_VISIBILITY_ENUM_NAME_AVAILABLE)
        tmp = schedule_programming_visibility_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      schedule_programming_visibility = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_thermostat_user_interface_configuration_attribute_schedule_programming_visibility_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    schedule_programming_visibility
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for ThermostatUserInterfaceConfiguration
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_thermostat_user_interface_configuration_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_thermostat_user_interface_configuration_attribute_temperature_display_mode_callback) {
    subscription_topic = base_topic + "ThermostatUserInterfaceConfiguration/Attributes/TemperatureDisplayMode/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_user_interface_configuration_temperature_display_mode_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_user_interface_configuration_attribute_keypad_lockout_callback) {
    subscription_topic = base_topic + "ThermostatUserInterfaceConfiguration/Attributes/KeypadLockout/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_user_interface_configuration_keypad_lockout_attribute_update);
  }
  if(uic_mqtt_dotdot_thermostat_user_interface_configuration_attribute_schedule_programming_visibility_callback) {
    subscription_topic = base_topic + "ThermostatUserInterfaceConfiguration/Attributes/ScheduleProgrammingVisibility/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_thermostat_user_interface_configuration_schedule_programming_visibility_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for ThermostatUserInterfaceConfiguration
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_thermostat_user_interface_configuration_attribute_temperature_display_mode_callback_set(const uic_mqtt_dotdot_thermostat_user_interface_configuration_attribute_temperature_display_mode_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_user_interface_configuration_attribute_temperature_display_mode_callback = callback;
}
void uic_mqtt_dotdot_thermostat_user_interface_configuration_attribute_keypad_lockout_callback_set(const uic_mqtt_dotdot_thermostat_user_interface_configuration_attribute_keypad_lockout_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_user_interface_configuration_attribute_keypad_lockout_callback = callback;
}
void uic_mqtt_dotdot_thermostat_user_interface_configuration_attribute_schedule_programming_visibility_callback_set(const uic_mqtt_dotdot_thermostat_user_interface_configuration_attribute_schedule_programming_visibility_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_user_interface_configuration_attribute_schedule_programming_visibility_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for ColorControl
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_color_control_attribute_current_hue_callback_t uic_mqtt_dotdot_color_control_attribute_current_hue_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_current_saturation_callback_t uic_mqtt_dotdot_color_control_attribute_current_saturation_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_remaining_time_callback_t uic_mqtt_dotdot_color_control_attribute_remaining_time_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_currentx_callback_t uic_mqtt_dotdot_color_control_attribute_currentx_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_currenty_callback_t uic_mqtt_dotdot_color_control_attribute_currenty_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_drift_compensation_callback_t uic_mqtt_dotdot_color_control_attribute_drift_compensation_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_compensation_text_callback_t uic_mqtt_dotdot_color_control_attribute_compensation_text_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_color_temperature_mireds_callback_t uic_mqtt_dotdot_color_control_attribute_color_temperature_mireds_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_color_mode_callback_t uic_mqtt_dotdot_color_control_attribute_color_mode_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_options_callback_t uic_mqtt_dotdot_color_control_attribute_options_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_number_of_primaries_callback_t uic_mqtt_dotdot_color_control_attribute_number_of_primaries_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_primary1x_callback_t uic_mqtt_dotdot_color_control_attribute_primary1x_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_primary1y_callback_t uic_mqtt_dotdot_color_control_attribute_primary1y_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_primary1_intensity_callback_t uic_mqtt_dotdot_color_control_attribute_primary1_intensity_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_primary2x_callback_t uic_mqtt_dotdot_color_control_attribute_primary2x_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_primary2y_callback_t uic_mqtt_dotdot_color_control_attribute_primary2y_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_primary2_intensity_callback_t uic_mqtt_dotdot_color_control_attribute_primary2_intensity_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_primary3x_callback_t uic_mqtt_dotdot_color_control_attribute_primary3x_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_primary3y_callback_t uic_mqtt_dotdot_color_control_attribute_primary3y_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_primary3_intensity_callback_t uic_mqtt_dotdot_color_control_attribute_primary3_intensity_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_primary4x_callback_t uic_mqtt_dotdot_color_control_attribute_primary4x_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_primary4y_callback_t uic_mqtt_dotdot_color_control_attribute_primary4y_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_primary4_intensity_callback_t uic_mqtt_dotdot_color_control_attribute_primary4_intensity_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_primary5x_callback_t uic_mqtt_dotdot_color_control_attribute_primary5x_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_primary5y_callback_t uic_mqtt_dotdot_color_control_attribute_primary5y_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_primary5_intensity_callback_t uic_mqtt_dotdot_color_control_attribute_primary5_intensity_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_primary6x_callback_t uic_mqtt_dotdot_color_control_attribute_primary6x_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_primary6y_callback_t uic_mqtt_dotdot_color_control_attribute_primary6y_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_primary6_intensity_callback_t uic_mqtt_dotdot_color_control_attribute_primary6_intensity_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_white_pointx_callback_t uic_mqtt_dotdot_color_control_attribute_white_pointx_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_white_pointy_callback_t uic_mqtt_dotdot_color_control_attribute_white_pointy_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_color_pointrx_callback_t uic_mqtt_dotdot_color_control_attribute_color_pointrx_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_color_pointry_callback_t uic_mqtt_dotdot_color_control_attribute_color_pointry_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_color_pointr_intensity_callback_t uic_mqtt_dotdot_color_control_attribute_color_pointr_intensity_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_color_pointgx_callback_t uic_mqtt_dotdot_color_control_attribute_color_pointgx_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_color_pointgy_callback_t uic_mqtt_dotdot_color_control_attribute_color_pointgy_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_color_pointg_intensity_callback_t uic_mqtt_dotdot_color_control_attribute_color_pointg_intensity_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_color_pointbx_callback_t uic_mqtt_dotdot_color_control_attribute_color_pointbx_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_color_pointby_callback_t uic_mqtt_dotdot_color_control_attribute_color_pointby_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_color_pointb_intensity_callback_t uic_mqtt_dotdot_color_control_attribute_color_pointb_intensity_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_enhanced_current_hue_callback_t uic_mqtt_dotdot_color_control_attribute_enhanced_current_hue_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_enhanced_color_mode_callback_t uic_mqtt_dotdot_color_control_attribute_enhanced_color_mode_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_color_loop_active_callback_t uic_mqtt_dotdot_color_control_attribute_color_loop_active_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_color_loop_direction_callback_t uic_mqtt_dotdot_color_control_attribute_color_loop_direction_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_color_loop_time_callback_t uic_mqtt_dotdot_color_control_attribute_color_loop_time_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_color_loop_start_enhanced_hue_callback_t uic_mqtt_dotdot_color_control_attribute_color_loop_start_enhanced_hue_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_color_loop_stored_enhanced_hue_callback_t uic_mqtt_dotdot_color_control_attribute_color_loop_stored_enhanced_hue_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_color_capabilities_callback_t uic_mqtt_dotdot_color_control_attribute_color_capabilities_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_color_temp_physical_min_mireds_callback_t uic_mqtt_dotdot_color_control_attribute_color_temp_physical_min_mireds_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_color_temp_physical_max_mireds_callback_t uic_mqtt_dotdot_color_control_attribute_color_temp_physical_max_mireds_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_couple_color_temp_to_level_min_mireds_callback_t uic_mqtt_dotdot_color_control_attribute_couple_color_temp_to_level_min_mireds_callback = nullptr;
static uic_mqtt_dotdot_color_control_attribute_start_up_color_temperature_mireds_callback_t uic_mqtt_dotdot_color_control_attribute_start_up_color_temperature_mireds_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for ColorControl
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_color_control_current_hue_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_current_hue_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t current_hue = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::CurrentHue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      current_hue = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_current_hue_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    current_hue
  );

}
static void uic_mqtt_dotdot_on_color_control_current_saturation_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_current_saturation_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t current_saturation = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::CurrentSaturation: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      current_saturation = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_current_saturation_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    current_saturation
  );

}
static void uic_mqtt_dotdot_on_color_control_remaining_time_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_remaining_time_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t remaining_time = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::RemainingTime: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      remaining_time = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_remaining_time_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    remaining_time
  );

}
static void uic_mqtt_dotdot_on_color_control_currentx_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_currentx_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t currentx = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::CurrentX: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      currentx = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_currentx_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    currentx
  );

}
static void uic_mqtt_dotdot_on_color_control_currenty_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_currenty_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t currenty = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::CurrentY: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      currenty = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_currenty_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    currenty
  );

}
static void uic_mqtt_dotdot_on_color_control_drift_compensation_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_drift_compensation_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t drift_compensation = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::DriftCompensation: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<ColorControlDriftCompensation>("value", json_payload);
      if (tmp == numeric_limits<ColorControlDriftCompensation>::max()) {
      #ifdef COLOR_CONTROL_DRIFT_COMPENSATION_ENUM_NAME_AVAILABLE
        tmp = color_control_drift_compensation_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(DRIFT_COMPENSATION_ENUM_NAME_AVAILABLE)
        tmp = drift_compensation_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      drift_compensation = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_drift_compensation_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    drift_compensation
  );

}
static void uic_mqtt_dotdot_on_color_control_compensation_text_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_compensation_text_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  const char* compensation_text = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::CompensationText: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      compensation_text = json_payload.at("value").get_ptr<const std::string*>()->c_str();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_compensation_text_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    compensation_text
  );

}
static void uic_mqtt_dotdot_on_color_control_color_temperature_mireds_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_color_temperature_mireds_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t color_temperature_mireds = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::ColorTemperatureMireds: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      color_temperature_mireds = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_color_temperature_mireds_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    color_temperature_mireds
  );

}
static void uic_mqtt_dotdot_on_color_control_color_mode_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_color_mode_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t color_mode = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::ColorMode: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<ColorControlColorMode>("value", json_payload);
      if (tmp == numeric_limits<ColorControlColorMode>::max()) {
      #ifdef COLOR_CONTROL_COLOR_MODE_ENUM_NAME_AVAILABLE
        tmp = color_control_color_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(COLOR_MODE_ENUM_NAME_AVAILABLE)
        tmp = color_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      color_mode = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_color_mode_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    color_mode
  );

}
static void uic_mqtt_dotdot_on_color_control_options_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_options_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t options = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::Options: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      options = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, CCColorOptions);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_options_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    options
  );

}
static void uic_mqtt_dotdot_on_color_control_number_of_primaries_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_number_of_primaries_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t number_of_primaries = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::NumberOfPrimaries: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      number_of_primaries = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_number_of_primaries_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    number_of_primaries
  );

}
static void uic_mqtt_dotdot_on_color_control_primary1x_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_primary1x_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t primary1x = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::Primary1X: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      primary1x = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_primary1x_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    primary1x
  );

}
static void uic_mqtt_dotdot_on_color_control_primary1y_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_primary1y_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t primary1y = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::Primary1Y: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      primary1y = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_primary1y_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    primary1y
  );

}
static void uic_mqtt_dotdot_on_color_control_primary1_intensity_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_primary1_intensity_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t primary1_intensity = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::Primary1Intensity: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      primary1_intensity = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_primary1_intensity_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    primary1_intensity
  );

}
static void uic_mqtt_dotdot_on_color_control_primary2x_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_primary2x_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t primary2x = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::Primary2X: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      primary2x = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_primary2x_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    primary2x
  );

}
static void uic_mqtt_dotdot_on_color_control_primary2y_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_primary2y_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t primary2y = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::Primary2Y: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      primary2y = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_primary2y_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    primary2y
  );

}
static void uic_mqtt_dotdot_on_color_control_primary2_intensity_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_primary2_intensity_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t primary2_intensity = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::Primary2Intensity: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      primary2_intensity = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_primary2_intensity_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    primary2_intensity
  );

}
static void uic_mqtt_dotdot_on_color_control_primary3x_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_primary3x_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t primary3x = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::Primary3X: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      primary3x = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_primary3x_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    primary3x
  );

}
static void uic_mqtt_dotdot_on_color_control_primary3y_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_primary3y_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t primary3y = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::Primary3Y: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      primary3y = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_primary3y_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    primary3y
  );

}
static void uic_mqtt_dotdot_on_color_control_primary3_intensity_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_primary3_intensity_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t primary3_intensity = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::Primary3Intensity: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      primary3_intensity = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_primary3_intensity_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    primary3_intensity
  );

}
static void uic_mqtt_dotdot_on_color_control_primary4x_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_primary4x_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t primary4x = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::Primary4X: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      primary4x = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_primary4x_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    primary4x
  );

}
static void uic_mqtt_dotdot_on_color_control_primary4y_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_primary4y_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t primary4y = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::Primary4Y: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      primary4y = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_primary4y_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    primary4y
  );

}
static void uic_mqtt_dotdot_on_color_control_primary4_intensity_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_primary4_intensity_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t primary4_intensity = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::Primary4Intensity: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      primary4_intensity = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_primary4_intensity_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    primary4_intensity
  );

}
static void uic_mqtt_dotdot_on_color_control_primary5x_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_primary5x_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t primary5x = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::Primary5X: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      primary5x = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_primary5x_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    primary5x
  );

}
static void uic_mqtt_dotdot_on_color_control_primary5y_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_primary5y_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t primary5y = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::Primary5Y: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      primary5y = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_primary5y_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    primary5y
  );

}
static void uic_mqtt_dotdot_on_color_control_primary5_intensity_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_primary5_intensity_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t primary5_intensity = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::Primary5Intensity: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      primary5_intensity = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_primary5_intensity_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    primary5_intensity
  );

}
static void uic_mqtt_dotdot_on_color_control_primary6x_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_primary6x_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t primary6x = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::Primary6X: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      primary6x = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_primary6x_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    primary6x
  );

}
static void uic_mqtt_dotdot_on_color_control_primary6y_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_primary6y_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t primary6y = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::Primary6Y: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      primary6y = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_primary6y_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    primary6y
  );

}
static void uic_mqtt_dotdot_on_color_control_primary6_intensity_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_primary6_intensity_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t primary6_intensity = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::Primary6Intensity: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      primary6_intensity = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_primary6_intensity_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    primary6_intensity
  );

}
static void uic_mqtt_dotdot_on_color_control_white_pointx_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_white_pointx_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t white_pointx = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::WhitePointX: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      white_pointx = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_white_pointx_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    white_pointx
  );

}
static void uic_mqtt_dotdot_on_color_control_white_pointy_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_white_pointy_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t white_pointy = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::WhitePointY: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      white_pointy = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_white_pointy_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    white_pointy
  );

}
static void uic_mqtt_dotdot_on_color_control_color_pointrx_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_color_pointrx_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t color_pointrx = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::ColorPointRX: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      color_pointrx = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_color_pointrx_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    color_pointrx
  );

}
static void uic_mqtt_dotdot_on_color_control_color_pointry_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_color_pointry_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t color_pointry = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::ColorPointRY: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      color_pointry = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_color_pointry_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    color_pointry
  );

}
static void uic_mqtt_dotdot_on_color_control_color_pointr_intensity_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_color_pointr_intensity_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t color_pointr_intensity = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::ColorPointRIntensity: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      color_pointr_intensity = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_color_pointr_intensity_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    color_pointr_intensity
  );

}
static void uic_mqtt_dotdot_on_color_control_color_pointgx_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_color_pointgx_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t color_pointgx = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::ColorPointGX: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      color_pointgx = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_color_pointgx_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    color_pointgx
  );

}
static void uic_mqtt_dotdot_on_color_control_color_pointgy_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_color_pointgy_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t color_pointgy = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::ColorPointGY: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      color_pointgy = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_color_pointgy_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    color_pointgy
  );

}
static void uic_mqtt_dotdot_on_color_control_color_pointg_intensity_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_color_pointg_intensity_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t color_pointg_intensity = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::ColorPointGIntensity: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      color_pointg_intensity = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_color_pointg_intensity_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    color_pointg_intensity
  );

}
static void uic_mqtt_dotdot_on_color_control_color_pointbx_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_color_pointbx_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t color_pointbx = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::ColorPointBX: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      color_pointbx = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_color_pointbx_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    color_pointbx
  );

}
static void uic_mqtt_dotdot_on_color_control_color_pointby_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_color_pointby_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t color_pointby = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::ColorPointBY: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      color_pointby = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_color_pointby_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    color_pointby
  );

}
static void uic_mqtt_dotdot_on_color_control_color_pointb_intensity_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_color_pointb_intensity_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t color_pointb_intensity = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::ColorPointBIntensity: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      color_pointb_intensity = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_color_pointb_intensity_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    color_pointb_intensity
  );

}
static void uic_mqtt_dotdot_on_color_control_enhanced_current_hue_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_enhanced_current_hue_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t enhanced_current_hue = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::EnhancedCurrentHue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      enhanced_current_hue = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_enhanced_current_hue_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    enhanced_current_hue
  );

}
static void uic_mqtt_dotdot_on_color_control_enhanced_color_mode_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_enhanced_color_mode_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t enhanced_color_mode = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::EnhancedColorMode: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<ColorControlEnhancedColorMode>("value", json_payload);
      if (tmp == numeric_limits<ColorControlEnhancedColorMode>::max()) {
      #ifdef COLOR_CONTROL_ENHANCED_COLOR_MODE_ENUM_NAME_AVAILABLE
        tmp = color_control_enhanced_color_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(ENHANCED_COLOR_MODE_ENUM_NAME_AVAILABLE)
        tmp = enhanced_color_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      enhanced_color_mode = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_enhanced_color_mode_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    enhanced_color_mode
  );

}
static void uic_mqtt_dotdot_on_color_control_color_loop_active_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_color_loop_active_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t color_loop_active = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::ColorLoopActive: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      color_loop_active = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_color_loop_active_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    color_loop_active
  );

}
static void uic_mqtt_dotdot_on_color_control_color_loop_direction_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_color_loop_direction_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  CCColorLoopDirection color_loop_direction = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::ColorLoopDirection: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<CCColorLoopDirection>("value", json_payload);
      if (tmp == numeric_limits<CCColorLoopDirection>::max()) {
      #ifdef COLOR_CONTROL_COLOR_LOOP_DIRECTION_ENUM_NAME_AVAILABLE
        tmp = color_control_color_loop_direction_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(COLOR_LOOP_DIRECTION_ENUM_NAME_AVAILABLE)
        tmp = color_loop_direction_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      color_loop_direction = static_cast<CCColorLoopDirection>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_color_loop_direction_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    color_loop_direction
  );

}
static void uic_mqtt_dotdot_on_color_control_color_loop_time_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_color_loop_time_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t color_loop_time = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::ColorLoopTime: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      color_loop_time = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_color_loop_time_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    color_loop_time
  );

}
static void uic_mqtt_dotdot_on_color_control_color_loop_start_enhanced_hue_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_color_loop_start_enhanced_hue_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t color_loop_start_enhanced_hue = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::ColorLoopStartEnhancedHue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      color_loop_start_enhanced_hue = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_color_loop_start_enhanced_hue_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    color_loop_start_enhanced_hue
  );

}
static void uic_mqtt_dotdot_on_color_control_color_loop_stored_enhanced_hue_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_color_loop_stored_enhanced_hue_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t color_loop_stored_enhanced_hue = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::ColorLoopStoredEnhancedHue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      color_loop_stored_enhanced_hue = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_color_loop_stored_enhanced_hue_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    color_loop_stored_enhanced_hue
  );

}
static void uic_mqtt_dotdot_on_color_control_color_capabilities_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_color_capabilities_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t color_capabilities = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::ColorCapabilities: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      color_capabilities = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, ColorControlColorCapabilities);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_color_capabilities_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    color_capabilities
  );

}
static void uic_mqtt_dotdot_on_color_control_color_temp_physical_min_mireds_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_color_temp_physical_min_mireds_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t color_temp_physical_min_mireds = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::ColorTempPhysicalMinMireds: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      color_temp_physical_min_mireds = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_color_temp_physical_min_mireds_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    color_temp_physical_min_mireds
  );

}
static void uic_mqtt_dotdot_on_color_control_color_temp_physical_max_mireds_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_color_temp_physical_max_mireds_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t color_temp_physical_max_mireds = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::ColorTempPhysicalMaxMireds: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      color_temp_physical_max_mireds = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_color_temp_physical_max_mireds_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    color_temp_physical_max_mireds
  );

}
static void uic_mqtt_dotdot_on_color_control_couple_color_temp_to_level_min_mireds_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_couple_color_temp_to_level_min_mireds_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t couple_color_temp_to_level_min_mireds = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::CoupleColorTempToLevelMinMireds: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      couple_color_temp_to_level_min_mireds = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_couple_color_temp_to_level_min_mireds_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    couple_color_temp_to_level_min_mireds
  );

}
static void uic_mqtt_dotdot_on_color_control_start_up_color_temperature_mireds_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_color_control_attribute_start_up_color_temperature_mireds_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t start_up_color_temperature_mireds = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ColorControl::StartUpColorTemperatureMireds: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      start_up_color_temperature_mireds = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_color_control_attribute_start_up_color_temperature_mireds_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    start_up_color_temperature_mireds
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for ColorControl
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_color_control_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_color_control_attribute_current_hue_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/CurrentHue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_current_hue_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_current_saturation_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/CurrentSaturation/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_current_saturation_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_remaining_time_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/RemainingTime/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_remaining_time_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_currentx_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/CurrentX/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_currentx_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_currenty_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/CurrentY/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_currenty_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_drift_compensation_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/DriftCompensation/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_drift_compensation_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_compensation_text_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/CompensationText/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_compensation_text_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_color_temperature_mireds_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/ColorTemperatureMireds/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_color_temperature_mireds_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_color_mode_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/ColorMode/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_color_mode_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_options_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/Options/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_options_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_number_of_primaries_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/NumberOfPrimaries/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_number_of_primaries_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_primary1x_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/Primary1X/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_primary1x_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_primary1y_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/Primary1Y/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_primary1y_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_primary1_intensity_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/Primary1Intensity/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_primary1_intensity_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_primary2x_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/Primary2X/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_primary2x_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_primary2y_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/Primary2Y/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_primary2y_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_primary2_intensity_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/Primary2Intensity/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_primary2_intensity_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_primary3x_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/Primary3X/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_primary3x_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_primary3y_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/Primary3Y/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_primary3y_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_primary3_intensity_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/Primary3Intensity/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_primary3_intensity_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_primary4x_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/Primary4X/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_primary4x_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_primary4y_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/Primary4Y/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_primary4y_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_primary4_intensity_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/Primary4Intensity/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_primary4_intensity_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_primary5x_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/Primary5X/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_primary5x_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_primary5y_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/Primary5Y/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_primary5y_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_primary5_intensity_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/Primary5Intensity/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_primary5_intensity_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_primary6x_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/Primary6X/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_primary6x_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_primary6y_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/Primary6Y/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_primary6y_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_primary6_intensity_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/Primary6Intensity/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_primary6_intensity_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_white_pointx_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/WhitePointX/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_white_pointx_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_white_pointy_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/WhitePointY/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_white_pointy_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_color_pointrx_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/ColorPointRX/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_color_pointrx_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_color_pointry_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/ColorPointRY/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_color_pointry_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_color_pointr_intensity_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/ColorPointRIntensity/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_color_pointr_intensity_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_color_pointgx_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/ColorPointGX/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_color_pointgx_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_color_pointgy_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/ColorPointGY/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_color_pointgy_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_color_pointg_intensity_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/ColorPointGIntensity/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_color_pointg_intensity_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_color_pointbx_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/ColorPointBX/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_color_pointbx_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_color_pointby_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/ColorPointBY/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_color_pointby_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_color_pointb_intensity_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/ColorPointBIntensity/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_color_pointb_intensity_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_enhanced_current_hue_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/EnhancedCurrentHue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_enhanced_current_hue_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_enhanced_color_mode_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/EnhancedColorMode/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_enhanced_color_mode_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_color_loop_active_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/ColorLoopActive/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_color_loop_active_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_color_loop_direction_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/ColorLoopDirection/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_color_loop_direction_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_color_loop_time_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/ColorLoopTime/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_color_loop_time_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_color_loop_start_enhanced_hue_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/ColorLoopStartEnhancedHue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_color_loop_start_enhanced_hue_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_color_loop_stored_enhanced_hue_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/ColorLoopStoredEnhancedHue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_color_loop_stored_enhanced_hue_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_color_capabilities_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/ColorCapabilities/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_color_capabilities_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_color_temp_physical_min_mireds_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/ColorTempPhysicalMinMireds/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_color_temp_physical_min_mireds_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_color_temp_physical_max_mireds_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/ColorTempPhysicalMaxMireds/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_color_temp_physical_max_mireds_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_couple_color_temp_to_level_min_mireds_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/CoupleColorTempToLevelMinMireds/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_couple_color_temp_to_level_min_mireds_attribute_update);
  }
  if(uic_mqtt_dotdot_color_control_attribute_start_up_color_temperature_mireds_callback) {
    subscription_topic = base_topic + "ColorControl/Attributes/StartUpColorTemperatureMireds/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_color_control_start_up_color_temperature_mireds_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for ColorControl
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_color_control_attribute_current_hue_callback_set(const uic_mqtt_dotdot_color_control_attribute_current_hue_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_current_hue_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_current_saturation_callback_set(const uic_mqtt_dotdot_color_control_attribute_current_saturation_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_current_saturation_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_remaining_time_callback_set(const uic_mqtt_dotdot_color_control_attribute_remaining_time_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_remaining_time_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_currentx_callback_set(const uic_mqtt_dotdot_color_control_attribute_currentx_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_currentx_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_currenty_callback_set(const uic_mqtt_dotdot_color_control_attribute_currenty_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_currenty_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_drift_compensation_callback_set(const uic_mqtt_dotdot_color_control_attribute_drift_compensation_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_drift_compensation_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_compensation_text_callback_set(const uic_mqtt_dotdot_color_control_attribute_compensation_text_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_compensation_text_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_color_temperature_mireds_callback_set(const uic_mqtt_dotdot_color_control_attribute_color_temperature_mireds_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_color_temperature_mireds_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_color_mode_callback_set(const uic_mqtt_dotdot_color_control_attribute_color_mode_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_color_mode_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_options_callback_set(const uic_mqtt_dotdot_color_control_attribute_options_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_options_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_number_of_primaries_callback_set(const uic_mqtt_dotdot_color_control_attribute_number_of_primaries_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_number_of_primaries_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_primary1x_callback_set(const uic_mqtt_dotdot_color_control_attribute_primary1x_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_primary1x_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_primary1y_callback_set(const uic_mqtt_dotdot_color_control_attribute_primary1y_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_primary1y_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_primary1_intensity_callback_set(const uic_mqtt_dotdot_color_control_attribute_primary1_intensity_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_primary1_intensity_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_primary2x_callback_set(const uic_mqtt_dotdot_color_control_attribute_primary2x_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_primary2x_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_primary2y_callback_set(const uic_mqtt_dotdot_color_control_attribute_primary2y_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_primary2y_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_primary2_intensity_callback_set(const uic_mqtt_dotdot_color_control_attribute_primary2_intensity_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_primary2_intensity_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_primary3x_callback_set(const uic_mqtt_dotdot_color_control_attribute_primary3x_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_primary3x_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_primary3y_callback_set(const uic_mqtt_dotdot_color_control_attribute_primary3y_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_primary3y_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_primary3_intensity_callback_set(const uic_mqtt_dotdot_color_control_attribute_primary3_intensity_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_primary3_intensity_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_primary4x_callback_set(const uic_mqtt_dotdot_color_control_attribute_primary4x_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_primary4x_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_primary4y_callback_set(const uic_mqtt_dotdot_color_control_attribute_primary4y_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_primary4y_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_primary4_intensity_callback_set(const uic_mqtt_dotdot_color_control_attribute_primary4_intensity_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_primary4_intensity_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_primary5x_callback_set(const uic_mqtt_dotdot_color_control_attribute_primary5x_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_primary5x_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_primary5y_callback_set(const uic_mqtt_dotdot_color_control_attribute_primary5y_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_primary5y_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_primary5_intensity_callback_set(const uic_mqtt_dotdot_color_control_attribute_primary5_intensity_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_primary5_intensity_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_primary6x_callback_set(const uic_mqtt_dotdot_color_control_attribute_primary6x_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_primary6x_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_primary6y_callback_set(const uic_mqtt_dotdot_color_control_attribute_primary6y_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_primary6y_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_primary6_intensity_callback_set(const uic_mqtt_dotdot_color_control_attribute_primary6_intensity_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_primary6_intensity_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_white_pointx_callback_set(const uic_mqtt_dotdot_color_control_attribute_white_pointx_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_white_pointx_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_white_pointy_callback_set(const uic_mqtt_dotdot_color_control_attribute_white_pointy_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_white_pointy_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_color_pointrx_callback_set(const uic_mqtt_dotdot_color_control_attribute_color_pointrx_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_color_pointrx_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_color_pointry_callback_set(const uic_mqtt_dotdot_color_control_attribute_color_pointry_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_color_pointry_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_color_pointr_intensity_callback_set(const uic_mqtt_dotdot_color_control_attribute_color_pointr_intensity_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_color_pointr_intensity_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_color_pointgx_callback_set(const uic_mqtt_dotdot_color_control_attribute_color_pointgx_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_color_pointgx_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_color_pointgy_callback_set(const uic_mqtt_dotdot_color_control_attribute_color_pointgy_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_color_pointgy_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_color_pointg_intensity_callback_set(const uic_mqtt_dotdot_color_control_attribute_color_pointg_intensity_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_color_pointg_intensity_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_color_pointbx_callback_set(const uic_mqtt_dotdot_color_control_attribute_color_pointbx_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_color_pointbx_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_color_pointby_callback_set(const uic_mqtt_dotdot_color_control_attribute_color_pointby_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_color_pointby_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_color_pointb_intensity_callback_set(const uic_mqtt_dotdot_color_control_attribute_color_pointb_intensity_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_color_pointb_intensity_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_enhanced_current_hue_callback_set(const uic_mqtt_dotdot_color_control_attribute_enhanced_current_hue_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_enhanced_current_hue_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_enhanced_color_mode_callback_set(const uic_mqtt_dotdot_color_control_attribute_enhanced_color_mode_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_enhanced_color_mode_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_color_loop_active_callback_set(const uic_mqtt_dotdot_color_control_attribute_color_loop_active_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_color_loop_active_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_color_loop_direction_callback_set(const uic_mqtt_dotdot_color_control_attribute_color_loop_direction_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_color_loop_direction_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_color_loop_time_callback_set(const uic_mqtt_dotdot_color_control_attribute_color_loop_time_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_color_loop_time_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_color_loop_start_enhanced_hue_callback_set(const uic_mqtt_dotdot_color_control_attribute_color_loop_start_enhanced_hue_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_color_loop_start_enhanced_hue_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_color_loop_stored_enhanced_hue_callback_set(const uic_mqtt_dotdot_color_control_attribute_color_loop_stored_enhanced_hue_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_color_loop_stored_enhanced_hue_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_color_capabilities_callback_set(const uic_mqtt_dotdot_color_control_attribute_color_capabilities_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_color_capabilities_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_color_temp_physical_min_mireds_callback_set(const uic_mqtt_dotdot_color_control_attribute_color_temp_physical_min_mireds_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_color_temp_physical_min_mireds_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_color_temp_physical_max_mireds_callback_set(const uic_mqtt_dotdot_color_control_attribute_color_temp_physical_max_mireds_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_color_temp_physical_max_mireds_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_couple_color_temp_to_level_min_mireds_callback_set(const uic_mqtt_dotdot_color_control_attribute_couple_color_temp_to_level_min_mireds_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_couple_color_temp_to_level_min_mireds_callback = callback;
}
void uic_mqtt_dotdot_color_control_attribute_start_up_color_temperature_mireds_callback_set(const uic_mqtt_dotdot_color_control_attribute_start_up_color_temperature_mireds_callback_t callback)
{
  uic_mqtt_dotdot_color_control_attribute_start_up_color_temperature_mireds_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for BallastConfiguration
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_ballast_configuration_attribute_physical_min_level_callback_t uic_mqtt_dotdot_ballast_configuration_attribute_physical_min_level_callback = nullptr;
static uic_mqtt_dotdot_ballast_configuration_attribute_physical_max_level_callback_t uic_mqtt_dotdot_ballast_configuration_attribute_physical_max_level_callback = nullptr;
static uic_mqtt_dotdot_ballast_configuration_attribute_ballast_status_callback_t uic_mqtt_dotdot_ballast_configuration_attribute_ballast_status_callback = nullptr;
static uic_mqtt_dotdot_ballast_configuration_attribute_min_level_callback_t uic_mqtt_dotdot_ballast_configuration_attribute_min_level_callback = nullptr;
static uic_mqtt_dotdot_ballast_configuration_attribute_max_level_callback_t uic_mqtt_dotdot_ballast_configuration_attribute_max_level_callback = nullptr;
static uic_mqtt_dotdot_ballast_configuration_attribute_power_on_level_callback_t uic_mqtt_dotdot_ballast_configuration_attribute_power_on_level_callback = nullptr;
static uic_mqtt_dotdot_ballast_configuration_attribute_power_on_fade_time_callback_t uic_mqtt_dotdot_ballast_configuration_attribute_power_on_fade_time_callback = nullptr;
static uic_mqtt_dotdot_ballast_configuration_attribute_intrinsic_ballast_factor_callback_t uic_mqtt_dotdot_ballast_configuration_attribute_intrinsic_ballast_factor_callback = nullptr;
static uic_mqtt_dotdot_ballast_configuration_attribute_ballast_factor_adjustment_callback_t uic_mqtt_dotdot_ballast_configuration_attribute_ballast_factor_adjustment_callback = nullptr;
static uic_mqtt_dotdot_ballast_configuration_attribute_lamp_quantity_callback_t uic_mqtt_dotdot_ballast_configuration_attribute_lamp_quantity_callback = nullptr;
static uic_mqtt_dotdot_ballast_configuration_attribute_lamp_type_callback_t uic_mqtt_dotdot_ballast_configuration_attribute_lamp_type_callback = nullptr;
static uic_mqtt_dotdot_ballast_configuration_attribute_lamp_manufacturer_callback_t uic_mqtt_dotdot_ballast_configuration_attribute_lamp_manufacturer_callback = nullptr;
static uic_mqtt_dotdot_ballast_configuration_attribute_lamp_rated_hours_callback_t uic_mqtt_dotdot_ballast_configuration_attribute_lamp_rated_hours_callback = nullptr;
static uic_mqtt_dotdot_ballast_configuration_attribute_lamp_burn_hours_callback_t uic_mqtt_dotdot_ballast_configuration_attribute_lamp_burn_hours_callback = nullptr;
static uic_mqtt_dotdot_ballast_configuration_attribute_lamp_alarm_mode_callback_t uic_mqtt_dotdot_ballast_configuration_attribute_lamp_alarm_mode_callback = nullptr;
static uic_mqtt_dotdot_ballast_configuration_attribute_lamp_burn_hours_trip_point_callback_t uic_mqtt_dotdot_ballast_configuration_attribute_lamp_burn_hours_trip_point_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for BallastConfiguration
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_ballast_configuration_physical_min_level_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_ballast_configuration_attribute_physical_min_level_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t physical_min_level = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "BallastConfiguration::PhysicalMinLevel: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      physical_min_level = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_ballast_configuration_attribute_physical_min_level_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    physical_min_level
  );

}
static void uic_mqtt_dotdot_on_ballast_configuration_physical_max_level_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_ballast_configuration_attribute_physical_max_level_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t physical_max_level = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "BallastConfiguration::PhysicalMaxLevel: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      physical_max_level = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_ballast_configuration_attribute_physical_max_level_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    physical_max_level
  );

}
static void uic_mqtt_dotdot_on_ballast_configuration_ballast_status_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_ballast_configuration_attribute_ballast_status_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t ballast_status = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "BallastConfiguration::BallastStatus: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      ballast_status = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, BallastConfigurationBallastStatus);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_ballast_configuration_attribute_ballast_status_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    ballast_status
  );

}
static void uic_mqtt_dotdot_on_ballast_configuration_min_level_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_ballast_configuration_attribute_min_level_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t min_level = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "BallastConfiguration::MinLevel: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      min_level = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_ballast_configuration_attribute_min_level_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    min_level
  );

}
static void uic_mqtt_dotdot_on_ballast_configuration_max_level_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_ballast_configuration_attribute_max_level_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t max_level = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "BallastConfiguration::MaxLevel: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      max_level = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_ballast_configuration_attribute_max_level_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    max_level
  );

}
static void uic_mqtt_dotdot_on_ballast_configuration_power_on_level_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_ballast_configuration_attribute_power_on_level_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t power_on_level = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "BallastConfiguration::PowerOnLevel: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      power_on_level = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_ballast_configuration_attribute_power_on_level_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    power_on_level
  );

}
static void uic_mqtt_dotdot_on_ballast_configuration_power_on_fade_time_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_ballast_configuration_attribute_power_on_fade_time_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t power_on_fade_time = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "BallastConfiguration::PowerOnFadeTime: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      power_on_fade_time = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_ballast_configuration_attribute_power_on_fade_time_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    power_on_fade_time
  );

}
static void uic_mqtt_dotdot_on_ballast_configuration_intrinsic_ballast_factor_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_ballast_configuration_attribute_intrinsic_ballast_factor_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t intrinsic_ballast_factor = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "BallastConfiguration::IntrinsicBallastFactor: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      intrinsic_ballast_factor = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_ballast_configuration_attribute_intrinsic_ballast_factor_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    intrinsic_ballast_factor
  );

}
static void uic_mqtt_dotdot_on_ballast_configuration_ballast_factor_adjustment_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_ballast_configuration_attribute_ballast_factor_adjustment_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t ballast_factor_adjustment = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "BallastConfiguration::BallastFactorAdjustment: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      ballast_factor_adjustment = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_ballast_configuration_attribute_ballast_factor_adjustment_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    ballast_factor_adjustment
  );

}
static void uic_mqtt_dotdot_on_ballast_configuration_lamp_quantity_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_ballast_configuration_attribute_lamp_quantity_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t lamp_quantity = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "BallastConfiguration::LampQuantity: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      lamp_quantity = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_ballast_configuration_attribute_lamp_quantity_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    lamp_quantity
  );

}
static void uic_mqtt_dotdot_on_ballast_configuration_lamp_type_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_ballast_configuration_attribute_lamp_type_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  const char* lamp_type = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "BallastConfiguration::LampType: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      lamp_type = json_payload.at("value").get_ptr<const std::string*>()->c_str();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_ballast_configuration_attribute_lamp_type_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    lamp_type
  );

}
static void uic_mqtt_dotdot_on_ballast_configuration_lamp_manufacturer_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_ballast_configuration_attribute_lamp_manufacturer_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  const char* lamp_manufacturer = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "BallastConfiguration::LampManufacturer: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      lamp_manufacturer = json_payload.at("value").get_ptr<const std::string*>()->c_str();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_ballast_configuration_attribute_lamp_manufacturer_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    lamp_manufacturer
  );

}
static void uic_mqtt_dotdot_on_ballast_configuration_lamp_rated_hours_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_ballast_configuration_attribute_lamp_rated_hours_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t lamp_rated_hours = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "BallastConfiguration::LampRatedHours: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      lamp_rated_hours = json_payload.at("value").get<uint32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_ballast_configuration_attribute_lamp_rated_hours_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    lamp_rated_hours
  );

}
static void uic_mqtt_dotdot_on_ballast_configuration_lamp_burn_hours_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_ballast_configuration_attribute_lamp_burn_hours_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t lamp_burn_hours = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "BallastConfiguration::LampBurnHours: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      lamp_burn_hours = json_payload.at("value").get<uint32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_ballast_configuration_attribute_lamp_burn_hours_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    lamp_burn_hours
  );

}
static void uic_mqtt_dotdot_on_ballast_configuration_lamp_alarm_mode_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_ballast_configuration_attribute_lamp_alarm_mode_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t lamp_alarm_mode = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "BallastConfiguration::LampAlarmMode: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      lamp_alarm_mode = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, BallastConfigurationLampAlarmMode);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_ballast_configuration_attribute_lamp_alarm_mode_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    lamp_alarm_mode
  );

}
static void uic_mqtt_dotdot_on_ballast_configuration_lamp_burn_hours_trip_point_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_ballast_configuration_attribute_lamp_burn_hours_trip_point_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t lamp_burn_hours_trip_point = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "BallastConfiguration::LampBurnHoursTripPoint: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      lamp_burn_hours_trip_point = json_payload.at("value").get<uint32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_ballast_configuration_attribute_lamp_burn_hours_trip_point_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    lamp_burn_hours_trip_point
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for BallastConfiguration
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_ballast_configuration_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_ballast_configuration_attribute_physical_min_level_callback) {
    subscription_topic = base_topic + "BallastConfiguration/Attributes/PhysicalMinLevel/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_ballast_configuration_physical_min_level_attribute_update);
  }
  if(uic_mqtt_dotdot_ballast_configuration_attribute_physical_max_level_callback) {
    subscription_topic = base_topic + "BallastConfiguration/Attributes/PhysicalMaxLevel/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_ballast_configuration_physical_max_level_attribute_update);
  }
  if(uic_mqtt_dotdot_ballast_configuration_attribute_ballast_status_callback) {
    subscription_topic = base_topic + "BallastConfiguration/Attributes/BallastStatus/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_ballast_configuration_ballast_status_attribute_update);
  }
  if(uic_mqtt_dotdot_ballast_configuration_attribute_min_level_callback) {
    subscription_topic = base_topic + "BallastConfiguration/Attributes/MinLevel/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_ballast_configuration_min_level_attribute_update);
  }
  if(uic_mqtt_dotdot_ballast_configuration_attribute_max_level_callback) {
    subscription_topic = base_topic + "BallastConfiguration/Attributes/MaxLevel/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_ballast_configuration_max_level_attribute_update);
  }
  if(uic_mqtt_dotdot_ballast_configuration_attribute_power_on_level_callback) {
    subscription_topic = base_topic + "BallastConfiguration/Attributes/PowerOnLevel/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_ballast_configuration_power_on_level_attribute_update);
  }
  if(uic_mqtt_dotdot_ballast_configuration_attribute_power_on_fade_time_callback) {
    subscription_topic = base_topic + "BallastConfiguration/Attributes/PowerOnFadeTime/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_ballast_configuration_power_on_fade_time_attribute_update);
  }
  if(uic_mqtt_dotdot_ballast_configuration_attribute_intrinsic_ballast_factor_callback) {
    subscription_topic = base_topic + "BallastConfiguration/Attributes/IntrinsicBallastFactor/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_ballast_configuration_intrinsic_ballast_factor_attribute_update);
  }
  if(uic_mqtt_dotdot_ballast_configuration_attribute_ballast_factor_adjustment_callback) {
    subscription_topic = base_topic + "BallastConfiguration/Attributes/BallastFactorAdjustment/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_ballast_configuration_ballast_factor_adjustment_attribute_update);
  }
  if(uic_mqtt_dotdot_ballast_configuration_attribute_lamp_quantity_callback) {
    subscription_topic = base_topic + "BallastConfiguration/Attributes/LampQuantity/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_ballast_configuration_lamp_quantity_attribute_update);
  }
  if(uic_mqtt_dotdot_ballast_configuration_attribute_lamp_type_callback) {
    subscription_topic = base_topic + "BallastConfiguration/Attributes/LampType/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_ballast_configuration_lamp_type_attribute_update);
  }
  if(uic_mqtt_dotdot_ballast_configuration_attribute_lamp_manufacturer_callback) {
    subscription_topic = base_topic + "BallastConfiguration/Attributes/LampManufacturer/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_ballast_configuration_lamp_manufacturer_attribute_update);
  }
  if(uic_mqtt_dotdot_ballast_configuration_attribute_lamp_rated_hours_callback) {
    subscription_topic = base_topic + "BallastConfiguration/Attributes/LampRatedHours/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_ballast_configuration_lamp_rated_hours_attribute_update);
  }
  if(uic_mqtt_dotdot_ballast_configuration_attribute_lamp_burn_hours_callback) {
    subscription_topic = base_topic + "BallastConfiguration/Attributes/LampBurnHours/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_ballast_configuration_lamp_burn_hours_attribute_update);
  }
  if(uic_mqtt_dotdot_ballast_configuration_attribute_lamp_alarm_mode_callback) {
    subscription_topic = base_topic + "BallastConfiguration/Attributes/LampAlarmMode/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_ballast_configuration_lamp_alarm_mode_attribute_update);
  }
  if(uic_mqtt_dotdot_ballast_configuration_attribute_lamp_burn_hours_trip_point_callback) {
    subscription_topic = base_topic + "BallastConfiguration/Attributes/LampBurnHoursTripPoint/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_ballast_configuration_lamp_burn_hours_trip_point_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for BallastConfiguration
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_ballast_configuration_attribute_physical_min_level_callback_set(const uic_mqtt_dotdot_ballast_configuration_attribute_physical_min_level_callback_t callback)
{
  uic_mqtt_dotdot_ballast_configuration_attribute_physical_min_level_callback = callback;
}
void uic_mqtt_dotdot_ballast_configuration_attribute_physical_max_level_callback_set(const uic_mqtt_dotdot_ballast_configuration_attribute_physical_max_level_callback_t callback)
{
  uic_mqtt_dotdot_ballast_configuration_attribute_physical_max_level_callback = callback;
}
void uic_mqtt_dotdot_ballast_configuration_attribute_ballast_status_callback_set(const uic_mqtt_dotdot_ballast_configuration_attribute_ballast_status_callback_t callback)
{
  uic_mqtt_dotdot_ballast_configuration_attribute_ballast_status_callback = callback;
}
void uic_mqtt_dotdot_ballast_configuration_attribute_min_level_callback_set(const uic_mqtt_dotdot_ballast_configuration_attribute_min_level_callback_t callback)
{
  uic_mqtt_dotdot_ballast_configuration_attribute_min_level_callback = callback;
}
void uic_mqtt_dotdot_ballast_configuration_attribute_max_level_callback_set(const uic_mqtt_dotdot_ballast_configuration_attribute_max_level_callback_t callback)
{
  uic_mqtt_dotdot_ballast_configuration_attribute_max_level_callback = callback;
}
void uic_mqtt_dotdot_ballast_configuration_attribute_power_on_level_callback_set(const uic_mqtt_dotdot_ballast_configuration_attribute_power_on_level_callback_t callback)
{
  uic_mqtt_dotdot_ballast_configuration_attribute_power_on_level_callback = callback;
}
void uic_mqtt_dotdot_ballast_configuration_attribute_power_on_fade_time_callback_set(const uic_mqtt_dotdot_ballast_configuration_attribute_power_on_fade_time_callback_t callback)
{
  uic_mqtt_dotdot_ballast_configuration_attribute_power_on_fade_time_callback = callback;
}
void uic_mqtt_dotdot_ballast_configuration_attribute_intrinsic_ballast_factor_callback_set(const uic_mqtt_dotdot_ballast_configuration_attribute_intrinsic_ballast_factor_callback_t callback)
{
  uic_mqtt_dotdot_ballast_configuration_attribute_intrinsic_ballast_factor_callback = callback;
}
void uic_mqtt_dotdot_ballast_configuration_attribute_ballast_factor_adjustment_callback_set(const uic_mqtt_dotdot_ballast_configuration_attribute_ballast_factor_adjustment_callback_t callback)
{
  uic_mqtt_dotdot_ballast_configuration_attribute_ballast_factor_adjustment_callback = callback;
}
void uic_mqtt_dotdot_ballast_configuration_attribute_lamp_quantity_callback_set(const uic_mqtt_dotdot_ballast_configuration_attribute_lamp_quantity_callback_t callback)
{
  uic_mqtt_dotdot_ballast_configuration_attribute_lamp_quantity_callback = callback;
}
void uic_mqtt_dotdot_ballast_configuration_attribute_lamp_type_callback_set(const uic_mqtt_dotdot_ballast_configuration_attribute_lamp_type_callback_t callback)
{
  uic_mqtt_dotdot_ballast_configuration_attribute_lamp_type_callback = callback;
}
void uic_mqtt_dotdot_ballast_configuration_attribute_lamp_manufacturer_callback_set(const uic_mqtt_dotdot_ballast_configuration_attribute_lamp_manufacturer_callback_t callback)
{
  uic_mqtt_dotdot_ballast_configuration_attribute_lamp_manufacturer_callback = callback;
}
void uic_mqtt_dotdot_ballast_configuration_attribute_lamp_rated_hours_callback_set(const uic_mqtt_dotdot_ballast_configuration_attribute_lamp_rated_hours_callback_t callback)
{
  uic_mqtt_dotdot_ballast_configuration_attribute_lamp_rated_hours_callback = callback;
}
void uic_mqtt_dotdot_ballast_configuration_attribute_lamp_burn_hours_callback_set(const uic_mqtt_dotdot_ballast_configuration_attribute_lamp_burn_hours_callback_t callback)
{
  uic_mqtt_dotdot_ballast_configuration_attribute_lamp_burn_hours_callback = callback;
}
void uic_mqtt_dotdot_ballast_configuration_attribute_lamp_alarm_mode_callback_set(const uic_mqtt_dotdot_ballast_configuration_attribute_lamp_alarm_mode_callback_t callback)
{
  uic_mqtt_dotdot_ballast_configuration_attribute_lamp_alarm_mode_callback = callback;
}
void uic_mqtt_dotdot_ballast_configuration_attribute_lamp_burn_hours_trip_point_callback_set(const uic_mqtt_dotdot_ballast_configuration_attribute_lamp_burn_hours_trip_point_callback_t callback)
{
  uic_mqtt_dotdot_ballast_configuration_attribute_lamp_burn_hours_trip_point_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for IlluminanceMeasurement
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_illuminance_measurement_attribute_measured_value_callback_t uic_mqtt_dotdot_illuminance_measurement_attribute_measured_value_callback = nullptr;
static uic_mqtt_dotdot_illuminance_measurement_attribute_min_measured_value_callback_t uic_mqtt_dotdot_illuminance_measurement_attribute_min_measured_value_callback = nullptr;
static uic_mqtt_dotdot_illuminance_measurement_attribute_max_measured_value_callback_t uic_mqtt_dotdot_illuminance_measurement_attribute_max_measured_value_callback = nullptr;
static uic_mqtt_dotdot_illuminance_measurement_attribute_tolerance_callback_t uic_mqtt_dotdot_illuminance_measurement_attribute_tolerance_callback = nullptr;
static uic_mqtt_dotdot_illuminance_measurement_attribute_light_sensor_type_callback_t uic_mqtt_dotdot_illuminance_measurement_attribute_light_sensor_type_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for IlluminanceMeasurement
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_illuminance_measurement_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_illuminance_measurement_attribute_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "IlluminanceMeasurement::MeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      measured_value = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_illuminance_measurement_attribute_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    measured_value
  );

}
static void uic_mqtt_dotdot_on_illuminance_measurement_min_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_illuminance_measurement_attribute_min_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t min_measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "IlluminanceMeasurement::MinMeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      min_measured_value = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_illuminance_measurement_attribute_min_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    min_measured_value
  );

}
static void uic_mqtt_dotdot_on_illuminance_measurement_max_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_illuminance_measurement_attribute_max_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t max_measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "IlluminanceMeasurement::MaxMeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      max_measured_value = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_illuminance_measurement_attribute_max_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    max_measured_value
  );

}
static void uic_mqtt_dotdot_on_illuminance_measurement_tolerance_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_illuminance_measurement_attribute_tolerance_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t tolerance = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "IlluminanceMeasurement::Tolerance: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      tolerance = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_illuminance_measurement_attribute_tolerance_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    tolerance
  );

}
static void uic_mqtt_dotdot_on_illuminance_measurement_light_sensor_type_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_illuminance_measurement_attribute_light_sensor_type_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t light_sensor_type = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "IlluminanceMeasurement::LightSensorType: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<IlluminanceMeasurementLightSensorType>("value", json_payload);
      if (tmp == numeric_limits<IlluminanceMeasurementLightSensorType>::max()) {
      #ifdef ILLUMINANCE_MEASUREMENT_LIGHT_SENSOR_TYPE_ENUM_NAME_AVAILABLE
        tmp = illuminance_measurement_light_sensor_type_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(LIGHT_SENSOR_TYPE_ENUM_NAME_AVAILABLE)
        tmp = light_sensor_type_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      light_sensor_type = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_illuminance_measurement_attribute_light_sensor_type_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    light_sensor_type
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for IlluminanceMeasurement
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_illuminance_measurement_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_illuminance_measurement_attribute_measured_value_callback) {
    subscription_topic = base_topic + "IlluminanceMeasurement/Attributes/MeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_illuminance_measurement_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_illuminance_measurement_attribute_min_measured_value_callback) {
    subscription_topic = base_topic + "IlluminanceMeasurement/Attributes/MinMeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_illuminance_measurement_min_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_illuminance_measurement_attribute_max_measured_value_callback) {
    subscription_topic = base_topic + "IlluminanceMeasurement/Attributes/MaxMeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_illuminance_measurement_max_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_illuminance_measurement_attribute_tolerance_callback) {
    subscription_topic = base_topic + "IlluminanceMeasurement/Attributes/Tolerance/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_illuminance_measurement_tolerance_attribute_update);
  }
  if(uic_mqtt_dotdot_illuminance_measurement_attribute_light_sensor_type_callback) {
    subscription_topic = base_topic + "IlluminanceMeasurement/Attributes/LightSensorType/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_illuminance_measurement_light_sensor_type_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for IlluminanceMeasurement
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_illuminance_measurement_attribute_measured_value_callback_set(const uic_mqtt_dotdot_illuminance_measurement_attribute_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_illuminance_measurement_attribute_measured_value_callback = callback;
}
void uic_mqtt_dotdot_illuminance_measurement_attribute_min_measured_value_callback_set(const uic_mqtt_dotdot_illuminance_measurement_attribute_min_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_illuminance_measurement_attribute_min_measured_value_callback = callback;
}
void uic_mqtt_dotdot_illuminance_measurement_attribute_max_measured_value_callback_set(const uic_mqtt_dotdot_illuminance_measurement_attribute_max_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_illuminance_measurement_attribute_max_measured_value_callback = callback;
}
void uic_mqtt_dotdot_illuminance_measurement_attribute_tolerance_callback_set(const uic_mqtt_dotdot_illuminance_measurement_attribute_tolerance_callback_t callback)
{
  uic_mqtt_dotdot_illuminance_measurement_attribute_tolerance_callback = callback;
}
void uic_mqtt_dotdot_illuminance_measurement_attribute_light_sensor_type_callback_set(const uic_mqtt_dotdot_illuminance_measurement_attribute_light_sensor_type_callback_t callback)
{
  uic_mqtt_dotdot_illuminance_measurement_attribute_light_sensor_type_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for IlluminanceLevelSensing
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_illuminance_level_sensing_attribute_level_status_callback_t uic_mqtt_dotdot_illuminance_level_sensing_attribute_level_status_callback = nullptr;
static uic_mqtt_dotdot_illuminance_level_sensing_attribute_light_sensor_type_callback_t uic_mqtt_dotdot_illuminance_level_sensing_attribute_light_sensor_type_callback = nullptr;
static uic_mqtt_dotdot_illuminance_level_sensing_attribute_illuminance_target_level_callback_t uic_mqtt_dotdot_illuminance_level_sensing_attribute_illuminance_target_level_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for IlluminanceLevelSensing
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_illuminance_level_sensing_level_status_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_illuminance_level_sensing_attribute_level_status_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t level_status = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "IlluminanceLevelSensing::LevelStatus: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<IlluminanceLevelSensingLevelStatus>("value", json_payload);
      if (tmp == numeric_limits<IlluminanceLevelSensingLevelStatus>::max()) {
      #ifdef ILLUMINANCE_LEVEL_SENSING_LEVEL_STATUS_ENUM_NAME_AVAILABLE
        tmp = illuminance_level_sensing_level_status_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(LEVEL_STATUS_ENUM_NAME_AVAILABLE)
        tmp = level_status_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      level_status = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_illuminance_level_sensing_attribute_level_status_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    level_status
  );

}
static void uic_mqtt_dotdot_on_illuminance_level_sensing_light_sensor_type_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_illuminance_level_sensing_attribute_light_sensor_type_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t light_sensor_type = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "IlluminanceLevelSensing::LightSensorType: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<IlluminanceLevelSensingLightSensorType>("value", json_payload);
      if (tmp == numeric_limits<IlluminanceLevelSensingLightSensorType>::max()) {
      #ifdef ILLUMINANCE_LEVEL_SENSING_LIGHT_SENSOR_TYPE_ENUM_NAME_AVAILABLE
        tmp = illuminance_level_sensing_light_sensor_type_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(LIGHT_SENSOR_TYPE_ENUM_NAME_AVAILABLE)
        tmp = light_sensor_type_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      light_sensor_type = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_illuminance_level_sensing_attribute_light_sensor_type_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    light_sensor_type
  );

}
static void uic_mqtt_dotdot_on_illuminance_level_sensing_illuminance_target_level_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_illuminance_level_sensing_attribute_illuminance_target_level_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t illuminance_target_level = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "IlluminanceLevelSensing::IlluminanceTargetLevel: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      illuminance_target_level = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_illuminance_level_sensing_attribute_illuminance_target_level_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    illuminance_target_level
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for IlluminanceLevelSensing
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_illuminance_level_sensing_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_illuminance_level_sensing_attribute_level_status_callback) {
    subscription_topic = base_topic + "IlluminanceLevelSensing/Attributes/LevelStatus/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_illuminance_level_sensing_level_status_attribute_update);
  }
  if(uic_mqtt_dotdot_illuminance_level_sensing_attribute_light_sensor_type_callback) {
    subscription_topic = base_topic + "IlluminanceLevelSensing/Attributes/LightSensorType/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_illuminance_level_sensing_light_sensor_type_attribute_update);
  }
  if(uic_mqtt_dotdot_illuminance_level_sensing_attribute_illuminance_target_level_callback) {
    subscription_topic = base_topic + "IlluminanceLevelSensing/Attributes/IlluminanceTargetLevel/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_illuminance_level_sensing_illuminance_target_level_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for IlluminanceLevelSensing
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_illuminance_level_sensing_attribute_level_status_callback_set(const uic_mqtt_dotdot_illuminance_level_sensing_attribute_level_status_callback_t callback)
{
  uic_mqtt_dotdot_illuminance_level_sensing_attribute_level_status_callback = callback;
}
void uic_mqtt_dotdot_illuminance_level_sensing_attribute_light_sensor_type_callback_set(const uic_mqtt_dotdot_illuminance_level_sensing_attribute_light_sensor_type_callback_t callback)
{
  uic_mqtt_dotdot_illuminance_level_sensing_attribute_light_sensor_type_callback = callback;
}
void uic_mqtt_dotdot_illuminance_level_sensing_attribute_illuminance_target_level_callback_set(const uic_mqtt_dotdot_illuminance_level_sensing_attribute_illuminance_target_level_callback_t callback)
{
  uic_mqtt_dotdot_illuminance_level_sensing_attribute_illuminance_target_level_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for TemperatureMeasurement
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_temperature_measurement_attribute_measured_value_callback_t uic_mqtt_dotdot_temperature_measurement_attribute_measured_value_callback = nullptr;
static uic_mqtt_dotdot_temperature_measurement_attribute_min_measured_value_callback_t uic_mqtt_dotdot_temperature_measurement_attribute_min_measured_value_callback = nullptr;
static uic_mqtt_dotdot_temperature_measurement_attribute_max_measured_value_callback_t uic_mqtt_dotdot_temperature_measurement_attribute_max_measured_value_callback = nullptr;
static uic_mqtt_dotdot_temperature_measurement_attribute_tolerance_callback_t uic_mqtt_dotdot_temperature_measurement_attribute_tolerance_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for TemperatureMeasurement
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_temperature_measurement_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_temperature_measurement_attribute_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "TemperatureMeasurement::MeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      measured_value = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_temperature_measurement_attribute_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    measured_value
  );

}
static void uic_mqtt_dotdot_on_temperature_measurement_min_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_temperature_measurement_attribute_min_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t min_measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "TemperatureMeasurement::MinMeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      min_measured_value = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_temperature_measurement_attribute_min_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    min_measured_value
  );

}
static void uic_mqtt_dotdot_on_temperature_measurement_max_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_temperature_measurement_attribute_max_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t max_measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "TemperatureMeasurement::MaxMeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      max_measured_value = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_temperature_measurement_attribute_max_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    max_measured_value
  );

}
static void uic_mqtt_dotdot_on_temperature_measurement_tolerance_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_temperature_measurement_attribute_tolerance_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t tolerance = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "TemperatureMeasurement::Tolerance: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      tolerance = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_temperature_measurement_attribute_tolerance_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    tolerance
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for TemperatureMeasurement
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_temperature_measurement_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_temperature_measurement_attribute_measured_value_callback) {
    subscription_topic = base_topic + "TemperatureMeasurement/Attributes/MeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_temperature_measurement_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_temperature_measurement_attribute_min_measured_value_callback) {
    subscription_topic = base_topic + "TemperatureMeasurement/Attributes/MinMeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_temperature_measurement_min_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_temperature_measurement_attribute_max_measured_value_callback) {
    subscription_topic = base_topic + "TemperatureMeasurement/Attributes/MaxMeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_temperature_measurement_max_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_temperature_measurement_attribute_tolerance_callback) {
    subscription_topic = base_topic + "TemperatureMeasurement/Attributes/Tolerance/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_temperature_measurement_tolerance_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for TemperatureMeasurement
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_temperature_measurement_attribute_measured_value_callback_set(const uic_mqtt_dotdot_temperature_measurement_attribute_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_temperature_measurement_attribute_measured_value_callback = callback;
}
void uic_mqtt_dotdot_temperature_measurement_attribute_min_measured_value_callback_set(const uic_mqtt_dotdot_temperature_measurement_attribute_min_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_temperature_measurement_attribute_min_measured_value_callback = callback;
}
void uic_mqtt_dotdot_temperature_measurement_attribute_max_measured_value_callback_set(const uic_mqtt_dotdot_temperature_measurement_attribute_max_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_temperature_measurement_attribute_max_measured_value_callback = callback;
}
void uic_mqtt_dotdot_temperature_measurement_attribute_tolerance_callback_set(const uic_mqtt_dotdot_temperature_measurement_attribute_tolerance_callback_t callback)
{
  uic_mqtt_dotdot_temperature_measurement_attribute_tolerance_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for PressureMeasurement
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_pressure_measurement_attribute_measured_value_callback_t uic_mqtt_dotdot_pressure_measurement_attribute_measured_value_callback = nullptr;
static uic_mqtt_dotdot_pressure_measurement_attribute_min_measured_value_callback_t uic_mqtt_dotdot_pressure_measurement_attribute_min_measured_value_callback = nullptr;
static uic_mqtt_dotdot_pressure_measurement_attribute_max_measured_value_callback_t uic_mqtt_dotdot_pressure_measurement_attribute_max_measured_value_callback = nullptr;
static uic_mqtt_dotdot_pressure_measurement_attribute_tolerance_callback_t uic_mqtt_dotdot_pressure_measurement_attribute_tolerance_callback = nullptr;
static uic_mqtt_dotdot_pressure_measurement_attribute_scaled_value_callback_t uic_mqtt_dotdot_pressure_measurement_attribute_scaled_value_callback = nullptr;
static uic_mqtt_dotdot_pressure_measurement_attribute_min_scaled_value_callback_t uic_mqtt_dotdot_pressure_measurement_attribute_min_scaled_value_callback = nullptr;
static uic_mqtt_dotdot_pressure_measurement_attribute_max_scaled_value_callback_t uic_mqtt_dotdot_pressure_measurement_attribute_max_scaled_value_callback = nullptr;
static uic_mqtt_dotdot_pressure_measurement_attribute_scaled_tolerance_callback_t uic_mqtt_dotdot_pressure_measurement_attribute_scaled_tolerance_callback = nullptr;
static uic_mqtt_dotdot_pressure_measurement_attribute_scale_callback_t uic_mqtt_dotdot_pressure_measurement_attribute_scale_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for PressureMeasurement
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_pressure_measurement_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pressure_measurement_attribute_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PressureMeasurement::MeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      measured_value = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pressure_measurement_attribute_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    measured_value
  );

}
static void uic_mqtt_dotdot_on_pressure_measurement_min_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pressure_measurement_attribute_min_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t min_measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PressureMeasurement::MinMeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      min_measured_value = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pressure_measurement_attribute_min_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    min_measured_value
  );

}
static void uic_mqtt_dotdot_on_pressure_measurement_max_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pressure_measurement_attribute_max_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t max_measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PressureMeasurement::MaxMeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      max_measured_value = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pressure_measurement_attribute_max_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    max_measured_value
  );

}
static void uic_mqtt_dotdot_on_pressure_measurement_tolerance_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pressure_measurement_attribute_tolerance_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t tolerance = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PressureMeasurement::Tolerance: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      tolerance = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pressure_measurement_attribute_tolerance_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    tolerance
  );

}
static void uic_mqtt_dotdot_on_pressure_measurement_scaled_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pressure_measurement_attribute_scaled_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t scaled_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PressureMeasurement::ScaledValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      scaled_value = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pressure_measurement_attribute_scaled_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    scaled_value
  );

}
static void uic_mqtt_dotdot_on_pressure_measurement_min_scaled_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pressure_measurement_attribute_min_scaled_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t min_scaled_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PressureMeasurement::MinScaledValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      min_scaled_value = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pressure_measurement_attribute_min_scaled_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    min_scaled_value
  );

}
static void uic_mqtt_dotdot_on_pressure_measurement_max_scaled_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pressure_measurement_attribute_max_scaled_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t max_scaled_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PressureMeasurement::MaxScaledValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      max_scaled_value = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pressure_measurement_attribute_max_scaled_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    max_scaled_value
  );

}
static void uic_mqtt_dotdot_on_pressure_measurement_scaled_tolerance_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pressure_measurement_attribute_scaled_tolerance_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t scaled_tolerance = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PressureMeasurement::ScaledTolerance: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      scaled_tolerance = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pressure_measurement_attribute_scaled_tolerance_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    scaled_tolerance
  );

}
static void uic_mqtt_dotdot_on_pressure_measurement_scale_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pressure_measurement_attribute_scale_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int8_t scale = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PressureMeasurement::Scale: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      scale = json_payload.at("value").get<int8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pressure_measurement_attribute_scale_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    scale
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for PressureMeasurement
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_pressure_measurement_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_pressure_measurement_attribute_measured_value_callback) {
    subscription_topic = base_topic + "PressureMeasurement/Attributes/MeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pressure_measurement_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_pressure_measurement_attribute_min_measured_value_callback) {
    subscription_topic = base_topic + "PressureMeasurement/Attributes/MinMeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pressure_measurement_min_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_pressure_measurement_attribute_max_measured_value_callback) {
    subscription_topic = base_topic + "PressureMeasurement/Attributes/MaxMeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pressure_measurement_max_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_pressure_measurement_attribute_tolerance_callback) {
    subscription_topic = base_topic + "PressureMeasurement/Attributes/Tolerance/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pressure_measurement_tolerance_attribute_update);
  }
  if(uic_mqtt_dotdot_pressure_measurement_attribute_scaled_value_callback) {
    subscription_topic = base_topic + "PressureMeasurement/Attributes/ScaledValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pressure_measurement_scaled_value_attribute_update);
  }
  if(uic_mqtt_dotdot_pressure_measurement_attribute_min_scaled_value_callback) {
    subscription_topic = base_topic + "PressureMeasurement/Attributes/MinScaledValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pressure_measurement_min_scaled_value_attribute_update);
  }
  if(uic_mqtt_dotdot_pressure_measurement_attribute_max_scaled_value_callback) {
    subscription_topic = base_topic + "PressureMeasurement/Attributes/MaxScaledValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pressure_measurement_max_scaled_value_attribute_update);
  }
  if(uic_mqtt_dotdot_pressure_measurement_attribute_scaled_tolerance_callback) {
    subscription_topic = base_topic + "PressureMeasurement/Attributes/ScaledTolerance/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pressure_measurement_scaled_tolerance_attribute_update);
  }
  if(uic_mqtt_dotdot_pressure_measurement_attribute_scale_callback) {
    subscription_topic = base_topic + "PressureMeasurement/Attributes/Scale/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pressure_measurement_scale_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for PressureMeasurement
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_pressure_measurement_attribute_measured_value_callback_set(const uic_mqtt_dotdot_pressure_measurement_attribute_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_pressure_measurement_attribute_measured_value_callback = callback;
}
void uic_mqtt_dotdot_pressure_measurement_attribute_min_measured_value_callback_set(const uic_mqtt_dotdot_pressure_measurement_attribute_min_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_pressure_measurement_attribute_min_measured_value_callback = callback;
}
void uic_mqtt_dotdot_pressure_measurement_attribute_max_measured_value_callback_set(const uic_mqtt_dotdot_pressure_measurement_attribute_max_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_pressure_measurement_attribute_max_measured_value_callback = callback;
}
void uic_mqtt_dotdot_pressure_measurement_attribute_tolerance_callback_set(const uic_mqtt_dotdot_pressure_measurement_attribute_tolerance_callback_t callback)
{
  uic_mqtt_dotdot_pressure_measurement_attribute_tolerance_callback = callback;
}
void uic_mqtt_dotdot_pressure_measurement_attribute_scaled_value_callback_set(const uic_mqtt_dotdot_pressure_measurement_attribute_scaled_value_callback_t callback)
{
  uic_mqtt_dotdot_pressure_measurement_attribute_scaled_value_callback = callback;
}
void uic_mqtt_dotdot_pressure_measurement_attribute_min_scaled_value_callback_set(const uic_mqtt_dotdot_pressure_measurement_attribute_min_scaled_value_callback_t callback)
{
  uic_mqtt_dotdot_pressure_measurement_attribute_min_scaled_value_callback = callback;
}
void uic_mqtt_dotdot_pressure_measurement_attribute_max_scaled_value_callback_set(const uic_mqtt_dotdot_pressure_measurement_attribute_max_scaled_value_callback_t callback)
{
  uic_mqtt_dotdot_pressure_measurement_attribute_max_scaled_value_callback = callback;
}
void uic_mqtt_dotdot_pressure_measurement_attribute_scaled_tolerance_callback_set(const uic_mqtt_dotdot_pressure_measurement_attribute_scaled_tolerance_callback_t callback)
{
  uic_mqtt_dotdot_pressure_measurement_attribute_scaled_tolerance_callback = callback;
}
void uic_mqtt_dotdot_pressure_measurement_attribute_scale_callback_set(const uic_mqtt_dotdot_pressure_measurement_attribute_scale_callback_t callback)
{
  uic_mqtt_dotdot_pressure_measurement_attribute_scale_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for FlowMeasurement
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_flow_measurement_attribute_measured_value_callback_t uic_mqtt_dotdot_flow_measurement_attribute_measured_value_callback = nullptr;
static uic_mqtt_dotdot_flow_measurement_attribute_min_measured_value_callback_t uic_mqtt_dotdot_flow_measurement_attribute_min_measured_value_callback = nullptr;
static uic_mqtt_dotdot_flow_measurement_attribute_max_measured_value_callback_t uic_mqtt_dotdot_flow_measurement_attribute_max_measured_value_callback = nullptr;
static uic_mqtt_dotdot_flow_measurement_attribute_tolerance_callback_t uic_mqtt_dotdot_flow_measurement_attribute_tolerance_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for FlowMeasurement
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_flow_measurement_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_flow_measurement_attribute_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "FlowMeasurement::MeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      measured_value = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_flow_measurement_attribute_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    measured_value
  );

}
static void uic_mqtt_dotdot_on_flow_measurement_min_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_flow_measurement_attribute_min_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t min_measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "FlowMeasurement::MinMeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      min_measured_value = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_flow_measurement_attribute_min_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    min_measured_value
  );

}
static void uic_mqtt_dotdot_on_flow_measurement_max_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_flow_measurement_attribute_max_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t max_measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "FlowMeasurement::MaxMeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      max_measured_value = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_flow_measurement_attribute_max_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    max_measured_value
  );

}
static void uic_mqtt_dotdot_on_flow_measurement_tolerance_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_flow_measurement_attribute_tolerance_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t tolerance = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "FlowMeasurement::Tolerance: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      tolerance = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_flow_measurement_attribute_tolerance_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    tolerance
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for FlowMeasurement
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_flow_measurement_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_flow_measurement_attribute_measured_value_callback) {
    subscription_topic = base_topic + "FlowMeasurement/Attributes/MeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_flow_measurement_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_flow_measurement_attribute_min_measured_value_callback) {
    subscription_topic = base_topic + "FlowMeasurement/Attributes/MinMeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_flow_measurement_min_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_flow_measurement_attribute_max_measured_value_callback) {
    subscription_topic = base_topic + "FlowMeasurement/Attributes/MaxMeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_flow_measurement_max_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_flow_measurement_attribute_tolerance_callback) {
    subscription_topic = base_topic + "FlowMeasurement/Attributes/Tolerance/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_flow_measurement_tolerance_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for FlowMeasurement
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_flow_measurement_attribute_measured_value_callback_set(const uic_mqtt_dotdot_flow_measurement_attribute_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_flow_measurement_attribute_measured_value_callback = callback;
}
void uic_mqtt_dotdot_flow_measurement_attribute_min_measured_value_callback_set(const uic_mqtt_dotdot_flow_measurement_attribute_min_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_flow_measurement_attribute_min_measured_value_callback = callback;
}
void uic_mqtt_dotdot_flow_measurement_attribute_max_measured_value_callback_set(const uic_mqtt_dotdot_flow_measurement_attribute_max_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_flow_measurement_attribute_max_measured_value_callback = callback;
}
void uic_mqtt_dotdot_flow_measurement_attribute_tolerance_callback_set(const uic_mqtt_dotdot_flow_measurement_attribute_tolerance_callback_t callback)
{
  uic_mqtt_dotdot_flow_measurement_attribute_tolerance_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for RelativityHumidity
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_relativity_humidity_attribute_measured_value_callback_t uic_mqtt_dotdot_relativity_humidity_attribute_measured_value_callback = nullptr;
static uic_mqtt_dotdot_relativity_humidity_attribute_min_measured_value_callback_t uic_mqtt_dotdot_relativity_humidity_attribute_min_measured_value_callback = nullptr;
static uic_mqtt_dotdot_relativity_humidity_attribute_max_measured_value_callback_t uic_mqtt_dotdot_relativity_humidity_attribute_max_measured_value_callback = nullptr;
static uic_mqtt_dotdot_relativity_humidity_attribute_tolerance_callback_t uic_mqtt_dotdot_relativity_humidity_attribute_tolerance_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for RelativityHumidity
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_relativity_humidity_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_relativity_humidity_attribute_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "RelativityHumidity::MeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      measured_value = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_relativity_humidity_attribute_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    measured_value
  );

}
static void uic_mqtt_dotdot_on_relativity_humidity_min_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_relativity_humidity_attribute_min_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t min_measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "RelativityHumidity::MinMeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      min_measured_value = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_relativity_humidity_attribute_min_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    min_measured_value
  );

}
static void uic_mqtt_dotdot_on_relativity_humidity_max_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_relativity_humidity_attribute_max_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t max_measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "RelativityHumidity::MaxMeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      max_measured_value = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_relativity_humidity_attribute_max_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    max_measured_value
  );

}
static void uic_mqtt_dotdot_on_relativity_humidity_tolerance_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_relativity_humidity_attribute_tolerance_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t tolerance = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "RelativityHumidity::Tolerance: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      tolerance = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_relativity_humidity_attribute_tolerance_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    tolerance
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for RelativityHumidity
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_relativity_humidity_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_relativity_humidity_attribute_measured_value_callback) {
    subscription_topic = base_topic + "RelativityHumidity/Attributes/MeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_relativity_humidity_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_relativity_humidity_attribute_min_measured_value_callback) {
    subscription_topic = base_topic + "RelativityHumidity/Attributes/MinMeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_relativity_humidity_min_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_relativity_humidity_attribute_max_measured_value_callback) {
    subscription_topic = base_topic + "RelativityHumidity/Attributes/MaxMeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_relativity_humidity_max_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_relativity_humidity_attribute_tolerance_callback) {
    subscription_topic = base_topic + "RelativityHumidity/Attributes/Tolerance/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_relativity_humidity_tolerance_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for RelativityHumidity
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_relativity_humidity_attribute_measured_value_callback_set(const uic_mqtt_dotdot_relativity_humidity_attribute_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_relativity_humidity_attribute_measured_value_callback = callback;
}
void uic_mqtt_dotdot_relativity_humidity_attribute_min_measured_value_callback_set(const uic_mqtt_dotdot_relativity_humidity_attribute_min_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_relativity_humidity_attribute_min_measured_value_callback = callback;
}
void uic_mqtt_dotdot_relativity_humidity_attribute_max_measured_value_callback_set(const uic_mqtt_dotdot_relativity_humidity_attribute_max_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_relativity_humidity_attribute_max_measured_value_callback = callback;
}
void uic_mqtt_dotdot_relativity_humidity_attribute_tolerance_callback_set(const uic_mqtt_dotdot_relativity_humidity_attribute_tolerance_callback_t callback)
{
  uic_mqtt_dotdot_relativity_humidity_attribute_tolerance_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for OccupancySensing
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_occupancy_sensing_attribute_occupancy_callback_t uic_mqtt_dotdot_occupancy_sensing_attribute_occupancy_callback = nullptr;
static uic_mqtt_dotdot_occupancy_sensing_attribute_occupancy_sensor_type_callback_t uic_mqtt_dotdot_occupancy_sensing_attribute_occupancy_sensor_type_callback = nullptr;
static uic_mqtt_dotdot_occupancy_sensing_attribute_occupancy_sensor_type_bitmap_callback_t uic_mqtt_dotdot_occupancy_sensing_attribute_occupancy_sensor_type_bitmap_callback = nullptr;
static uic_mqtt_dotdot_occupancy_sensing_attribute_pir_occupied_to_unoccupied_delay_callback_t uic_mqtt_dotdot_occupancy_sensing_attribute_pir_occupied_to_unoccupied_delay_callback = nullptr;
static uic_mqtt_dotdot_occupancy_sensing_attribute_pir_unoccupied_to_occupied_delay_callback_t uic_mqtt_dotdot_occupancy_sensing_attribute_pir_unoccupied_to_occupied_delay_callback = nullptr;
static uic_mqtt_dotdot_occupancy_sensing_attribute_pir_unoccupied_to_occupied_threshold_callback_t uic_mqtt_dotdot_occupancy_sensing_attribute_pir_unoccupied_to_occupied_threshold_callback = nullptr;
static uic_mqtt_dotdot_occupancy_sensing_attribute_ultrasonic_occupied_to_unoccupied_delay_callback_t uic_mqtt_dotdot_occupancy_sensing_attribute_ultrasonic_occupied_to_unoccupied_delay_callback = nullptr;
static uic_mqtt_dotdot_occupancy_sensing_attribute_ultrasonic_unoccupied_to_occupied_delay_callback_t uic_mqtt_dotdot_occupancy_sensing_attribute_ultrasonic_unoccupied_to_occupied_delay_callback = nullptr;
static uic_mqtt_dotdot_occupancy_sensing_attribute_ultrasonic_unoccupied_to_occupied_threshold_callback_t uic_mqtt_dotdot_occupancy_sensing_attribute_ultrasonic_unoccupied_to_occupied_threshold_callback = nullptr;
static uic_mqtt_dotdot_occupancy_sensing_attribute_physical_contact_occupied_to_unoccupied_delay_callback_t uic_mqtt_dotdot_occupancy_sensing_attribute_physical_contact_occupied_to_unoccupied_delay_callback = nullptr;
static uic_mqtt_dotdot_occupancy_sensing_attribute_physical_contact_unoccupied_to_occupied_delay_callback_t uic_mqtt_dotdot_occupancy_sensing_attribute_physical_contact_unoccupied_to_occupied_delay_callback = nullptr;
static uic_mqtt_dotdot_occupancy_sensing_attribute_physical_contact_unoccupied_to_occupied_threshold_callback_t uic_mqtt_dotdot_occupancy_sensing_attribute_physical_contact_unoccupied_to_occupied_threshold_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for OccupancySensing
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_occupancy_sensing_occupancy_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_occupancy_sensing_attribute_occupancy_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t occupancy = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "OccupancySensing::Occupancy: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      occupancy = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, OccupancySensingOccupancy);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_occupancy_sensing_attribute_occupancy_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    occupancy
  );

}
static void uic_mqtt_dotdot_on_occupancy_sensing_occupancy_sensor_type_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_occupancy_sensing_attribute_occupancy_sensor_type_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t occupancy_sensor_type = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "OccupancySensing::OccupancySensorType: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<OccupancySensingOccupancySensorType>("value", json_payload);
      if (tmp == numeric_limits<OccupancySensingOccupancySensorType>::max()) {
      #ifdef OCCUPANCY_SENSING_OCCUPANCY_SENSOR_TYPE_ENUM_NAME_AVAILABLE
        tmp = occupancy_sensing_occupancy_sensor_type_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(OCCUPANCY_SENSOR_TYPE_ENUM_NAME_AVAILABLE)
        tmp = occupancy_sensor_type_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      occupancy_sensor_type = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_occupancy_sensing_attribute_occupancy_sensor_type_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    occupancy_sensor_type
  );

}
static void uic_mqtt_dotdot_on_occupancy_sensing_occupancy_sensor_type_bitmap_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_occupancy_sensing_attribute_occupancy_sensor_type_bitmap_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t occupancy_sensor_type_bitmap = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "OccupancySensing::OccupancySensorTypeBitmap: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      occupancy_sensor_type_bitmap = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, OccupancySensingOccupancySensorTypeBitmap);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_occupancy_sensing_attribute_occupancy_sensor_type_bitmap_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    occupancy_sensor_type_bitmap
  );

}
static void uic_mqtt_dotdot_on_occupancy_sensing_pir_occupied_to_unoccupied_delay_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_occupancy_sensing_attribute_pir_occupied_to_unoccupied_delay_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t pir_occupied_to_unoccupied_delay = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "OccupancySensing::PIROccupiedToUnoccupiedDelay: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      pir_occupied_to_unoccupied_delay = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_occupancy_sensing_attribute_pir_occupied_to_unoccupied_delay_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    pir_occupied_to_unoccupied_delay
  );

}
static void uic_mqtt_dotdot_on_occupancy_sensing_pir_unoccupied_to_occupied_delay_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_occupancy_sensing_attribute_pir_unoccupied_to_occupied_delay_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t pir_unoccupied_to_occupied_delay = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "OccupancySensing::PIRUnoccupiedToOccupiedDelay: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      pir_unoccupied_to_occupied_delay = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_occupancy_sensing_attribute_pir_unoccupied_to_occupied_delay_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    pir_unoccupied_to_occupied_delay
  );

}
static void uic_mqtt_dotdot_on_occupancy_sensing_pir_unoccupied_to_occupied_threshold_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_occupancy_sensing_attribute_pir_unoccupied_to_occupied_threshold_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t pir_unoccupied_to_occupied_threshold = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "OccupancySensing::PIRUnoccupiedToOccupiedThreshold: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      pir_unoccupied_to_occupied_threshold = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_occupancy_sensing_attribute_pir_unoccupied_to_occupied_threshold_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    pir_unoccupied_to_occupied_threshold
  );

}
static void uic_mqtt_dotdot_on_occupancy_sensing_ultrasonic_occupied_to_unoccupied_delay_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_occupancy_sensing_attribute_ultrasonic_occupied_to_unoccupied_delay_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t ultrasonic_occupied_to_unoccupied_delay = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "OccupancySensing::UltrasonicOccupiedToUnoccupiedDelay: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      ultrasonic_occupied_to_unoccupied_delay = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_occupancy_sensing_attribute_ultrasonic_occupied_to_unoccupied_delay_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    ultrasonic_occupied_to_unoccupied_delay
  );

}
static void uic_mqtt_dotdot_on_occupancy_sensing_ultrasonic_unoccupied_to_occupied_delay_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_occupancy_sensing_attribute_ultrasonic_unoccupied_to_occupied_delay_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t ultrasonic_unoccupied_to_occupied_delay = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "OccupancySensing::UltrasonicUnoccupiedToOccupiedDelay: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      ultrasonic_unoccupied_to_occupied_delay = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_occupancy_sensing_attribute_ultrasonic_unoccupied_to_occupied_delay_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    ultrasonic_unoccupied_to_occupied_delay
  );

}
static void uic_mqtt_dotdot_on_occupancy_sensing_ultrasonic_unoccupied_to_occupied_threshold_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_occupancy_sensing_attribute_ultrasonic_unoccupied_to_occupied_threshold_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t ultrasonic_unoccupied_to_occupied_threshold = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "OccupancySensing::UltrasonicUnoccupiedToOccupiedThreshold: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      ultrasonic_unoccupied_to_occupied_threshold = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_occupancy_sensing_attribute_ultrasonic_unoccupied_to_occupied_threshold_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    ultrasonic_unoccupied_to_occupied_threshold
  );

}
static void uic_mqtt_dotdot_on_occupancy_sensing_physical_contact_occupied_to_unoccupied_delay_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_occupancy_sensing_attribute_physical_contact_occupied_to_unoccupied_delay_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t physical_contact_occupied_to_unoccupied_delay = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "OccupancySensing::PhysicalContactOccupiedToUnoccupiedDelay: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      physical_contact_occupied_to_unoccupied_delay = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_occupancy_sensing_attribute_physical_contact_occupied_to_unoccupied_delay_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    physical_contact_occupied_to_unoccupied_delay
  );

}
static void uic_mqtt_dotdot_on_occupancy_sensing_physical_contact_unoccupied_to_occupied_delay_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_occupancy_sensing_attribute_physical_contact_unoccupied_to_occupied_delay_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t physical_contact_unoccupied_to_occupied_delay = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "OccupancySensing::PhysicalContactUnoccupiedToOccupiedDelay: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      physical_contact_unoccupied_to_occupied_delay = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_occupancy_sensing_attribute_physical_contact_unoccupied_to_occupied_delay_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    physical_contact_unoccupied_to_occupied_delay
  );

}
static void uic_mqtt_dotdot_on_occupancy_sensing_physical_contact_unoccupied_to_occupied_threshold_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_occupancy_sensing_attribute_physical_contact_unoccupied_to_occupied_threshold_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t physical_contact_unoccupied_to_occupied_threshold = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "OccupancySensing::PhysicalContactUnoccupiedToOccupiedThreshold: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      physical_contact_unoccupied_to_occupied_threshold = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_occupancy_sensing_attribute_physical_contact_unoccupied_to_occupied_threshold_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    physical_contact_unoccupied_to_occupied_threshold
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for OccupancySensing
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_occupancy_sensing_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_occupancy_sensing_attribute_occupancy_callback) {
    subscription_topic = base_topic + "OccupancySensing/Attributes/Occupancy/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_occupancy_sensing_occupancy_attribute_update);
  }
  if(uic_mqtt_dotdot_occupancy_sensing_attribute_occupancy_sensor_type_callback) {
    subscription_topic = base_topic + "OccupancySensing/Attributes/OccupancySensorType/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_occupancy_sensing_occupancy_sensor_type_attribute_update);
  }
  if(uic_mqtt_dotdot_occupancy_sensing_attribute_occupancy_sensor_type_bitmap_callback) {
    subscription_topic = base_topic + "OccupancySensing/Attributes/OccupancySensorTypeBitmap/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_occupancy_sensing_occupancy_sensor_type_bitmap_attribute_update);
  }
  if(uic_mqtt_dotdot_occupancy_sensing_attribute_pir_occupied_to_unoccupied_delay_callback) {
    subscription_topic = base_topic + "OccupancySensing/Attributes/PIROccupiedToUnoccupiedDelay/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_occupancy_sensing_pir_occupied_to_unoccupied_delay_attribute_update);
  }
  if(uic_mqtt_dotdot_occupancy_sensing_attribute_pir_unoccupied_to_occupied_delay_callback) {
    subscription_topic = base_topic + "OccupancySensing/Attributes/PIRUnoccupiedToOccupiedDelay/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_occupancy_sensing_pir_unoccupied_to_occupied_delay_attribute_update);
  }
  if(uic_mqtt_dotdot_occupancy_sensing_attribute_pir_unoccupied_to_occupied_threshold_callback) {
    subscription_topic = base_topic + "OccupancySensing/Attributes/PIRUnoccupiedToOccupiedThreshold/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_occupancy_sensing_pir_unoccupied_to_occupied_threshold_attribute_update);
  }
  if(uic_mqtt_dotdot_occupancy_sensing_attribute_ultrasonic_occupied_to_unoccupied_delay_callback) {
    subscription_topic = base_topic + "OccupancySensing/Attributes/UltrasonicOccupiedToUnoccupiedDelay/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_occupancy_sensing_ultrasonic_occupied_to_unoccupied_delay_attribute_update);
  }
  if(uic_mqtt_dotdot_occupancy_sensing_attribute_ultrasonic_unoccupied_to_occupied_delay_callback) {
    subscription_topic = base_topic + "OccupancySensing/Attributes/UltrasonicUnoccupiedToOccupiedDelay/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_occupancy_sensing_ultrasonic_unoccupied_to_occupied_delay_attribute_update);
  }
  if(uic_mqtt_dotdot_occupancy_sensing_attribute_ultrasonic_unoccupied_to_occupied_threshold_callback) {
    subscription_topic = base_topic + "OccupancySensing/Attributes/UltrasonicUnoccupiedToOccupiedThreshold/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_occupancy_sensing_ultrasonic_unoccupied_to_occupied_threshold_attribute_update);
  }
  if(uic_mqtt_dotdot_occupancy_sensing_attribute_physical_contact_occupied_to_unoccupied_delay_callback) {
    subscription_topic = base_topic + "OccupancySensing/Attributes/PhysicalContactOccupiedToUnoccupiedDelay/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_occupancy_sensing_physical_contact_occupied_to_unoccupied_delay_attribute_update);
  }
  if(uic_mqtt_dotdot_occupancy_sensing_attribute_physical_contact_unoccupied_to_occupied_delay_callback) {
    subscription_topic = base_topic + "OccupancySensing/Attributes/PhysicalContactUnoccupiedToOccupiedDelay/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_occupancy_sensing_physical_contact_unoccupied_to_occupied_delay_attribute_update);
  }
  if(uic_mqtt_dotdot_occupancy_sensing_attribute_physical_contact_unoccupied_to_occupied_threshold_callback) {
    subscription_topic = base_topic + "OccupancySensing/Attributes/PhysicalContactUnoccupiedToOccupiedThreshold/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_occupancy_sensing_physical_contact_unoccupied_to_occupied_threshold_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for OccupancySensing
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_occupancy_sensing_attribute_occupancy_callback_set(const uic_mqtt_dotdot_occupancy_sensing_attribute_occupancy_callback_t callback)
{
  uic_mqtt_dotdot_occupancy_sensing_attribute_occupancy_callback = callback;
}
void uic_mqtt_dotdot_occupancy_sensing_attribute_occupancy_sensor_type_callback_set(const uic_mqtt_dotdot_occupancy_sensing_attribute_occupancy_sensor_type_callback_t callback)
{
  uic_mqtt_dotdot_occupancy_sensing_attribute_occupancy_sensor_type_callback = callback;
}
void uic_mqtt_dotdot_occupancy_sensing_attribute_occupancy_sensor_type_bitmap_callback_set(const uic_mqtt_dotdot_occupancy_sensing_attribute_occupancy_sensor_type_bitmap_callback_t callback)
{
  uic_mqtt_dotdot_occupancy_sensing_attribute_occupancy_sensor_type_bitmap_callback = callback;
}
void uic_mqtt_dotdot_occupancy_sensing_attribute_pir_occupied_to_unoccupied_delay_callback_set(const uic_mqtt_dotdot_occupancy_sensing_attribute_pir_occupied_to_unoccupied_delay_callback_t callback)
{
  uic_mqtt_dotdot_occupancy_sensing_attribute_pir_occupied_to_unoccupied_delay_callback = callback;
}
void uic_mqtt_dotdot_occupancy_sensing_attribute_pir_unoccupied_to_occupied_delay_callback_set(const uic_mqtt_dotdot_occupancy_sensing_attribute_pir_unoccupied_to_occupied_delay_callback_t callback)
{
  uic_mqtt_dotdot_occupancy_sensing_attribute_pir_unoccupied_to_occupied_delay_callback = callback;
}
void uic_mqtt_dotdot_occupancy_sensing_attribute_pir_unoccupied_to_occupied_threshold_callback_set(const uic_mqtt_dotdot_occupancy_sensing_attribute_pir_unoccupied_to_occupied_threshold_callback_t callback)
{
  uic_mqtt_dotdot_occupancy_sensing_attribute_pir_unoccupied_to_occupied_threshold_callback = callback;
}
void uic_mqtt_dotdot_occupancy_sensing_attribute_ultrasonic_occupied_to_unoccupied_delay_callback_set(const uic_mqtt_dotdot_occupancy_sensing_attribute_ultrasonic_occupied_to_unoccupied_delay_callback_t callback)
{
  uic_mqtt_dotdot_occupancy_sensing_attribute_ultrasonic_occupied_to_unoccupied_delay_callback = callback;
}
void uic_mqtt_dotdot_occupancy_sensing_attribute_ultrasonic_unoccupied_to_occupied_delay_callback_set(const uic_mqtt_dotdot_occupancy_sensing_attribute_ultrasonic_unoccupied_to_occupied_delay_callback_t callback)
{
  uic_mqtt_dotdot_occupancy_sensing_attribute_ultrasonic_unoccupied_to_occupied_delay_callback = callback;
}
void uic_mqtt_dotdot_occupancy_sensing_attribute_ultrasonic_unoccupied_to_occupied_threshold_callback_set(const uic_mqtt_dotdot_occupancy_sensing_attribute_ultrasonic_unoccupied_to_occupied_threshold_callback_t callback)
{
  uic_mqtt_dotdot_occupancy_sensing_attribute_ultrasonic_unoccupied_to_occupied_threshold_callback = callback;
}
void uic_mqtt_dotdot_occupancy_sensing_attribute_physical_contact_occupied_to_unoccupied_delay_callback_set(const uic_mqtt_dotdot_occupancy_sensing_attribute_physical_contact_occupied_to_unoccupied_delay_callback_t callback)
{
  uic_mqtt_dotdot_occupancy_sensing_attribute_physical_contact_occupied_to_unoccupied_delay_callback = callback;
}
void uic_mqtt_dotdot_occupancy_sensing_attribute_physical_contact_unoccupied_to_occupied_delay_callback_set(const uic_mqtt_dotdot_occupancy_sensing_attribute_physical_contact_unoccupied_to_occupied_delay_callback_t callback)
{
  uic_mqtt_dotdot_occupancy_sensing_attribute_physical_contact_unoccupied_to_occupied_delay_callback = callback;
}
void uic_mqtt_dotdot_occupancy_sensing_attribute_physical_contact_unoccupied_to_occupied_threshold_callback_set(const uic_mqtt_dotdot_occupancy_sensing_attribute_physical_contact_unoccupied_to_occupied_threshold_callback_t callback)
{
  uic_mqtt_dotdot_occupancy_sensing_attribute_physical_contact_unoccupied_to_occupied_threshold_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for SoilMoisture
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_soil_moisture_attribute_measured_value_callback_t uic_mqtt_dotdot_soil_moisture_attribute_measured_value_callback = nullptr;
static uic_mqtt_dotdot_soil_moisture_attribute_min_measured_value_callback_t uic_mqtt_dotdot_soil_moisture_attribute_min_measured_value_callback = nullptr;
static uic_mqtt_dotdot_soil_moisture_attribute_max_measured_value_callback_t uic_mqtt_dotdot_soil_moisture_attribute_max_measured_value_callback = nullptr;
static uic_mqtt_dotdot_soil_moisture_attribute_tolerance_callback_t uic_mqtt_dotdot_soil_moisture_attribute_tolerance_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for SoilMoisture
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_soil_moisture_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_soil_moisture_attribute_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "SoilMoisture::MeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      measured_value = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_soil_moisture_attribute_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    measured_value
  );

}
static void uic_mqtt_dotdot_on_soil_moisture_min_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_soil_moisture_attribute_min_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t min_measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "SoilMoisture::MinMeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      min_measured_value = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_soil_moisture_attribute_min_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    min_measured_value
  );

}
static void uic_mqtt_dotdot_on_soil_moisture_max_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_soil_moisture_attribute_max_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t max_measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "SoilMoisture::MaxMeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      max_measured_value = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_soil_moisture_attribute_max_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    max_measured_value
  );

}
static void uic_mqtt_dotdot_on_soil_moisture_tolerance_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_soil_moisture_attribute_tolerance_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t tolerance = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "SoilMoisture::Tolerance: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      tolerance = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_soil_moisture_attribute_tolerance_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    tolerance
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for SoilMoisture
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_soil_moisture_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_soil_moisture_attribute_measured_value_callback) {
    subscription_topic = base_topic + "SoilMoisture/Attributes/MeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_soil_moisture_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_soil_moisture_attribute_min_measured_value_callback) {
    subscription_topic = base_topic + "SoilMoisture/Attributes/MinMeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_soil_moisture_min_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_soil_moisture_attribute_max_measured_value_callback) {
    subscription_topic = base_topic + "SoilMoisture/Attributes/MaxMeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_soil_moisture_max_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_soil_moisture_attribute_tolerance_callback) {
    subscription_topic = base_topic + "SoilMoisture/Attributes/Tolerance/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_soil_moisture_tolerance_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for SoilMoisture
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_soil_moisture_attribute_measured_value_callback_set(const uic_mqtt_dotdot_soil_moisture_attribute_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_soil_moisture_attribute_measured_value_callback = callback;
}
void uic_mqtt_dotdot_soil_moisture_attribute_min_measured_value_callback_set(const uic_mqtt_dotdot_soil_moisture_attribute_min_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_soil_moisture_attribute_min_measured_value_callback = callback;
}
void uic_mqtt_dotdot_soil_moisture_attribute_max_measured_value_callback_set(const uic_mqtt_dotdot_soil_moisture_attribute_max_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_soil_moisture_attribute_max_measured_value_callback = callback;
}
void uic_mqtt_dotdot_soil_moisture_attribute_tolerance_callback_set(const uic_mqtt_dotdot_soil_moisture_attribute_tolerance_callback_t callback)
{
  uic_mqtt_dotdot_soil_moisture_attribute_tolerance_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for PhMeasurement
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_ph_measurement_attribute_measured_value_callback_t uic_mqtt_dotdot_ph_measurement_attribute_measured_value_callback = nullptr;
static uic_mqtt_dotdot_ph_measurement_attribute_min_measured_value_callback_t uic_mqtt_dotdot_ph_measurement_attribute_min_measured_value_callback = nullptr;
static uic_mqtt_dotdot_ph_measurement_attribute_max_measured_value_callback_t uic_mqtt_dotdot_ph_measurement_attribute_max_measured_value_callback = nullptr;
static uic_mqtt_dotdot_ph_measurement_attribute_tolerance_callback_t uic_mqtt_dotdot_ph_measurement_attribute_tolerance_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for PhMeasurement
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_ph_measurement_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_ph_measurement_attribute_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PhMeasurement::MeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      measured_value = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_ph_measurement_attribute_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    measured_value
  );

}
static void uic_mqtt_dotdot_on_ph_measurement_min_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_ph_measurement_attribute_min_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t min_measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PhMeasurement::MinMeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      min_measured_value = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_ph_measurement_attribute_min_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    min_measured_value
  );

}
static void uic_mqtt_dotdot_on_ph_measurement_max_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_ph_measurement_attribute_max_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t max_measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PhMeasurement::MaxMeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      max_measured_value = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_ph_measurement_attribute_max_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    max_measured_value
  );

}
static void uic_mqtt_dotdot_on_ph_measurement_tolerance_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_ph_measurement_attribute_tolerance_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t tolerance = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PhMeasurement::Tolerance: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      tolerance = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_ph_measurement_attribute_tolerance_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    tolerance
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for PhMeasurement
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_ph_measurement_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_ph_measurement_attribute_measured_value_callback) {
    subscription_topic = base_topic + "PhMeasurement/Attributes/MeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_ph_measurement_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_ph_measurement_attribute_min_measured_value_callback) {
    subscription_topic = base_topic + "PhMeasurement/Attributes/MinMeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_ph_measurement_min_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_ph_measurement_attribute_max_measured_value_callback) {
    subscription_topic = base_topic + "PhMeasurement/Attributes/MaxMeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_ph_measurement_max_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_ph_measurement_attribute_tolerance_callback) {
    subscription_topic = base_topic + "PhMeasurement/Attributes/Tolerance/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_ph_measurement_tolerance_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for PhMeasurement
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_ph_measurement_attribute_measured_value_callback_set(const uic_mqtt_dotdot_ph_measurement_attribute_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_ph_measurement_attribute_measured_value_callback = callback;
}
void uic_mqtt_dotdot_ph_measurement_attribute_min_measured_value_callback_set(const uic_mqtt_dotdot_ph_measurement_attribute_min_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_ph_measurement_attribute_min_measured_value_callback = callback;
}
void uic_mqtt_dotdot_ph_measurement_attribute_max_measured_value_callback_set(const uic_mqtt_dotdot_ph_measurement_attribute_max_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_ph_measurement_attribute_max_measured_value_callback = callback;
}
void uic_mqtt_dotdot_ph_measurement_attribute_tolerance_callback_set(const uic_mqtt_dotdot_ph_measurement_attribute_tolerance_callback_t callback)
{
  uic_mqtt_dotdot_ph_measurement_attribute_tolerance_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for ElectricalConductivityMeasurement
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_electrical_conductivity_measurement_attribute_measured_value_callback_t uic_mqtt_dotdot_electrical_conductivity_measurement_attribute_measured_value_callback = nullptr;
static uic_mqtt_dotdot_electrical_conductivity_measurement_attribute_min_measured_value_callback_t uic_mqtt_dotdot_electrical_conductivity_measurement_attribute_min_measured_value_callback = nullptr;
static uic_mqtt_dotdot_electrical_conductivity_measurement_attribute_max_measured_value_callback_t uic_mqtt_dotdot_electrical_conductivity_measurement_attribute_max_measured_value_callback = nullptr;
static uic_mqtt_dotdot_electrical_conductivity_measurement_attribute_tolerance_callback_t uic_mqtt_dotdot_electrical_conductivity_measurement_attribute_tolerance_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for ElectricalConductivityMeasurement
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_electrical_conductivity_measurement_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_conductivity_measurement_attribute_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalConductivityMeasurement::MeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      measured_value = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_conductivity_measurement_attribute_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    measured_value
  );

}
static void uic_mqtt_dotdot_on_electrical_conductivity_measurement_min_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_conductivity_measurement_attribute_min_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t min_measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalConductivityMeasurement::MinMeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      min_measured_value = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_conductivity_measurement_attribute_min_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    min_measured_value
  );

}
static void uic_mqtt_dotdot_on_electrical_conductivity_measurement_max_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_conductivity_measurement_attribute_max_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t max_measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalConductivityMeasurement::MaxMeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      max_measured_value = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_conductivity_measurement_attribute_max_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    max_measured_value
  );

}
static void uic_mqtt_dotdot_on_electrical_conductivity_measurement_tolerance_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_conductivity_measurement_attribute_tolerance_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t tolerance = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalConductivityMeasurement::Tolerance: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      tolerance = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_conductivity_measurement_attribute_tolerance_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    tolerance
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for ElectricalConductivityMeasurement
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_electrical_conductivity_measurement_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_electrical_conductivity_measurement_attribute_measured_value_callback) {
    subscription_topic = base_topic + "ElectricalConductivityMeasurement/Attributes/MeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_conductivity_measurement_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_conductivity_measurement_attribute_min_measured_value_callback) {
    subscription_topic = base_topic + "ElectricalConductivityMeasurement/Attributes/MinMeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_conductivity_measurement_min_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_conductivity_measurement_attribute_max_measured_value_callback) {
    subscription_topic = base_topic + "ElectricalConductivityMeasurement/Attributes/MaxMeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_conductivity_measurement_max_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_conductivity_measurement_attribute_tolerance_callback) {
    subscription_topic = base_topic + "ElectricalConductivityMeasurement/Attributes/Tolerance/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_conductivity_measurement_tolerance_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for ElectricalConductivityMeasurement
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_electrical_conductivity_measurement_attribute_measured_value_callback_set(const uic_mqtt_dotdot_electrical_conductivity_measurement_attribute_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_electrical_conductivity_measurement_attribute_measured_value_callback = callback;
}
void uic_mqtt_dotdot_electrical_conductivity_measurement_attribute_min_measured_value_callback_set(const uic_mqtt_dotdot_electrical_conductivity_measurement_attribute_min_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_electrical_conductivity_measurement_attribute_min_measured_value_callback = callback;
}
void uic_mqtt_dotdot_electrical_conductivity_measurement_attribute_max_measured_value_callback_set(const uic_mqtt_dotdot_electrical_conductivity_measurement_attribute_max_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_electrical_conductivity_measurement_attribute_max_measured_value_callback = callback;
}
void uic_mqtt_dotdot_electrical_conductivity_measurement_attribute_tolerance_callback_set(const uic_mqtt_dotdot_electrical_conductivity_measurement_attribute_tolerance_callback_t callback)
{
  uic_mqtt_dotdot_electrical_conductivity_measurement_attribute_tolerance_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for WindSpeedMeasurement
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_wind_speed_measurement_attribute_measured_value_callback_t uic_mqtt_dotdot_wind_speed_measurement_attribute_measured_value_callback = nullptr;
static uic_mqtt_dotdot_wind_speed_measurement_attribute_min_measured_value_callback_t uic_mqtt_dotdot_wind_speed_measurement_attribute_min_measured_value_callback = nullptr;
static uic_mqtt_dotdot_wind_speed_measurement_attribute_max_measured_value_callback_t uic_mqtt_dotdot_wind_speed_measurement_attribute_max_measured_value_callback = nullptr;
static uic_mqtt_dotdot_wind_speed_measurement_attribute_tolerance_callback_t uic_mqtt_dotdot_wind_speed_measurement_attribute_tolerance_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for WindSpeedMeasurement
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_wind_speed_measurement_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_wind_speed_measurement_attribute_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "WindSpeedMeasurement::MeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      measured_value = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_wind_speed_measurement_attribute_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    measured_value
  );

}
static void uic_mqtt_dotdot_on_wind_speed_measurement_min_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_wind_speed_measurement_attribute_min_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t min_measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "WindSpeedMeasurement::MinMeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      min_measured_value = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_wind_speed_measurement_attribute_min_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    min_measured_value
  );

}
static void uic_mqtt_dotdot_on_wind_speed_measurement_max_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_wind_speed_measurement_attribute_max_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t max_measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "WindSpeedMeasurement::MaxMeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      max_measured_value = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_wind_speed_measurement_attribute_max_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    max_measured_value
  );

}
static void uic_mqtt_dotdot_on_wind_speed_measurement_tolerance_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_wind_speed_measurement_attribute_tolerance_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t tolerance = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "WindSpeedMeasurement::Tolerance: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      tolerance = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_wind_speed_measurement_attribute_tolerance_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    tolerance
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for WindSpeedMeasurement
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_wind_speed_measurement_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_wind_speed_measurement_attribute_measured_value_callback) {
    subscription_topic = base_topic + "WindSpeedMeasurement/Attributes/MeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_wind_speed_measurement_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_wind_speed_measurement_attribute_min_measured_value_callback) {
    subscription_topic = base_topic + "WindSpeedMeasurement/Attributes/MinMeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_wind_speed_measurement_min_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_wind_speed_measurement_attribute_max_measured_value_callback) {
    subscription_topic = base_topic + "WindSpeedMeasurement/Attributes/MaxMeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_wind_speed_measurement_max_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_wind_speed_measurement_attribute_tolerance_callback) {
    subscription_topic = base_topic + "WindSpeedMeasurement/Attributes/Tolerance/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_wind_speed_measurement_tolerance_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for WindSpeedMeasurement
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_wind_speed_measurement_attribute_measured_value_callback_set(const uic_mqtt_dotdot_wind_speed_measurement_attribute_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_wind_speed_measurement_attribute_measured_value_callback = callback;
}
void uic_mqtt_dotdot_wind_speed_measurement_attribute_min_measured_value_callback_set(const uic_mqtt_dotdot_wind_speed_measurement_attribute_min_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_wind_speed_measurement_attribute_min_measured_value_callback = callback;
}
void uic_mqtt_dotdot_wind_speed_measurement_attribute_max_measured_value_callback_set(const uic_mqtt_dotdot_wind_speed_measurement_attribute_max_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_wind_speed_measurement_attribute_max_measured_value_callback = callback;
}
void uic_mqtt_dotdot_wind_speed_measurement_attribute_tolerance_callback_set(const uic_mqtt_dotdot_wind_speed_measurement_attribute_tolerance_callback_t callback)
{
  uic_mqtt_dotdot_wind_speed_measurement_attribute_tolerance_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for CarbonMonoxide
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_carbon_monoxide_attribute_measured_value_callback_t uic_mqtt_dotdot_carbon_monoxide_attribute_measured_value_callback = nullptr;
static uic_mqtt_dotdot_carbon_monoxide_attribute_min_measured_value_callback_t uic_mqtt_dotdot_carbon_monoxide_attribute_min_measured_value_callback = nullptr;
static uic_mqtt_dotdot_carbon_monoxide_attribute_max_measured_value_callback_t uic_mqtt_dotdot_carbon_monoxide_attribute_max_measured_value_callback = nullptr;
static uic_mqtt_dotdot_carbon_monoxide_attribute_tolerance_callback_t uic_mqtt_dotdot_carbon_monoxide_attribute_tolerance_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for CarbonMonoxide
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_carbon_monoxide_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_carbon_monoxide_attribute_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  float measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "CarbonMonoxide::MeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      measured_value = json_payload.at("value").get<float>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_carbon_monoxide_attribute_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    measured_value
  );

}
static void uic_mqtt_dotdot_on_carbon_monoxide_min_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_carbon_monoxide_attribute_min_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  float min_measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "CarbonMonoxide::MinMeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      min_measured_value = json_payload.at("value").get<float>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_carbon_monoxide_attribute_min_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    min_measured_value
  );

}
static void uic_mqtt_dotdot_on_carbon_monoxide_max_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_carbon_monoxide_attribute_max_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  float max_measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "CarbonMonoxide::MaxMeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      max_measured_value = json_payload.at("value").get<float>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_carbon_monoxide_attribute_max_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    max_measured_value
  );

}
static void uic_mqtt_dotdot_on_carbon_monoxide_tolerance_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_carbon_monoxide_attribute_tolerance_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  float tolerance = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "CarbonMonoxide::Tolerance: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      tolerance = json_payload.at("value").get<float>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_carbon_monoxide_attribute_tolerance_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    tolerance
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for CarbonMonoxide
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_carbon_monoxide_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_carbon_monoxide_attribute_measured_value_callback) {
    subscription_topic = base_topic + "CarbonMonoxide/Attributes/MeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_carbon_monoxide_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_carbon_monoxide_attribute_min_measured_value_callback) {
    subscription_topic = base_topic + "CarbonMonoxide/Attributes/MinMeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_carbon_monoxide_min_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_carbon_monoxide_attribute_max_measured_value_callback) {
    subscription_topic = base_topic + "CarbonMonoxide/Attributes/MaxMeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_carbon_monoxide_max_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_carbon_monoxide_attribute_tolerance_callback) {
    subscription_topic = base_topic + "CarbonMonoxide/Attributes/Tolerance/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_carbon_monoxide_tolerance_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for CarbonMonoxide
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_carbon_monoxide_attribute_measured_value_callback_set(const uic_mqtt_dotdot_carbon_monoxide_attribute_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_carbon_monoxide_attribute_measured_value_callback = callback;
}
void uic_mqtt_dotdot_carbon_monoxide_attribute_min_measured_value_callback_set(const uic_mqtt_dotdot_carbon_monoxide_attribute_min_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_carbon_monoxide_attribute_min_measured_value_callback = callback;
}
void uic_mqtt_dotdot_carbon_monoxide_attribute_max_measured_value_callback_set(const uic_mqtt_dotdot_carbon_monoxide_attribute_max_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_carbon_monoxide_attribute_max_measured_value_callback = callback;
}
void uic_mqtt_dotdot_carbon_monoxide_attribute_tolerance_callback_set(const uic_mqtt_dotdot_carbon_monoxide_attribute_tolerance_callback_t callback)
{
  uic_mqtt_dotdot_carbon_monoxide_attribute_tolerance_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for CarbonDioxide
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_carbon_dioxide_attribute_measured_value_callback_t uic_mqtt_dotdot_carbon_dioxide_attribute_measured_value_callback = nullptr;
static uic_mqtt_dotdot_carbon_dioxide_attribute_min_measured_value_callback_t uic_mqtt_dotdot_carbon_dioxide_attribute_min_measured_value_callback = nullptr;
static uic_mqtt_dotdot_carbon_dioxide_attribute_max_measured_value_callback_t uic_mqtt_dotdot_carbon_dioxide_attribute_max_measured_value_callback = nullptr;
static uic_mqtt_dotdot_carbon_dioxide_attribute_tolerance_callback_t uic_mqtt_dotdot_carbon_dioxide_attribute_tolerance_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for CarbonDioxide
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_carbon_dioxide_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_carbon_dioxide_attribute_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  float measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "CarbonDioxide::MeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      measured_value = json_payload.at("value").get<float>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_carbon_dioxide_attribute_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    measured_value
  );

}
static void uic_mqtt_dotdot_on_carbon_dioxide_min_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_carbon_dioxide_attribute_min_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  float min_measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "CarbonDioxide::MinMeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      min_measured_value = json_payload.at("value").get<float>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_carbon_dioxide_attribute_min_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    min_measured_value
  );

}
static void uic_mqtt_dotdot_on_carbon_dioxide_max_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_carbon_dioxide_attribute_max_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  float max_measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "CarbonDioxide::MaxMeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      max_measured_value = json_payload.at("value").get<float>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_carbon_dioxide_attribute_max_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    max_measured_value
  );

}
static void uic_mqtt_dotdot_on_carbon_dioxide_tolerance_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_carbon_dioxide_attribute_tolerance_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  float tolerance = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "CarbonDioxide::Tolerance: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      tolerance = json_payload.at("value").get<float>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_carbon_dioxide_attribute_tolerance_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    tolerance
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for CarbonDioxide
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_carbon_dioxide_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_carbon_dioxide_attribute_measured_value_callback) {
    subscription_topic = base_topic + "CarbonDioxide/Attributes/MeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_carbon_dioxide_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_carbon_dioxide_attribute_min_measured_value_callback) {
    subscription_topic = base_topic + "CarbonDioxide/Attributes/MinMeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_carbon_dioxide_min_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_carbon_dioxide_attribute_max_measured_value_callback) {
    subscription_topic = base_topic + "CarbonDioxide/Attributes/MaxMeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_carbon_dioxide_max_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_carbon_dioxide_attribute_tolerance_callback) {
    subscription_topic = base_topic + "CarbonDioxide/Attributes/Tolerance/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_carbon_dioxide_tolerance_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for CarbonDioxide
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_carbon_dioxide_attribute_measured_value_callback_set(const uic_mqtt_dotdot_carbon_dioxide_attribute_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_carbon_dioxide_attribute_measured_value_callback = callback;
}
void uic_mqtt_dotdot_carbon_dioxide_attribute_min_measured_value_callback_set(const uic_mqtt_dotdot_carbon_dioxide_attribute_min_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_carbon_dioxide_attribute_min_measured_value_callback = callback;
}
void uic_mqtt_dotdot_carbon_dioxide_attribute_max_measured_value_callback_set(const uic_mqtt_dotdot_carbon_dioxide_attribute_max_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_carbon_dioxide_attribute_max_measured_value_callback = callback;
}
void uic_mqtt_dotdot_carbon_dioxide_attribute_tolerance_callback_set(const uic_mqtt_dotdot_carbon_dioxide_attribute_tolerance_callback_t callback)
{
  uic_mqtt_dotdot_carbon_dioxide_attribute_tolerance_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for PM25
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_pm25_attribute_measured_value_callback_t uic_mqtt_dotdot_pm25_attribute_measured_value_callback = nullptr;
static uic_mqtt_dotdot_pm25_attribute_min_measured_value_callback_t uic_mqtt_dotdot_pm25_attribute_min_measured_value_callback = nullptr;
static uic_mqtt_dotdot_pm25_attribute_max_measured_value_callback_t uic_mqtt_dotdot_pm25_attribute_max_measured_value_callback = nullptr;
static uic_mqtt_dotdot_pm25_attribute_tolerance_callback_t uic_mqtt_dotdot_pm25_attribute_tolerance_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for PM25
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_pm25_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pm25_attribute_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  float measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PM25::MeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      measured_value = json_payload.at("value").get<float>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pm25_attribute_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    measured_value
  );

}
static void uic_mqtt_dotdot_on_pm25_min_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pm25_attribute_min_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  float min_measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PM25::MinMeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      min_measured_value = json_payload.at("value").get<float>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pm25_attribute_min_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    min_measured_value
  );

}
static void uic_mqtt_dotdot_on_pm25_max_measured_value_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pm25_attribute_max_measured_value_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  float max_measured_value = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PM25::MaxMeasuredValue: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      max_measured_value = json_payload.at("value").get<float>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pm25_attribute_max_measured_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    max_measured_value
  );

}
static void uic_mqtt_dotdot_on_pm25_tolerance_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_pm25_attribute_tolerance_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  float tolerance = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "PM25::Tolerance: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      tolerance = json_payload.at("value").get<float>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_pm25_attribute_tolerance_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    tolerance
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for PM25
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_pm25_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_pm25_attribute_measured_value_callback) {
    subscription_topic = base_topic + "PM25/Attributes/MeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pm25_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_pm25_attribute_min_measured_value_callback) {
    subscription_topic = base_topic + "PM25/Attributes/MinMeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pm25_min_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_pm25_attribute_max_measured_value_callback) {
    subscription_topic = base_topic + "PM25/Attributes/MaxMeasuredValue/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pm25_max_measured_value_attribute_update);
  }
  if(uic_mqtt_dotdot_pm25_attribute_tolerance_callback) {
    subscription_topic = base_topic + "PM25/Attributes/Tolerance/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_pm25_tolerance_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for PM25
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_pm25_attribute_measured_value_callback_set(const uic_mqtt_dotdot_pm25_attribute_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_pm25_attribute_measured_value_callback = callback;
}
void uic_mqtt_dotdot_pm25_attribute_min_measured_value_callback_set(const uic_mqtt_dotdot_pm25_attribute_min_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_pm25_attribute_min_measured_value_callback = callback;
}
void uic_mqtt_dotdot_pm25_attribute_max_measured_value_callback_set(const uic_mqtt_dotdot_pm25_attribute_max_measured_value_callback_t callback)
{
  uic_mqtt_dotdot_pm25_attribute_max_measured_value_callback = callback;
}
void uic_mqtt_dotdot_pm25_attribute_tolerance_callback_set(const uic_mqtt_dotdot_pm25_attribute_tolerance_callback_t callback)
{
  uic_mqtt_dotdot_pm25_attribute_tolerance_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for IASZone
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_ias_zone_attribute_zone_state_callback_t uic_mqtt_dotdot_ias_zone_attribute_zone_state_callback = nullptr;
static uic_mqtt_dotdot_ias_zone_attribute_zone_type_callback_t uic_mqtt_dotdot_ias_zone_attribute_zone_type_callback = nullptr;
static uic_mqtt_dotdot_ias_zone_attribute_zone_status_callback_t uic_mqtt_dotdot_ias_zone_attribute_zone_status_callback = nullptr;
static uic_mqtt_dotdot_ias_zone_attribute_iascie_address_callback_t uic_mqtt_dotdot_ias_zone_attribute_iascie_address_callback = nullptr;
static uic_mqtt_dotdot_ias_zone_attribute_zoneid_callback_t uic_mqtt_dotdot_ias_zone_attribute_zoneid_callback = nullptr;
static uic_mqtt_dotdot_ias_zone_attribute_number_of_zone_sensitivity_levels_supported_callback_t uic_mqtt_dotdot_ias_zone_attribute_number_of_zone_sensitivity_levels_supported_callback = nullptr;
static uic_mqtt_dotdot_ias_zone_attribute_current_zone_sensitivity_level_callback_t uic_mqtt_dotdot_ias_zone_attribute_current_zone_sensitivity_level_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for IASZone
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_ias_zone_zone_state_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_ias_zone_attribute_zone_state_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t zone_state = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "IASZone::ZoneState: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<IASZoneZoneState>("value", json_payload);
      if (tmp == numeric_limits<IASZoneZoneState>::max()) {
      #ifdef IAS_ZONE_ZONE_STATE_ENUM_NAME_AVAILABLE
        tmp = ias_zone_zone_state_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(ZONE_STATE_ENUM_NAME_AVAILABLE)
        tmp = zone_state_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      zone_state = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_ias_zone_attribute_zone_state_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    zone_state
  );

}
static void uic_mqtt_dotdot_on_ias_zone_zone_type_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_ias_zone_attribute_zone_type_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  IasZoneType zone_type = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "IASZone::ZoneType: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<IasZoneType>("value", json_payload);
      if (tmp == numeric_limits<IasZoneType>::max()) {
      #ifdef IAS_ZONE_ZONE_TYPE_ENUM_NAME_AVAILABLE
        tmp = ias_zone_zone_type_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(ZONE_TYPE_ENUM_NAME_AVAILABLE)
        tmp = zone_type_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      zone_type = static_cast<IasZoneType>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_ias_zone_attribute_zone_type_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    zone_type
  );

}
static void uic_mqtt_dotdot_on_ias_zone_zone_status_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_ias_zone_attribute_zone_status_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t zone_status = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "IASZone::ZoneStatus: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      zone_status = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, IasZoneStatus);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_ias_zone_attribute_zone_status_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    zone_status
  );

}
static void uic_mqtt_dotdot_on_ias_zone_iascie_address_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_ias_zone_attribute_iascie_address_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  EUI64 iascie_address = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "IASZone::IASCIEAddress: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      iascie_address = json_payload.at("value").get<EUI64>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_ias_zone_attribute_iascie_address_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    iascie_address
  );

}
static void uic_mqtt_dotdot_on_ias_zone_zoneid_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_ias_zone_attribute_zoneid_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t zoneid = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "IASZone::ZoneID: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      zoneid = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_ias_zone_attribute_zoneid_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    zoneid
  );

}
static void uic_mqtt_dotdot_on_ias_zone_number_of_zone_sensitivity_levels_supported_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_ias_zone_attribute_number_of_zone_sensitivity_levels_supported_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t number_of_zone_sensitivity_levels_supported = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "IASZone::NumberOfZoneSensitivityLevelsSupported: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      number_of_zone_sensitivity_levels_supported = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_ias_zone_attribute_number_of_zone_sensitivity_levels_supported_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    number_of_zone_sensitivity_levels_supported
  );

}
static void uic_mqtt_dotdot_on_ias_zone_current_zone_sensitivity_level_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_ias_zone_attribute_current_zone_sensitivity_level_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t current_zone_sensitivity_level = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "IASZone::CurrentZoneSensitivityLevel: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      current_zone_sensitivity_level = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_ias_zone_attribute_current_zone_sensitivity_level_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    current_zone_sensitivity_level
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for IASZone
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_ias_zone_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_ias_zone_attribute_zone_state_callback) {
    subscription_topic = base_topic + "IASZone/Attributes/ZoneState/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_ias_zone_zone_state_attribute_update);
  }
  if(uic_mqtt_dotdot_ias_zone_attribute_zone_type_callback) {
    subscription_topic = base_topic + "IASZone/Attributes/ZoneType/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_ias_zone_zone_type_attribute_update);
  }
  if(uic_mqtt_dotdot_ias_zone_attribute_zone_status_callback) {
    subscription_topic = base_topic + "IASZone/Attributes/ZoneStatus/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_ias_zone_zone_status_attribute_update);
  }
  if(uic_mqtt_dotdot_ias_zone_attribute_iascie_address_callback) {
    subscription_topic = base_topic + "IASZone/Attributes/IASCIEAddress/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_ias_zone_iascie_address_attribute_update);
  }
  if(uic_mqtt_dotdot_ias_zone_attribute_zoneid_callback) {
    subscription_topic = base_topic + "IASZone/Attributes/ZoneID/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_ias_zone_zoneid_attribute_update);
  }
  if(uic_mqtt_dotdot_ias_zone_attribute_number_of_zone_sensitivity_levels_supported_callback) {
    subscription_topic = base_topic + "IASZone/Attributes/NumberOfZoneSensitivityLevelsSupported/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_ias_zone_number_of_zone_sensitivity_levels_supported_attribute_update);
  }
  if(uic_mqtt_dotdot_ias_zone_attribute_current_zone_sensitivity_level_callback) {
    subscription_topic = base_topic + "IASZone/Attributes/CurrentZoneSensitivityLevel/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_ias_zone_current_zone_sensitivity_level_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for IASZone
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_ias_zone_attribute_zone_state_callback_set(const uic_mqtt_dotdot_ias_zone_attribute_zone_state_callback_t callback)
{
  uic_mqtt_dotdot_ias_zone_attribute_zone_state_callback = callback;
}
void uic_mqtt_dotdot_ias_zone_attribute_zone_type_callback_set(const uic_mqtt_dotdot_ias_zone_attribute_zone_type_callback_t callback)
{
  uic_mqtt_dotdot_ias_zone_attribute_zone_type_callback = callback;
}
void uic_mqtt_dotdot_ias_zone_attribute_zone_status_callback_set(const uic_mqtt_dotdot_ias_zone_attribute_zone_status_callback_t callback)
{
  uic_mqtt_dotdot_ias_zone_attribute_zone_status_callback = callback;
}
void uic_mqtt_dotdot_ias_zone_attribute_iascie_address_callback_set(const uic_mqtt_dotdot_ias_zone_attribute_iascie_address_callback_t callback)
{
  uic_mqtt_dotdot_ias_zone_attribute_iascie_address_callback = callback;
}
void uic_mqtt_dotdot_ias_zone_attribute_zoneid_callback_set(const uic_mqtt_dotdot_ias_zone_attribute_zoneid_callback_t callback)
{
  uic_mqtt_dotdot_ias_zone_attribute_zoneid_callback = callback;
}
void uic_mqtt_dotdot_ias_zone_attribute_number_of_zone_sensitivity_levels_supported_callback_set(const uic_mqtt_dotdot_ias_zone_attribute_number_of_zone_sensitivity_levels_supported_callback_t callback)
{
  uic_mqtt_dotdot_ias_zone_attribute_number_of_zone_sensitivity_levels_supported_callback = callback;
}
void uic_mqtt_dotdot_ias_zone_attribute_current_zone_sensitivity_level_callback_set(const uic_mqtt_dotdot_ias_zone_attribute_current_zone_sensitivity_level_callback_t callback)
{
  uic_mqtt_dotdot_ias_zone_attribute_current_zone_sensitivity_level_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for IASWD
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_iaswd_attribute_max_duration_callback_t uic_mqtt_dotdot_iaswd_attribute_max_duration_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for IASWD
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_iaswd_max_duration_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_iaswd_attribute_max_duration_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t max_duration = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "IASWD::MaxDuration: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      max_duration = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_iaswd_attribute_max_duration_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    max_duration
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for IASWD
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_iaswd_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_iaswd_attribute_max_duration_callback) {
    subscription_topic = base_topic + "IASWD/Attributes/MaxDuration/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_iaswd_max_duration_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for IASWD
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_iaswd_attribute_max_duration_callback_set(const uic_mqtt_dotdot_iaswd_attribute_max_duration_callback_t callback)
{
  uic_mqtt_dotdot_iaswd_attribute_max_duration_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for Metering
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_metering_attribute_current_summation_delivered_callback_t uic_mqtt_dotdot_metering_attribute_current_summation_delivered_callback = nullptr;
static uic_mqtt_dotdot_metering_attribute_current_summation_received_callback_t uic_mqtt_dotdot_metering_attribute_current_summation_received_callback = nullptr;
static uic_mqtt_dotdot_metering_attribute_current_max_demand_delivered_callback_t uic_mqtt_dotdot_metering_attribute_current_max_demand_delivered_callback = nullptr;
static uic_mqtt_dotdot_metering_attribute_current_max_demand_received_callback_t uic_mqtt_dotdot_metering_attribute_current_max_demand_received_callback = nullptr;
static uic_mqtt_dotdot_metering_attribute_power_factor_callback_t uic_mqtt_dotdot_metering_attribute_power_factor_callback = nullptr;
static uic_mqtt_dotdot_metering_attribute_reading_snap_shot_time_callback_t uic_mqtt_dotdot_metering_attribute_reading_snap_shot_time_callback = nullptr;
static uic_mqtt_dotdot_metering_attribute_current_max_demand_delivered_time_callback_t uic_mqtt_dotdot_metering_attribute_current_max_demand_delivered_time_callback = nullptr;
static uic_mqtt_dotdot_metering_attribute_current_max_demand_received_time_callback_t uic_mqtt_dotdot_metering_attribute_current_max_demand_received_time_callback = nullptr;
static uic_mqtt_dotdot_metering_attribute_default_update_period_callback_t uic_mqtt_dotdot_metering_attribute_default_update_period_callback = nullptr;
static uic_mqtt_dotdot_metering_attribute_supply_status_callback_t uic_mqtt_dotdot_metering_attribute_supply_status_callback = nullptr;
static uic_mqtt_dotdot_metering_attribute_current_inlet_energy_carrier_summation_callback_t uic_mqtt_dotdot_metering_attribute_current_inlet_energy_carrier_summation_callback = nullptr;
static uic_mqtt_dotdot_metering_attribute_current_outlet_energy_carrier_summation_callback_t uic_mqtt_dotdot_metering_attribute_current_outlet_energy_carrier_summation_callback = nullptr;
static uic_mqtt_dotdot_metering_attribute_inlet_temperature_callback_t uic_mqtt_dotdot_metering_attribute_inlet_temperature_callback = nullptr;
static uic_mqtt_dotdot_metering_attribute_outlet_temperature_callback_t uic_mqtt_dotdot_metering_attribute_outlet_temperature_callback = nullptr;
static uic_mqtt_dotdot_metering_attribute_unitof_measure_callback_t uic_mqtt_dotdot_metering_attribute_unitof_measure_callback = nullptr;
static uic_mqtt_dotdot_metering_attribute_multiplier_callback_t uic_mqtt_dotdot_metering_attribute_multiplier_callback = nullptr;
static uic_mqtt_dotdot_metering_attribute_divisor_callback_t uic_mqtt_dotdot_metering_attribute_divisor_callback = nullptr;
static uic_mqtt_dotdot_metering_attribute_summation_formatting_callback_t uic_mqtt_dotdot_metering_attribute_summation_formatting_callback = nullptr;
static uic_mqtt_dotdot_metering_attribute_demand_formatting_callback_t uic_mqtt_dotdot_metering_attribute_demand_formatting_callback = nullptr;
static uic_mqtt_dotdot_metering_attribute_historical_consumption_formatting_callback_t uic_mqtt_dotdot_metering_attribute_historical_consumption_formatting_callback = nullptr;
static uic_mqtt_dotdot_metering_attribute_metering_device_type_callback_t uic_mqtt_dotdot_metering_attribute_metering_device_type_callback = nullptr;
static uic_mqtt_dotdot_metering_attribute_energy_carrier_unit_of_measure_callback_t uic_mqtt_dotdot_metering_attribute_energy_carrier_unit_of_measure_callback = nullptr;
static uic_mqtt_dotdot_metering_attribute_energy_carrier_summation_formatting_callback_t uic_mqtt_dotdot_metering_attribute_energy_carrier_summation_formatting_callback = nullptr;
static uic_mqtt_dotdot_metering_attribute_energy_carrier_demand_formatting_callback_t uic_mqtt_dotdot_metering_attribute_energy_carrier_demand_formatting_callback = nullptr;
static uic_mqtt_dotdot_metering_attribute_temperature_unit_of_measure_callback_t uic_mqtt_dotdot_metering_attribute_temperature_unit_of_measure_callback = nullptr;
static uic_mqtt_dotdot_metering_attribute_temperature_formatting_callback_t uic_mqtt_dotdot_metering_attribute_temperature_formatting_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for Metering
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_metering_current_summation_delivered_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_metering_attribute_current_summation_delivered_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint64_t current_summation_delivered = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Metering::CurrentSummationDelivered: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      current_summation_delivered = json_payload.at("value").get<uint64_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_metering_attribute_current_summation_delivered_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    current_summation_delivered
  );

}
static void uic_mqtt_dotdot_on_metering_current_summation_received_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_metering_attribute_current_summation_received_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint64_t current_summation_received = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Metering::CurrentSummationReceived: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      current_summation_received = json_payload.at("value").get<uint64_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_metering_attribute_current_summation_received_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    current_summation_received
  );

}
static void uic_mqtt_dotdot_on_metering_current_max_demand_delivered_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_metering_attribute_current_max_demand_delivered_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint64_t current_max_demand_delivered = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Metering::CurrentMaxDemandDelivered: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      current_max_demand_delivered = json_payload.at("value").get<uint64_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_metering_attribute_current_max_demand_delivered_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    current_max_demand_delivered
  );

}
static void uic_mqtt_dotdot_on_metering_current_max_demand_received_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_metering_attribute_current_max_demand_received_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int8_t current_max_demand_received = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Metering::CurrentMaxDemandReceived: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      current_max_demand_received = json_payload.at("value").get<int8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_metering_attribute_current_max_demand_received_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    current_max_demand_received
  );

}
static void uic_mqtt_dotdot_on_metering_power_factor_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_metering_attribute_power_factor_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int8_t power_factor = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Metering::PowerFactor: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      power_factor = json_payload.at("value").get<int8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_metering_attribute_power_factor_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    power_factor
  );

}
static void uic_mqtt_dotdot_on_metering_reading_snap_shot_time_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_metering_attribute_reading_snap_shot_time_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  UTC reading_snap_shot_time = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Metering::ReadingSnapShotTime: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      reading_snap_shot_time = json_payload.at("value").get<UTC>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_metering_attribute_reading_snap_shot_time_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    reading_snap_shot_time
  );

}
static void uic_mqtt_dotdot_on_metering_current_max_demand_delivered_time_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_metering_attribute_current_max_demand_delivered_time_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  UTC current_max_demand_delivered_time = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Metering::CurrentMaxDemandDeliveredTime: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      current_max_demand_delivered_time = json_payload.at("value").get<UTC>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_metering_attribute_current_max_demand_delivered_time_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    current_max_demand_delivered_time
  );

}
static void uic_mqtt_dotdot_on_metering_current_max_demand_received_time_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_metering_attribute_current_max_demand_received_time_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  UTC current_max_demand_received_time = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Metering::CurrentMaxDemandReceivedTime: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      current_max_demand_received_time = json_payload.at("value").get<UTC>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_metering_attribute_current_max_demand_received_time_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    current_max_demand_received_time
  );

}
static void uic_mqtt_dotdot_on_metering_default_update_period_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_metering_attribute_default_update_period_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t default_update_period = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Metering::DefaultUpdatePeriod: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      default_update_period = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_metering_attribute_default_update_period_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    default_update_period
  );

}
static void uic_mqtt_dotdot_on_metering_supply_status_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_metering_attribute_supply_status_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t supply_status = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Metering::SupplyStatus: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<MeteringSupplyStatus>("value", json_payload);
      if (tmp == numeric_limits<MeteringSupplyStatus>::max()) {
      #ifdef METERING_SUPPLY_STATUS_ENUM_NAME_AVAILABLE
        tmp = metering_supply_status_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(SUPPLY_STATUS_ENUM_NAME_AVAILABLE)
        tmp = supply_status_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      supply_status = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_metering_attribute_supply_status_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    supply_status
  );

}
static void uic_mqtt_dotdot_on_metering_current_inlet_energy_carrier_summation_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_metering_attribute_current_inlet_energy_carrier_summation_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint64_t current_inlet_energy_carrier_summation = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Metering::CurrentInletEnergyCarrierSummation: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      current_inlet_energy_carrier_summation = json_payload.at("value").get<uint64_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_metering_attribute_current_inlet_energy_carrier_summation_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    current_inlet_energy_carrier_summation
  );

}
static void uic_mqtt_dotdot_on_metering_current_outlet_energy_carrier_summation_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_metering_attribute_current_outlet_energy_carrier_summation_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint64_t current_outlet_energy_carrier_summation = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Metering::CurrentOutletEnergyCarrierSummation: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      current_outlet_energy_carrier_summation = json_payload.at("value").get<uint64_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_metering_attribute_current_outlet_energy_carrier_summation_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    current_outlet_energy_carrier_summation
  );

}
static void uic_mqtt_dotdot_on_metering_inlet_temperature_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_metering_attribute_inlet_temperature_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t inlet_temperature = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Metering::InletTemperature: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      inlet_temperature = json_payload.at("value").get<uint32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_metering_attribute_inlet_temperature_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    inlet_temperature
  );

}
static void uic_mqtt_dotdot_on_metering_outlet_temperature_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_metering_attribute_outlet_temperature_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t outlet_temperature = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Metering::OutletTemperature: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      outlet_temperature = json_payload.at("value").get<uint32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_metering_attribute_outlet_temperature_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    outlet_temperature
  );

}
static void uic_mqtt_dotdot_on_metering_unitof_measure_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_metering_attribute_unitof_measure_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t unitof_measure = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Metering::UnitofMeasure: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<MeteringUnitofMeasure>("value", json_payload);
      if (tmp == numeric_limits<MeteringUnitofMeasure>::max()) {
      #ifdef METERING_UNITOF_MEASURE_ENUM_NAME_AVAILABLE
        tmp = metering_unitof_measure_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(UNITOF_MEASURE_ENUM_NAME_AVAILABLE)
        tmp = unitof_measure_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      unitof_measure = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_metering_attribute_unitof_measure_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    unitof_measure
  );

}
static void uic_mqtt_dotdot_on_metering_multiplier_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_metering_attribute_multiplier_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t multiplier = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Metering::Multiplier: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      multiplier = json_payload.at("value").get<uint32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_metering_attribute_multiplier_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    multiplier
  );

}
static void uic_mqtt_dotdot_on_metering_divisor_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_metering_attribute_divisor_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t divisor = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Metering::Divisor: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      divisor = json_payload.at("value").get<uint32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_metering_attribute_divisor_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    divisor
  );

}
static void uic_mqtt_dotdot_on_metering_summation_formatting_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_metering_attribute_summation_formatting_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t summation_formatting = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Metering::SummationFormatting: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      summation_formatting = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, MeteringSummationFormatting);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_metering_attribute_summation_formatting_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    summation_formatting
  );

}
static void uic_mqtt_dotdot_on_metering_demand_formatting_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_metering_attribute_demand_formatting_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t demand_formatting = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Metering::DemandFormatting: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      demand_formatting = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, MeteringDemandFormatting);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_metering_attribute_demand_formatting_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    demand_formatting
  );

}
static void uic_mqtt_dotdot_on_metering_historical_consumption_formatting_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_metering_attribute_historical_consumption_formatting_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t historical_consumption_formatting = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Metering::HistoricalConsumptionFormatting: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      historical_consumption_formatting = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, MeteringHistoricalConsumptionFormatting);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_metering_attribute_historical_consumption_formatting_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    historical_consumption_formatting
  );

}
static void uic_mqtt_dotdot_on_metering_metering_device_type_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_metering_attribute_metering_device_type_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t metering_device_type = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Metering::MeteringDeviceType: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<MeteringMeteringDeviceType>("value", json_payload);
      if (tmp == numeric_limits<MeteringMeteringDeviceType>::max()) {
      #ifdef METERING_METERING_DEVICE_TYPE_ENUM_NAME_AVAILABLE
        tmp = metering_metering_device_type_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(METERING_DEVICE_TYPE_ENUM_NAME_AVAILABLE)
        tmp = metering_device_type_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      metering_device_type = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_metering_attribute_metering_device_type_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    metering_device_type
  );

}
static void uic_mqtt_dotdot_on_metering_energy_carrier_unit_of_measure_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_metering_attribute_energy_carrier_unit_of_measure_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t energy_carrier_unit_of_measure = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Metering::EnergyCarrierUnitOfMeasure: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<MeteringEnergyCarrierUnitOfMeasure>("value", json_payload);
      if (tmp == numeric_limits<MeteringEnergyCarrierUnitOfMeasure>::max()) {
      #ifdef METERING_ENERGY_CARRIER_UNIT_OF_MEASURE_ENUM_NAME_AVAILABLE
        tmp = metering_energy_carrier_unit_of_measure_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(ENERGY_CARRIER_UNIT_OF_MEASURE_ENUM_NAME_AVAILABLE)
        tmp = energy_carrier_unit_of_measure_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      energy_carrier_unit_of_measure = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_metering_attribute_energy_carrier_unit_of_measure_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    energy_carrier_unit_of_measure
  );

}
static void uic_mqtt_dotdot_on_metering_energy_carrier_summation_formatting_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_metering_attribute_energy_carrier_summation_formatting_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t energy_carrier_summation_formatting = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Metering::EnergyCarrierSummationFormatting: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      energy_carrier_summation_formatting = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, MeteringEnergyCarrierSummationFormatting);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_metering_attribute_energy_carrier_summation_formatting_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    energy_carrier_summation_formatting
  );

}
static void uic_mqtt_dotdot_on_metering_energy_carrier_demand_formatting_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_metering_attribute_energy_carrier_demand_formatting_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t energy_carrier_demand_formatting = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Metering::EnergyCarrierDemandFormatting: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      energy_carrier_demand_formatting = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, MeteringEnergyCarrierDemandFormatting);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_metering_attribute_energy_carrier_demand_formatting_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    energy_carrier_demand_formatting
  );

}
static void uic_mqtt_dotdot_on_metering_temperature_unit_of_measure_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_metering_attribute_temperature_unit_of_measure_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t temperature_unit_of_measure = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Metering::TemperatureUnitOfMeasure: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<MeteringTemperatureUnitOfMeasure>("value", json_payload);
      if (tmp == numeric_limits<MeteringTemperatureUnitOfMeasure>::max()) {
      #ifdef METERING_TEMPERATURE_UNIT_OF_MEASURE_ENUM_NAME_AVAILABLE
        tmp = metering_temperature_unit_of_measure_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(TEMPERATURE_UNIT_OF_MEASURE_ENUM_NAME_AVAILABLE)
        tmp = temperature_unit_of_measure_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      temperature_unit_of_measure = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_metering_attribute_temperature_unit_of_measure_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    temperature_unit_of_measure
  );

}
static void uic_mqtt_dotdot_on_metering_temperature_formatting_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_metering_attribute_temperature_formatting_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t temperature_formatting = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Metering::TemperatureFormatting: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      temperature_formatting = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, MeteringTemperatureFormatting);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_metering_attribute_temperature_formatting_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    temperature_formatting
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for Metering
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_metering_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_metering_attribute_current_summation_delivered_callback) {
    subscription_topic = base_topic + "Metering/Attributes/CurrentSummationDelivered/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_metering_current_summation_delivered_attribute_update);
  }
  if(uic_mqtt_dotdot_metering_attribute_current_summation_received_callback) {
    subscription_topic = base_topic + "Metering/Attributes/CurrentSummationReceived/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_metering_current_summation_received_attribute_update);
  }
  if(uic_mqtt_dotdot_metering_attribute_current_max_demand_delivered_callback) {
    subscription_topic = base_topic + "Metering/Attributes/CurrentMaxDemandDelivered/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_metering_current_max_demand_delivered_attribute_update);
  }
  if(uic_mqtt_dotdot_metering_attribute_current_max_demand_received_callback) {
    subscription_topic = base_topic + "Metering/Attributes/CurrentMaxDemandReceived/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_metering_current_max_demand_received_attribute_update);
  }
  if(uic_mqtt_dotdot_metering_attribute_power_factor_callback) {
    subscription_topic = base_topic + "Metering/Attributes/PowerFactor/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_metering_power_factor_attribute_update);
  }
  if(uic_mqtt_dotdot_metering_attribute_reading_snap_shot_time_callback) {
    subscription_topic = base_topic + "Metering/Attributes/ReadingSnapShotTime/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_metering_reading_snap_shot_time_attribute_update);
  }
  if(uic_mqtt_dotdot_metering_attribute_current_max_demand_delivered_time_callback) {
    subscription_topic = base_topic + "Metering/Attributes/CurrentMaxDemandDeliveredTime/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_metering_current_max_demand_delivered_time_attribute_update);
  }
  if(uic_mqtt_dotdot_metering_attribute_current_max_demand_received_time_callback) {
    subscription_topic = base_topic + "Metering/Attributes/CurrentMaxDemandReceivedTime/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_metering_current_max_demand_received_time_attribute_update);
  }
  if(uic_mqtt_dotdot_metering_attribute_default_update_period_callback) {
    subscription_topic = base_topic + "Metering/Attributes/DefaultUpdatePeriod/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_metering_default_update_period_attribute_update);
  }
  if(uic_mqtt_dotdot_metering_attribute_supply_status_callback) {
    subscription_topic = base_topic + "Metering/Attributes/SupplyStatus/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_metering_supply_status_attribute_update);
  }
  if(uic_mqtt_dotdot_metering_attribute_current_inlet_energy_carrier_summation_callback) {
    subscription_topic = base_topic + "Metering/Attributes/CurrentInletEnergyCarrierSummation/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_metering_current_inlet_energy_carrier_summation_attribute_update);
  }
  if(uic_mqtt_dotdot_metering_attribute_current_outlet_energy_carrier_summation_callback) {
    subscription_topic = base_topic + "Metering/Attributes/CurrentOutletEnergyCarrierSummation/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_metering_current_outlet_energy_carrier_summation_attribute_update);
  }
  if(uic_mqtt_dotdot_metering_attribute_inlet_temperature_callback) {
    subscription_topic = base_topic + "Metering/Attributes/InletTemperature/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_metering_inlet_temperature_attribute_update);
  }
  if(uic_mqtt_dotdot_metering_attribute_outlet_temperature_callback) {
    subscription_topic = base_topic + "Metering/Attributes/OutletTemperature/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_metering_outlet_temperature_attribute_update);
  }
  if(uic_mqtt_dotdot_metering_attribute_unitof_measure_callback) {
    subscription_topic = base_topic + "Metering/Attributes/UnitofMeasure/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_metering_unitof_measure_attribute_update);
  }
  if(uic_mqtt_dotdot_metering_attribute_multiplier_callback) {
    subscription_topic = base_topic + "Metering/Attributes/Multiplier/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_metering_multiplier_attribute_update);
  }
  if(uic_mqtt_dotdot_metering_attribute_divisor_callback) {
    subscription_topic = base_topic + "Metering/Attributes/Divisor/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_metering_divisor_attribute_update);
  }
  if(uic_mqtt_dotdot_metering_attribute_summation_formatting_callback) {
    subscription_topic = base_topic + "Metering/Attributes/SummationFormatting/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_metering_summation_formatting_attribute_update);
  }
  if(uic_mqtt_dotdot_metering_attribute_demand_formatting_callback) {
    subscription_topic = base_topic + "Metering/Attributes/DemandFormatting/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_metering_demand_formatting_attribute_update);
  }
  if(uic_mqtt_dotdot_metering_attribute_historical_consumption_formatting_callback) {
    subscription_topic = base_topic + "Metering/Attributes/HistoricalConsumptionFormatting/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_metering_historical_consumption_formatting_attribute_update);
  }
  if(uic_mqtt_dotdot_metering_attribute_metering_device_type_callback) {
    subscription_topic = base_topic + "Metering/Attributes/MeteringDeviceType/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_metering_metering_device_type_attribute_update);
  }
  if(uic_mqtt_dotdot_metering_attribute_energy_carrier_unit_of_measure_callback) {
    subscription_topic = base_topic + "Metering/Attributes/EnergyCarrierUnitOfMeasure/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_metering_energy_carrier_unit_of_measure_attribute_update);
  }
  if(uic_mqtt_dotdot_metering_attribute_energy_carrier_summation_formatting_callback) {
    subscription_topic = base_topic + "Metering/Attributes/EnergyCarrierSummationFormatting/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_metering_energy_carrier_summation_formatting_attribute_update);
  }
  if(uic_mqtt_dotdot_metering_attribute_energy_carrier_demand_formatting_callback) {
    subscription_topic = base_topic + "Metering/Attributes/EnergyCarrierDemandFormatting/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_metering_energy_carrier_demand_formatting_attribute_update);
  }
  if(uic_mqtt_dotdot_metering_attribute_temperature_unit_of_measure_callback) {
    subscription_topic = base_topic + "Metering/Attributes/TemperatureUnitOfMeasure/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_metering_temperature_unit_of_measure_attribute_update);
  }
  if(uic_mqtt_dotdot_metering_attribute_temperature_formatting_callback) {
    subscription_topic = base_topic + "Metering/Attributes/TemperatureFormatting/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_metering_temperature_formatting_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for Metering
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_metering_attribute_current_summation_delivered_callback_set(const uic_mqtt_dotdot_metering_attribute_current_summation_delivered_callback_t callback)
{
  uic_mqtt_dotdot_metering_attribute_current_summation_delivered_callback = callback;
}
void uic_mqtt_dotdot_metering_attribute_current_summation_received_callback_set(const uic_mqtt_dotdot_metering_attribute_current_summation_received_callback_t callback)
{
  uic_mqtt_dotdot_metering_attribute_current_summation_received_callback = callback;
}
void uic_mqtt_dotdot_metering_attribute_current_max_demand_delivered_callback_set(const uic_mqtt_dotdot_metering_attribute_current_max_demand_delivered_callback_t callback)
{
  uic_mqtt_dotdot_metering_attribute_current_max_demand_delivered_callback = callback;
}
void uic_mqtt_dotdot_metering_attribute_current_max_demand_received_callback_set(const uic_mqtt_dotdot_metering_attribute_current_max_demand_received_callback_t callback)
{
  uic_mqtt_dotdot_metering_attribute_current_max_demand_received_callback = callback;
}
void uic_mqtt_dotdot_metering_attribute_power_factor_callback_set(const uic_mqtt_dotdot_metering_attribute_power_factor_callback_t callback)
{
  uic_mqtt_dotdot_metering_attribute_power_factor_callback = callback;
}
void uic_mqtt_dotdot_metering_attribute_reading_snap_shot_time_callback_set(const uic_mqtt_dotdot_metering_attribute_reading_snap_shot_time_callback_t callback)
{
  uic_mqtt_dotdot_metering_attribute_reading_snap_shot_time_callback = callback;
}
void uic_mqtt_dotdot_metering_attribute_current_max_demand_delivered_time_callback_set(const uic_mqtt_dotdot_metering_attribute_current_max_demand_delivered_time_callback_t callback)
{
  uic_mqtt_dotdot_metering_attribute_current_max_demand_delivered_time_callback = callback;
}
void uic_mqtt_dotdot_metering_attribute_current_max_demand_received_time_callback_set(const uic_mqtt_dotdot_metering_attribute_current_max_demand_received_time_callback_t callback)
{
  uic_mqtt_dotdot_metering_attribute_current_max_demand_received_time_callback = callback;
}
void uic_mqtt_dotdot_metering_attribute_default_update_period_callback_set(const uic_mqtt_dotdot_metering_attribute_default_update_period_callback_t callback)
{
  uic_mqtt_dotdot_metering_attribute_default_update_period_callback = callback;
}
void uic_mqtt_dotdot_metering_attribute_supply_status_callback_set(const uic_mqtt_dotdot_metering_attribute_supply_status_callback_t callback)
{
  uic_mqtt_dotdot_metering_attribute_supply_status_callback = callback;
}
void uic_mqtt_dotdot_metering_attribute_current_inlet_energy_carrier_summation_callback_set(const uic_mqtt_dotdot_metering_attribute_current_inlet_energy_carrier_summation_callback_t callback)
{
  uic_mqtt_dotdot_metering_attribute_current_inlet_energy_carrier_summation_callback = callback;
}
void uic_mqtt_dotdot_metering_attribute_current_outlet_energy_carrier_summation_callback_set(const uic_mqtt_dotdot_metering_attribute_current_outlet_energy_carrier_summation_callback_t callback)
{
  uic_mqtt_dotdot_metering_attribute_current_outlet_energy_carrier_summation_callback = callback;
}
void uic_mqtt_dotdot_metering_attribute_inlet_temperature_callback_set(const uic_mqtt_dotdot_metering_attribute_inlet_temperature_callback_t callback)
{
  uic_mqtt_dotdot_metering_attribute_inlet_temperature_callback = callback;
}
void uic_mqtt_dotdot_metering_attribute_outlet_temperature_callback_set(const uic_mqtt_dotdot_metering_attribute_outlet_temperature_callback_t callback)
{
  uic_mqtt_dotdot_metering_attribute_outlet_temperature_callback = callback;
}
void uic_mqtt_dotdot_metering_attribute_unitof_measure_callback_set(const uic_mqtt_dotdot_metering_attribute_unitof_measure_callback_t callback)
{
  uic_mqtt_dotdot_metering_attribute_unitof_measure_callback = callback;
}
void uic_mqtt_dotdot_metering_attribute_multiplier_callback_set(const uic_mqtt_dotdot_metering_attribute_multiplier_callback_t callback)
{
  uic_mqtt_dotdot_metering_attribute_multiplier_callback = callback;
}
void uic_mqtt_dotdot_metering_attribute_divisor_callback_set(const uic_mqtt_dotdot_metering_attribute_divisor_callback_t callback)
{
  uic_mqtt_dotdot_metering_attribute_divisor_callback = callback;
}
void uic_mqtt_dotdot_metering_attribute_summation_formatting_callback_set(const uic_mqtt_dotdot_metering_attribute_summation_formatting_callback_t callback)
{
  uic_mqtt_dotdot_metering_attribute_summation_formatting_callback = callback;
}
void uic_mqtt_dotdot_metering_attribute_demand_formatting_callback_set(const uic_mqtt_dotdot_metering_attribute_demand_formatting_callback_t callback)
{
  uic_mqtt_dotdot_metering_attribute_demand_formatting_callback = callback;
}
void uic_mqtt_dotdot_metering_attribute_historical_consumption_formatting_callback_set(const uic_mqtt_dotdot_metering_attribute_historical_consumption_formatting_callback_t callback)
{
  uic_mqtt_dotdot_metering_attribute_historical_consumption_formatting_callback = callback;
}
void uic_mqtt_dotdot_metering_attribute_metering_device_type_callback_set(const uic_mqtt_dotdot_metering_attribute_metering_device_type_callback_t callback)
{
  uic_mqtt_dotdot_metering_attribute_metering_device_type_callback = callback;
}
void uic_mqtt_dotdot_metering_attribute_energy_carrier_unit_of_measure_callback_set(const uic_mqtt_dotdot_metering_attribute_energy_carrier_unit_of_measure_callback_t callback)
{
  uic_mqtt_dotdot_metering_attribute_energy_carrier_unit_of_measure_callback = callback;
}
void uic_mqtt_dotdot_metering_attribute_energy_carrier_summation_formatting_callback_set(const uic_mqtt_dotdot_metering_attribute_energy_carrier_summation_formatting_callback_t callback)
{
  uic_mqtt_dotdot_metering_attribute_energy_carrier_summation_formatting_callback = callback;
}
void uic_mqtt_dotdot_metering_attribute_energy_carrier_demand_formatting_callback_set(const uic_mqtt_dotdot_metering_attribute_energy_carrier_demand_formatting_callback_t callback)
{
  uic_mqtt_dotdot_metering_attribute_energy_carrier_demand_formatting_callback = callback;
}
void uic_mqtt_dotdot_metering_attribute_temperature_unit_of_measure_callback_set(const uic_mqtt_dotdot_metering_attribute_temperature_unit_of_measure_callback_t callback)
{
  uic_mqtt_dotdot_metering_attribute_temperature_unit_of_measure_callback = callback;
}
void uic_mqtt_dotdot_metering_attribute_temperature_formatting_callback_set(const uic_mqtt_dotdot_metering_attribute_temperature_formatting_callback_t callback)
{
  uic_mqtt_dotdot_metering_attribute_temperature_formatting_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for ElectricalMeasurement
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_electrical_measurement_attribute_measurement_type_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_measurement_type_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_min_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_min_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_max_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_max_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_min_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_min_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_max_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_max_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_min_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_min_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_max_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_max_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_multiplier_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_multiplier_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_divisor_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_divisor_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_multiplier_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_multiplier_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_divisor_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_divisor_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_multiplier_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_multiplier_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_divisor_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_divisor_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_min_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_min_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_max_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_max_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_neutral_current_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_neutral_current_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_total_active_power_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_total_active_power_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_total_reactive_power_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_total_reactive_power_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_total_apparent_power_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_total_apparent_power_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_measured1st_harmonic_current_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_measured1st_harmonic_current_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_measured3rd_harmonic_current_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_measured3rd_harmonic_current_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_measured5th_harmonic_current_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_measured5th_harmonic_current_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_measured7th_harmonic_current_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_measured7th_harmonic_current_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_measured9th_harmonic_current_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_measured9th_harmonic_current_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_measured11th_harmonic_current_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_measured11th_harmonic_current_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase1st_harmonic_current_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase1st_harmonic_current_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase3rd_harmonic_current_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase3rd_harmonic_current_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase5th_harmonic_current_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase5th_harmonic_current_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase7th_harmonic_current_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase7th_harmonic_current_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase9th_harmonic_current_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase9th_harmonic_current_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase11th_harmonic_current_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase11th_harmonic_current_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_multiplier_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_multiplier_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_divisor_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_divisor_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_power_multiplier_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_power_multiplier_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_power_divisor_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_power_divisor_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_harmonic_current_multiplier_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_harmonic_current_multiplier_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_phase_harmonic_current_multiplier_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_phase_harmonic_current_multiplier_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_line_current_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_line_current_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_active_current_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_active_current_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_reactive_current_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_reactive_current_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_min_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_min_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_max_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_max_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_min_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_min_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_max_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_max_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_active_power_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_active_power_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_active_power_min_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_active_power_min_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_active_power_max_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_active_power_max_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_reactive_power_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_reactive_power_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_apparent_power_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_apparent_power_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_power_factor_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_power_factor_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_voltage_measurement_period_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_voltage_measurement_period_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_over_voltage_counter_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_over_voltage_counter_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_under_voltage_counter_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_under_voltage_counter_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_over_voltage_period_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_over_voltage_period_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_under_voltage_period_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_under_voltage_period_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_sag_period_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_sag_period_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_swell_period_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_swell_period_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_ac_voltage_multiplier_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_ac_voltage_multiplier_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_ac_voltage_divisor_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_ac_voltage_divisor_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_ac_current_multiplier_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_ac_current_multiplier_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_ac_current_divisor_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_ac_current_divisor_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_ac_power_multiplier_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_ac_power_multiplier_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_ac_power_divisor_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_ac_power_divisor_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_dc_overload_alarms_mask_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_dc_overload_alarms_mask_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_overload_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_overload_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_overload_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_overload_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_ac_alarms_mask_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_ac_alarms_mask_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_ac_voltage_overload_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_ac_voltage_overload_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_ac_current_overload_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_ac_current_overload_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_ac_active_power_overload_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_ac_active_power_overload_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_ac_reactive_power_overload_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_ac_reactive_power_overload_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_over_voltage_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_over_voltage_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_under_voltage_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_under_voltage_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_over_voltage_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_over_voltage_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_under_voltage_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_under_voltage_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_sag_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_sag_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_swell_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_swell_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_line_current_phb_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_line_current_phb_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_active_current_phb_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_active_current_phb_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_reactive_current_phb_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_reactive_current_phb_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_phb_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_phb_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_min_phb_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_min_phb_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_max_phb_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_max_phb_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_phb_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_phb_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_min_phb_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_min_phb_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_max_phb_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_max_phb_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_active_power_phb_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_active_power_phb_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_active_power_min_phb_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_active_power_min_phb_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_active_power_max_phb_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_active_power_max_phb_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_reactive_power_phb_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_reactive_power_phb_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_apparent_power_phb_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_apparent_power_phb_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_power_factor_phb_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_power_factor_phb_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_voltage_measurement_period_phb_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_voltage_measurement_period_phb_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_over_voltage_counter_phb_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_over_voltage_counter_phb_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_under_voltage_counter_phb_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_under_voltage_counter_phb_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_over_voltage_period_phb_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_over_voltage_period_phb_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_under_voltage_period_phb_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_under_voltage_period_phb_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_sag_period_phb_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_sag_period_phb_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_swell_period_phb_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_swell_period_phb_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_line_current_phc_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_line_current_phc_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_active_current_phc_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_active_current_phc_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_reactive_current_phc_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_reactive_current_phc_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_phc_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_phc_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_min_phc_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_min_phc_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_max_phc_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_max_phc_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_phc_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_phc_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_min_phc_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_min_phc_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_max_phc_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_max_phc_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_active_power_phc_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_active_power_phc_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_active_power_min_phc_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_active_power_min_phc_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_active_power_max_phc_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_active_power_max_phc_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_reactive_power_phc_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_reactive_power_phc_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_apparent_power_phc_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_apparent_power_phc_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_power_factor_phc_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_power_factor_phc_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_voltage_measurement_period_phc_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_voltage_measurement_period_phc_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_over_voltage_counter_phc_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_over_voltage_counter_phc_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_under_voltage_counter_phc_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_under_voltage_counter_phc_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_over_voltage_period_phc_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_over_voltage_period_phc_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_under_voltage_period_phc_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_under_voltage_period_phc_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_sag_period_phc_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_sag_period_phc_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_swell_period_phc_callback_t uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_swell_period_phc_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for ElectricalMeasurement
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_electrical_measurement_measurement_type_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_measurement_type_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t measurement_type = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::MeasurementType: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      measurement_type = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, ElectricalMeasurementMeasurementType);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_measurement_type_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    measurement_type
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_dc_voltage_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t dc_voltage = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::DCVoltage: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      dc_voltage = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    dc_voltage
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_dc_voltage_min_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_min_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t dc_voltage_min = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::DCVoltageMin: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      dc_voltage_min = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_min_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    dc_voltage_min
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_dc_voltage_max_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_max_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t dc_voltage_max = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::DCVoltageMax: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      dc_voltage_max = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_max_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    dc_voltage_max
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_dc_current_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t dc_current = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::DCCurrent: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      dc_current = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    dc_current
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_dc_current_min_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_min_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t dc_current_min = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::DCCurrentMin: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      dc_current_min = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_min_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    dc_current_min
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_dc_current_max_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_max_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t dc_current_max = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::DCCurrentMax: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      dc_current_max = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_max_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    dc_current_max
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_dc_power_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t dc_power = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::DCPower: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      dc_power = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    dc_power
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_dc_power_min_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_min_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t dc_power_min = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::DCPowerMin: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      dc_power_min = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_min_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    dc_power_min
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_dc_power_max_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_max_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t dc_power_max = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::DCPowerMax: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      dc_power_max = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_max_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    dc_power_max
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_dc_voltage_multiplier_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_multiplier_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t dc_voltage_multiplier = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::DCVoltageMultiplier: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      dc_voltage_multiplier = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_multiplier_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    dc_voltage_multiplier
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_dc_voltage_divisor_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_divisor_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t dc_voltage_divisor = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::DCVoltageDivisor: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      dc_voltage_divisor = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_divisor_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    dc_voltage_divisor
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_dc_current_multiplier_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_multiplier_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t dc_current_multiplier = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::DCCurrentMultiplier: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      dc_current_multiplier = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_multiplier_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    dc_current_multiplier
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_dc_current_divisor_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_divisor_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t dc_current_divisor = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::DCCurrentDivisor: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      dc_current_divisor = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_divisor_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    dc_current_divisor
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_dc_power_multiplier_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_multiplier_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t dc_power_multiplier = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::DCPowerMultiplier: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      dc_power_multiplier = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_multiplier_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    dc_power_multiplier
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_dc_power_divisor_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_divisor_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t dc_power_divisor = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::DCPowerDivisor: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      dc_power_divisor = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_divisor_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    dc_power_divisor
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_ac_frequency_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t ac_frequency = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ACFrequency: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      ac_frequency = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    ac_frequency
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_ac_frequency_min_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_min_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t ac_frequency_min = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ACFrequencyMin: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      ac_frequency_min = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_min_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    ac_frequency_min
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_ac_frequency_max_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_max_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t ac_frequency_max = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ACFrequencyMax: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      ac_frequency_max = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_max_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    ac_frequency_max
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_neutral_current_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_neutral_current_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t neutral_current = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::NeutralCurrent: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      neutral_current = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_neutral_current_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    neutral_current
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_total_active_power_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_total_active_power_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int32_t total_active_power = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::TotalActivePower: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      total_active_power = json_payload.at("value").get<int32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_total_active_power_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    total_active_power
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_total_reactive_power_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_total_reactive_power_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int32_t total_reactive_power = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::TotalReactivePower: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      total_reactive_power = json_payload.at("value").get<int32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_total_reactive_power_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    total_reactive_power
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_total_apparent_power_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_total_apparent_power_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t total_apparent_power = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::TotalApparentPower: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      total_apparent_power = json_payload.at("value").get<uint32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_total_apparent_power_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    total_apparent_power
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_measured1st_harmonic_current_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_measured1st_harmonic_current_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t measured1st_harmonic_current = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::Measured1stHarmonicCurrent: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      measured1st_harmonic_current = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_measured1st_harmonic_current_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    measured1st_harmonic_current
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_measured3rd_harmonic_current_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_measured3rd_harmonic_current_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t measured3rd_harmonic_current = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::Measured3rdHarmonicCurrent: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      measured3rd_harmonic_current = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_measured3rd_harmonic_current_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    measured3rd_harmonic_current
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_measured5th_harmonic_current_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_measured5th_harmonic_current_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t measured5th_harmonic_current = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::Measured5thHarmonicCurrent: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      measured5th_harmonic_current = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_measured5th_harmonic_current_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    measured5th_harmonic_current
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_measured7th_harmonic_current_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_measured7th_harmonic_current_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t measured7th_harmonic_current = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::Measured7thHarmonicCurrent: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      measured7th_harmonic_current = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_measured7th_harmonic_current_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    measured7th_harmonic_current
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_measured9th_harmonic_current_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_measured9th_harmonic_current_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t measured9th_harmonic_current = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::Measured9thHarmonicCurrent: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      measured9th_harmonic_current = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_measured9th_harmonic_current_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    measured9th_harmonic_current
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_measured11th_harmonic_current_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_measured11th_harmonic_current_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t measured11th_harmonic_current = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::Measured11thHarmonicCurrent: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      measured11th_harmonic_current = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_measured11th_harmonic_current_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    measured11th_harmonic_current
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_measured_phase1st_harmonic_current_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase1st_harmonic_current_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t measured_phase1st_harmonic_current = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::MeasuredPhase1stHarmonicCurrent: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      measured_phase1st_harmonic_current = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase1st_harmonic_current_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    measured_phase1st_harmonic_current
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_measured_phase3rd_harmonic_current_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase3rd_harmonic_current_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t measured_phase3rd_harmonic_current = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::MeasuredPhase3rdHarmonicCurrent: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      measured_phase3rd_harmonic_current = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase3rd_harmonic_current_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    measured_phase3rd_harmonic_current
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_measured_phase5th_harmonic_current_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase5th_harmonic_current_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t measured_phase5th_harmonic_current = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::MeasuredPhase5thHarmonicCurrent: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      measured_phase5th_harmonic_current = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase5th_harmonic_current_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    measured_phase5th_harmonic_current
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_measured_phase7th_harmonic_current_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase7th_harmonic_current_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t measured_phase7th_harmonic_current = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::MeasuredPhase7thHarmonicCurrent: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      measured_phase7th_harmonic_current = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase7th_harmonic_current_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    measured_phase7th_harmonic_current
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_measured_phase9th_harmonic_current_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase9th_harmonic_current_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t measured_phase9th_harmonic_current = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::MeasuredPhase9thHarmonicCurrent: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      measured_phase9th_harmonic_current = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase9th_harmonic_current_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    measured_phase9th_harmonic_current
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_measured_phase11th_harmonic_current_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase11th_harmonic_current_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t measured_phase11th_harmonic_current = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::MeasuredPhase11thHarmonicCurrent: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      measured_phase11th_harmonic_current = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase11th_harmonic_current_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    measured_phase11th_harmonic_current
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_ac_frequency_multiplier_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_multiplier_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t ac_frequency_multiplier = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ACFrequencyMultiplier: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      ac_frequency_multiplier = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_multiplier_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    ac_frequency_multiplier
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_ac_frequency_divisor_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_divisor_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t ac_frequency_divisor = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ACFrequencyDivisor: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      ac_frequency_divisor = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_divisor_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    ac_frequency_divisor
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_power_multiplier_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_power_multiplier_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t power_multiplier = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::PowerMultiplier: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      power_multiplier = json_payload.at("value").get<uint32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_power_multiplier_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    power_multiplier
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_power_divisor_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_power_divisor_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t power_divisor = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::PowerDivisor: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      power_divisor = json_payload.at("value").get<uint32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_power_divisor_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    power_divisor
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_harmonic_current_multiplier_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_harmonic_current_multiplier_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int8_t harmonic_current_multiplier = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::HarmonicCurrentMultiplier: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      harmonic_current_multiplier = json_payload.at("value").get<int8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_harmonic_current_multiplier_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    harmonic_current_multiplier
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_phase_harmonic_current_multiplier_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_phase_harmonic_current_multiplier_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int8_t phase_harmonic_current_multiplier = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::PhaseHarmonicCurrentMultiplier: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      phase_harmonic_current_multiplier = json_payload.at("value").get<int8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_phase_harmonic_current_multiplier_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    phase_harmonic_current_multiplier
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_line_current_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_line_current_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t line_current = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::LineCurrent: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      line_current = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_line_current_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    line_current
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_active_current_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_active_current_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t active_current = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ActiveCurrent: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      active_current = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_active_current_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    active_current
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_reactive_current_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_reactive_current_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t reactive_current = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ReactiveCurrent: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      reactive_current = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_reactive_current_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    reactive_current
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_rms_voltage_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t rms_voltage = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::RMSVoltage: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rms_voltage = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rms_voltage
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_rms_voltage_min_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_min_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t rms_voltage_min = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::RMSVoltageMin: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rms_voltage_min = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_min_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rms_voltage_min
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_rms_voltage_max_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_max_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t rms_voltage_max = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::RMSVoltageMax: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rms_voltage_max = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_max_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rms_voltage_max
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_rms_current_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t rms_current = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::RMSCurrent: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rms_current = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rms_current
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_rms_current_min_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_min_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t rms_current_min = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::RMSCurrentMin: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rms_current_min = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_min_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rms_current_min
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_rms_current_max_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_max_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t rms_current_max = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::RMSCurrentMax: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rms_current_max = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_max_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rms_current_max
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_active_power_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_active_power_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t active_power = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ActivePower: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      active_power = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_active_power_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    active_power
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_active_power_min_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_active_power_min_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t active_power_min = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ActivePowerMin: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      active_power_min = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_active_power_min_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    active_power_min
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_active_power_max_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_active_power_max_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t active_power_max = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ActivePowerMax: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      active_power_max = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_active_power_max_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    active_power_max
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_reactive_power_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_reactive_power_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t reactive_power = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ReactivePower: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      reactive_power = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_reactive_power_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    reactive_power
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_apparent_power_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_apparent_power_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t apparent_power = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ApparentPower: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      apparent_power = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_apparent_power_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    apparent_power
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_power_factor_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_power_factor_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int8_t power_factor = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::PowerFactor: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      power_factor = json_payload.at("value").get<int8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_power_factor_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    power_factor
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_average_rms_voltage_measurement_period_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_voltage_measurement_period_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t average_rms_voltage_measurement_period = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::AverageRMSVoltageMeasurementPeriod: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      average_rms_voltage_measurement_period = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_voltage_measurement_period_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    average_rms_voltage_measurement_period
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_average_rms_over_voltage_counter_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_over_voltage_counter_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t average_rms_over_voltage_counter = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::AverageRMSOverVoltageCounter: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      average_rms_over_voltage_counter = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_over_voltage_counter_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    average_rms_over_voltage_counter
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_average_rms_under_voltage_counter_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_under_voltage_counter_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t average_rms_under_voltage_counter = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::AverageRMSUnderVoltageCounter: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      average_rms_under_voltage_counter = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_under_voltage_counter_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    average_rms_under_voltage_counter
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_rms_extreme_over_voltage_period_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_over_voltage_period_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t rms_extreme_over_voltage_period = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::RMSExtremeOverVoltagePeriod: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rms_extreme_over_voltage_period = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_over_voltage_period_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rms_extreme_over_voltage_period
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_rms_extreme_under_voltage_period_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_under_voltage_period_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t rms_extreme_under_voltage_period = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::RMSExtremeUnderVoltagePeriod: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rms_extreme_under_voltage_period = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_under_voltage_period_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rms_extreme_under_voltage_period
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_rms_voltage_sag_period_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_sag_period_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t rms_voltage_sag_period = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::RMSVoltageSagPeriod: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rms_voltage_sag_period = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_sag_period_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rms_voltage_sag_period
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_rms_voltage_swell_period_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_swell_period_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t rms_voltage_swell_period = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::RMSVoltageSwellPeriod: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rms_voltage_swell_period = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_swell_period_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rms_voltage_swell_period
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_ac_voltage_multiplier_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_ac_voltage_multiplier_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t ac_voltage_multiplier = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ACVoltageMultiplier: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      ac_voltage_multiplier = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_ac_voltage_multiplier_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    ac_voltage_multiplier
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_ac_voltage_divisor_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_ac_voltage_divisor_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t ac_voltage_divisor = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ACVoltageDivisor: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      ac_voltage_divisor = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_ac_voltage_divisor_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    ac_voltage_divisor
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_ac_current_multiplier_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_ac_current_multiplier_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t ac_current_multiplier = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ACCurrentMultiplier: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      ac_current_multiplier = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_ac_current_multiplier_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    ac_current_multiplier
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_ac_current_divisor_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_ac_current_divisor_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t ac_current_divisor = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ACCurrentDivisor: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      ac_current_divisor = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_ac_current_divisor_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    ac_current_divisor
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_ac_power_multiplier_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_ac_power_multiplier_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t ac_power_multiplier = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ACPowerMultiplier: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      ac_power_multiplier = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_ac_power_multiplier_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    ac_power_multiplier
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_ac_power_divisor_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_ac_power_divisor_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t ac_power_divisor = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ACPowerDivisor: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      ac_power_divisor = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_ac_power_divisor_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    ac_power_divisor
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_dc_overload_alarms_mask_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_dc_overload_alarms_mask_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t dc_overload_alarms_mask = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::DCOverloadAlarmsMask: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      dc_overload_alarms_mask = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, ElectricalMeasurementDCOverloadAlarmsMask);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_dc_overload_alarms_mask_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    dc_overload_alarms_mask
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_dc_voltage_overload_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_overload_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t dc_voltage_overload = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::DCVoltageOverload: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      dc_voltage_overload = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_overload_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    dc_voltage_overload
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_dc_current_overload_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_overload_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t dc_current_overload = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::DCCurrentOverload: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      dc_current_overload = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_overload_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    dc_current_overload
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_ac_alarms_mask_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_ac_alarms_mask_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t ac_alarms_mask = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ACAlarmsMask: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      ac_alarms_mask = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, ElectricalMeasurementACAlarmsMask);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_ac_alarms_mask_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    ac_alarms_mask
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_ac_voltage_overload_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_ac_voltage_overload_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t ac_voltage_overload = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ACVoltageOverload: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      ac_voltage_overload = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_ac_voltage_overload_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    ac_voltage_overload
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_ac_current_overload_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_ac_current_overload_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t ac_current_overload = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ACCurrentOverload: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      ac_current_overload = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_ac_current_overload_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    ac_current_overload
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_ac_active_power_overload_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_ac_active_power_overload_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t ac_active_power_overload = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ACActivePowerOverload: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      ac_active_power_overload = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_ac_active_power_overload_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    ac_active_power_overload
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_ac_reactive_power_overload_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_ac_reactive_power_overload_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t ac_reactive_power_overload = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ACReactivePowerOverload: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      ac_reactive_power_overload = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_ac_reactive_power_overload_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    ac_reactive_power_overload
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_average_rms_over_voltage_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_over_voltage_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t average_rms_over_voltage = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::AverageRMSOverVoltage: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      average_rms_over_voltage = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_over_voltage_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    average_rms_over_voltage
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_average_rms_under_voltage_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_under_voltage_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t average_rms_under_voltage = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::AverageRMSUnderVoltage: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      average_rms_under_voltage = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_under_voltage_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    average_rms_under_voltage
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_rms_extreme_over_voltage_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_over_voltage_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t rms_extreme_over_voltage = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::RMSExtremeOverVoltage: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rms_extreme_over_voltage = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_over_voltage_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rms_extreme_over_voltage
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_rms_extreme_under_voltage_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_under_voltage_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t rms_extreme_under_voltage = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::RMSExtremeUnderVoltage: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rms_extreme_under_voltage = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_under_voltage_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rms_extreme_under_voltage
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_rms_voltage_sag_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_sag_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t rms_voltage_sag = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::RMSVoltageSag: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rms_voltage_sag = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_sag_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rms_voltage_sag
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_rms_voltage_swell_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_swell_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t rms_voltage_swell = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::RMSVoltageSwell: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rms_voltage_swell = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_swell_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rms_voltage_swell
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_line_current_phb_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_line_current_phb_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t line_current_phb = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::LineCurrentPhB: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      line_current_phb = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_line_current_phb_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    line_current_phb
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_active_current_phb_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_active_current_phb_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t active_current_phb = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ActiveCurrentPhB: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      active_current_phb = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_active_current_phb_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    active_current_phb
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_reactive_current_phb_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_reactive_current_phb_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t reactive_current_phb = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ReactiveCurrentPhB: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      reactive_current_phb = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_reactive_current_phb_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    reactive_current_phb
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_rms_voltage_phb_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_phb_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t rms_voltage_phb = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::RMSVoltagePhB: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rms_voltage_phb = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_phb_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rms_voltage_phb
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_rms_voltage_min_phb_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_min_phb_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t rms_voltage_min_phb = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::RMSVoltageMinPhB: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rms_voltage_min_phb = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_min_phb_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rms_voltage_min_phb
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_rms_voltage_max_phb_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_max_phb_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t rms_voltage_max_phb = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::RMSVoltageMaxPhB: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rms_voltage_max_phb = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_max_phb_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rms_voltage_max_phb
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_rms_current_phb_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_phb_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t rms_current_phb = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::RMSCurrentPhB: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rms_current_phb = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_phb_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rms_current_phb
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_rms_current_min_phb_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_min_phb_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t rms_current_min_phb = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::RMSCurrentMinPhB: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rms_current_min_phb = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_min_phb_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rms_current_min_phb
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_rms_current_max_phb_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_max_phb_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t rms_current_max_phb = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::RMSCurrentMaxPhB: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rms_current_max_phb = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_max_phb_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rms_current_max_phb
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_active_power_phb_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_active_power_phb_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t active_power_phb = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ActivePowerPhB: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      active_power_phb = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_active_power_phb_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    active_power_phb
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_active_power_min_phb_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_active_power_min_phb_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t active_power_min_phb = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ActivePowerMinPhB: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      active_power_min_phb = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_active_power_min_phb_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    active_power_min_phb
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_active_power_max_phb_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_active_power_max_phb_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t active_power_max_phb = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ActivePowerMaxPhB: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      active_power_max_phb = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_active_power_max_phb_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    active_power_max_phb
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_reactive_power_phb_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_reactive_power_phb_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t reactive_power_phb = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ReactivePowerPhB: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      reactive_power_phb = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_reactive_power_phb_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    reactive_power_phb
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_apparent_power_phb_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_apparent_power_phb_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t apparent_power_phb = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ApparentPowerPhB: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      apparent_power_phb = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_apparent_power_phb_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    apparent_power_phb
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_power_factor_phb_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_power_factor_phb_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int8_t power_factor_phb = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::PowerFactorPhB: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      power_factor_phb = json_payload.at("value").get<int8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_power_factor_phb_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    power_factor_phb
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_average_rms_voltage_measurement_period_phb_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_voltage_measurement_period_phb_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t average_rms_voltage_measurement_period_phb = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::AverageRMSVoltageMeasurementPeriodPhB: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      average_rms_voltage_measurement_period_phb = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_voltage_measurement_period_phb_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    average_rms_voltage_measurement_period_phb
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_average_rms_over_voltage_counter_phb_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_over_voltage_counter_phb_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t average_rms_over_voltage_counter_phb = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::AverageRMSOverVoltageCounterPhB: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      average_rms_over_voltage_counter_phb = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_over_voltage_counter_phb_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    average_rms_over_voltage_counter_phb
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_average_rms_under_voltage_counter_phb_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_under_voltage_counter_phb_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t average_rms_under_voltage_counter_phb = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::AverageRMSUnderVoltageCounterPhB: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      average_rms_under_voltage_counter_phb = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_under_voltage_counter_phb_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    average_rms_under_voltage_counter_phb
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_rms_extreme_over_voltage_period_phb_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_over_voltage_period_phb_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t rms_extreme_over_voltage_period_phb = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::RMSExtremeOverVoltagePeriodPhB: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rms_extreme_over_voltage_period_phb = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_over_voltage_period_phb_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rms_extreme_over_voltage_period_phb
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_rms_extreme_under_voltage_period_phb_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_under_voltage_period_phb_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t rms_extreme_under_voltage_period_phb = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::RMSExtremeUnderVoltagePeriodPhB: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rms_extreme_under_voltage_period_phb = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_under_voltage_period_phb_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rms_extreme_under_voltage_period_phb
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_rms_voltage_sag_period_phb_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_sag_period_phb_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t rms_voltage_sag_period_phb = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::RMSVoltageSagPeriodPhB: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rms_voltage_sag_period_phb = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_sag_period_phb_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rms_voltage_sag_period_phb
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_rms_voltage_swell_period_phb_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_swell_period_phb_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t rms_voltage_swell_period_phb = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::RMSVoltageSwellPeriodPhB: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rms_voltage_swell_period_phb = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_swell_period_phb_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rms_voltage_swell_period_phb
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_line_current_phc_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_line_current_phc_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t line_current_phc = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::LineCurrentPhC: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      line_current_phc = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_line_current_phc_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    line_current_phc
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_active_current_phc_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_active_current_phc_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t active_current_phc = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ActiveCurrentPhC: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      active_current_phc = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_active_current_phc_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    active_current_phc
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_reactive_current_phc_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_reactive_current_phc_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t reactive_current_phc = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ReactiveCurrentPhC: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      reactive_current_phc = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_reactive_current_phc_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    reactive_current_phc
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_rms_voltage_phc_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_phc_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t rms_voltage_phc = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::RMSVoltagePhC: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rms_voltage_phc = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_phc_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rms_voltage_phc
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_rms_voltage_min_phc_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_min_phc_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t rms_voltage_min_phc = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::RMSVoltageMinPhC: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rms_voltage_min_phc = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_min_phc_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rms_voltage_min_phc
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_rms_voltage_max_phc_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_max_phc_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t rms_voltage_max_phc = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::RMSVoltageMaxPhC: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rms_voltage_max_phc = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_max_phc_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rms_voltage_max_phc
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_rms_current_phc_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_phc_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t rms_current_phc = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::RMSCurrentPhC: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rms_current_phc = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_phc_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rms_current_phc
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_rms_current_min_phc_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_min_phc_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t rms_current_min_phc = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::RMSCurrentMinPhC: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rms_current_min_phc = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_min_phc_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rms_current_min_phc
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_rms_current_max_phc_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_max_phc_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t rms_current_max_phc = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::RMSCurrentMaxPhC: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rms_current_max_phc = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_max_phc_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rms_current_max_phc
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_active_power_phc_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_active_power_phc_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t active_power_phc = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ActivePowerPhC: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      active_power_phc = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_active_power_phc_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    active_power_phc
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_active_power_min_phc_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_active_power_min_phc_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t active_power_min_phc = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ActivePowerMinPhC: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      active_power_min_phc = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_active_power_min_phc_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    active_power_min_phc
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_active_power_max_phc_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_active_power_max_phc_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t active_power_max_phc = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ActivePowerMaxPhC: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      active_power_max_phc = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_active_power_max_phc_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    active_power_max_phc
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_reactive_power_phc_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_reactive_power_phc_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int16_t reactive_power_phc = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ReactivePowerPhC: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      reactive_power_phc = json_payload.at("value").get<int16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_reactive_power_phc_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    reactive_power_phc
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_apparent_power_phc_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_apparent_power_phc_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t apparent_power_phc = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::ApparentPowerPhC: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      apparent_power_phc = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_apparent_power_phc_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    apparent_power_phc
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_power_factor_phc_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_power_factor_phc_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int8_t power_factor_phc = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::PowerFactorPhC: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      power_factor_phc = json_payload.at("value").get<int8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_power_factor_phc_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    power_factor_phc
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_average_rms_voltage_measurement_period_phc_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_voltage_measurement_period_phc_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t average_rms_voltage_measurement_period_phc = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::AverageRMSVoltageMeasurementPeriodPhC: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      average_rms_voltage_measurement_period_phc = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_voltage_measurement_period_phc_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    average_rms_voltage_measurement_period_phc
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_average_rms_over_voltage_counter_phc_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_over_voltage_counter_phc_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t average_rms_over_voltage_counter_phc = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::AverageRMSOverVoltageCounterPhC: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      average_rms_over_voltage_counter_phc = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_over_voltage_counter_phc_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    average_rms_over_voltage_counter_phc
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_average_rms_under_voltage_counter_phc_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_under_voltage_counter_phc_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t average_rms_under_voltage_counter_phc = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::AverageRMSUnderVoltageCounterPhC: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      average_rms_under_voltage_counter_phc = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_under_voltage_counter_phc_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    average_rms_under_voltage_counter_phc
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_rms_extreme_over_voltage_period_phc_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_over_voltage_period_phc_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t rms_extreme_over_voltage_period_phc = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::RMSExtremeOverVoltagePeriodPhC: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rms_extreme_over_voltage_period_phc = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_over_voltage_period_phc_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rms_extreme_over_voltage_period_phc
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_rms_extreme_under_voltage_period_phc_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_under_voltage_period_phc_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t rms_extreme_under_voltage_period_phc = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::RMSExtremeUnderVoltagePeriodPhC: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rms_extreme_under_voltage_period_phc = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_under_voltage_period_phc_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rms_extreme_under_voltage_period_phc
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_rms_voltage_sag_period_phc_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_sag_period_phc_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t rms_voltage_sag_period_phc = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::RMSVoltageSagPeriodPhC: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rms_voltage_sag_period_phc = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_sag_period_phc_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rms_voltage_sag_period_phc
  );

}
static void uic_mqtt_dotdot_on_electrical_measurement_rms_voltage_swell_period_phc_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_swell_period_phc_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t rms_voltage_swell_period_phc = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ElectricalMeasurement::RMSVoltageSwellPeriodPhC: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      rms_voltage_swell_period_phc = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_swell_period_phc_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    rms_voltage_swell_period_phc
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for ElectricalMeasurement
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_electrical_measurement_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_electrical_measurement_attribute_measurement_type_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/MeasurementType/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_measurement_type_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/DCVoltage/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_dc_voltage_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_min_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/DCVoltageMin/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_dc_voltage_min_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_max_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/DCVoltageMax/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_dc_voltage_max_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/DCCurrent/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_dc_current_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_min_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/DCCurrentMin/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_dc_current_min_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_max_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/DCCurrentMax/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_dc_current_max_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/DCPower/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_dc_power_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_min_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/DCPowerMin/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_dc_power_min_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_max_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/DCPowerMax/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_dc_power_max_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_multiplier_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/DCVoltageMultiplier/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_dc_voltage_multiplier_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_divisor_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/DCVoltageDivisor/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_dc_voltage_divisor_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_multiplier_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/DCCurrentMultiplier/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_dc_current_multiplier_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_divisor_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/DCCurrentDivisor/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_dc_current_divisor_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_multiplier_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/DCPowerMultiplier/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_dc_power_multiplier_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_divisor_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/DCPowerDivisor/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_dc_power_divisor_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ACFrequency/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_ac_frequency_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_min_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ACFrequencyMin/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_ac_frequency_min_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_max_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ACFrequencyMax/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_ac_frequency_max_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_neutral_current_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/NeutralCurrent/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_neutral_current_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_total_active_power_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/TotalActivePower/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_total_active_power_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_total_reactive_power_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/TotalReactivePower/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_total_reactive_power_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_total_apparent_power_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/TotalApparentPower/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_total_apparent_power_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_measured1st_harmonic_current_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/Measured1stHarmonicCurrent/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_measured1st_harmonic_current_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_measured3rd_harmonic_current_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/Measured3rdHarmonicCurrent/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_measured3rd_harmonic_current_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_measured5th_harmonic_current_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/Measured5thHarmonicCurrent/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_measured5th_harmonic_current_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_measured7th_harmonic_current_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/Measured7thHarmonicCurrent/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_measured7th_harmonic_current_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_measured9th_harmonic_current_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/Measured9thHarmonicCurrent/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_measured9th_harmonic_current_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_measured11th_harmonic_current_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/Measured11thHarmonicCurrent/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_measured11th_harmonic_current_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase1st_harmonic_current_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/MeasuredPhase1stHarmonicCurrent/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_measured_phase1st_harmonic_current_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase3rd_harmonic_current_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/MeasuredPhase3rdHarmonicCurrent/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_measured_phase3rd_harmonic_current_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase5th_harmonic_current_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/MeasuredPhase5thHarmonicCurrent/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_measured_phase5th_harmonic_current_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase7th_harmonic_current_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/MeasuredPhase7thHarmonicCurrent/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_measured_phase7th_harmonic_current_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase9th_harmonic_current_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/MeasuredPhase9thHarmonicCurrent/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_measured_phase9th_harmonic_current_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase11th_harmonic_current_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/MeasuredPhase11thHarmonicCurrent/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_measured_phase11th_harmonic_current_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_multiplier_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ACFrequencyMultiplier/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_ac_frequency_multiplier_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_divisor_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ACFrequencyDivisor/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_ac_frequency_divisor_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_power_multiplier_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/PowerMultiplier/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_power_multiplier_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_power_divisor_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/PowerDivisor/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_power_divisor_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_harmonic_current_multiplier_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/HarmonicCurrentMultiplier/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_harmonic_current_multiplier_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_phase_harmonic_current_multiplier_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/PhaseHarmonicCurrentMultiplier/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_phase_harmonic_current_multiplier_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_line_current_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/LineCurrent/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_line_current_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_active_current_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ActiveCurrent/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_active_current_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_reactive_current_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ReactiveCurrent/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_reactive_current_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/RMSVoltage/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_rms_voltage_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_min_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/RMSVoltageMin/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_rms_voltage_min_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_max_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/RMSVoltageMax/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_rms_voltage_max_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/RMSCurrent/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_rms_current_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_min_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/RMSCurrentMin/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_rms_current_min_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_max_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/RMSCurrentMax/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_rms_current_max_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_active_power_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ActivePower/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_active_power_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_active_power_min_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ActivePowerMin/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_active_power_min_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_active_power_max_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ActivePowerMax/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_active_power_max_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_reactive_power_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ReactivePower/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_reactive_power_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_apparent_power_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ApparentPower/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_apparent_power_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_power_factor_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/PowerFactor/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_power_factor_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_voltage_measurement_period_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/AverageRMSVoltageMeasurementPeriod/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_average_rms_voltage_measurement_period_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_over_voltage_counter_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/AverageRMSOverVoltageCounter/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_average_rms_over_voltage_counter_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_under_voltage_counter_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/AverageRMSUnderVoltageCounter/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_average_rms_under_voltage_counter_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_over_voltage_period_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/RMSExtremeOverVoltagePeriod/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_rms_extreme_over_voltage_period_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_under_voltage_period_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/RMSExtremeUnderVoltagePeriod/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_rms_extreme_under_voltage_period_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_sag_period_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/RMSVoltageSagPeriod/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_rms_voltage_sag_period_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_swell_period_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/RMSVoltageSwellPeriod/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_rms_voltage_swell_period_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_ac_voltage_multiplier_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ACVoltageMultiplier/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_ac_voltage_multiplier_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_ac_voltage_divisor_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ACVoltageDivisor/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_ac_voltage_divisor_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_ac_current_multiplier_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ACCurrentMultiplier/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_ac_current_multiplier_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_ac_current_divisor_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ACCurrentDivisor/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_ac_current_divisor_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_ac_power_multiplier_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ACPowerMultiplier/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_ac_power_multiplier_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_ac_power_divisor_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ACPowerDivisor/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_ac_power_divisor_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_dc_overload_alarms_mask_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/DCOverloadAlarmsMask/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_dc_overload_alarms_mask_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_overload_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/DCVoltageOverload/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_dc_voltage_overload_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_overload_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/DCCurrentOverload/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_dc_current_overload_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_ac_alarms_mask_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ACAlarmsMask/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_ac_alarms_mask_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_ac_voltage_overload_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ACVoltageOverload/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_ac_voltage_overload_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_ac_current_overload_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ACCurrentOverload/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_ac_current_overload_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_ac_active_power_overload_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ACActivePowerOverload/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_ac_active_power_overload_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_ac_reactive_power_overload_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ACReactivePowerOverload/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_ac_reactive_power_overload_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_over_voltage_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/AverageRMSOverVoltage/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_average_rms_over_voltage_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_under_voltage_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/AverageRMSUnderVoltage/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_average_rms_under_voltage_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_over_voltage_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/RMSExtremeOverVoltage/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_rms_extreme_over_voltage_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_under_voltage_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/RMSExtremeUnderVoltage/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_rms_extreme_under_voltage_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_sag_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/RMSVoltageSag/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_rms_voltage_sag_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_swell_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/RMSVoltageSwell/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_rms_voltage_swell_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_line_current_phb_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/LineCurrentPhB/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_line_current_phb_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_active_current_phb_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ActiveCurrentPhB/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_active_current_phb_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_reactive_current_phb_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ReactiveCurrentPhB/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_reactive_current_phb_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_phb_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/RMSVoltagePhB/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_rms_voltage_phb_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_min_phb_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/RMSVoltageMinPhB/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_rms_voltage_min_phb_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_max_phb_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/RMSVoltageMaxPhB/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_rms_voltage_max_phb_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_phb_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/RMSCurrentPhB/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_rms_current_phb_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_min_phb_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/RMSCurrentMinPhB/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_rms_current_min_phb_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_max_phb_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/RMSCurrentMaxPhB/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_rms_current_max_phb_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_active_power_phb_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ActivePowerPhB/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_active_power_phb_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_active_power_min_phb_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ActivePowerMinPhB/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_active_power_min_phb_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_active_power_max_phb_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ActivePowerMaxPhB/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_active_power_max_phb_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_reactive_power_phb_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ReactivePowerPhB/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_reactive_power_phb_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_apparent_power_phb_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ApparentPowerPhB/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_apparent_power_phb_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_power_factor_phb_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/PowerFactorPhB/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_power_factor_phb_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_voltage_measurement_period_phb_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/AverageRMSVoltageMeasurementPeriodPhB/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_average_rms_voltage_measurement_period_phb_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_over_voltage_counter_phb_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/AverageRMSOverVoltageCounterPhB/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_average_rms_over_voltage_counter_phb_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_under_voltage_counter_phb_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/AverageRMSUnderVoltageCounterPhB/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_average_rms_under_voltage_counter_phb_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_over_voltage_period_phb_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/RMSExtremeOverVoltagePeriodPhB/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_rms_extreme_over_voltage_period_phb_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_under_voltage_period_phb_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/RMSExtremeUnderVoltagePeriodPhB/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_rms_extreme_under_voltage_period_phb_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_sag_period_phb_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/RMSVoltageSagPeriodPhB/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_rms_voltage_sag_period_phb_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_swell_period_phb_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/RMSVoltageSwellPeriodPhB/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_rms_voltage_swell_period_phb_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_line_current_phc_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/LineCurrentPhC/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_line_current_phc_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_active_current_phc_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ActiveCurrentPhC/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_active_current_phc_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_reactive_current_phc_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ReactiveCurrentPhC/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_reactive_current_phc_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_phc_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/RMSVoltagePhC/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_rms_voltage_phc_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_min_phc_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/RMSVoltageMinPhC/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_rms_voltage_min_phc_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_max_phc_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/RMSVoltageMaxPhC/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_rms_voltage_max_phc_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_phc_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/RMSCurrentPhC/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_rms_current_phc_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_min_phc_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/RMSCurrentMinPhC/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_rms_current_min_phc_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_max_phc_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/RMSCurrentMaxPhC/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_rms_current_max_phc_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_active_power_phc_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ActivePowerPhC/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_active_power_phc_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_active_power_min_phc_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ActivePowerMinPhC/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_active_power_min_phc_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_active_power_max_phc_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ActivePowerMaxPhC/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_active_power_max_phc_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_reactive_power_phc_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ReactivePowerPhC/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_reactive_power_phc_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_apparent_power_phc_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/ApparentPowerPhC/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_apparent_power_phc_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_power_factor_phc_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/PowerFactorPhC/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_power_factor_phc_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_voltage_measurement_period_phc_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/AverageRMSVoltageMeasurementPeriodPhC/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_average_rms_voltage_measurement_period_phc_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_over_voltage_counter_phc_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/AverageRMSOverVoltageCounterPhC/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_average_rms_over_voltage_counter_phc_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_under_voltage_counter_phc_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/AverageRMSUnderVoltageCounterPhC/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_average_rms_under_voltage_counter_phc_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_over_voltage_period_phc_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/RMSExtremeOverVoltagePeriodPhC/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_rms_extreme_over_voltage_period_phc_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_under_voltage_period_phc_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/RMSExtremeUnderVoltagePeriodPhC/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_rms_extreme_under_voltage_period_phc_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_sag_period_phc_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/RMSVoltageSagPeriodPhC/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_rms_voltage_sag_period_phc_attribute_update);
  }
  if(uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_swell_period_phc_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Attributes/RMSVoltageSwellPeriodPhC/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_electrical_measurement_rms_voltage_swell_period_phc_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for ElectricalMeasurement
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_electrical_measurement_attribute_measurement_type_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_measurement_type_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_measurement_type_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_min_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_min_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_min_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_max_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_max_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_max_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_min_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_min_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_min_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_max_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_max_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_max_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_min_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_min_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_min_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_max_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_max_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_max_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_multiplier_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_multiplier_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_multiplier_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_divisor_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_divisor_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_divisor_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_multiplier_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_multiplier_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_multiplier_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_divisor_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_divisor_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_divisor_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_multiplier_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_multiplier_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_multiplier_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_divisor_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_divisor_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_dc_power_divisor_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_min_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_min_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_min_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_max_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_max_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_max_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_neutral_current_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_neutral_current_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_neutral_current_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_total_active_power_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_total_active_power_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_total_active_power_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_total_reactive_power_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_total_reactive_power_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_total_reactive_power_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_total_apparent_power_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_total_apparent_power_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_total_apparent_power_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_measured1st_harmonic_current_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_measured1st_harmonic_current_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_measured1st_harmonic_current_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_measured3rd_harmonic_current_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_measured3rd_harmonic_current_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_measured3rd_harmonic_current_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_measured5th_harmonic_current_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_measured5th_harmonic_current_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_measured5th_harmonic_current_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_measured7th_harmonic_current_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_measured7th_harmonic_current_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_measured7th_harmonic_current_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_measured9th_harmonic_current_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_measured9th_harmonic_current_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_measured9th_harmonic_current_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_measured11th_harmonic_current_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_measured11th_harmonic_current_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_measured11th_harmonic_current_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase1st_harmonic_current_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase1st_harmonic_current_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase1st_harmonic_current_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase3rd_harmonic_current_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase3rd_harmonic_current_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase3rd_harmonic_current_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase5th_harmonic_current_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase5th_harmonic_current_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase5th_harmonic_current_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase7th_harmonic_current_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase7th_harmonic_current_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase7th_harmonic_current_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase9th_harmonic_current_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase9th_harmonic_current_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase9th_harmonic_current_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase11th_harmonic_current_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase11th_harmonic_current_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_measured_phase11th_harmonic_current_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_multiplier_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_multiplier_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_multiplier_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_divisor_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_divisor_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_ac_frequency_divisor_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_power_multiplier_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_power_multiplier_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_power_multiplier_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_power_divisor_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_power_divisor_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_power_divisor_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_harmonic_current_multiplier_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_harmonic_current_multiplier_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_harmonic_current_multiplier_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_phase_harmonic_current_multiplier_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_phase_harmonic_current_multiplier_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_phase_harmonic_current_multiplier_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_line_current_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_line_current_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_line_current_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_active_current_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_active_current_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_active_current_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_reactive_current_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_reactive_current_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_reactive_current_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_min_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_min_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_min_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_max_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_max_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_max_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_min_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_min_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_min_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_max_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_max_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_max_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_active_power_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_active_power_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_active_power_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_active_power_min_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_active_power_min_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_active_power_min_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_active_power_max_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_active_power_max_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_active_power_max_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_reactive_power_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_reactive_power_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_reactive_power_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_apparent_power_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_apparent_power_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_apparent_power_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_power_factor_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_power_factor_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_power_factor_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_voltage_measurement_period_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_voltage_measurement_period_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_voltage_measurement_period_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_over_voltage_counter_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_over_voltage_counter_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_over_voltage_counter_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_under_voltage_counter_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_under_voltage_counter_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_under_voltage_counter_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_over_voltage_period_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_over_voltage_period_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_over_voltage_period_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_under_voltage_period_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_under_voltage_period_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_under_voltage_period_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_sag_period_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_sag_period_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_sag_period_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_swell_period_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_swell_period_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_swell_period_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_ac_voltage_multiplier_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_ac_voltage_multiplier_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_ac_voltage_multiplier_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_ac_voltage_divisor_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_ac_voltage_divisor_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_ac_voltage_divisor_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_ac_current_multiplier_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_ac_current_multiplier_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_ac_current_multiplier_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_ac_current_divisor_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_ac_current_divisor_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_ac_current_divisor_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_ac_power_multiplier_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_ac_power_multiplier_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_ac_power_multiplier_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_ac_power_divisor_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_ac_power_divisor_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_ac_power_divisor_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_dc_overload_alarms_mask_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_dc_overload_alarms_mask_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_dc_overload_alarms_mask_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_overload_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_overload_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_dc_voltage_overload_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_overload_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_overload_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_dc_current_overload_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_ac_alarms_mask_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_ac_alarms_mask_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_ac_alarms_mask_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_ac_voltage_overload_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_ac_voltage_overload_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_ac_voltage_overload_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_ac_current_overload_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_ac_current_overload_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_ac_current_overload_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_ac_active_power_overload_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_ac_active_power_overload_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_ac_active_power_overload_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_ac_reactive_power_overload_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_ac_reactive_power_overload_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_ac_reactive_power_overload_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_over_voltage_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_over_voltage_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_over_voltage_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_under_voltage_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_under_voltage_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_under_voltage_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_over_voltage_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_over_voltage_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_over_voltage_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_under_voltage_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_under_voltage_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_under_voltage_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_sag_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_sag_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_sag_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_swell_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_swell_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_swell_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_line_current_phb_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_line_current_phb_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_line_current_phb_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_active_current_phb_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_active_current_phb_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_active_current_phb_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_reactive_current_phb_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_reactive_current_phb_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_reactive_current_phb_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_phb_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_phb_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_phb_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_min_phb_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_min_phb_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_min_phb_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_max_phb_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_max_phb_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_max_phb_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_phb_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_phb_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_phb_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_min_phb_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_min_phb_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_min_phb_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_max_phb_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_max_phb_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_max_phb_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_active_power_phb_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_active_power_phb_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_active_power_phb_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_active_power_min_phb_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_active_power_min_phb_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_active_power_min_phb_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_active_power_max_phb_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_active_power_max_phb_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_active_power_max_phb_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_reactive_power_phb_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_reactive_power_phb_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_reactive_power_phb_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_apparent_power_phb_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_apparent_power_phb_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_apparent_power_phb_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_power_factor_phb_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_power_factor_phb_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_power_factor_phb_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_voltage_measurement_period_phb_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_voltage_measurement_period_phb_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_voltage_measurement_period_phb_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_over_voltage_counter_phb_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_over_voltage_counter_phb_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_over_voltage_counter_phb_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_under_voltage_counter_phb_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_under_voltage_counter_phb_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_under_voltage_counter_phb_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_over_voltage_period_phb_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_over_voltage_period_phb_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_over_voltage_period_phb_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_under_voltage_period_phb_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_under_voltage_period_phb_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_under_voltage_period_phb_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_sag_period_phb_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_sag_period_phb_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_sag_period_phb_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_swell_period_phb_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_swell_period_phb_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_swell_period_phb_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_line_current_phc_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_line_current_phc_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_line_current_phc_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_active_current_phc_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_active_current_phc_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_active_current_phc_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_reactive_current_phc_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_reactive_current_phc_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_reactive_current_phc_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_phc_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_phc_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_phc_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_min_phc_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_min_phc_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_min_phc_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_max_phc_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_max_phc_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_max_phc_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_phc_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_phc_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_phc_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_min_phc_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_min_phc_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_min_phc_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_max_phc_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_max_phc_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_rms_current_max_phc_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_active_power_phc_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_active_power_phc_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_active_power_phc_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_active_power_min_phc_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_active_power_min_phc_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_active_power_min_phc_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_active_power_max_phc_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_active_power_max_phc_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_active_power_max_phc_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_reactive_power_phc_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_reactive_power_phc_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_reactive_power_phc_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_apparent_power_phc_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_apparent_power_phc_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_apparent_power_phc_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_power_factor_phc_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_power_factor_phc_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_power_factor_phc_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_voltage_measurement_period_phc_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_voltage_measurement_period_phc_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_voltage_measurement_period_phc_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_over_voltage_counter_phc_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_over_voltage_counter_phc_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_over_voltage_counter_phc_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_under_voltage_counter_phc_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_under_voltage_counter_phc_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_average_rms_under_voltage_counter_phc_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_over_voltage_period_phc_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_over_voltage_period_phc_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_over_voltage_period_phc_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_under_voltage_period_phc_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_under_voltage_period_phc_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_rms_extreme_under_voltage_period_phc_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_sag_period_phc_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_sag_period_phc_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_sag_period_phc_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_swell_period_phc_callback_set(const uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_swell_period_phc_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_attribute_rms_voltage_swell_period_phc_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for Diagnostics
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_diagnostics_attribute_number_of_resets_callback_t uic_mqtt_dotdot_diagnostics_attribute_number_of_resets_callback = nullptr;
static uic_mqtt_dotdot_diagnostics_attribute_persistent_memory_writes_callback_t uic_mqtt_dotdot_diagnostics_attribute_persistent_memory_writes_callback = nullptr;
static uic_mqtt_dotdot_diagnostics_attribute_mac_rx_bcast_callback_t uic_mqtt_dotdot_diagnostics_attribute_mac_rx_bcast_callback = nullptr;
static uic_mqtt_dotdot_diagnostics_attribute_mac_tx_bcast_callback_t uic_mqtt_dotdot_diagnostics_attribute_mac_tx_bcast_callback = nullptr;
static uic_mqtt_dotdot_diagnostics_attribute_mac_rx_ucast_callback_t uic_mqtt_dotdot_diagnostics_attribute_mac_rx_ucast_callback = nullptr;
static uic_mqtt_dotdot_diagnostics_attribute_mac_tx_ucast_callback_t uic_mqtt_dotdot_diagnostics_attribute_mac_tx_ucast_callback = nullptr;
static uic_mqtt_dotdot_diagnostics_attribute_mac_tx_ucast_retry_callback_t uic_mqtt_dotdot_diagnostics_attribute_mac_tx_ucast_retry_callback = nullptr;
static uic_mqtt_dotdot_diagnostics_attribute_mac_tx_ucast_fail_callback_t uic_mqtt_dotdot_diagnostics_attribute_mac_tx_ucast_fail_callback = nullptr;
static uic_mqtt_dotdot_diagnostics_attribute_aps_rx_bcast_callback_t uic_mqtt_dotdot_diagnostics_attribute_aps_rx_bcast_callback = nullptr;
static uic_mqtt_dotdot_diagnostics_attribute_aps_tx_bcast_callback_t uic_mqtt_dotdot_diagnostics_attribute_aps_tx_bcast_callback = nullptr;
static uic_mqtt_dotdot_diagnostics_attribute_aps_rx_ucast_callback_t uic_mqtt_dotdot_diagnostics_attribute_aps_rx_ucast_callback = nullptr;
static uic_mqtt_dotdot_diagnostics_attribute_aps_tx_ucast_success_callback_t uic_mqtt_dotdot_diagnostics_attribute_aps_tx_ucast_success_callback = nullptr;
static uic_mqtt_dotdot_diagnostics_attribute_aps_tx_ucast_retry_callback_t uic_mqtt_dotdot_diagnostics_attribute_aps_tx_ucast_retry_callback = nullptr;
static uic_mqtt_dotdot_diagnostics_attribute_aps_tx_ucast_fail_callback_t uic_mqtt_dotdot_diagnostics_attribute_aps_tx_ucast_fail_callback = nullptr;
static uic_mqtt_dotdot_diagnostics_attribute_route_disc_initiated_callback_t uic_mqtt_dotdot_diagnostics_attribute_route_disc_initiated_callback = nullptr;
static uic_mqtt_dotdot_diagnostics_attribute_neighbor_added_callback_t uic_mqtt_dotdot_diagnostics_attribute_neighbor_added_callback = nullptr;
static uic_mqtt_dotdot_diagnostics_attribute_neighbor_removed_callback_t uic_mqtt_dotdot_diagnostics_attribute_neighbor_removed_callback = nullptr;
static uic_mqtt_dotdot_diagnostics_attribute_neighbor_stale_callback_t uic_mqtt_dotdot_diagnostics_attribute_neighbor_stale_callback = nullptr;
static uic_mqtt_dotdot_diagnostics_attribute_join_indication_callback_t uic_mqtt_dotdot_diagnostics_attribute_join_indication_callback = nullptr;
static uic_mqtt_dotdot_diagnostics_attribute_child_moved_callback_t uic_mqtt_dotdot_diagnostics_attribute_child_moved_callback = nullptr;
static uic_mqtt_dotdot_diagnostics_attribute_nwkfc_failure_callback_t uic_mqtt_dotdot_diagnostics_attribute_nwkfc_failure_callback = nullptr;
static uic_mqtt_dotdot_diagnostics_attribute_apsfc_failure_callback_t uic_mqtt_dotdot_diagnostics_attribute_apsfc_failure_callback = nullptr;
static uic_mqtt_dotdot_diagnostics_attribute_aps_unauthorized_key_callback_t uic_mqtt_dotdot_diagnostics_attribute_aps_unauthorized_key_callback = nullptr;
static uic_mqtt_dotdot_diagnostics_attribute_nwk_decrypt_failures_callback_t uic_mqtt_dotdot_diagnostics_attribute_nwk_decrypt_failures_callback = nullptr;
static uic_mqtt_dotdot_diagnostics_attribute_aps_decrypt_failures_callback_t uic_mqtt_dotdot_diagnostics_attribute_aps_decrypt_failures_callback = nullptr;
static uic_mqtt_dotdot_diagnostics_attribute_packet_buffer_allocate_failures_callback_t uic_mqtt_dotdot_diagnostics_attribute_packet_buffer_allocate_failures_callback = nullptr;
static uic_mqtt_dotdot_diagnostics_attribute_relayed_ucast_callback_t uic_mqtt_dotdot_diagnostics_attribute_relayed_ucast_callback = nullptr;
static uic_mqtt_dotdot_diagnostics_attribute_phy_to_mac_queue_limit_reached_callback_t uic_mqtt_dotdot_diagnostics_attribute_phy_to_mac_queue_limit_reached_callback = nullptr;
static uic_mqtt_dotdot_diagnostics_attribute_packet_validate_drop_count_callback_t uic_mqtt_dotdot_diagnostics_attribute_packet_validate_drop_count_callback = nullptr;
static uic_mqtt_dotdot_diagnostics_attribute_average_mac_retry_per_aps_message_sent_callback_t uic_mqtt_dotdot_diagnostics_attribute_average_mac_retry_per_aps_message_sent_callback = nullptr;
static uic_mqtt_dotdot_diagnostics_attribute_last_messagelqi_callback_t uic_mqtt_dotdot_diagnostics_attribute_last_messagelqi_callback = nullptr;
static uic_mqtt_dotdot_diagnostics_attribute_last_messagerssi_callback_t uic_mqtt_dotdot_diagnostics_attribute_last_messagerssi_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for Diagnostics
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_diagnostics_number_of_resets_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_diagnostics_attribute_number_of_resets_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t number_of_resets = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Diagnostics::NumberOfResets: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      number_of_resets = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_diagnostics_attribute_number_of_resets_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    number_of_resets
  );

}
static void uic_mqtt_dotdot_on_diagnostics_persistent_memory_writes_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_diagnostics_attribute_persistent_memory_writes_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t persistent_memory_writes = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Diagnostics::PersistentMemoryWrites: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      persistent_memory_writes = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_diagnostics_attribute_persistent_memory_writes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    persistent_memory_writes
  );

}
static void uic_mqtt_dotdot_on_diagnostics_mac_rx_bcast_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_diagnostics_attribute_mac_rx_bcast_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t mac_rx_bcast = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Diagnostics::MacRxBcast: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      mac_rx_bcast = json_payload.at("value").get<uint32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_diagnostics_attribute_mac_rx_bcast_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    mac_rx_bcast
  );

}
static void uic_mqtt_dotdot_on_diagnostics_mac_tx_bcast_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_diagnostics_attribute_mac_tx_bcast_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t mac_tx_bcast = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Diagnostics::MacTxBcast: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      mac_tx_bcast = json_payload.at("value").get<uint32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_diagnostics_attribute_mac_tx_bcast_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    mac_tx_bcast
  );

}
static void uic_mqtt_dotdot_on_diagnostics_mac_rx_ucast_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_diagnostics_attribute_mac_rx_ucast_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t mac_rx_ucast = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Diagnostics::MacRxUcast: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      mac_rx_ucast = json_payload.at("value").get<uint32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_diagnostics_attribute_mac_rx_ucast_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    mac_rx_ucast
  );

}
static void uic_mqtt_dotdot_on_diagnostics_mac_tx_ucast_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_diagnostics_attribute_mac_tx_ucast_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t mac_tx_ucast = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Diagnostics::MacTxUcast: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      mac_tx_ucast = json_payload.at("value").get<uint32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_diagnostics_attribute_mac_tx_ucast_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    mac_tx_ucast
  );

}
static void uic_mqtt_dotdot_on_diagnostics_mac_tx_ucast_retry_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_diagnostics_attribute_mac_tx_ucast_retry_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t mac_tx_ucast_retry = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Diagnostics::MacTxUcastRetry: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      mac_tx_ucast_retry = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_diagnostics_attribute_mac_tx_ucast_retry_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    mac_tx_ucast_retry
  );

}
static void uic_mqtt_dotdot_on_diagnostics_mac_tx_ucast_fail_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_diagnostics_attribute_mac_tx_ucast_fail_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t mac_tx_ucast_fail = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Diagnostics::MacTxUcastFail: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      mac_tx_ucast_fail = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_diagnostics_attribute_mac_tx_ucast_fail_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    mac_tx_ucast_fail
  );

}
static void uic_mqtt_dotdot_on_diagnostics_aps_rx_bcast_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_diagnostics_attribute_aps_rx_bcast_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t aps_rx_bcast = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Diagnostics::APSRxBcast: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      aps_rx_bcast = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_diagnostics_attribute_aps_rx_bcast_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    aps_rx_bcast
  );

}
static void uic_mqtt_dotdot_on_diagnostics_aps_tx_bcast_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_diagnostics_attribute_aps_tx_bcast_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t aps_tx_bcast = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Diagnostics::APSTxBcast: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      aps_tx_bcast = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_diagnostics_attribute_aps_tx_bcast_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    aps_tx_bcast
  );

}
static void uic_mqtt_dotdot_on_diagnostics_aps_rx_ucast_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_diagnostics_attribute_aps_rx_ucast_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t aps_rx_ucast = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Diagnostics::APSRxUcast: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      aps_rx_ucast = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_diagnostics_attribute_aps_rx_ucast_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    aps_rx_ucast
  );

}
static void uic_mqtt_dotdot_on_diagnostics_aps_tx_ucast_success_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_diagnostics_attribute_aps_tx_ucast_success_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t aps_tx_ucast_success = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Diagnostics::APSTxUcastSuccess: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      aps_tx_ucast_success = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_diagnostics_attribute_aps_tx_ucast_success_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    aps_tx_ucast_success
  );

}
static void uic_mqtt_dotdot_on_diagnostics_aps_tx_ucast_retry_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_diagnostics_attribute_aps_tx_ucast_retry_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t aps_tx_ucast_retry = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Diagnostics::APSTxUcastRetry: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      aps_tx_ucast_retry = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_diagnostics_attribute_aps_tx_ucast_retry_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    aps_tx_ucast_retry
  );

}
static void uic_mqtt_dotdot_on_diagnostics_aps_tx_ucast_fail_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_diagnostics_attribute_aps_tx_ucast_fail_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t aps_tx_ucast_fail = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Diagnostics::APSTxUcastFail: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      aps_tx_ucast_fail = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_diagnostics_attribute_aps_tx_ucast_fail_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    aps_tx_ucast_fail
  );

}
static void uic_mqtt_dotdot_on_diagnostics_route_disc_initiated_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_diagnostics_attribute_route_disc_initiated_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t route_disc_initiated = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Diagnostics::RouteDiscInitiated: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      route_disc_initiated = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_diagnostics_attribute_route_disc_initiated_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    route_disc_initiated
  );

}
static void uic_mqtt_dotdot_on_diagnostics_neighbor_added_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_diagnostics_attribute_neighbor_added_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t neighbor_added = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Diagnostics::NeighborAdded: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      neighbor_added = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_diagnostics_attribute_neighbor_added_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    neighbor_added
  );

}
static void uic_mqtt_dotdot_on_diagnostics_neighbor_removed_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_diagnostics_attribute_neighbor_removed_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t neighbor_removed = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Diagnostics::NeighborRemoved: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      neighbor_removed = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_diagnostics_attribute_neighbor_removed_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    neighbor_removed
  );

}
static void uic_mqtt_dotdot_on_diagnostics_neighbor_stale_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_diagnostics_attribute_neighbor_stale_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t neighbor_stale = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Diagnostics::NeighborStale: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      neighbor_stale = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_diagnostics_attribute_neighbor_stale_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    neighbor_stale
  );

}
static void uic_mqtt_dotdot_on_diagnostics_join_indication_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_diagnostics_attribute_join_indication_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t join_indication = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Diagnostics::JoinIndication: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      join_indication = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_diagnostics_attribute_join_indication_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    join_indication
  );

}
static void uic_mqtt_dotdot_on_diagnostics_child_moved_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_diagnostics_attribute_child_moved_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t child_moved = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Diagnostics::ChildMoved: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      child_moved = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_diagnostics_attribute_child_moved_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    child_moved
  );

}
static void uic_mqtt_dotdot_on_diagnostics_nwkfc_failure_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_diagnostics_attribute_nwkfc_failure_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t nwkfc_failure = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Diagnostics::NWKFCFailure: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      nwkfc_failure = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_diagnostics_attribute_nwkfc_failure_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    nwkfc_failure
  );

}
static void uic_mqtt_dotdot_on_diagnostics_apsfc_failure_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_diagnostics_attribute_apsfc_failure_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t apsfc_failure = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Diagnostics::APSFCFailure: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      apsfc_failure = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_diagnostics_attribute_apsfc_failure_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    apsfc_failure
  );

}
static void uic_mqtt_dotdot_on_diagnostics_aps_unauthorized_key_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_diagnostics_attribute_aps_unauthorized_key_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t aps_unauthorized_key = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Diagnostics::APSUnauthorizedKey: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      aps_unauthorized_key = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_diagnostics_attribute_aps_unauthorized_key_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    aps_unauthorized_key
  );

}
static void uic_mqtt_dotdot_on_diagnostics_nwk_decrypt_failures_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_diagnostics_attribute_nwk_decrypt_failures_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t nwk_decrypt_failures = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Diagnostics::NWKDecryptFailures: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      nwk_decrypt_failures = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_diagnostics_attribute_nwk_decrypt_failures_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    nwk_decrypt_failures
  );

}
static void uic_mqtt_dotdot_on_diagnostics_aps_decrypt_failures_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_diagnostics_attribute_aps_decrypt_failures_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t aps_decrypt_failures = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Diagnostics::APSDecryptFailures: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      aps_decrypt_failures = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_diagnostics_attribute_aps_decrypt_failures_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    aps_decrypt_failures
  );

}
static void uic_mqtt_dotdot_on_diagnostics_packet_buffer_allocate_failures_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_diagnostics_attribute_packet_buffer_allocate_failures_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t packet_buffer_allocate_failures = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Diagnostics::PacketBufferAllocateFailures: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      packet_buffer_allocate_failures = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_diagnostics_attribute_packet_buffer_allocate_failures_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    packet_buffer_allocate_failures
  );

}
static void uic_mqtt_dotdot_on_diagnostics_relayed_ucast_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_diagnostics_attribute_relayed_ucast_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t relayed_ucast = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Diagnostics::RelayedUcast: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      relayed_ucast = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_diagnostics_attribute_relayed_ucast_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    relayed_ucast
  );

}
static void uic_mqtt_dotdot_on_diagnostics_phy_to_mac_queue_limit_reached_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_diagnostics_attribute_phy_to_mac_queue_limit_reached_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t phy_to_mac_queue_limit_reached = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Diagnostics::PHYToMACQueueLimitReached: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      phy_to_mac_queue_limit_reached = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_diagnostics_attribute_phy_to_mac_queue_limit_reached_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    phy_to_mac_queue_limit_reached
  );

}
static void uic_mqtt_dotdot_on_diagnostics_packet_validate_drop_count_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_diagnostics_attribute_packet_validate_drop_count_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t packet_validate_drop_count = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Diagnostics::PacketValidateDropCount: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      packet_validate_drop_count = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_diagnostics_attribute_packet_validate_drop_count_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    packet_validate_drop_count
  );

}
static void uic_mqtt_dotdot_on_diagnostics_average_mac_retry_per_aps_message_sent_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_diagnostics_attribute_average_mac_retry_per_aps_message_sent_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t average_mac_retry_per_aps_message_sent = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Diagnostics::AverageMACRetryPerAPSMessageSent: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      average_mac_retry_per_aps_message_sent = json_payload.at("value").get<uint16_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_diagnostics_attribute_average_mac_retry_per_aps_message_sent_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    average_mac_retry_per_aps_message_sent
  );

}
static void uic_mqtt_dotdot_on_diagnostics_last_messagelqi_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_diagnostics_attribute_last_messagelqi_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t last_messagelqi = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Diagnostics::LastMessageLQI: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      last_messagelqi = json_payload.at("value").get<uint8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_diagnostics_attribute_last_messagelqi_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    last_messagelqi
  );

}
static void uic_mqtt_dotdot_on_diagnostics_last_messagerssi_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_diagnostics_attribute_last_messagerssi_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int8_t last_messagerssi = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Diagnostics::LastMessageRSSI: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      last_messagerssi = json_payload.at("value").get<int8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_diagnostics_attribute_last_messagerssi_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    last_messagerssi
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for Diagnostics
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_diagnostics_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_diagnostics_attribute_number_of_resets_callback) {
    subscription_topic = base_topic + "Diagnostics/Attributes/NumberOfResets/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_diagnostics_number_of_resets_attribute_update);
  }
  if(uic_mqtt_dotdot_diagnostics_attribute_persistent_memory_writes_callback) {
    subscription_topic = base_topic + "Diagnostics/Attributes/PersistentMemoryWrites/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_diagnostics_persistent_memory_writes_attribute_update);
  }
  if(uic_mqtt_dotdot_diagnostics_attribute_mac_rx_bcast_callback) {
    subscription_topic = base_topic + "Diagnostics/Attributes/MacRxBcast/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_diagnostics_mac_rx_bcast_attribute_update);
  }
  if(uic_mqtt_dotdot_diagnostics_attribute_mac_tx_bcast_callback) {
    subscription_topic = base_topic + "Diagnostics/Attributes/MacTxBcast/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_diagnostics_mac_tx_bcast_attribute_update);
  }
  if(uic_mqtt_dotdot_diagnostics_attribute_mac_rx_ucast_callback) {
    subscription_topic = base_topic + "Diagnostics/Attributes/MacRxUcast/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_diagnostics_mac_rx_ucast_attribute_update);
  }
  if(uic_mqtt_dotdot_diagnostics_attribute_mac_tx_ucast_callback) {
    subscription_topic = base_topic + "Diagnostics/Attributes/MacTxUcast/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_diagnostics_mac_tx_ucast_attribute_update);
  }
  if(uic_mqtt_dotdot_diagnostics_attribute_mac_tx_ucast_retry_callback) {
    subscription_topic = base_topic + "Diagnostics/Attributes/MacTxUcastRetry/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_diagnostics_mac_tx_ucast_retry_attribute_update);
  }
  if(uic_mqtt_dotdot_diagnostics_attribute_mac_tx_ucast_fail_callback) {
    subscription_topic = base_topic + "Diagnostics/Attributes/MacTxUcastFail/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_diagnostics_mac_tx_ucast_fail_attribute_update);
  }
  if(uic_mqtt_dotdot_diagnostics_attribute_aps_rx_bcast_callback) {
    subscription_topic = base_topic + "Diagnostics/Attributes/APSRxBcast/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_diagnostics_aps_rx_bcast_attribute_update);
  }
  if(uic_mqtt_dotdot_diagnostics_attribute_aps_tx_bcast_callback) {
    subscription_topic = base_topic + "Diagnostics/Attributes/APSTxBcast/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_diagnostics_aps_tx_bcast_attribute_update);
  }
  if(uic_mqtt_dotdot_diagnostics_attribute_aps_rx_ucast_callback) {
    subscription_topic = base_topic + "Diagnostics/Attributes/APSRxUcast/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_diagnostics_aps_rx_ucast_attribute_update);
  }
  if(uic_mqtt_dotdot_diagnostics_attribute_aps_tx_ucast_success_callback) {
    subscription_topic = base_topic + "Diagnostics/Attributes/APSTxUcastSuccess/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_diagnostics_aps_tx_ucast_success_attribute_update);
  }
  if(uic_mqtt_dotdot_diagnostics_attribute_aps_tx_ucast_retry_callback) {
    subscription_topic = base_topic + "Diagnostics/Attributes/APSTxUcastRetry/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_diagnostics_aps_tx_ucast_retry_attribute_update);
  }
  if(uic_mqtt_dotdot_diagnostics_attribute_aps_tx_ucast_fail_callback) {
    subscription_topic = base_topic + "Diagnostics/Attributes/APSTxUcastFail/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_diagnostics_aps_tx_ucast_fail_attribute_update);
  }
  if(uic_mqtt_dotdot_diagnostics_attribute_route_disc_initiated_callback) {
    subscription_topic = base_topic + "Diagnostics/Attributes/RouteDiscInitiated/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_diagnostics_route_disc_initiated_attribute_update);
  }
  if(uic_mqtt_dotdot_diagnostics_attribute_neighbor_added_callback) {
    subscription_topic = base_topic + "Diagnostics/Attributes/NeighborAdded/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_diagnostics_neighbor_added_attribute_update);
  }
  if(uic_mqtt_dotdot_diagnostics_attribute_neighbor_removed_callback) {
    subscription_topic = base_topic + "Diagnostics/Attributes/NeighborRemoved/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_diagnostics_neighbor_removed_attribute_update);
  }
  if(uic_mqtt_dotdot_diagnostics_attribute_neighbor_stale_callback) {
    subscription_topic = base_topic + "Diagnostics/Attributes/NeighborStale/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_diagnostics_neighbor_stale_attribute_update);
  }
  if(uic_mqtt_dotdot_diagnostics_attribute_join_indication_callback) {
    subscription_topic = base_topic + "Diagnostics/Attributes/JoinIndication/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_diagnostics_join_indication_attribute_update);
  }
  if(uic_mqtt_dotdot_diagnostics_attribute_child_moved_callback) {
    subscription_topic = base_topic + "Diagnostics/Attributes/ChildMoved/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_diagnostics_child_moved_attribute_update);
  }
  if(uic_mqtt_dotdot_diagnostics_attribute_nwkfc_failure_callback) {
    subscription_topic = base_topic + "Diagnostics/Attributes/NWKFCFailure/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_diagnostics_nwkfc_failure_attribute_update);
  }
  if(uic_mqtt_dotdot_diagnostics_attribute_apsfc_failure_callback) {
    subscription_topic = base_topic + "Diagnostics/Attributes/APSFCFailure/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_diagnostics_apsfc_failure_attribute_update);
  }
  if(uic_mqtt_dotdot_diagnostics_attribute_aps_unauthorized_key_callback) {
    subscription_topic = base_topic + "Diagnostics/Attributes/APSUnauthorizedKey/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_diagnostics_aps_unauthorized_key_attribute_update);
  }
  if(uic_mqtt_dotdot_diagnostics_attribute_nwk_decrypt_failures_callback) {
    subscription_topic = base_topic + "Diagnostics/Attributes/NWKDecryptFailures/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_diagnostics_nwk_decrypt_failures_attribute_update);
  }
  if(uic_mqtt_dotdot_diagnostics_attribute_aps_decrypt_failures_callback) {
    subscription_topic = base_topic + "Diagnostics/Attributes/APSDecryptFailures/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_diagnostics_aps_decrypt_failures_attribute_update);
  }
  if(uic_mqtt_dotdot_diagnostics_attribute_packet_buffer_allocate_failures_callback) {
    subscription_topic = base_topic + "Diagnostics/Attributes/PacketBufferAllocateFailures/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_diagnostics_packet_buffer_allocate_failures_attribute_update);
  }
  if(uic_mqtt_dotdot_diagnostics_attribute_relayed_ucast_callback) {
    subscription_topic = base_topic + "Diagnostics/Attributes/RelayedUcast/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_diagnostics_relayed_ucast_attribute_update);
  }
  if(uic_mqtt_dotdot_diagnostics_attribute_phy_to_mac_queue_limit_reached_callback) {
    subscription_topic = base_topic + "Diagnostics/Attributes/PHYToMACQueueLimitReached/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_diagnostics_phy_to_mac_queue_limit_reached_attribute_update);
  }
  if(uic_mqtt_dotdot_diagnostics_attribute_packet_validate_drop_count_callback) {
    subscription_topic = base_topic + "Diagnostics/Attributes/PacketValidateDropCount/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_diagnostics_packet_validate_drop_count_attribute_update);
  }
  if(uic_mqtt_dotdot_diagnostics_attribute_average_mac_retry_per_aps_message_sent_callback) {
    subscription_topic = base_topic + "Diagnostics/Attributes/AverageMACRetryPerAPSMessageSent/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_diagnostics_average_mac_retry_per_aps_message_sent_attribute_update);
  }
  if(uic_mqtt_dotdot_diagnostics_attribute_last_messagelqi_callback) {
    subscription_topic = base_topic + "Diagnostics/Attributes/LastMessageLQI/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_diagnostics_last_messagelqi_attribute_update);
  }
  if(uic_mqtt_dotdot_diagnostics_attribute_last_messagerssi_callback) {
    subscription_topic = base_topic + "Diagnostics/Attributes/LastMessageRSSI/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_diagnostics_last_messagerssi_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for Diagnostics
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_diagnostics_attribute_number_of_resets_callback_set(const uic_mqtt_dotdot_diagnostics_attribute_number_of_resets_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_attribute_number_of_resets_callback = callback;
}
void uic_mqtt_dotdot_diagnostics_attribute_persistent_memory_writes_callback_set(const uic_mqtt_dotdot_diagnostics_attribute_persistent_memory_writes_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_attribute_persistent_memory_writes_callback = callback;
}
void uic_mqtt_dotdot_diagnostics_attribute_mac_rx_bcast_callback_set(const uic_mqtt_dotdot_diagnostics_attribute_mac_rx_bcast_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_attribute_mac_rx_bcast_callback = callback;
}
void uic_mqtt_dotdot_diagnostics_attribute_mac_tx_bcast_callback_set(const uic_mqtt_dotdot_diagnostics_attribute_mac_tx_bcast_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_attribute_mac_tx_bcast_callback = callback;
}
void uic_mqtt_dotdot_diagnostics_attribute_mac_rx_ucast_callback_set(const uic_mqtt_dotdot_diagnostics_attribute_mac_rx_ucast_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_attribute_mac_rx_ucast_callback = callback;
}
void uic_mqtt_dotdot_diagnostics_attribute_mac_tx_ucast_callback_set(const uic_mqtt_dotdot_diagnostics_attribute_mac_tx_ucast_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_attribute_mac_tx_ucast_callback = callback;
}
void uic_mqtt_dotdot_diagnostics_attribute_mac_tx_ucast_retry_callback_set(const uic_mqtt_dotdot_diagnostics_attribute_mac_tx_ucast_retry_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_attribute_mac_tx_ucast_retry_callback = callback;
}
void uic_mqtt_dotdot_diagnostics_attribute_mac_tx_ucast_fail_callback_set(const uic_mqtt_dotdot_diagnostics_attribute_mac_tx_ucast_fail_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_attribute_mac_tx_ucast_fail_callback = callback;
}
void uic_mqtt_dotdot_diagnostics_attribute_aps_rx_bcast_callback_set(const uic_mqtt_dotdot_diagnostics_attribute_aps_rx_bcast_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_attribute_aps_rx_bcast_callback = callback;
}
void uic_mqtt_dotdot_diagnostics_attribute_aps_tx_bcast_callback_set(const uic_mqtt_dotdot_diagnostics_attribute_aps_tx_bcast_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_attribute_aps_tx_bcast_callback = callback;
}
void uic_mqtt_dotdot_diagnostics_attribute_aps_rx_ucast_callback_set(const uic_mqtt_dotdot_diagnostics_attribute_aps_rx_ucast_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_attribute_aps_rx_ucast_callback = callback;
}
void uic_mqtt_dotdot_diagnostics_attribute_aps_tx_ucast_success_callback_set(const uic_mqtt_dotdot_diagnostics_attribute_aps_tx_ucast_success_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_attribute_aps_tx_ucast_success_callback = callback;
}
void uic_mqtt_dotdot_diagnostics_attribute_aps_tx_ucast_retry_callback_set(const uic_mqtt_dotdot_diagnostics_attribute_aps_tx_ucast_retry_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_attribute_aps_tx_ucast_retry_callback = callback;
}
void uic_mqtt_dotdot_diagnostics_attribute_aps_tx_ucast_fail_callback_set(const uic_mqtt_dotdot_diagnostics_attribute_aps_tx_ucast_fail_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_attribute_aps_tx_ucast_fail_callback = callback;
}
void uic_mqtt_dotdot_diagnostics_attribute_route_disc_initiated_callback_set(const uic_mqtt_dotdot_diagnostics_attribute_route_disc_initiated_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_attribute_route_disc_initiated_callback = callback;
}
void uic_mqtt_dotdot_diagnostics_attribute_neighbor_added_callback_set(const uic_mqtt_dotdot_diagnostics_attribute_neighbor_added_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_attribute_neighbor_added_callback = callback;
}
void uic_mqtt_dotdot_diagnostics_attribute_neighbor_removed_callback_set(const uic_mqtt_dotdot_diagnostics_attribute_neighbor_removed_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_attribute_neighbor_removed_callback = callback;
}
void uic_mqtt_dotdot_diagnostics_attribute_neighbor_stale_callback_set(const uic_mqtt_dotdot_diagnostics_attribute_neighbor_stale_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_attribute_neighbor_stale_callback = callback;
}
void uic_mqtt_dotdot_diagnostics_attribute_join_indication_callback_set(const uic_mqtt_dotdot_diagnostics_attribute_join_indication_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_attribute_join_indication_callback = callback;
}
void uic_mqtt_dotdot_diagnostics_attribute_child_moved_callback_set(const uic_mqtt_dotdot_diagnostics_attribute_child_moved_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_attribute_child_moved_callback = callback;
}
void uic_mqtt_dotdot_diagnostics_attribute_nwkfc_failure_callback_set(const uic_mqtt_dotdot_diagnostics_attribute_nwkfc_failure_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_attribute_nwkfc_failure_callback = callback;
}
void uic_mqtt_dotdot_diagnostics_attribute_apsfc_failure_callback_set(const uic_mqtt_dotdot_diagnostics_attribute_apsfc_failure_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_attribute_apsfc_failure_callback = callback;
}
void uic_mqtt_dotdot_diagnostics_attribute_aps_unauthorized_key_callback_set(const uic_mqtt_dotdot_diagnostics_attribute_aps_unauthorized_key_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_attribute_aps_unauthorized_key_callback = callback;
}
void uic_mqtt_dotdot_diagnostics_attribute_nwk_decrypt_failures_callback_set(const uic_mqtt_dotdot_diagnostics_attribute_nwk_decrypt_failures_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_attribute_nwk_decrypt_failures_callback = callback;
}
void uic_mqtt_dotdot_diagnostics_attribute_aps_decrypt_failures_callback_set(const uic_mqtt_dotdot_diagnostics_attribute_aps_decrypt_failures_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_attribute_aps_decrypt_failures_callback = callback;
}
void uic_mqtt_dotdot_diagnostics_attribute_packet_buffer_allocate_failures_callback_set(const uic_mqtt_dotdot_diagnostics_attribute_packet_buffer_allocate_failures_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_attribute_packet_buffer_allocate_failures_callback = callback;
}
void uic_mqtt_dotdot_diagnostics_attribute_relayed_ucast_callback_set(const uic_mqtt_dotdot_diagnostics_attribute_relayed_ucast_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_attribute_relayed_ucast_callback = callback;
}
void uic_mqtt_dotdot_diagnostics_attribute_phy_to_mac_queue_limit_reached_callback_set(const uic_mqtt_dotdot_diagnostics_attribute_phy_to_mac_queue_limit_reached_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_attribute_phy_to_mac_queue_limit_reached_callback = callback;
}
void uic_mqtt_dotdot_diagnostics_attribute_packet_validate_drop_count_callback_set(const uic_mqtt_dotdot_diagnostics_attribute_packet_validate_drop_count_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_attribute_packet_validate_drop_count_callback = callback;
}
void uic_mqtt_dotdot_diagnostics_attribute_average_mac_retry_per_aps_message_sent_callback_set(const uic_mqtt_dotdot_diagnostics_attribute_average_mac_retry_per_aps_message_sent_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_attribute_average_mac_retry_per_aps_message_sent_callback = callback;
}
void uic_mqtt_dotdot_diagnostics_attribute_last_messagelqi_callback_set(const uic_mqtt_dotdot_diagnostics_attribute_last_messagelqi_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_attribute_last_messagelqi_callback = callback;
}
void uic_mqtt_dotdot_diagnostics_attribute_last_messagerssi_callback_set(const uic_mqtt_dotdot_diagnostics_attribute_last_messagerssi_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_attribute_last_messagerssi_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for ProtocolController-RFTelemetry
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_protocol_controller_rf_telemetry_attribute_tx_report_enabled_callback_t uic_mqtt_dotdot_protocol_controller_rf_telemetry_attribute_tx_report_enabled_callback = nullptr;
static uic_mqtt_dotdot_protocol_controller_rf_telemetry_attribute_pti_enabled_callback_t uic_mqtt_dotdot_protocol_controller_rf_telemetry_attribute_pti_enabled_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for ProtocolController-RFTelemetry
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_protocol_controller_rf_telemetry_tx_report_enabled_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_protocol_controller_rf_telemetry_attribute_tx_report_enabled_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  bool tx_report_enabled = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ProtocolController-RFTelemetry::TxReportEnabled: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      tx_report_enabled = get_bool_from_json(json_payload, "value");

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_protocol_controller_rf_telemetry_attribute_tx_report_enabled_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    tx_report_enabled
  );

}
static void uic_mqtt_dotdot_on_protocol_controller_rf_telemetry_pti_enabled_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_protocol_controller_rf_telemetry_attribute_pti_enabled_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  bool pti_enabled = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ProtocolController-RFTelemetry::PTIEnabled: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      pti_enabled = get_bool_from_json(json_payload, "value");

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_protocol_controller_rf_telemetry_attribute_pti_enabled_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    pti_enabled
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for ProtocolController-RFTelemetry
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_protocol_controller_rf_telemetry_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_protocol_controller_rf_telemetry_attribute_tx_report_enabled_callback) {
    subscription_topic = base_topic + "ProtocolController/RFTelemetry/Attributes/TxReportEnabled/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_protocol_controller_rf_telemetry_tx_report_enabled_attribute_update);
  }
  if(uic_mqtt_dotdot_protocol_controller_rf_telemetry_attribute_pti_enabled_callback) {
    subscription_topic = base_topic + "ProtocolController/RFTelemetry/Attributes/PTIEnabled/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_protocol_controller_rf_telemetry_pti_enabled_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for ProtocolController-RFTelemetry
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_protocol_controller_rf_telemetry_attribute_tx_report_enabled_callback_set(const uic_mqtt_dotdot_protocol_controller_rf_telemetry_attribute_tx_report_enabled_callback_t callback)
{
  uic_mqtt_dotdot_protocol_controller_rf_telemetry_attribute_tx_report_enabled_callback = callback;
}
void uic_mqtt_dotdot_protocol_controller_rf_telemetry_attribute_pti_enabled_callback_set(const uic_mqtt_dotdot_protocol_controller_rf_telemetry_attribute_pti_enabled_callback_t callback)
{
  uic_mqtt_dotdot_protocol_controller_rf_telemetry_attribute_pti_enabled_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for State
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_state_attribute_endpoint_id_list_callback_t uic_mqtt_dotdot_state_attribute_endpoint_id_list_callback = nullptr;
static uic_mqtt_dotdot_state_attribute_network_status_callback_t uic_mqtt_dotdot_state_attribute_network_status_callback = nullptr;
static uic_mqtt_dotdot_state_attribute_security_callback_t uic_mqtt_dotdot_state_attribute_security_callback = nullptr;
static uic_mqtt_dotdot_state_attribute_maximum_command_delay_callback_t uic_mqtt_dotdot_state_attribute_maximum_command_delay_callback = nullptr;
static uic_mqtt_dotdot_state_attribute_network_list_callback_t uic_mqtt_dotdot_state_attribute_network_list_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for State
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_state_endpoint_id_list_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_state_attribute_endpoint_id_list_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  std::vector<uint8_t> endpoint_id_list;
  size_t endpoint_id_list_count = 0;

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "State::EndpointIdList: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      auto &endpoint_id_list_json = json_payload.at("value");
      for (size_t i = 0; i < endpoint_id_list_json.size(); i++) {
        endpoint_id_list.push_back(endpoint_id_list_json.at(i).get<uint8_t>());
          }
      // Take our vector and pack it into the updated state
      endpoint_id_list_count = endpoint_id_list.size();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_state_attribute_endpoint_id_list_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    endpoint_id_list_count,
    endpoint_id_list.data()
  );

}
static void uic_mqtt_dotdot_on_state_network_status_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_state_attribute_network_status_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  NodeStateNetworkStatus network_status = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "State::NetworkStatus: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<NodeStateNetworkStatus>("value", json_payload);
      if (tmp == numeric_limits<NodeStateNetworkStatus>::max()) {
      #ifdef STATE_NETWORK_STATUS_ENUM_NAME_AVAILABLE
        tmp = state_network_status_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(NETWORK_STATUS_ENUM_NAME_AVAILABLE)
        tmp = network_status_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      network_status = static_cast<NodeStateNetworkStatus>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_state_attribute_network_status_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    network_status
  );

}
static void uic_mqtt_dotdot_on_state_security_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_state_attribute_security_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  NodeStateSecurity security = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "State::Security: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<NodeStateSecurity>("value", json_payload);
      if (tmp == numeric_limits<NodeStateSecurity>::max()) {
      #ifdef STATE_SECURITY_ENUM_NAME_AVAILABLE
        tmp = state_security_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(SECURITY_ENUM_NAME_AVAILABLE)
        tmp = security_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      security = static_cast<NodeStateSecurity>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_state_attribute_security_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    security
  );

}
static void uic_mqtt_dotdot_on_state_maximum_command_delay_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_state_attribute_maximum_command_delay_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t maximum_command_delay = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "State::MaximumCommandDelay: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      maximum_command_delay = json_payload.at("value").get<uint32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_state_attribute_maximum_command_delay_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    maximum_command_delay
  );

}
static void uic_mqtt_dotdot_on_state_network_list_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_state_attribute_network_list_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  std::vector<const char*> network_list;
  size_t network_list_count = 0;

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "State::NetworkList: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      auto &network_list_json = json_payload.at("value");
      for (size_t i = 0; i < network_list_json.size(); i++) {
        network_list.push_back(network_list_json.at(i).get_ptr<const std::string*>()->c_str());
      }
      // Take our vector and pack it into the updated state
      network_list_count = network_list.size();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_state_attribute_network_list_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    network_list_count,
    network_list.data()
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for State
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_state_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_state_attribute_endpoint_id_list_callback) {
    subscription_topic = base_topic + "State/Attributes/EndpointIdList/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_state_endpoint_id_list_attribute_update);
  }
  if(uic_mqtt_dotdot_state_attribute_network_status_callback) {
    subscription_topic = base_topic + "State/Attributes/NetworkStatus/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_state_network_status_attribute_update);
  }
  if(uic_mqtt_dotdot_state_attribute_security_callback) {
    subscription_topic = base_topic + "State/Attributes/Security/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_state_security_attribute_update);
  }
  if(uic_mqtt_dotdot_state_attribute_maximum_command_delay_callback) {
    subscription_topic = base_topic + "State/Attributes/MaximumCommandDelay/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_state_maximum_command_delay_attribute_update);
  }
  if(uic_mqtt_dotdot_state_attribute_network_list_callback) {
    subscription_topic = base_topic + "State/Attributes/NetworkList/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_state_network_list_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for State
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_state_attribute_endpoint_id_list_callback_set(const uic_mqtt_dotdot_state_attribute_endpoint_id_list_callback_t callback)
{
  uic_mqtt_dotdot_state_attribute_endpoint_id_list_callback = callback;
}
void uic_mqtt_dotdot_state_attribute_network_status_callback_set(const uic_mqtt_dotdot_state_attribute_network_status_callback_t callback)
{
  uic_mqtt_dotdot_state_attribute_network_status_callback = callback;
}
void uic_mqtt_dotdot_state_attribute_security_callback_set(const uic_mqtt_dotdot_state_attribute_security_callback_t callback)
{
  uic_mqtt_dotdot_state_attribute_security_callback = callback;
}
void uic_mqtt_dotdot_state_attribute_maximum_command_delay_callback_set(const uic_mqtt_dotdot_state_attribute_maximum_command_delay_callback_t callback)
{
  uic_mqtt_dotdot_state_attribute_maximum_command_delay_callback = callback;
}
void uic_mqtt_dotdot_state_attribute_network_list_callback_set(const uic_mqtt_dotdot_state_attribute_network_list_callback_t callback)
{
  uic_mqtt_dotdot_state_attribute_network_list_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for Binding
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_binding_attribute_binding_table_full_callback_t uic_mqtt_dotdot_binding_attribute_binding_table_full_callback = nullptr;
static uic_mqtt_dotdot_binding_attribute_bindable_cluster_list_callback_t uic_mqtt_dotdot_binding_attribute_bindable_cluster_list_callback = nullptr;
static uic_mqtt_dotdot_binding_attribute_binding_table_callback_t uic_mqtt_dotdot_binding_attribute_binding_table_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for Binding
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_binding_binding_table_full_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_binding_attribute_binding_table_full_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  bool binding_table_full = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Binding::BindingTableFull: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      binding_table_full = get_bool_from_json(json_payload, "value");

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_binding_attribute_binding_table_full_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    binding_table_full
  );

}
static void uic_mqtt_dotdot_on_binding_bindable_cluster_list_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_binding_attribute_bindable_cluster_list_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  std::vector<const char*> bindable_cluster_list;
  size_t bindable_cluster_list_count = 0;

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Binding::BindableClusterList: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      auto &bindable_cluster_list_json = json_payload.at("value");
      for (size_t i = 0; i < bindable_cluster_list_json.size(); i++) {
        bindable_cluster_list.push_back(bindable_cluster_list_json.at(i).get_ptr<const std::string*>()->c_str());
      }
      // Take our vector and pack it into the updated state
      bindable_cluster_list_count = bindable_cluster_list.size();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_binding_attribute_bindable_cluster_list_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    bindable_cluster_list_count,
    bindable_cluster_list.data()
  );

}
static void uic_mqtt_dotdot_on_binding_binding_table_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_binding_attribute_binding_table_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  std::vector<BindingObject> binding_table;
  size_t binding_table_count = 0;

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Binding::BindingTable: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      auto &binding_table_json = json_payload.at("value");
      for (size_t i = 0; i < binding_table_json.size(); i++) {
        BindingObject element = {};
        element.ClusterName = binding_table_json.at(i).at("ClusterName").get_ptr<const std::string*>()->c_str();
        element.DestinationUnid = binding_table_json.at(i).at("DestinationUnid").get_ptr<const std::string*>()->c_str();
        element.DestinationEp = binding_table_json.at(i).at("DestinationEp").get<uint8_t>();
        binding_table.push_back(element);
      }
      // Take our vector and pack it into the updated state
      binding_table_count = binding_table.size();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_binding_attribute_binding_table_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    binding_table_count,
    binding_table.data()
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for Binding
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_binding_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_binding_attribute_binding_table_full_callback) {
    subscription_topic = base_topic + "Binding/Attributes/BindingTableFull/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_binding_binding_table_full_attribute_update);
  }
  if(uic_mqtt_dotdot_binding_attribute_bindable_cluster_list_callback) {
    subscription_topic = base_topic + "Binding/Attributes/BindableClusterList/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_binding_bindable_cluster_list_attribute_update);
  }
  if(uic_mqtt_dotdot_binding_attribute_binding_table_callback) {
    subscription_topic = base_topic + "Binding/Attributes/BindingTable/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_binding_binding_table_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for Binding
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_binding_attribute_binding_table_full_callback_set(const uic_mqtt_dotdot_binding_attribute_binding_table_full_callback_t callback)
{
  uic_mqtt_dotdot_binding_attribute_binding_table_full_callback = callback;
}
void uic_mqtt_dotdot_binding_attribute_bindable_cluster_list_callback_set(const uic_mqtt_dotdot_binding_attribute_bindable_cluster_list_callback_t callback)
{
  uic_mqtt_dotdot_binding_attribute_bindable_cluster_list_callback = callback;
}
void uic_mqtt_dotdot_binding_attribute_binding_table_callback_set(const uic_mqtt_dotdot_binding_attribute_binding_table_callback_t callback)
{
  uic_mqtt_dotdot_binding_attribute_binding_table_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for SystemMetrics
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_system_metrics_attribute_reporting_interval_seconds_callback_t uic_mqtt_dotdot_system_metrics_attribute_reporting_interval_seconds_callback = nullptr;
static uic_mqtt_dotdot_system_metrics_attribute_cpu_usage_percent_callback_t uic_mqtt_dotdot_system_metrics_attribute_cpu_usage_percent_callback = nullptr;
static uic_mqtt_dotdot_system_metrics_attribute_cpu_frequencym_hz_callback_t uic_mqtt_dotdot_system_metrics_attribute_cpu_frequencym_hz_callback = nullptr;
static uic_mqtt_dotdot_system_metrics_attribute_cpu_average_usage_percent_callback_t uic_mqtt_dotdot_system_metrics_attribute_cpu_average_usage_percent_callback = nullptr;
static uic_mqtt_dotdot_system_metrics_attribute_cpu_min_usage_percent_callback_t uic_mqtt_dotdot_system_metrics_attribute_cpu_min_usage_percent_callback = nullptr;
static uic_mqtt_dotdot_system_metrics_attribute_cpu_max_usage_percent_callback_t uic_mqtt_dotdot_system_metrics_attribute_cpu_max_usage_percent_callback = nullptr;
static uic_mqtt_dotdot_system_metrics_attribute_ram_totalmb_callback_t uic_mqtt_dotdot_system_metrics_attribute_ram_totalmb_callback = nullptr;
static uic_mqtt_dotdot_system_metrics_attribute_ram_freemb_callback_t uic_mqtt_dotdot_system_metrics_attribute_ram_freemb_callback = nullptr;
static uic_mqtt_dotdot_system_metrics_attribute_ram_availablemb_callback_t uic_mqtt_dotdot_system_metrics_attribute_ram_availablemb_callback = nullptr;
static uic_mqtt_dotdot_system_metrics_attribute_swap_memory_totalmb_callback_t uic_mqtt_dotdot_system_metrics_attribute_swap_memory_totalmb_callback = nullptr;
static uic_mqtt_dotdot_system_metrics_attribute_swap_memory_usedmb_callback_t uic_mqtt_dotdot_system_metrics_attribute_swap_memory_usedmb_callback = nullptr;
static uic_mqtt_dotdot_system_metrics_attribute_virtual_memory_totalmb_callback_t uic_mqtt_dotdot_system_metrics_attribute_virtual_memory_totalmb_callback = nullptr;
static uic_mqtt_dotdot_system_metrics_attribute_virtual_memory_usedmb_callback_t uic_mqtt_dotdot_system_metrics_attribute_virtual_memory_usedmb_callback = nullptr;
static uic_mqtt_dotdot_system_metrics_attribute_disks_usage_callback_t uic_mqtt_dotdot_system_metrics_attribute_disks_usage_callback = nullptr;
static uic_mqtt_dotdot_system_metrics_attribute_disks_counters_callback_t uic_mqtt_dotdot_system_metrics_attribute_disks_counters_callback = nullptr;
static uic_mqtt_dotdot_system_metrics_attribute_network_interfaces_data_callback_t uic_mqtt_dotdot_system_metrics_attribute_network_interfaces_data_callback = nullptr;
static uic_mqtt_dotdot_system_metrics_attribute_wireless_network_interfaces_data_callback_t uic_mqtt_dotdot_system_metrics_attribute_wireless_network_interfaces_data_callback = nullptr;
static uic_mqtt_dotdot_system_metrics_attribute_hostname_callback_t uic_mqtt_dotdot_system_metrics_attribute_hostname_callback = nullptr;
static uic_mqtt_dotdot_system_metrics_attribute_fqdn_callback_t uic_mqtt_dotdot_system_metrics_attribute_fqdn_callback = nullptr;
static uic_mqtt_dotdot_system_metrics_attribute_uptime_minutes_callback_t uic_mqtt_dotdot_system_metrics_attribute_uptime_minutes_callback = nullptr;
static uic_mqtt_dotdot_system_metrics_attribute_current_temperature_celcius_callback_t uic_mqtt_dotdot_system_metrics_attribute_current_temperature_celcius_callback = nullptr;
static uic_mqtt_dotdot_system_metrics_attribute_average_temperature_celcius_callback_t uic_mqtt_dotdot_system_metrics_attribute_average_temperature_celcius_callback = nullptr;
static uic_mqtt_dotdot_system_metrics_attribute_min_temperature_celcius_callback_t uic_mqtt_dotdot_system_metrics_attribute_min_temperature_celcius_callback = nullptr;
static uic_mqtt_dotdot_system_metrics_attribute_max_temperature_celcius_callback_t uic_mqtt_dotdot_system_metrics_attribute_max_temperature_celcius_callback = nullptr;
static uic_mqtt_dotdot_system_metrics_attribute_power_plugged_callback_t uic_mqtt_dotdot_system_metrics_attribute_power_plugged_callback = nullptr;
static uic_mqtt_dotdot_system_metrics_attribute_battery_percentage_callback_t uic_mqtt_dotdot_system_metrics_attribute_battery_percentage_callback = nullptr;
static uic_mqtt_dotdot_system_metrics_attribute_system_interrupts_callback_t uic_mqtt_dotdot_system_metrics_attribute_system_interrupts_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for SystemMetrics
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_system_metrics_reporting_interval_seconds_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_system_metrics_attribute_reporting_interval_seconds_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t reporting_interval_seconds = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "SystemMetrics::ReportingIntervalSeconds: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      reporting_interval_seconds = json_payload.at("value").get<uint32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_system_metrics_attribute_reporting_interval_seconds_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    reporting_interval_seconds
  );

}
static void uic_mqtt_dotdot_on_system_metrics_cpu_usage_percent_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_system_metrics_attribute_cpu_usage_percent_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  std::vector<double> cpu_usage_percent;
  size_t cpu_usage_percent_count = 0;

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "SystemMetrics::CPUUsagePercent: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      auto &cpu_usage_percent_json = json_payload.at("value");
      for (size_t i = 0; i < cpu_usage_percent_json.size(); i++) {
        cpu_usage_percent.push_back(cpu_usage_percent_json.at(i).get<double>());
          }
      // Take our vector and pack it into the updated state
      cpu_usage_percent_count = cpu_usage_percent.size();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_system_metrics_attribute_cpu_usage_percent_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    cpu_usage_percent_count,
    cpu_usage_percent.data()
  );

}
static void uic_mqtt_dotdot_on_system_metrics_cpu_frequencym_hz_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_system_metrics_attribute_cpu_frequencym_hz_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  std::vector<double> cpu_frequencym_hz;
  size_t cpu_frequencym_hz_count = 0;

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "SystemMetrics::CPUFrequencyMHz: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      auto &cpu_frequencym_hz_json = json_payload.at("value");
      for (size_t i = 0; i < cpu_frequencym_hz_json.size(); i++) {
        cpu_frequencym_hz.push_back(cpu_frequencym_hz_json.at(i).get<double>());
          }
      // Take our vector and pack it into the updated state
      cpu_frequencym_hz_count = cpu_frequencym_hz.size();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_system_metrics_attribute_cpu_frequencym_hz_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    cpu_frequencym_hz_count,
    cpu_frequencym_hz.data()
  );

}
static void uic_mqtt_dotdot_on_system_metrics_cpu_average_usage_percent_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_system_metrics_attribute_cpu_average_usage_percent_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  std::vector<double> cpu_average_usage_percent;
  size_t cpu_average_usage_percent_count = 0;

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "SystemMetrics::CPUAverageUsagePercent: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      auto &cpu_average_usage_percent_json = json_payload.at("value");
      for (size_t i = 0; i < cpu_average_usage_percent_json.size(); i++) {
        cpu_average_usage_percent.push_back(cpu_average_usage_percent_json.at(i).get<double>());
          }
      // Take our vector and pack it into the updated state
      cpu_average_usage_percent_count = cpu_average_usage_percent.size();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_system_metrics_attribute_cpu_average_usage_percent_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    cpu_average_usage_percent_count,
    cpu_average_usage_percent.data()
  );

}
static void uic_mqtt_dotdot_on_system_metrics_cpu_min_usage_percent_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_system_metrics_attribute_cpu_min_usage_percent_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  std::vector<double> cpu_min_usage_percent;
  size_t cpu_min_usage_percent_count = 0;

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "SystemMetrics::CPUMinUsagePercent: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      auto &cpu_min_usage_percent_json = json_payload.at("value");
      for (size_t i = 0; i < cpu_min_usage_percent_json.size(); i++) {
        cpu_min_usage_percent.push_back(cpu_min_usage_percent_json.at(i).get<double>());
          }
      // Take our vector and pack it into the updated state
      cpu_min_usage_percent_count = cpu_min_usage_percent.size();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_system_metrics_attribute_cpu_min_usage_percent_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    cpu_min_usage_percent_count,
    cpu_min_usage_percent.data()
  );

}
static void uic_mqtt_dotdot_on_system_metrics_cpu_max_usage_percent_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_system_metrics_attribute_cpu_max_usage_percent_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  std::vector<double> cpu_max_usage_percent;
  size_t cpu_max_usage_percent_count = 0;

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "SystemMetrics::CPUMaxUsagePercent: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      auto &cpu_max_usage_percent_json = json_payload.at("value");
      for (size_t i = 0; i < cpu_max_usage_percent_json.size(); i++) {
        cpu_max_usage_percent.push_back(cpu_max_usage_percent_json.at(i).get<double>());
          }
      // Take our vector and pack it into the updated state
      cpu_max_usage_percent_count = cpu_max_usage_percent.size();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_system_metrics_attribute_cpu_max_usage_percent_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    cpu_max_usage_percent_count,
    cpu_max_usage_percent.data()
  );

}
static void uic_mqtt_dotdot_on_system_metrics_ram_totalmb_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_system_metrics_attribute_ram_totalmb_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  double ram_totalmb = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "SystemMetrics::RAMTotalMB: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      ram_totalmb = json_payload.at("value").get<double>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_system_metrics_attribute_ram_totalmb_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    ram_totalmb
  );

}
static void uic_mqtt_dotdot_on_system_metrics_ram_freemb_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_system_metrics_attribute_ram_freemb_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  double ram_freemb = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "SystemMetrics::RAMFreeMB: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      ram_freemb = json_payload.at("value").get<double>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_system_metrics_attribute_ram_freemb_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    ram_freemb
  );

}
static void uic_mqtt_dotdot_on_system_metrics_ram_availablemb_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_system_metrics_attribute_ram_availablemb_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  double ram_availablemb = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "SystemMetrics::RAMAvailableMB: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      ram_availablemb = json_payload.at("value").get<double>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_system_metrics_attribute_ram_availablemb_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    ram_availablemb
  );

}
static void uic_mqtt_dotdot_on_system_metrics_swap_memory_totalmb_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_system_metrics_attribute_swap_memory_totalmb_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  double swap_memory_totalmb = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "SystemMetrics::SWAPMemoryTotalMB: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      swap_memory_totalmb = json_payload.at("value").get<double>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_system_metrics_attribute_swap_memory_totalmb_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    swap_memory_totalmb
  );

}
static void uic_mqtt_dotdot_on_system_metrics_swap_memory_usedmb_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_system_metrics_attribute_swap_memory_usedmb_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  double swap_memory_usedmb = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "SystemMetrics::SWAPMemoryUsedMB: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      swap_memory_usedmb = json_payload.at("value").get<double>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_system_metrics_attribute_swap_memory_usedmb_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    swap_memory_usedmb
  );

}
static void uic_mqtt_dotdot_on_system_metrics_virtual_memory_totalmb_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_system_metrics_attribute_virtual_memory_totalmb_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  double virtual_memory_totalmb = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "SystemMetrics::VirtualMemoryTotalMB: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      virtual_memory_totalmb = json_payload.at("value").get<double>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_system_metrics_attribute_virtual_memory_totalmb_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    virtual_memory_totalmb
  );

}
static void uic_mqtt_dotdot_on_system_metrics_virtual_memory_usedmb_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_system_metrics_attribute_virtual_memory_usedmb_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  double virtual_memory_usedmb = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "SystemMetrics::VirtualMemoryUsedMB: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      virtual_memory_usedmb = json_payload.at("value").get<double>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_system_metrics_attribute_virtual_memory_usedmb_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    virtual_memory_usedmb
  );

}
static void uic_mqtt_dotdot_on_system_metrics_disks_usage_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_system_metrics_attribute_disks_usage_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  std::vector<DiskUsageData> disks_usage;
  size_t disks_usage_count = 0;

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "SystemMetrics::DisksUsage: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      auto &disks_usage_json = json_payload.at("value");
      for (size_t i = 0; i < disks_usage_json.size(); i++) {
        DiskUsageData element = {};
        element.UUID = disks_usage_json.at(i).at("UUID").get_ptr<const std::string*>()->c_str();
        element.UsagePercent = disks_usage_json.at(i).at("UsagePercent").get<double>();
        element.FreeSpaceMB = disks_usage_json.at(i).at("FreeSpaceMB").get<double>();
        disks_usage.push_back(element);
      }
      // Take our vector and pack it into the updated state
      disks_usage_count = disks_usage.size();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_system_metrics_attribute_disks_usage_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    disks_usage_count,
    disks_usage.data()
  );

}
static void uic_mqtt_dotdot_on_system_metrics_disks_counters_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_system_metrics_attribute_disks_counters_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  std::vector<DiskIOCounters> disks_counters;
  size_t disks_counters_count = 0;

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "SystemMetrics::DisksCounters: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      auto &disks_counters_json = json_payload.at("value");
      for (size_t i = 0; i < disks_counters_json.size(); i++) {
        DiskIOCounters element = {};
        element.UUID = disks_counters_json.at(i).at("UUID").get_ptr<const std::string*>()->c_str();
        element.ReadCount = disks_counters_json.at(i).at("ReadCount").get<uint64_t>();
        element.WriteCount = disks_counters_json.at(i).at("WriteCount").get<uint64_t>();
        element.ReadBytes = disks_counters_json.at(i).at("ReadBytes").get<uint64_t>();
        element.WriteBytes = disks_counters_json.at(i).at("WriteBytes").get<uint64_t>();
        disks_counters.push_back(element);
      }
      // Take our vector and pack it into the updated state
      disks_counters_count = disks_counters.size();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_system_metrics_attribute_disks_counters_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    disks_counters_count,
    disks_counters.data()
  );

}
static void uic_mqtt_dotdot_on_system_metrics_network_interfaces_data_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_system_metrics_attribute_network_interfaces_data_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  std::vector<NetworkInterfaceData> network_interfaces_data;
  size_t network_interfaces_data_count = 0;

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "SystemMetrics::NetworkInterfacesData: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      auto &network_interfaces_data_json = json_payload.at("value");
      for (size_t i = 0; i < network_interfaces_data_json.size(); i++) {
        NetworkInterfaceData element = {};
        element.InterfaceName = network_interfaces_data_json.at(i).at("InterfaceName").get_ptr<const std::string*>()->c_str();
        element.BytesSent = network_interfaces_data_json.at(i).at("BytesSent").get<uint64_t>();
        element.BytesReceived = network_interfaces_data_json.at(i).at("BytesReceived").get<uint64_t>();
        element.PacketsSent = network_interfaces_data_json.at(i).at("PacketsSent").get<uint64_t>();
        element.PacketsReceived = network_interfaces_data_json.at(i).at("PacketsReceived").get<uint64_t>();
        element.ErrorsIn = network_interfaces_data_json.at(i).at("ErrorsIn").get<uint64_t>();
        element.ErrorsOut = network_interfaces_data_json.at(i).at("ErrorsOut").get<uint64_t>();
        element.DropIn = network_interfaces_data_json.at(i).at("DropIn").get<uint64_t>();
        element.DropOut = network_interfaces_data_json.at(i).at("DropOut").get<uint64_t>();
        network_interfaces_data.push_back(element);
      }
      // Take our vector and pack it into the updated state
      network_interfaces_data_count = network_interfaces_data.size();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_system_metrics_attribute_network_interfaces_data_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    network_interfaces_data_count,
    network_interfaces_data.data()
  );

}
static void uic_mqtt_dotdot_on_system_metrics_wireless_network_interfaces_data_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_system_metrics_attribute_wireless_network_interfaces_data_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  std::vector<WirelessNetworkInterfaceData> wireless_network_interfaces_data;
  size_t wireless_network_interfaces_data_count = 0;

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "SystemMetrics::WirelessNetworkInterfacesData: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      auto &wireless_network_interfaces_data_json = json_payload.at("value");
      for (size_t i = 0; i < wireless_network_interfaces_data_json.size(); i++) {
        WirelessNetworkInterfaceData element = {};
        element.InterfaceName = wireless_network_interfaces_data_json.at(i).at("InterfaceName").get_ptr<const std::string*>()->c_str();
        element.SignalStrengthdBm = wireless_network_interfaces_data_json.at(i).at("SignalStrengthdBm").get<double>();
        wireless_network_interfaces_data.push_back(element);
      }
      // Take our vector and pack it into the updated state
      wireless_network_interfaces_data_count = wireless_network_interfaces_data.size();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_system_metrics_attribute_wireless_network_interfaces_data_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    wireless_network_interfaces_data_count,
    wireless_network_interfaces_data.data()
  );

}
static void uic_mqtt_dotdot_on_system_metrics_hostname_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_system_metrics_attribute_hostname_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  const char* hostname = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "SystemMetrics::Hostname: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      hostname = json_payload.at("value").get_ptr<const std::string*>()->c_str();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_system_metrics_attribute_hostname_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    hostname
  );

}
static void uic_mqtt_dotdot_on_system_metrics_fqdn_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_system_metrics_attribute_fqdn_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  const char* fqdn = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "SystemMetrics::FQDN: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      fqdn = json_payload.at("value").get_ptr<const std::string*>()->c_str();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_system_metrics_attribute_fqdn_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    fqdn
  );

}
static void uic_mqtt_dotdot_on_system_metrics_uptime_minutes_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_system_metrics_attribute_uptime_minutes_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint64_t uptime_minutes = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "SystemMetrics::UptimeMinutes: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uptime_minutes = json_payload.at("value").get<uint64_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_system_metrics_attribute_uptime_minutes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    uptime_minutes
  );

}
static void uic_mqtt_dotdot_on_system_metrics_current_temperature_celcius_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_system_metrics_attribute_current_temperature_celcius_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  double current_temperature_celcius = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "SystemMetrics::CurrentTemperatureCelcius: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      current_temperature_celcius = json_payload.at("value").get<double>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_system_metrics_attribute_current_temperature_celcius_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    current_temperature_celcius
  );

}
static void uic_mqtt_dotdot_on_system_metrics_average_temperature_celcius_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_system_metrics_attribute_average_temperature_celcius_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  double average_temperature_celcius = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "SystemMetrics::AverageTemperatureCelcius: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      average_temperature_celcius = json_payload.at("value").get<double>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_system_metrics_attribute_average_temperature_celcius_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    average_temperature_celcius
  );

}
static void uic_mqtt_dotdot_on_system_metrics_min_temperature_celcius_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_system_metrics_attribute_min_temperature_celcius_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  double min_temperature_celcius = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "SystemMetrics::MinTemperatureCelcius: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      min_temperature_celcius = json_payload.at("value").get<double>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_system_metrics_attribute_min_temperature_celcius_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    min_temperature_celcius
  );

}
static void uic_mqtt_dotdot_on_system_metrics_max_temperature_celcius_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_system_metrics_attribute_max_temperature_celcius_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  double max_temperature_celcius = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "SystemMetrics::MaxTemperatureCelcius: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      max_temperature_celcius = json_payload.at("value").get<double>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_system_metrics_attribute_max_temperature_celcius_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    max_temperature_celcius
  );

}
static void uic_mqtt_dotdot_on_system_metrics_power_plugged_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_system_metrics_attribute_power_plugged_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  bool power_plugged = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "SystemMetrics::PowerPlugged: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      power_plugged = get_bool_from_json(json_payload, "value");

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_system_metrics_attribute_power_plugged_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    power_plugged
  );

}
static void uic_mqtt_dotdot_on_system_metrics_battery_percentage_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_system_metrics_attribute_battery_percentage_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  double battery_percentage = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "SystemMetrics::BatteryPercentage: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      battery_percentage = json_payload.at("value").get<double>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_system_metrics_attribute_battery_percentage_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    battery_percentage
  );

}
static void uic_mqtt_dotdot_on_system_metrics_system_interrupts_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_system_metrics_attribute_system_interrupts_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint64_t system_interrupts = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "SystemMetrics::SystemInterrupts: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      system_interrupts = json_payload.at("value").get<uint64_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_system_metrics_attribute_system_interrupts_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    system_interrupts
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for SystemMetrics
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_system_metrics_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_system_metrics_attribute_reporting_interval_seconds_callback) {
    subscription_topic = base_topic + "SystemMetrics/Attributes/ReportingIntervalSeconds/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_system_metrics_reporting_interval_seconds_attribute_update);
  }
  if(uic_mqtt_dotdot_system_metrics_attribute_cpu_usage_percent_callback) {
    subscription_topic = base_topic + "SystemMetrics/Attributes/CPUUsagePercent/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_system_metrics_cpu_usage_percent_attribute_update);
  }
  if(uic_mqtt_dotdot_system_metrics_attribute_cpu_frequencym_hz_callback) {
    subscription_topic = base_topic + "SystemMetrics/Attributes/CPUFrequencyMHz/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_system_metrics_cpu_frequencym_hz_attribute_update);
  }
  if(uic_mqtt_dotdot_system_metrics_attribute_cpu_average_usage_percent_callback) {
    subscription_topic = base_topic + "SystemMetrics/Attributes/CPUAverageUsagePercent/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_system_metrics_cpu_average_usage_percent_attribute_update);
  }
  if(uic_mqtt_dotdot_system_metrics_attribute_cpu_min_usage_percent_callback) {
    subscription_topic = base_topic + "SystemMetrics/Attributes/CPUMinUsagePercent/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_system_metrics_cpu_min_usage_percent_attribute_update);
  }
  if(uic_mqtt_dotdot_system_metrics_attribute_cpu_max_usage_percent_callback) {
    subscription_topic = base_topic + "SystemMetrics/Attributes/CPUMaxUsagePercent/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_system_metrics_cpu_max_usage_percent_attribute_update);
  }
  if(uic_mqtt_dotdot_system_metrics_attribute_ram_totalmb_callback) {
    subscription_topic = base_topic + "SystemMetrics/Attributes/RAMTotalMB/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_system_metrics_ram_totalmb_attribute_update);
  }
  if(uic_mqtt_dotdot_system_metrics_attribute_ram_freemb_callback) {
    subscription_topic = base_topic + "SystemMetrics/Attributes/RAMFreeMB/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_system_metrics_ram_freemb_attribute_update);
  }
  if(uic_mqtt_dotdot_system_metrics_attribute_ram_availablemb_callback) {
    subscription_topic = base_topic + "SystemMetrics/Attributes/RAMAvailableMB/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_system_metrics_ram_availablemb_attribute_update);
  }
  if(uic_mqtt_dotdot_system_metrics_attribute_swap_memory_totalmb_callback) {
    subscription_topic = base_topic + "SystemMetrics/Attributes/SWAPMemoryTotalMB/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_system_metrics_swap_memory_totalmb_attribute_update);
  }
  if(uic_mqtt_dotdot_system_metrics_attribute_swap_memory_usedmb_callback) {
    subscription_topic = base_topic + "SystemMetrics/Attributes/SWAPMemoryUsedMB/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_system_metrics_swap_memory_usedmb_attribute_update);
  }
  if(uic_mqtt_dotdot_system_metrics_attribute_virtual_memory_totalmb_callback) {
    subscription_topic = base_topic + "SystemMetrics/Attributes/VirtualMemoryTotalMB/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_system_metrics_virtual_memory_totalmb_attribute_update);
  }
  if(uic_mqtt_dotdot_system_metrics_attribute_virtual_memory_usedmb_callback) {
    subscription_topic = base_topic + "SystemMetrics/Attributes/VirtualMemoryUsedMB/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_system_metrics_virtual_memory_usedmb_attribute_update);
  }
  if(uic_mqtt_dotdot_system_metrics_attribute_disks_usage_callback) {
    subscription_topic = base_topic + "SystemMetrics/Attributes/DisksUsage/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_system_metrics_disks_usage_attribute_update);
  }
  if(uic_mqtt_dotdot_system_metrics_attribute_disks_counters_callback) {
    subscription_topic = base_topic + "SystemMetrics/Attributes/DisksCounters/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_system_metrics_disks_counters_attribute_update);
  }
  if(uic_mqtt_dotdot_system_metrics_attribute_network_interfaces_data_callback) {
    subscription_topic = base_topic + "SystemMetrics/Attributes/NetworkInterfacesData/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_system_metrics_network_interfaces_data_attribute_update);
  }
  if(uic_mqtt_dotdot_system_metrics_attribute_wireless_network_interfaces_data_callback) {
    subscription_topic = base_topic + "SystemMetrics/Attributes/WirelessNetworkInterfacesData/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_system_metrics_wireless_network_interfaces_data_attribute_update);
  }
  if(uic_mqtt_dotdot_system_metrics_attribute_hostname_callback) {
    subscription_topic = base_topic + "SystemMetrics/Attributes/Hostname/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_system_metrics_hostname_attribute_update);
  }
  if(uic_mqtt_dotdot_system_metrics_attribute_fqdn_callback) {
    subscription_topic = base_topic + "SystemMetrics/Attributes/FQDN/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_system_metrics_fqdn_attribute_update);
  }
  if(uic_mqtt_dotdot_system_metrics_attribute_uptime_minutes_callback) {
    subscription_topic = base_topic + "SystemMetrics/Attributes/UptimeMinutes/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_system_metrics_uptime_minutes_attribute_update);
  }
  if(uic_mqtt_dotdot_system_metrics_attribute_current_temperature_celcius_callback) {
    subscription_topic = base_topic + "SystemMetrics/Attributes/CurrentTemperatureCelcius/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_system_metrics_current_temperature_celcius_attribute_update);
  }
  if(uic_mqtt_dotdot_system_metrics_attribute_average_temperature_celcius_callback) {
    subscription_topic = base_topic + "SystemMetrics/Attributes/AverageTemperatureCelcius/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_system_metrics_average_temperature_celcius_attribute_update);
  }
  if(uic_mqtt_dotdot_system_metrics_attribute_min_temperature_celcius_callback) {
    subscription_topic = base_topic + "SystemMetrics/Attributes/MinTemperatureCelcius/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_system_metrics_min_temperature_celcius_attribute_update);
  }
  if(uic_mqtt_dotdot_system_metrics_attribute_max_temperature_celcius_callback) {
    subscription_topic = base_topic + "SystemMetrics/Attributes/MaxTemperatureCelcius/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_system_metrics_max_temperature_celcius_attribute_update);
  }
  if(uic_mqtt_dotdot_system_metrics_attribute_power_plugged_callback) {
    subscription_topic = base_topic + "SystemMetrics/Attributes/PowerPlugged/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_system_metrics_power_plugged_attribute_update);
  }
  if(uic_mqtt_dotdot_system_metrics_attribute_battery_percentage_callback) {
    subscription_topic = base_topic + "SystemMetrics/Attributes/BatteryPercentage/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_system_metrics_battery_percentage_attribute_update);
  }
  if(uic_mqtt_dotdot_system_metrics_attribute_system_interrupts_callback) {
    subscription_topic = base_topic + "SystemMetrics/Attributes/SystemInterrupts/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_system_metrics_system_interrupts_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for SystemMetrics
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_system_metrics_attribute_reporting_interval_seconds_callback_set(const uic_mqtt_dotdot_system_metrics_attribute_reporting_interval_seconds_callback_t callback)
{
  uic_mqtt_dotdot_system_metrics_attribute_reporting_interval_seconds_callback = callback;
}
void uic_mqtt_dotdot_system_metrics_attribute_cpu_usage_percent_callback_set(const uic_mqtt_dotdot_system_metrics_attribute_cpu_usage_percent_callback_t callback)
{
  uic_mqtt_dotdot_system_metrics_attribute_cpu_usage_percent_callback = callback;
}
void uic_mqtt_dotdot_system_metrics_attribute_cpu_frequencym_hz_callback_set(const uic_mqtt_dotdot_system_metrics_attribute_cpu_frequencym_hz_callback_t callback)
{
  uic_mqtt_dotdot_system_metrics_attribute_cpu_frequencym_hz_callback = callback;
}
void uic_mqtt_dotdot_system_metrics_attribute_cpu_average_usage_percent_callback_set(const uic_mqtt_dotdot_system_metrics_attribute_cpu_average_usage_percent_callback_t callback)
{
  uic_mqtt_dotdot_system_metrics_attribute_cpu_average_usage_percent_callback = callback;
}
void uic_mqtt_dotdot_system_metrics_attribute_cpu_min_usage_percent_callback_set(const uic_mqtt_dotdot_system_metrics_attribute_cpu_min_usage_percent_callback_t callback)
{
  uic_mqtt_dotdot_system_metrics_attribute_cpu_min_usage_percent_callback = callback;
}
void uic_mqtt_dotdot_system_metrics_attribute_cpu_max_usage_percent_callback_set(const uic_mqtt_dotdot_system_metrics_attribute_cpu_max_usage_percent_callback_t callback)
{
  uic_mqtt_dotdot_system_metrics_attribute_cpu_max_usage_percent_callback = callback;
}
void uic_mqtt_dotdot_system_metrics_attribute_ram_totalmb_callback_set(const uic_mqtt_dotdot_system_metrics_attribute_ram_totalmb_callback_t callback)
{
  uic_mqtt_dotdot_system_metrics_attribute_ram_totalmb_callback = callback;
}
void uic_mqtt_dotdot_system_metrics_attribute_ram_freemb_callback_set(const uic_mqtt_dotdot_system_metrics_attribute_ram_freemb_callback_t callback)
{
  uic_mqtt_dotdot_system_metrics_attribute_ram_freemb_callback = callback;
}
void uic_mqtt_dotdot_system_metrics_attribute_ram_availablemb_callback_set(const uic_mqtt_dotdot_system_metrics_attribute_ram_availablemb_callback_t callback)
{
  uic_mqtt_dotdot_system_metrics_attribute_ram_availablemb_callback = callback;
}
void uic_mqtt_dotdot_system_metrics_attribute_swap_memory_totalmb_callback_set(const uic_mqtt_dotdot_system_metrics_attribute_swap_memory_totalmb_callback_t callback)
{
  uic_mqtt_dotdot_system_metrics_attribute_swap_memory_totalmb_callback = callback;
}
void uic_mqtt_dotdot_system_metrics_attribute_swap_memory_usedmb_callback_set(const uic_mqtt_dotdot_system_metrics_attribute_swap_memory_usedmb_callback_t callback)
{
  uic_mqtt_dotdot_system_metrics_attribute_swap_memory_usedmb_callback = callback;
}
void uic_mqtt_dotdot_system_metrics_attribute_virtual_memory_totalmb_callback_set(const uic_mqtt_dotdot_system_metrics_attribute_virtual_memory_totalmb_callback_t callback)
{
  uic_mqtt_dotdot_system_metrics_attribute_virtual_memory_totalmb_callback = callback;
}
void uic_mqtt_dotdot_system_metrics_attribute_virtual_memory_usedmb_callback_set(const uic_mqtt_dotdot_system_metrics_attribute_virtual_memory_usedmb_callback_t callback)
{
  uic_mqtt_dotdot_system_metrics_attribute_virtual_memory_usedmb_callback = callback;
}
void uic_mqtt_dotdot_system_metrics_attribute_disks_usage_callback_set(const uic_mqtt_dotdot_system_metrics_attribute_disks_usage_callback_t callback)
{
  uic_mqtt_dotdot_system_metrics_attribute_disks_usage_callback = callback;
}
void uic_mqtt_dotdot_system_metrics_attribute_disks_counters_callback_set(const uic_mqtt_dotdot_system_metrics_attribute_disks_counters_callback_t callback)
{
  uic_mqtt_dotdot_system_metrics_attribute_disks_counters_callback = callback;
}
void uic_mqtt_dotdot_system_metrics_attribute_network_interfaces_data_callback_set(const uic_mqtt_dotdot_system_metrics_attribute_network_interfaces_data_callback_t callback)
{
  uic_mqtt_dotdot_system_metrics_attribute_network_interfaces_data_callback = callback;
}
void uic_mqtt_dotdot_system_metrics_attribute_wireless_network_interfaces_data_callback_set(const uic_mqtt_dotdot_system_metrics_attribute_wireless_network_interfaces_data_callback_t callback)
{
  uic_mqtt_dotdot_system_metrics_attribute_wireless_network_interfaces_data_callback = callback;
}
void uic_mqtt_dotdot_system_metrics_attribute_hostname_callback_set(const uic_mqtt_dotdot_system_metrics_attribute_hostname_callback_t callback)
{
  uic_mqtt_dotdot_system_metrics_attribute_hostname_callback = callback;
}
void uic_mqtt_dotdot_system_metrics_attribute_fqdn_callback_set(const uic_mqtt_dotdot_system_metrics_attribute_fqdn_callback_t callback)
{
  uic_mqtt_dotdot_system_metrics_attribute_fqdn_callback = callback;
}
void uic_mqtt_dotdot_system_metrics_attribute_uptime_minutes_callback_set(const uic_mqtt_dotdot_system_metrics_attribute_uptime_minutes_callback_t callback)
{
  uic_mqtt_dotdot_system_metrics_attribute_uptime_minutes_callback = callback;
}
void uic_mqtt_dotdot_system_metrics_attribute_current_temperature_celcius_callback_set(const uic_mqtt_dotdot_system_metrics_attribute_current_temperature_celcius_callback_t callback)
{
  uic_mqtt_dotdot_system_metrics_attribute_current_temperature_celcius_callback = callback;
}
void uic_mqtt_dotdot_system_metrics_attribute_average_temperature_celcius_callback_set(const uic_mqtt_dotdot_system_metrics_attribute_average_temperature_celcius_callback_t callback)
{
  uic_mqtt_dotdot_system_metrics_attribute_average_temperature_celcius_callback = callback;
}
void uic_mqtt_dotdot_system_metrics_attribute_min_temperature_celcius_callback_set(const uic_mqtt_dotdot_system_metrics_attribute_min_temperature_celcius_callback_t callback)
{
  uic_mqtt_dotdot_system_metrics_attribute_min_temperature_celcius_callback = callback;
}
void uic_mqtt_dotdot_system_metrics_attribute_max_temperature_celcius_callback_set(const uic_mqtt_dotdot_system_metrics_attribute_max_temperature_celcius_callback_t callback)
{
  uic_mqtt_dotdot_system_metrics_attribute_max_temperature_celcius_callback = callback;
}
void uic_mqtt_dotdot_system_metrics_attribute_power_plugged_callback_set(const uic_mqtt_dotdot_system_metrics_attribute_power_plugged_callback_t callback)
{
  uic_mqtt_dotdot_system_metrics_attribute_power_plugged_callback = callback;
}
void uic_mqtt_dotdot_system_metrics_attribute_battery_percentage_callback_set(const uic_mqtt_dotdot_system_metrics_attribute_battery_percentage_callback_t callback)
{
  uic_mqtt_dotdot_system_metrics_attribute_battery_percentage_callback = callback;
}
void uic_mqtt_dotdot_system_metrics_attribute_system_interrupts_callback_set(const uic_mqtt_dotdot_system_metrics_attribute_system_interrupts_callback_t callback)
{
  uic_mqtt_dotdot_system_metrics_attribute_system_interrupts_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for ApplicationMonitoring
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_application_monitoring_attribute_application_name_callback_t uic_mqtt_dotdot_application_monitoring_attribute_application_name_callback = nullptr;
static uic_mqtt_dotdot_application_monitoring_attribute_application_version_callback_t uic_mqtt_dotdot_application_monitoring_attribute_application_version_callback = nullptr;
static uic_mqtt_dotdot_application_monitoring_attribute_application_connected_callback_t uic_mqtt_dotdot_application_monitoring_attribute_application_connected_callback = nullptr;
static uic_mqtt_dotdot_application_monitoring_attribute_application_mqtt_topics_callback_t uic_mqtt_dotdot_application_monitoring_attribute_application_mqtt_topics_callback = nullptr;
static uic_mqtt_dotdot_application_monitoring_attribute_uptime_minutes_callback_t uic_mqtt_dotdot_application_monitoring_attribute_uptime_minutes_callback = nullptr;
static uic_mqtt_dotdot_application_monitoring_attribute_process_id_callback_t uic_mqtt_dotdot_application_monitoring_attribute_process_id_callback = nullptr;
static uic_mqtt_dotdot_application_monitoring_attribute_hostname_callback_t uic_mqtt_dotdot_application_monitoring_attribute_hostname_callback = nullptr;
static uic_mqtt_dotdot_application_monitoring_attribute_fqdn_callback_t uic_mqtt_dotdot_application_monitoring_attribute_fqdn_callback = nullptr;
static uic_mqtt_dotdot_application_monitoring_attribute_mqtt_logging_enabled_callback_t uic_mqtt_dotdot_application_monitoring_attribute_mqtt_logging_enabled_callback = nullptr;
static uic_mqtt_dotdot_application_monitoring_attribute_mqtt_logging_level_callback_t uic_mqtt_dotdot_application_monitoring_attribute_mqtt_logging_level_callback = nullptr;
static uic_mqtt_dotdot_application_monitoring_attribute_mqtt_statistics_reporting_interval_seconds_callback_t uic_mqtt_dotdot_application_monitoring_attribute_mqtt_statistics_reporting_interval_seconds_callback = nullptr;
static uic_mqtt_dotdot_application_monitoring_attribute_mqtt_messages_sent_callback_t uic_mqtt_dotdot_application_monitoring_attribute_mqtt_messages_sent_callback = nullptr;
static uic_mqtt_dotdot_application_monitoring_attribute_mqtt_messages_received_callback_t uic_mqtt_dotdot_application_monitoring_attribute_mqtt_messages_received_callback = nullptr;
static uic_mqtt_dotdot_application_monitoring_attribute_mqtt_subscription_count_callback_t uic_mqtt_dotdot_application_monitoring_attribute_mqtt_subscription_count_callback = nullptr;
static uic_mqtt_dotdot_application_monitoring_attribute_mqtt_average_delivery_time_seconds_callback_t uic_mqtt_dotdot_application_monitoring_attribute_mqtt_average_delivery_time_seconds_callback = nullptr;
static uic_mqtt_dotdot_application_monitoring_attribute_mqtt_min_delivery_time_seconds_callback_t uic_mqtt_dotdot_application_monitoring_attribute_mqtt_min_delivery_time_seconds_callback = nullptr;
static uic_mqtt_dotdot_application_monitoring_attribute_mqtt_max_delivery_time_seconds_callback_t uic_mqtt_dotdot_application_monitoring_attribute_mqtt_max_delivery_time_seconds_callback = nullptr;
static uic_mqtt_dotdot_application_monitoring_attribute_application_statistics_reporting_interval_seconds_callback_t uic_mqtt_dotdot_application_monitoring_attribute_application_statistics_reporting_interval_seconds_callback = nullptr;
static uic_mqtt_dotdot_application_monitoring_attribute_application_cpu_usage_percent_callback_t uic_mqtt_dotdot_application_monitoring_attribute_application_cpu_usage_percent_callback = nullptr;
static uic_mqtt_dotdot_application_monitoring_attribute_application_cpu_average_usage_percent_callback_t uic_mqtt_dotdot_application_monitoring_attribute_application_cpu_average_usage_percent_callback = nullptr;
static uic_mqtt_dotdot_application_monitoring_attribute_application_cpu_min_usage_percent_callback_t uic_mqtt_dotdot_application_monitoring_attribute_application_cpu_min_usage_percent_callback = nullptr;
static uic_mqtt_dotdot_application_monitoring_attribute_application_cpu_max_usage_percent_callback_t uic_mqtt_dotdot_application_monitoring_attribute_application_cpu_max_usage_percent_callback = nullptr;
static uic_mqtt_dotdot_application_monitoring_attribute_application_ram_usagemb_callback_t uic_mqtt_dotdot_application_monitoring_attribute_application_ram_usagemb_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for ApplicationMonitoring
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_application_monitoring_application_name_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_application_monitoring_attribute_application_name_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  const char* application_name = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ApplicationMonitoring::ApplicationName: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      application_name = json_payload.at("value").get_ptr<const std::string*>()->c_str();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_application_monitoring_attribute_application_name_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    application_name
  );

}
static void uic_mqtt_dotdot_on_application_monitoring_application_version_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_application_monitoring_attribute_application_version_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  const char* application_version = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ApplicationMonitoring::ApplicationVersion: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      application_version = json_payload.at("value").get_ptr<const std::string*>()->c_str();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_application_monitoring_attribute_application_version_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    application_version
  );

}
static void uic_mqtt_dotdot_on_application_monitoring_application_connected_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_application_monitoring_attribute_application_connected_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  bool application_connected = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ApplicationMonitoring::ApplicationConnected: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      application_connected = get_bool_from_json(json_payload, "value");

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_application_monitoring_attribute_application_connected_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    application_connected
  );

}
static void uic_mqtt_dotdot_on_application_monitoring_application_mqtt_topics_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_application_monitoring_attribute_application_mqtt_topics_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  std::vector<const char*> application_mqtt_topics;
  size_t application_mqtt_topics_count = 0;

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ApplicationMonitoring::ApplicationMQTTTopics: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      auto &application_mqtt_topics_json = json_payload.at("value");
      for (size_t i = 0; i < application_mqtt_topics_json.size(); i++) {
        application_mqtt_topics.push_back(application_mqtt_topics_json.at(i).get_ptr<const std::string*>()->c_str());
      }
      // Take our vector and pack it into the updated state
      application_mqtt_topics_count = application_mqtt_topics.size();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_application_monitoring_attribute_application_mqtt_topics_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    application_mqtt_topics_count,
    application_mqtt_topics.data()
  );

}
static void uic_mqtt_dotdot_on_application_monitoring_uptime_minutes_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_application_monitoring_attribute_uptime_minutes_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint64_t uptime_minutes = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ApplicationMonitoring::UptimeMinutes: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uptime_minutes = json_payload.at("value").get<uint64_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_application_monitoring_attribute_uptime_minutes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    uptime_minutes
  );

}
static void uic_mqtt_dotdot_on_application_monitoring_process_id_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_application_monitoring_attribute_process_id_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint64_t process_id = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ApplicationMonitoring::ProcessId: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      process_id = json_payload.at("value").get<uint64_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_application_monitoring_attribute_process_id_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    process_id
  );

}
static void uic_mqtt_dotdot_on_application_monitoring_hostname_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_application_monitoring_attribute_hostname_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  const char* hostname = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ApplicationMonitoring::Hostname: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      hostname = json_payload.at("value").get_ptr<const std::string*>()->c_str();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_application_monitoring_attribute_hostname_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    hostname
  );

}
static void uic_mqtt_dotdot_on_application_monitoring_fqdn_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_application_monitoring_attribute_fqdn_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  const char* fqdn = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ApplicationMonitoring::FQDN: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      fqdn = json_payload.at("value").get_ptr<const std::string*>()->c_str();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_application_monitoring_attribute_fqdn_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    fqdn
  );

}
static void uic_mqtt_dotdot_on_application_monitoring_mqtt_logging_enabled_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_application_monitoring_attribute_mqtt_logging_enabled_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  bool mqtt_logging_enabled = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ApplicationMonitoring::MQTTLoggingEnabled: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      mqtt_logging_enabled = get_bool_from_json(json_payload, "value");

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_application_monitoring_attribute_mqtt_logging_enabled_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    mqtt_logging_enabled
  );

}
static void uic_mqtt_dotdot_on_application_monitoring_mqtt_logging_level_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_application_monitoring_attribute_mqtt_logging_level_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  LoggingLevelEnum mqtt_logging_level = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ApplicationMonitoring::MQTTLoggingLevel: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<LoggingLevelEnum>("value", json_payload);
      if (tmp == numeric_limits<LoggingLevelEnum>::max()) {
      #ifdef APPLICATION_MONITORING_MQTT_LOGGING_LEVEL_ENUM_NAME_AVAILABLE
        tmp = application_monitoring_mqtt_logging_level_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(MQTT_LOGGING_LEVEL_ENUM_NAME_AVAILABLE)
        tmp = mqtt_logging_level_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      mqtt_logging_level = static_cast<LoggingLevelEnum>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_application_monitoring_attribute_mqtt_logging_level_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    mqtt_logging_level
  );

}
static void uic_mqtt_dotdot_on_application_monitoring_mqtt_statistics_reporting_interval_seconds_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_application_monitoring_attribute_mqtt_statistics_reporting_interval_seconds_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t mqtt_statistics_reporting_interval_seconds = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ApplicationMonitoring::MQTTStatisticsReportingIntervalSeconds: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      mqtt_statistics_reporting_interval_seconds = json_payload.at("value").get<uint32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_application_monitoring_attribute_mqtt_statistics_reporting_interval_seconds_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    mqtt_statistics_reporting_interval_seconds
  );

}
static void uic_mqtt_dotdot_on_application_monitoring_mqtt_messages_sent_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_application_monitoring_attribute_mqtt_messages_sent_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint64_t mqtt_messages_sent = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ApplicationMonitoring::MQTTMessagesSent: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      mqtt_messages_sent = json_payload.at("value").get<uint64_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_application_monitoring_attribute_mqtt_messages_sent_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    mqtt_messages_sent
  );

}
static void uic_mqtt_dotdot_on_application_monitoring_mqtt_messages_received_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_application_monitoring_attribute_mqtt_messages_received_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint64_t mqtt_messages_received = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ApplicationMonitoring::MQTTMessagesReceived: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      mqtt_messages_received = json_payload.at("value").get<uint64_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_application_monitoring_attribute_mqtt_messages_received_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    mqtt_messages_received
  );

}
static void uic_mqtt_dotdot_on_application_monitoring_mqtt_subscription_count_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_application_monitoring_attribute_mqtt_subscription_count_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint64_t mqtt_subscription_count = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ApplicationMonitoring::MQTTSubscriptionCount: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      mqtt_subscription_count = json_payload.at("value").get<uint64_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_application_monitoring_attribute_mqtt_subscription_count_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    mqtt_subscription_count
  );

}
static void uic_mqtt_dotdot_on_application_monitoring_mqtt_average_delivery_time_seconds_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_application_monitoring_attribute_mqtt_average_delivery_time_seconds_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  double mqtt_average_delivery_time_seconds = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ApplicationMonitoring::MQTTAverageDeliveryTimeSeconds: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      mqtt_average_delivery_time_seconds = json_payload.at("value").get<double>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_application_monitoring_attribute_mqtt_average_delivery_time_seconds_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    mqtt_average_delivery_time_seconds
  );

}
static void uic_mqtt_dotdot_on_application_monitoring_mqtt_min_delivery_time_seconds_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_application_monitoring_attribute_mqtt_min_delivery_time_seconds_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  double mqtt_min_delivery_time_seconds = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ApplicationMonitoring::MQTTMinDeliveryTimeSeconds: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      mqtt_min_delivery_time_seconds = json_payload.at("value").get<double>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_application_monitoring_attribute_mqtt_min_delivery_time_seconds_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    mqtt_min_delivery_time_seconds
  );

}
static void uic_mqtt_dotdot_on_application_monitoring_mqtt_max_delivery_time_seconds_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_application_monitoring_attribute_mqtt_max_delivery_time_seconds_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  double mqtt_max_delivery_time_seconds = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ApplicationMonitoring::MQTTMaxDeliveryTimeSeconds: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      mqtt_max_delivery_time_seconds = json_payload.at("value").get<double>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_application_monitoring_attribute_mqtt_max_delivery_time_seconds_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    mqtt_max_delivery_time_seconds
  );

}
static void uic_mqtt_dotdot_on_application_monitoring_application_statistics_reporting_interval_seconds_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_application_monitoring_attribute_application_statistics_reporting_interval_seconds_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint32_t application_statistics_reporting_interval_seconds = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ApplicationMonitoring::ApplicationStatisticsReportingIntervalSeconds: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      application_statistics_reporting_interval_seconds = json_payload.at("value").get<uint32_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_application_monitoring_attribute_application_statistics_reporting_interval_seconds_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    application_statistics_reporting_interval_seconds
  );

}
static void uic_mqtt_dotdot_on_application_monitoring_application_cpu_usage_percent_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_application_monitoring_attribute_application_cpu_usage_percent_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  double application_cpu_usage_percent = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ApplicationMonitoring::ApplicationCPUUsagePercent: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      application_cpu_usage_percent = json_payload.at("value").get<double>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_application_monitoring_attribute_application_cpu_usage_percent_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    application_cpu_usage_percent
  );

}
static void uic_mqtt_dotdot_on_application_monitoring_application_cpu_average_usage_percent_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_application_monitoring_attribute_application_cpu_average_usage_percent_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  double application_cpu_average_usage_percent = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ApplicationMonitoring::ApplicationCPUAverageUsagePercent: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      application_cpu_average_usage_percent = json_payload.at("value").get<double>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_application_monitoring_attribute_application_cpu_average_usage_percent_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    application_cpu_average_usage_percent
  );

}
static void uic_mqtt_dotdot_on_application_monitoring_application_cpu_min_usage_percent_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_application_monitoring_attribute_application_cpu_min_usage_percent_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  double application_cpu_min_usage_percent = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ApplicationMonitoring::ApplicationCPUMinUsagePercent: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      application_cpu_min_usage_percent = json_payload.at("value").get<double>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_application_monitoring_attribute_application_cpu_min_usage_percent_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    application_cpu_min_usage_percent
  );

}
static void uic_mqtt_dotdot_on_application_monitoring_application_cpu_max_usage_percent_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_application_monitoring_attribute_application_cpu_max_usage_percent_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  double application_cpu_max_usage_percent = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ApplicationMonitoring::ApplicationCPUMaxUsagePercent: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      application_cpu_max_usage_percent = json_payload.at("value").get<double>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_application_monitoring_attribute_application_cpu_max_usage_percent_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    application_cpu_max_usage_percent
  );

}
static void uic_mqtt_dotdot_on_application_monitoring_application_ram_usagemb_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_application_monitoring_attribute_application_ram_usagemb_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  double application_ram_usagemb = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ApplicationMonitoring::ApplicationRAMUsageMB: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      application_ram_usagemb = json_payload.at("value").get<double>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_application_monitoring_attribute_application_ram_usagemb_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    application_ram_usagemb
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for ApplicationMonitoring
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_application_monitoring_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_application_monitoring_attribute_application_name_callback) {
    subscription_topic = base_topic + "ApplicationMonitoring/Attributes/ApplicationName/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_application_monitoring_application_name_attribute_update);
  }
  if(uic_mqtt_dotdot_application_monitoring_attribute_application_version_callback) {
    subscription_topic = base_topic + "ApplicationMonitoring/Attributes/ApplicationVersion/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_application_monitoring_application_version_attribute_update);
  }
  if(uic_mqtt_dotdot_application_monitoring_attribute_application_connected_callback) {
    subscription_topic = base_topic + "ApplicationMonitoring/Attributes/ApplicationConnected/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_application_monitoring_application_connected_attribute_update);
  }
  if(uic_mqtt_dotdot_application_monitoring_attribute_application_mqtt_topics_callback) {
    subscription_topic = base_topic + "ApplicationMonitoring/Attributes/ApplicationMQTTTopics/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_application_monitoring_application_mqtt_topics_attribute_update);
  }
  if(uic_mqtt_dotdot_application_monitoring_attribute_uptime_minutes_callback) {
    subscription_topic = base_topic + "ApplicationMonitoring/Attributes/UptimeMinutes/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_application_monitoring_uptime_minutes_attribute_update);
  }
  if(uic_mqtt_dotdot_application_monitoring_attribute_process_id_callback) {
    subscription_topic = base_topic + "ApplicationMonitoring/Attributes/ProcessId/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_application_monitoring_process_id_attribute_update);
  }
  if(uic_mqtt_dotdot_application_monitoring_attribute_hostname_callback) {
    subscription_topic = base_topic + "ApplicationMonitoring/Attributes/Hostname/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_application_monitoring_hostname_attribute_update);
  }
  if(uic_mqtt_dotdot_application_monitoring_attribute_fqdn_callback) {
    subscription_topic = base_topic + "ApplicationMonitoring/Attributes/FQDN/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_application_monitoring_fqdn_attribute_update);
  }
  if(uic_mqtt_dotdot_application_monitoring_attribute_mqtt_logging_enabled_callback) {
    subscription_topic = base_topic + "ApplicationMonitoring/Attributes/MQTTLoggingEnabled/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_application_monitoring_mqtt_logging_enabled_attribute_update);
  }
  if(uic_mqtt_dotdot_application_monitoring_attribute_mqtt_logging_level_callback) {
    subscription_topic = base_topic + "ApplicationMonitoring/Attributes/MQTTLoggingLevel/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_application_monitoring_mqtt_logging_level_attribute_update);
  }
  if(uic_mqtt_dotdot_application_monitoring_attribute_mqtt_statistics_reporting_interval_seconds_callback) {
    subscription_topic = base_topic + "ApplicationMonitoring/Attributes/MQTTStatisticsReportingIntervalSeconds/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_application_monitoring_mqtt_statistics_reporting_interval_seconds_attribute_update);
  }
  if(uic_mqtt_dotdot_application_monitoring_attribute_mqtt_messages_sent_callback) {
    subscription_topic = base_topic + "ApplicationMonitoring/Attributes/MQTTMessagesSent/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_application_monitoring_mqtt_messages_sent_attribute_update);
  }
  if(uic_mqtt_dotdot_application_monitoring_attribute_mqtt_messages_received_callback) {
    subscription_topic = base_topic + "ApplicationMonitoring/Attributes/MQTTMessagesReceived/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_application_monitoring_mqtt_messages_received_attribute_update);
  }
  if(uic_mqtt_dotdot_application_monitoring_attribute_mqtt_subscription_count_callback) {
    subscription_topic = base_topic + "ApplicationMonitoring/Attributes/MQTTSubscriptionCount/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_application_monitoring_mqtt_subscription_count_attribute_update);
  }
  if(uic_mqtt_dotdot_application_monitoring_attribute_mqtt_average_delivery_time_seconds_callback) {
    subscription_topic = base_topic + "ApplicationMonitoring/Attributes/MQTTAverageDeliveryTimeSeconds/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_application_monitoring_mqtt_average_delivery_time_seconds_attribute_update);
  }
  if(uic_mqtt_dotdot_application_monitoring_attribute_mqtt_min_delivery_time_seconds_callback) {
    subscription_topic = base_topic + "ApplicationMonitoring/Attributes/MQTTMinDeliveryTimeSeconds/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_application_monitoring_mqtt_min_delivery_time_seconds_attribute_update);
  }
  if(uic_mqtt_dotdot_application_monitoring_attribute_mqtt_max_delivery_time_seconds_callback) {
    subscription_topic = base_topic + "ApplicationMonitoring/Attributes/MQTTMaxDeliveryTimeSeconds/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_application_monitoring_mqtt_max_delivery_time_seconds_attribute_update);
  }
  if(uic_mqtt_dotdot_application_monitoring_attribute_application_statistics_reporting_interval_seconds_callback) {
    subscription_topic = base_topic + "ApplicationMonitoring/Attributes/ApplicationStatisticsReportingIntervalSeconds/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_application_monitoring_application_statistics_reporting_interval_seconds_attribute_update);
  }
  if(uic_mqtt_dotdot_application_monitoring_attribute_application_cpu_usage_percent_callback) {
    subscription_topic = base_topic + "ApplicationMonitoring/Attributes/ApplicationCPUUsagePercent/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_application_monitoring_application_cpu_usage_percent_attribute_update);
  }
  if(uic_mqtt_dotdot_application_monitoring_attribute_application_cpu_average_usage_percent_callback) {
    subscription_topic = base_topic + "ApplicationMonitoring/Attributes/ApplicationCPUAverageUsagePercent/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_application_monitoring_application_cpu_average_usage_percent_attribute_update);
  }
  if(uic_mqtt_dotdot_application_monitoring_attribute_application_cpu_min_usage_percent_callback) {
    subscription_topic = base_topic + "ApplicationMonitoring/Attributes/ApplicationCPUMinUsagePercent/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_application_monitoring_application_cpu_min_usage_percent_attribute_update);
  }
  if(uic_mqtt_dotdot_application_monitoring_attribute_application_cpu_max_usage_percent_callback) {
    subscription_topic = base_topic + "ApplicationMonitoring/Attributes/ApplicationCPUMaxUsagePercent/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_application_monitoring_application_cpu_max_usage_percent_attribute_update);
  }
  if(uic_mqtt_dotdot_application_monitoring_attribute_application_ram_usagemb_callback) {
    subscription_topic = base_topic + "ApplicationMonitoring/Attributes/ApplicationRAMUsageMB/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_application_monitoring_application_ram_usagemb_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for ApplicationMonitoring
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_application_monitoring_attribute_application_name_callback_set(const uic_mqtt_dotdot_application_monitoring_attribute_application_name_callback_t callback)
{
  uic_mqtt_dotdot_application_monitoring_attribute_application_name_callback = callback;
}
void uic_mqtt_dotdot_application_monitoring_attribute_application_version_callback_set(const uic_mqtt_dotdot_application_monitoring_attribute_application_version_callback_t callback)
{
  uic_mqtt_dotdot_application_monitoring_attribute_application_version_callback = callback;
}
void uic_mqtt_dotdot_application_monitoring_attribute_application_connected_callback_set(const uic_mqtt_dotdot_application_monitoring_attribute_application_connected_callback_t callback)
{
  uic_mqtt_dotdot_application_monitoring_attribute_application_connected_callback = callback;
}
void uic_mqtt_dotdot_application_monitoring_attribute_application_mqtt_topics_callback_set(const uic_mqtt_dotdot_application_monitoring_attribute_application_mqtt_topics_callback_t callback)
{
  uic_mqtt_dotdot_application_monitoring_attribute_application_mqtt_topics_callback = callback;
}
void uic_mqtt_dotdot_application_monitoring_attribute_uptime_minutes_callback_set(const uic_mqtt_dotdot_application_monitoring_attribute_uptime_minutes_callback_t callback)
{
  uic_mqtt_dotdot_application_monitoring_attribute_uptime_minutes_callback = callback;
}
void uic_mqtt_dotdot_application_monitoring_attribute_process_id_callback_set(const uic_mqtt_dotdot_application_monitoring_attribute_process_id_callback_t callback)
{
  uic_mqtt_dotdot_application_monitoring_attribute_process_id_callback = callback;
}
void uic_mqtt_dotdot_application_monitoring_attribute_hostname_callback_set(const uic_mqtt_dotdot_application_monitoring_attribute_hostname_callback_t callback)
{
  uic_mqtt_dotdot_application_monitoring_attribute_hostname_callback = callback;
}
void uic_mqtt_dotdot_application_monitoring_attribute_fqdn_callback_set(const uic_mqtt_dotdot_application_monitoring_attribute_fqdn_callback_t callback)
{
  uic_mqtt_dotdot_application_monitoring_attribute_fqdn_callback = callback;
}
void uic_mqtt_dotdot_application_monitoring_attribute_mqtt_logging_enabled_callback_set(const uic_mqtt_dotdot_application_monitoring_attribute_mqtt_logging_enabled_callback_t callback)
{
  uic_mqtt_dotdot_application_monitoring_attribute_mqtt_logging_enabled_callback = callback;
}
void uic_mqtt_dotdot_application_monitoring_attribute_mqtt_logging_level_callback_set(const uic_mqtt_dotdot_application_monitoring_attribute_mqtt_logging_level_callback_t callback)
{
  uic_mqtt_dotdot_application_monitoring_attribute_mqtt_logging_level_callback = callback;
}
void uic_mqtt_dotdot_application_monitoring_attribute_mqtt_statistics_reporting_interval_seconds_callback_set(const uic_mqtt_dotdot_application_monitoring_attribute_mqtt_statistics_reporting_interval_seconds_callback_t callback)
{
  uic_mqtt_dotdot_application_monitoring_attribute_mqtt_statistics_reporting_interval_seconds_callback = callback;
}
void uic_mqtt_dotdot_application_monitoring_attribute_mqtt_messages_sent_callback_set(const uic_mqtt_dotdot_application_monitoring_attribute_mqtt_messages_sent_callback_t callback)
{
  uic_mqtt_dotdot_application_monitoring_attribute_mqtt_messages_sent_callback = callback;
}
void uic_mqtt_dotdot_application_monitoring_attribute_mqtt_messages_received_callback_set(const uic_mqtt_dotdot_application_monitoring_attribute_mqtt_messages_received_callback_t callback)
{
  uic_mqtt_dotdot_application_monitoring_attribute_mqtt_messages_received_callback = callback;
}
void uic_mqtt_dotdot_application_monitoring_attribute_mqtt_subscription_count_callback_set(const uic_mqtt_dotdot_application_monitoring_attribute_mqtt_subscription_count_callback_t callback)
{
  uic_mqtt_dotdot_application_monitoring_attribute_mqtt_subscription_count_callback = callback;
}
void uic_mqtt_dotdot_application_monitoring_attribute_mqtt_average_delivery_time_seconds_callback_set(const uic_mqtt_dotdot_application_monitoring_attribute_mqtt_average_delivery_time_seconds_callback_t callback)
{
  uic_mqtt_dotdot_application_monitoring_attribute_mqtt_average_delivery_time_seconds_callback = callback;
}
void uic_mqtt_dotdot_application_monitoring_attribute_mqtt_min_delivery_time_seconds_callback_set(const uic_mqtt_dotdot_application_monitoring_attribute_mqtt_min_delivery_time_seconds_callback_t callback)
{
  uic_mqtt_dotdot_application_monitoring_attribute_mqtt_min_delivery_time_seconds_callback = callback;
}
void uic_mqtt_dotdot_application_monitoring_attribute_mqtt_max_delivery_time_seconds_callback_set(const uic_mqtt_dotdot_application_monitoring_attribute_mqtt_max_delivery_time_seconds_callback_t callback)
{
  uic_mqtt_dotdot_application_monitoring_attribute_mqtt_max_delivery_time_seconds_callback = callback;
}
void uic_mqtt_dotdot_application_monitoring_attribute_application_statistics_reporting_interval_seconds_callback_set(const uic_mqtt_dotdot_application_monitoring_attribute_application_statistics_reporting_interval_seconds_callback_t callback)
{
  uic_mqtt_dotdot_application_monitoring_attribute_application_statistics_reporting_interval_seconds_callback = callback;
}
void uic_mqtt_dotdot_application_monitoring_attribute_application_cpu_usage_percent_callback_set(const uic_mqtt_dotdot_application_monitoring_attribute_application_cpu_usage_percent_callback_t callback)
{
  uic_mqtt_dotdot_application_monitoring_attribute_application_cpu_usage_percent_callback = callback;
}
void uic_mqtt_dotdot_application_monitoring_attribute_application_cpu_average_usage_percent_callback_set(const uic_mqtt_dotdot_application_monitoring_attribute_application_cpu_average_usage_percent_callback_t callback)
{
  uic_mqtt_dotdot_application_monitoring_attribute_application_cpu_average_usage_percent_callback = callback;
}
void uic_mqtt_dotdot_application_monitoring_attribute_application_cpu_min_usage_percent_callback_set(const uic_mqtt_dotdot_application_monitoring_attribute_application_cpu_min_usage_percent_callback_t callback)
{
  uic_mqtt_dotdot_application_monitoring_attribute_application_cpu_min_usage_percent_callback = callback;
}
void uic_mqtt_dotdot_application_monitoring_attribute_application_cpu_max_usage_percent_callback_set(const uic_mqtt_dotdot_application_monitoring_attribute_application_cpu_max_usage_percent_callback_t callback)
{
  uic_mqtt_dotdot_application_monitoring_attribute_application_cpu_max_usage_percent_callback = callback;
}
void uic_mqtt_dotdot_application_monitoring_attribute_application_ram_usagemb_callback_set(const uic_mqtt_dotdot_application_monitoring_attribute_application_ram_usagemb_callback_t callback)
{
  uic_mqtt_dotdot_application_monitoring_attribute_application_ram_usagemb_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for NameAndLocation
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_name_and_location_attribute_name_callback_t uic_mqtt_dotdot_name_and_location_attribute_name_callback = nullptr;
static uic_mqtt_dotdot_name_and_location_attribute_location_callback_t uic_mqtt_dotdot_name_and_location_attribute_location_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for NameAndLocation
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_name_and_location_name_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_name_and_location_attribute_name_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  const char* name = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "NameAndLocation::Name: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      name = json_payload.at("value").get_ptr<const std::string*>()->c_str();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_name_and_location_attribute_name_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    name
  );

}
static void uic_mqtt_dotdot_on_name_and_location_location_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_name_and_location_attribute_location_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  const char* location = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "NameAndLocation::Location: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      location = json_payload.at("value").get_ptr<const std::string*>()->c_str();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_name_and_location_attribute_location_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    location
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for NameAndLocation
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_name_and_location_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_name_and_location_attribute_name_callback) {
    subscription_topic = base_topic + "NameAndLocation/Attributes/Name/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_name_and_location_name_attribute_update);
  }
  if(uic_mqtt_dotdot_name_and_location_attribute_location_callback) {
    subscription_topic = base_topic + "NameAndLocation/Attributes/Location/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_name_and_location_location_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for NameAndLocation
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_name_and_location_attribute_name_callback_set(const uic_mqtt_dotdot_name_and_location_attribute_name_callback_t callback)
{
  uic_mqtt_dotdot_name_and_location_attribute_name_callback = callback;
}
void uic_mqtt_dotdot_name_and_location_attribute_location_callback_set(const uic_mqtt_dotdot_name_and_location_attribute_location_callback_t callback)
{
  uic_mqtt_dotdot_name_and_location_attribute_location_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for ConfigurationParameters
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_configuration_parameters_attribute_configuration_parameters_callback_t uic_mqtt_dotdot_configuration_parameters_attribute_configuration_parameters_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for ConfigurationParameters
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_configuration_parameters_configuration_parameters_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_configuration_parameters_attribute_configuration_parameters_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  std::vector<ConfigurationParameter> configuration_parameters;
  size_t configuration_parameters_count = 0;

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ConfigurationParameters::ConfigurationParameters: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      auto &configuration_parameters_json = json_payload.at("value");
      for (size_t i = 0; i < configuration_parameters_json.size(); i++) {
        ConfigurationParameter element = {};
        element.ParameterId = configuration_parameters_json.at(i).at("ParameterId").get<uint16_t>();
        element.Value = configuration_parameters_json.at(i).at("Value").get<int64_t>();
        element.Name = configuration_parameters_json.at(i).at("Name").get_ptr<const std::string*>()->c_str();
        element.Info = configuration_parameters_json.at(i).at("Info").get_ptr<const std::string*>()->c_str();
        element.MinimumValue = configuration_parameters_json.at(i).at("MinimumValue").get<int64_t>();
        element.MaximumValue = configuration_parameters_json.at(i).at("MaximumValue").get<int64_t>();
        element.DefaultValue = configuration_parameters_json.at(i).at("DefaultValue").get<int64_t>();
        element.DisplayFormat = configuration_parameters_json.at(i).at("DisplayFormat").get<uint8_t>();
        element.ReadOnly = configuration_parameters_json.at(i).at("ReadOnly").get<bool>();
        element.Advanced = configuration_parameters_json.at(i).at("Advanced").get<bool>();
        element.AlteringCapabilities = configuration_parameters_json.at(i).at("AlteringCapabilities").get<bool>();
        configuration_parameters.push_back(element);
      }
      // Take our vector and pack it into the updated state
      configuration_parameters_count = configuration_parameters.size();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_configuration_parameters_attribute_configuration_parameters_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    configuration_parameters_count,
    configuration_parameters.data()
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for ConfigurationParameters
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_configuration_parameters_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_configuration_parameters_attribute_configuration_parameters_callback) {
    subscription_topic = base_topic + "ConfigurationParameters/Attributes/ConfigurationParameters/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_configuration_parameters_configuration_parameters_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for ConfigurationParameters
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_configuration_parameters_attribute_configuration_parameters_callback_set(const uic_mqtt_dotdot_configuration_parameters_attribute_configuration_parameters_callback_t callback)
{
  uic_mqtt_dotdot_configuration_parameters_attribute_configuration_parameters_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for AoXLocator
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_aox_locator_attribute_reporting_mode_callback_t uic_mqtt_dotdot_aox_locator_attribute_reporting_mode_callback = nullptr;
static uic_mqtt_dotdot_aox_locator_attribute_position_and_orientation_valid_callback_t uic_mqtt_dotdot_aox_locator_attribute_position_and_orientation_valid_callback = nullptr;
static uic_mqtt_dotdot_aox_locator_attribute_position_and_orientation_callback_t uic_mqtt_dotdot_aox_locator_attribute_position_and_orientation_callback = nullptr;
static uic_mqtt_dotdot_aox_locator_attribute_azimuth_mask_callback_t uic_mqtt_dotdot_aox_locator_attribute_azimuth_mask_callback = nullptr;
static uic_mqtt_dotdot_aox_locator_attribute_elevation_mask_callback_t uic_mqtt_dotdot_aox_locator_attribute_elevation_mask_callback = nullptr;
static uic_mqtt_dotdot_aox_locator_attribute_allow_list_callback_t uic_mqtt_dotdot_aox_locator_attribute_allow_list_callback = nullptr;
static uic_mqtt_dotdot_aox_locator_attribute_aox_mode_callback_t uic_mqtt_dotdot_aox_locator_attribute_aox_mode_callback = nullptr;
static uic_mqtt_dotdot_aox_locator_attribute_antenna_mode_callback_t uic_mqtt_dotdot_aox_locator_attribute_antenna_mode_callback = nullptr;
static uic_mqtt_dotdot_aox_locator_attribute_antenna_array_callback_t uic_mqtt_dotdot_aox_locator_attribute_antenna_array_callback = nullptr;
static uic_mqtt_dotdot_aox_locator_attribute_period_samples_callback_t uic_mqtt_dotdot_aox_locator_attribute_period_samples_callback = nullptr;
static uic_mqtt_dotdot_aox_locator_attribute_angle_filtering_callback_t uic_mqtt_dotdot_aox_locator_attribute_angle_filtering_callback = nullptr;
static uic_mqtt_dotdot_aox_locator_attribute_angle_filtering_weight_callback_t uic_mqtt_dotdot_aox_locator_attribute_angle_filtering_weight_callback = nullptr;
static uic_mqtt_dotdot_aox_locator_attribute_angle_correction_timeout_callback_t uic_mqtt_dotdot_aox_locator_attribute_angle_correction_timeout_callback = nullptr;
static uic_mqtt_dotdot_aox_locator_attribute_angle_correction_delay_callback_t uic_mqtt_dotdot_aox_locator_attribute_angle_correction_delay_callback = nullptr;
static uic_mqtt_dotdot_aox_locator_attribute_cte_mode_callback_t uic_mqtt_dotdot_aox_locator_attribute_cte_mode_callback = nullptr;
static uic_mqtt_dotdot_aox_locator_attribute_cte_sampling_interval_callback_t uic_mqtt_dotdot_aox_locator_attribute_cte_sampling_interval_callback = nullptr;
static uic_mqtt_dotdot_aox_locator_attribute_cte_length_callback_t uic_mqtt_dotdot_aox_locator_attribute_cte_length_callback = nullptr;
static uic_mqtt_dotdot_aox_locator_attribute_slot_duration_callback_t uic_mqtt_dotdot_aox_locator_attribute_slot_duration_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for AoXLocator
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_aox_locator_reporting_mode_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_aox_locator_attribute_reporting_mode_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t reporting_mode = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "AoXLocator::ReportingMode: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<AoXLocatorReportingMode>("value", json_payload);
      if (tmp == numeric_limits<AoXLocatorReportingMode>::max()) {
      #ifdef AOX_LOCATOR_REPORTING_MODE_ENUM_NAME_AVAILABLE
        tmp = aox_locator_reporting_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(REPORTING_MODE_ENUM_NAME_AVAILABLE)
        tmp = reporting_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      reporting_mode = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_aox_locator_attribute_reporting_mode_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    reporting_mode
  );

}
static void uic_mqtt_dotdot_on_aox_locator_position_and_orientation_valid_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_aox_locator_attribute_position_and_orientation_valid_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  bool position_and_orientation_valid = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "AoXLocator::PositionAndOrientationValid: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      position_and_orientation_valid = get_bool_from_json(json_payload, "value");

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_aox_locator_attribute_position_and_orientation_valid_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    position_and_orientation_valid
  );

}
static void uic_mqtt_dotdot_on_aox_locator_position_and_orientation_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_aox_locator_attribute_position_and_orientation_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  CoordinateAndOrientation position_and_orientation = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "AoXLocator::PositionAndOrientation: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      position_and_orientation.CoordinateX = json_payload.at("value").at("CoordinateX").get<double>();
      position_and_orientation.CoordinateY = json_payload.at("value").at("CoordinateY").get<double>();
      position_and_orientation.CoordinateZ = json_payload.at("value").at("CoordinateZ").get<double>();
      position_and_orientation.OrientationX = json_payload.at("value").at("OrientationX").get<double>();
      position_and_orientation.OrientationY = json_payload.at("value").at("OrientationY").get<double>();
      position_and_orientation.OrientationZ = json_payload.at("value").at("OrientationZ").get<double>();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_aox_locator_attribute_position_and_orientation_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    position_and_orientation
  );

}
static void uic_mqtt_dotdot_on_aox_locator_azimuth_mask_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_aox_locator_attribute_azimuth_mask_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  std::vector<MinMaxPair> azimuth_mask;
  size_t azimuth_mask_count = 0;

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "AoXLocator::AzimuthMask: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      auto &azimuth_mask_json = json_payload.at("value");
      for (size_t i = 0; i < azimuth_mask_json.size(); i++) {
        MinMaxPair element = {};
        element.Min = azimuth_mask_json.at(i).at("Min").get<double>();
        element.Max = azimuth_mask_json.at(i).at("Max").get<double>();
        azimuth_mask.push_back(element);
      }
      // Take our vector and pack it into the updated state
      azimuth_mask_count = azimuth_mask.size();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_aox_locator_attribute_azimuth_mask_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    azimuth_mask_count,
    azimuth_mask.data()
  );

}
static void uic_mqtt_dotdot_on_aox_locator_elevation_mask_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_aox_locator_attribute_elevation_mask_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  std::vector<MinMaxPair> elevation_mask;
  size_t elevation_mask_count = 0;

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "AoXLocator::ElevationMask: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      auto &elevation_mask_json = json_payload.at("value");
      for (size_t i = 0; i < elevation_mask_json.size(); i++) {
        MinMaxPair element = {};
        element.Min = elevation_mask_json.at(i).at("Min").get<double>();
        element.Max = elevation_mask_json.at(i).at("Max").get<double>();
        elevation_mask.push_back(element);
      }
      // Take our vector and pack it into the updated state
      elevation_mask_count = elevation_mask.size();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_aox_locator_attribute_elevation_mask_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    elevation_mask_count,
    elevation_mask.data()
  );

}
static void uic_mqtt_dotdot_on_aox_locator_allow_list_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_aox_locator_attribute_allow_list_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  std::vector<const char*> allow_list;
  size_t allow_list_count = 0;

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "AoXLocator::AllowList: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      auto &allow_list_json = json_payload.at("value");
      for (size_t i = 0; i < allow_list_json.size(); i++) {
        allow_list.push_back(allow_list_json.at(i).get_ptr<const std::string*>()->c_str());
      }
      // Take our vector and pack it into the updated state
      allow_list_count = allow_list.size();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_aox_locator_attribute_allow_list_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    allow_list_count,
    allow_list.data()
  );

}
static void uic_mqtt_dotdot_on_aox_locator_aox_mode_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_aox_locator_attribute_aox_mode_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t aox_mode = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "AoXLocator::AoXMode: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<AoXLocatorAoXMode>("value", json_payload);
      if (tmp == numeric_limits<AoXLocatorAoXMode>::max()) {
      #ifdef AOX_LOCATOR_AOX_MODE_ENUM_NAME_AVAILABLE
        tmp = aox_locator_aox_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(AOX_MODE_ENUM_NAME_AVAILABLE)
        tmp = aox_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      aox_mode = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_aox_locator_attribute_aox_mode_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    aox_mode
  );

}
static void uic_mqtt_dotdot_on_aox_locator_antenna_mode_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_aox_locator_attribute_antenna_mode_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t antenna_mode = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "AoXLocator::AntennaMode: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<AoXLocatorAntennaMode>("value", json_payload);
      if (tmp == numeric_limits<AoXLocatorAntennaMode>::max()) {
      #ifdef AOX_LOCATOR_ANTENNA_MODE_ENUM_NAME_AVAILABLE
        tmp = aox_locator_antenna_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(ANTENNA_MODE_ENUM_NAME_AVAILABLE)
        tmp = antenna_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      antenna_mode = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_aox_locator_attribute_antenna_mode_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    antenna_mode
  );

}
static void uic_mqtt_dotdot_on_aox_locator_antenna_array_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_aox_locator_attribute_antenna_array_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  std::vector<int8_t> antenna_array;
  size_t antenna_array_count = 0;

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "AoXLocator::AntennaArray: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      auto &antenna_array_json = json_payload.at("value");
      for (size_t i = 0; i < antenna_array_json.size(); i++) {
        antenna_array.push_back(antenna_array_json.at(i).get<int8_t>());
          }
      // Take our vector and pack it into the updated state
      antenna_array_count = antenna_array.size();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_aox_locator_attribute_antenna_array_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    antenna_array_count,
    antenna_array.data()
  );

}
static void uic_mqtt_dotdot_on_aox_locator_period_samples_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_aox_locator_attribute_period_samples_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int8_t period_samples = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "AoXLocator::PeriodSamples: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      period_samples = json_payload.at("value").get<int8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_aox_locator_attribute_period_samples_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    period_samples
  );

}
static void uic_mqtt_dotdot_on_aox_locator_angle_filtering_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_aox_locator_attribute_angle_filtering_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  bool angle_filtering = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "AoXLocator::AngleFiltering: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      angle_filtering = get_bool_from_json(json_payload, "value");

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_aox_locator_attribute_angle_filtering_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    angle_filtering
  );

}
static void uic_mqtt_dotdot_on_aox_locator_angle_filtering_weight_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_aox_locator_attribute_angle_filtering_weight_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  double angle_filtering_weight = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "AoXLocator::AngleFilteringWeight: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      angle_filtering_weight = json_payload.at("value").get<double>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_aox_locator_attribute_angle_filtering_weight_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    angle_filtering_weight
  );

}
static void uic_mqtt_dotdot_on_aox_locator_angle_correction_timeout_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_aox_locator_attribute_angle_correction_timeout_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int8_t angle_correction_timeout = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "AoXLocator::AngleCorrectionTimeout: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      angle_correction_timeout = json_payload.at("value").get<int8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_aox_locator_attribute_angle_correction_timeout_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    angle_correction_timeout
  );

}
static void uic_mqtt_dotdot_on_aox_locator_angle_correction_delay_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_aox_locator_attribute_angle_correction_delay_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int8_t angle_correction_delay = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "AoXLocator::AngleCorrectionDelay: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      angle_correction_delay = json_payload.at("value").get<int8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_aox_locator_attribute_angle_correction_delay_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    angle_correction_delay
  );

}
static void uic_mqtt_dotdot_on_aox_locator_cte_mode_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_aox_locator_attribute_cte_mode_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint8_t cte_mode = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "AoXLocator::CTEMode: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<AoXLocatorCTEMode>("value", json_payload);
      if (tmp == numeric_limits<AoXLocatorCTEMode>::max()) {
      #ifdef AOX_LOCATOR_CTE_MODE_ENUM_NAME_AVAILABLE
        tmp = aox_locator_cte_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(CTE_MODE_ENUM_NAME_AVAILABLE)
        tmp = cte_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      cte_mode = static_cast<uint8_t>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_aox_locator_attribute_cte_mode_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    cte_mode
  );

}
static void uic_mqtt_dotdot_on_aox_locator_cte_sampling_interval_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_aox_locator_attribute_cte_sampling_interval_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int8_t cte_sampling_interval = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "AoXLocator::CTESamplingInterval: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      cte_sampling_interval = json_payload.at("value").get<int8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_aox_locator_attribute_cte_sampling_interval_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    cte_sampling_interval
  );

}
static void uic_mqtt_dotdot_on_aox_locator_cte_length_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_aox_locator_attribute_cte_length_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int8_t cte_length = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "AoXLocator::CTELength: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      cte_length = json_payload.at("value").get<int8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_aox_locator_attribute_cte_length_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    cte_length
  );

}
static void uic_mqtt_dotdot_on_aox_locator_slot_duration_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_aox_locator_attribute_slot_duration_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  int8_t slot_duration = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "AoXLocator::SlotDuration: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      slot_duration = json_payload.at("value").get<int8_t>();
    
    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_aox_locator_attribute_slot_duration_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    slot_duration
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for AoXLocator
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_aox_locator_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_aox_locator_attribute_reporting_mode_callback) {
    subscription_topic = base_topic + "AoXLocator/Attributes/ReportingMode/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_aox_locator_reporting_mode_attribute_update);
  }
  if(uic_mqtt_dotdot_aox_locator_attribute_position_and_orientation_valid_callback) {
    subscription_topic = base_topic + "AoXLocator/Attributes/PositionAndOrientationValid/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_aox_locator_position_and_orientation_valid_attribute_update);
  }
  if(uic_mqtt_dotdot_aox_locator_attribute_position_and_orientation_callback) {
    subscription_topic = base_topic + "AoXLocator/Attributes/PositionAndOrientation/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_aox_locator_position_and_orientation_attribute_update);
  }
  if(uic_mqtt_dotdot_aox_locator_attribute_azimuth_mask_callback) {
    subscription_topic = base_topic + "AoXLocator/Attributes/AzimuthMask/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_aox_locator_azimuth_mask_attribute_update);
  }
  if(uic_mqtt_dotdot_aox_locator_attribute_elevation_mask_callback) {
    subscription_topic = base_topic + "AoXLocator/Attributes/ElevationMask/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_aox_locator_elevation_mask_attribute_update);
  }
  if(uic_mqtt_dotdot_aox_locator_attribute_allow_list_callback) {
    subscription_topic = base_topic + "AoXLocator/Attributes/AllowList/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_aox_locator_allow_list_attribute_update);
  }
  if(uic_mqtt_dotdot_aox_locator_attribute_aox_mode_callback) {
    subscription_topic = base_topic + "AoXLocator/Attributes/AoXMode/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_aox_locator_aox_mode_attribute_update);
  }
  if(uic_mqtt_dotdot_aox_locator_attribute_antenna_mode_callback) {
    subscription_topic = base_topic + "AoXLocator/Attributes/AntennaMode/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_aox_locator_antenna_mode_attribute_update);
  }
  if(uic_mqtt_dotdot_aox_locator_attribute_antenna_array_callback) {
    subscription_topic = base_topic + "AoXLocator/Attributes/AntennaArray/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_aox_locator_antenna_array_attribute_update);
  }
  if(uic_mqtt_dotdot_aox_locator_attribute_period_samples_callback) {
    subscription_topic = base_topic + "AoXLocator/Attributes/PeriodSamples/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_aox_locator_period_samples_attribute_update);
  }
  if(uic_mqtt_dotdot_aox_locator_attribute_angle_filtering_callback) {
    subscription_topic = base_topic + "AoXLocator/Attributes/AngleFiltering/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_aox_locator_angle_filtering_attribute_update);
  }
  if(uic_mqtt_dotdot_aox_locator_attribute_angle_filtering_weight_callback) {
    subscription_topic = base_topic + "AoXLocator/Attributes/AngleFilteringWeight/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_aox_locator_angle_filtering_weight_attribute_update);
  }
  if(uic_mqtt_dotdot_aox_locator_attribute_angle_correction_timeout_callback) {
    subscription_topic = base_topic + "AoXLocator/Attributes/AngleCorrectionTimeout/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_aox_locator_angle_correction_timeout_attribute_update);
  }
  if(uic_mqtt_dotdot_aox_locator_attribute_angle_correction_delay_callback) {
    subscription_topic = base_topic + "AoXLocator/Attributes/AngleCorrectionDelay/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_aox_locator_angle_correction_delay_attribute_update);
  }
  if(uic_mqtt_dotdot_aox_locator_attribute_cte_mode_callback) {
    subscription_topic = base_topic + "AoXLocator/Attributes/CTEMode/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_aox_locator_cte_mode_attribute_update);
  }
  if(uic_mqtt_dotdot_aox_locator_attribute_cte_sampling_interval_callback) {
    subscription_topic = base_topic + "AoXLocator/Attributes/CTESamplingInterval/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_aox_locator_cte_sampling_interval_attribute_update);
  }
  if(uic_mqtt_dotdot_aox_locator_attribute_cte_length_callback) {
    subscription_topic = base_topic + "AoXLocator/Attributes/CTELength/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_aox_locator_cte_length_attribute_update);
  }
  if(uic_mqtt_dotdot_aox_locator_attribute_slot_duration_callback) {
    subscription_topic = base_topic + "AoXLocator/Attributes/SlotDuration/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_aox_locator_slot_duration_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for AoXLocator
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_aox_locator_attribute_reporting_mode_callback_set(const uic_mqtt_dotdot_aox_locator_attribute_reporting_mode_callback_t callback)
{
  uic_mqtt_dotdot_aox_locator_attribute_reporting_mode_callback = callback;
}
void uic_mqtt_dotdot_aox_locator_attribute_position_and_orientation_valid_callback_set(const uic_mqtt_dotdot_aox_locator_attribute_position_and_orientation_valid_callback_t callback)
{
  uic_mqtt_dotdot_aox_locator_attribute_position_and_orientation_valid_callback = callback;
}
void uic_mqtt_dotdot_aox_locator_attribute_position_and_orientation_callback_set(const uic_mqtt_dotdot_aox_locator_attribute_position_and_orientation_callback_t callback)
{
  uic_mqtt_dotdot_aox_locator_attribute_position_and_orientation_callback = callback;
}
void uic_mqtt_dotdot_aox_locator_attribute_azimuth_mask_callback_set(const uic_mqtt_dotdot_aox_locator_attribute_azimuth_mask_callback_t callback)
{
  uic_mqtt_dotdot_aox_locator_attribute_azimuth_mask_callback = callback;
}
void uic_mqtt_dotdot_aox_locator_attribute_elevation_mask_callback_set(const uic_mqtt_dotdot_aox_locator_attribute_elevation_mask_callback_t callback)
{
  uic_mqtt_dotdot_aox_locator_attribute_elevation_mask_callback = callback;
}
void uic_mqtt_dotdot_aox_locator_attribute_allow_list_callback_set(const uic_mqtt_dotdot_aox_locator_attribute_allow_list_callback_t callback)
{
  uic_mqtt_dotdot_aox_locator_attribute_allow_list_callback = callback;
}
void uic_mqtt_dotdot_aox_locator_attribute_aox_mode_callback_set(const uic_mqtt_dotdot_aox_locator_attribute_aox_mode_callback_t callback)
{
  uic_mqtt_dotdot_aox_locator_attribute_aox_mode_callback = callback;
}
void uic_mqtt_dotdot_aox_locator_attribute_antenna_mode_callback_set(const uic_mqtt_dotdot_aox_locator_attribute_antenna_mode_callback_t callback)
{
  uic_mqtt_dotdot_aox_locator_attribute_antenna_mode_callback = callback;
}
void uic_mqtt_dotdot_aox_locator_attribute_antenna_array_callback_set(const uic_mqtt_dotdot_aox_locator_attribute_antenna_array_callback_t callback)
{
  uic_mqtt_dotdot_aox_locator_attribute_antenna_array_callback = callback;
}
void uic_mqtt_dotdot_aox_locator_attribute_period_samples_callback_set(const uic_mqtt_dotdot_aox_locator_attribute_period_samples_callback_t callback)
{
  uic_mqtt_dotdot_aox_locator_attribute_period_samples_callback = callback;
}
void uic_mqtt_dotdot_aox_locator_attribute_angle_filtering_callback_set(const uic_mqtt_dotdot_aox_locator_attribute_angle_filtering_callback_t callback)
{
  uic_mqtt_dotdot_aox_locator_attribute_angle_filtering_callback = callback;
}
void uic_mqtt_dotdot_aox_locator_attribute_angle_filtering_weight_callback_set(const uic_mqtt_dotdot_aox_locator_attribute_angle_filtering_weight_callback_t callback)
{
  uic_mqtt_dotdot_aox_locator_attribute_angle_filtering_weight_callback = callback;
}
void uic_mqtt_dotdot_aox_locator_attribute_angle_correction_timeout_callback_set(const uic_mqtt_dotdot_aox_locator_attribute_angle_correction_timeout_callback_t callback)
{
  uic_mqtt_dotdot_aox_locator_attribute_angle_correction_timeout_callback = callback;
}
void uic_mqtt_dotdot_aox_locator_attribute_angle_correction_delay_callback_set(const uic_mqtt_dotdot_aox_locator_attribute_angle_correction_delay_callback_t callback)
{
  uic_mqtt_dotdot_aox_locator_attribute_angle_correction_delay_callback = callback;
}
void uic_mqtt_dotdot_aox_locator_attribute_cte_mode_callback_set(const uic_mqtt_dotdot_aox_locator_attribute_cte_mode_callback_t callback)
{
  uic_mqtt_dotdot_aox_locator_attribute_cte_mode_callback = callback;
}
void uic_mqtt_dotdot_aox_locator_attribute_cte_sampling_interval_callback_set(const uic_mqtt_dotdot_aox_locator_attribute_cte_sampling_interval_callback_t callback)
{
  uic_mqtt_dotdot_aox_locator_attribute_cte_sampling_interval_callback = callback;
}
void uic_mqtt_dotdot_aox_locator_attribute_cte_length_callback_set(const uic_mqtt_dotdot_aox_locator_attribute_cte_length_callback_t callback)
{
  uic_mqtt_dotdot_aox_locator_attribute_cte_length_callback = callback;
}
void uic_mqtt_dotdot_aox_locator_attribute_slot_duration_callback_set(const uic_mqtt_dotdot_aox_locator_attribute_slot_duration_callback_t callback)
{
  uic_mqtt_dotdot_aox_locator_attribute_slot_duration_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for AoXPositionEstimation
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_aox_position_estimation_attribute_position_callback_t uic_mqtt_dotdot_aox_position_estimation_attribute_position_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for AoXPositionEstimation
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_aox_position_estimation_position_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_aox_position_estimation_attribute_position_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  EstimatedPosition position = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "AoXPositionEstimation::Position: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      position.ApplicationId = json_payload.at("value").at("ApplicationId").get_ptr<const std::string*>()->c_str();
      position.X = json_payload.at("value").at("X").get<double>();
      position.Y = json_payload.at("value").at("Y").get<double>();
      position.Z = json_payload.at("value").at("Z").get<double>();
      position.DeviationX = json_payload.at("value").at("DeviationX").get<double>();
      position.DeviationY = json_payload.at("value").at("DeviationY").get<double>();
      position.DeviationZ = json_payload.at("value").at("DeviationZ").get<double>();
      position.Sequence = json_payload.at("value").at("Sequence").get<int32_t>();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_aox_position_estimation_attribute_position_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    position
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for AoXPositionEstimation
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_aox_position_estimation_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_aox_position_estimation_attribute_position_callback) {
    subscription_topic = base_topic + "AoXPositionEstimation/Attributes/Position/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_aox_position_estimation_position_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for AoXPositionEstimation
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_aox_position_estimation_attribute_position_callback_set(const uic_mqtt_dotdot_aox_position_estimation_attribute_position_callback_t callback)
{
  uic_mqtt_dotdot_aox_position_estimation_attribute_position_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for ProtocolController-NetworkManagement
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_protocol_controller_network_management_attribute_network_management_state_callback_t uic_mqtt_dotdot_protocol_controller_network_management_attribute_network_management_state_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for ProtocolController-NetworkManagement
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_protocol_controller_network_management_network_management_state_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_protocol_controller_network_management_attribute_network_management_state_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  NetworkManagementState network_management_state = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "ProtocolController-NetworkManagement::NetworkManagementState: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      network_management_state.State = json_payload.at("value").at("State").get<NM_State>();
      network_management_state.SupportedStateList = json_payload.at("value").at("SupportedStateList").get_ptr<const std::string*>()->c_str();
      network_management_state.StateParameters = json_payload.at("value").at("StateParameters").get<NM_StateParameters>();
      network_management_state.RequestedStateParameters = json_payload.at("value").at("RequestedStateParameters").get_ptr<const std::string*>()->c_str();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_protocol_controller_network_management_attribute_network_management_state_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    network_management_state
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for ProtocolController-NetworkManagement
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_protocol_controller_network_management_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_protocol_controller_network_management_attribute_network_management_state_callback) {
    subscription_topic = base_topic + "ProtocolController/NetworkManagement/Attributes/NetworkManagementState/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_protocol_controller_network_management_network_management_state_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for ProtocolController-NetworkManagement
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_protocol_controller_network_management_attribute_network_management_state_callback_set(const uic_mqtt_dotdot_protocol_controller_network_management_attribute_network_management_state_callback_t callback)
{
  uic_mqtt_dotdot_protocol_controller_network_management_attribute_network_management_state_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for Descriptor
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_descriptor_attribute_device_type_list_callback_t uic_mqtt_dotdot_descriptor_attribute_device_type_list_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for Descriptor
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_descriptor_device_type_list_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_descriptor_attribute_device_type_list_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  std::vector<DeviceTypeStruct> device_type_list;
  size_t device_type_list_count = 0;

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "Descriptor::DeviceTypeList: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      auto &device_type_list_json = json_payload.at("value");
      for (size_t i = 0; i < device_type_list_json.size(); i++) {
        DeviceTypeStruct element = {};
        element.DeviceType = device_type_list_json.at(i).at("DeviceType").get<DevTypeId>();
        element.Revision = device_type_list_json.at(i).at("Revision").get<uint16_t>();
        device_type_list.push_back(element);
      }
      // Take our vector and pack it into the updated state
      device_type_list_count = device_type_list.size();

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_descriptor_attribute_device_type_list_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    device_type_list_count,
    device_type_list.data()
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for Descriptor
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_descriptor_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_descriptor_attribute_device_type_list_callback) {
    subscription_topic = base_topic + "Descriptor/Attributes/DeviceTypeList/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_descriptor_device_type_list_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for Descriptor
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_descriptor_attribute_device_type_list_callback_set(const uic_mqtt_dotdot_descriptor_attribute_device_type_list_callback_t callback)
{
  uic_mqtt_dotdot_descriptor_attribute_device_type_list_callback = callback;
}

// End of supported cluster.

///////////////////////////////////////////////////////////////////////////////
// Callback pointers for UnifyFanControl
///////////////////////////////////////////////////////////////////////////////
static uic_mqtt_dotdot_unify_fan_control_attribute_z_wave_fan_mode_callback_t uic_mqtt_dotdot_unify_fan_control_attribute_z_wave_fan_mode_callback = nullptr;
static uic_mqtt_dotdot_unify_fan_control_attribute_z_wave_supported_fan_mode_callback_t uic_mqtt_dotdot_unify_fan_control_attribute_z_wave_supported_fan_mode_callback = nullptr;
static uic_mqtt_dotdot_unify_fan_control_attribute_z_wave_fan_state_callback_t uic_mqtt_dotdot_unify_fan_control_attribute_z_wave_fan_state_callback = nullptr;

///////////////////////////////////////////////////////////////////////////////
// Attribute update handlers for UnifyFanControl
///////////////////////////////////////////////////////////////////////////////
static void uic_mqtt_dotdot_on_unify_fan_control_z_wave_fan_mode_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_unify_fan_control_attribute_z_wave_fan_mode_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  ZWaveFanModeEnum z_wave_fan_mode = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "UnifyFanControl::ZWaveFanMode: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<ZWaveFanModeEnum>("value", json_payload);
      if (tmp == numeric_limits<ZWaveFanModeEnum>::max()) {
      #ifdef UNIFY_FAN_CONTROL_Z_WAVE_FAN_MODE_ENUM_NAME_AVAILABLE
        tmp = unify_fan_control_z_wave_fan_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(Z_WAVE_FAN_MODE_ENUM_NAME_AVAILABLE)
        tmp = z_wave_fan_mode_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      z_wave_fan_mode = static_cast<ZWaveFanModeEnum>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_unify_fan_control_attribute_z_wave_fan_mode_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    z_wave_fan_mode
  );

}
static void uic_mqtt_dotdot_on_unify_fan_control_z_wave_supported_fan_mode_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_unify_fan_control_attribute_z_wave_supported_fan_mode_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  uint16_t z_wave_supported_fan_mode = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "UnifyFanControl::ZWaveSupportedFanMode: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      z_wave_supported_fan_mode = uic_dotdot_mqtt::get_bitmap_decimal_value("value", json_payload, UnifyFanControlZWaveSupportedFanMode);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_unify_fan_control_attribute_z_wave_supported_fan_mode_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    z_wave_supported_fan_mode
  );

}
static void uic_mqtt_dotdot_on_unify_fan_control_z_wave_fan_state_attribute_update(
  const char *topic,
  const char *message,
  const size_t message_length) {
  if (uic_mqtt_dotdot_unify_fan_control_attribute_z_wave_fan_state_callback == nullptr) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string last_item;
  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
    sl_log_debug(LOG_TAG,
                "Error parsing last item from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_attribute_update_type_t update_type;
  if (last_item == "Reported") {
    update_type = UCL_REPORTED_UPDATED;
  } else if (last_item == "Desired") {
    update_type = UCL_DESIRED_UPDATED;
  } else {
    sl_log_debug(LOG_TAG,
                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
                topic);
    return;
  }

  // Empty message means unretained value.
  bool unretained = false;
  if (message_length == 0) {
    unretained = true;
  }


  ZWaveFanStateEnum z_wave_fan_state = {};

  nlohmann::json json_payload;
  try {

    if (unretained == false) {
      json_payload = nlohmann::json::parse(std::string(message));

      if (json_payload.find("value") == json_payload.end()) {
        sl_log_debug(LOG_TAG, "UnifyFanControl::ZWaveFanState: Missing attribute element: 'value'\n");
        return;
      }
// Start parsing value
      uint32_t tmp = get_enum_decimal_value<ZWaveFanStateEnum>("value", json_payload);
      if (tmp == numeric_limits<ZWaveFanStateEnum>::max()) {
      #ifdef UNIFY_FAN_CONTROL_Z_WAVE_FAN_STATE_ENUM_NAME_AVAILABLE
        tmp = unify_fan_control_z_wave_fan_state_get_enum_value_number(json_payload.at("value").get<std::string>());
      #elif defined(Z_WAVE_FAN_STATE_ENUM_NAME_AVAILABLE)
        tmp = z_wave_fan_state_get_enum_value_number(json_payload.at("value").get<std::string>());
      #endif
      }
      z_wave_fan_state = static_cast<ZWaveFanStateEnum>(tmp);

    // End parsing value
    }

  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
    return;
  }

  uic_mqtt_dotdot_unify_fan_control_attribute_z_wave_fan_state_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    unretained,
    update_type,
    z_wave_fan_state
  );

}

///////////////////////////////////////////////////////////////////////////////
// Attribute init functions for UnifyFanControl
///////////////////////////////////////////////////////////////////////////////
sl_status_t uic_mqtt_dotdot_unify_fan_control_attributes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_unify_fan_control_attribute_z_wave_fan_mode_callback) {
    subscription_topic = base_topic + "UnifyFanControl/Attributes/ZWaveFanMode/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_unify_fan_control_z_wave_fan_mode_attribute_update);
  }
  if(uic_mqtt_dotdot_unify_fan_control_attribute_z_wave_supported_fan_mode_callback) {
    subscription_topic = base_topic + "UnifyFanControl/Attributes/ZWaveSupportedFanMode/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_unify_fan_control_z_wave_supported_fan_mode_attribute_update);
  }
  if(uic_mqtt_dotdot_unify_fan_control_attribute_z_wave_fan_state_callback) {
    subscription_topic = base_topic + "UnifyFanControl/Attributes/ZWaveFanState/#";
    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_unify_fan_control_z_wave_fan_state_attribute_update);
  }

  return SL_STATUS_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Callback setters and getters for UnifyFanControl
///////////////////////////////////////////////////////////////////////////////
void uic_mqtt_dotdot_unify_fan_control_attribute_z_wave_fan_mode_callback_set(const uic_mqtt_dotdot_unify_fan_control_attribute_z_wave_fan_mode_callback_t callback)
{
  uic_mqtt_dotdot_unify_fan_control_attribute_z_wave_fan_mode_callback = callback;
}
void uic_mqtt_dotdot_unify_fan_control_attribute_z_wave_supported_fan_mode_callback_set(const uic_mqtt_dotdot_unify_fan_control_attribute_z_wave_supported_fan_mode_callback_t callback)
{
  uic_mqtt_dotdot_unify_fan_control_attribute_z_wave_supported_fan_mode_callback = callback;
}
void uic_mqtt_dotdot_unify_fan_control_attribute_z_wave_fan_state_callback_set(const uic_mqtt_dotdot_unify_fan_control_attribute_z_wave_fan_state_callback_t callback)
{
  uic_mqtt_dotdot_unify_fan_control_attribute_z_wave_fan_state_callback = callback;
}

// End of supported cluster.

