/******************************************************************************
 * # License
 * <b>Copyright 2022 Silicon Laboratories Inc. www.silabs.com</b>
 ******************************************************************************
 * The licensor of this software is Silicon Laboratories Inc. Your use of this
 * software is governed by the terms of Silicon Labs Master Software License
 * Agreement (MSLA) available at
 * www.silabs.com/about-us/legal/master-software-license-agreement. This
 * software is distributed to you in Source Code format and is governed by the
 * sections of the MSLA applicable to Source Code.
 *
 *****************************************************************************/

// This file is generated by ZCL Advanced Platform generator. Please don't edit manually.

// Includes from this component
#include "dotdot_mqtt_send_commands.h"
#include "dotdot_mqtt.hpp"
#include "dotdot_mqtt_command_helpers.hpp"
#include "dotdot_mqtt_parsing_helpers.hpp"
#include "sl_log.h"

// Generic includes
#include <string>
#include <nlohmann/json.hpp>

#define LOG_TAG "dotdot_mqtt_send_commands"

////////////////////////////////////////////////////////////////////////////////
// Sending Commands functions
////////////////////////////////////////////////////////////////////////////////

/**
 * @brief Sends/Publishes a ResetToFactoryDefaults command for
 * the Basic cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Basic/Commands/ResetToFactoryDefaults
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 */
void uic_mqtt_dotdot_basic_publish_reset_to_factory_defaults_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Basic/Commands/ResetToFactoryDefaults";


  std::string payload =
    get_json_payload_for_basic_reset_to_factory_defaults_command(
    );

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ResetToFactoryDefaults command for
 * the Basic cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Basic/Commands/ResetToFactoryDefaults
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 */
void uic_mqtt_dotdot_basic_publish_reset_to_factory_defaults_command_to_group(
  uint16_t destination_group_id
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Basic/Commands/ResetToFactoryDefaults";

  std::string payload =
    get_json_payload_for_basic_reset_to_factory_defaults_command(
    );

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a Identify command for
 * the Identify cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Identify/Commands/Identify
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_identify_publish_identify_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_identify_command_identify_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Identify/Commands/Identify";


  std::string payload =
    get_json_payload_for_identify_identify_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a Identify command for
 * the Identify cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Identify/Commands/Identify
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_identify_publish_identify_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_identify_command_identify_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Identify/Commands/Identify";

  std::string payload =
    get_json_payload_for_identify_identify_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a IdentifyQueryResponse command for
 * the Identify cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Identify/Commands/IdentifyQueryResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_identify_publish_identify_query_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_identify_command_identify_query_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Identify/Commands/IdentifyQueryResponse";


  std::string payload =
    get_json_payload_for_identify_identify_query_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a IdentifyQueryResponse command for
 * the Identify cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Identify/Commands/IdentifyQueryResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_identify_publish_identify_query_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_identify_command_identify_query_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Identify/Commands/IdentifyQueryResponse";

  std::string payload =
    get_json_payload_for_identify_identify_query_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a IdentifyQuery command for
 * the Identify cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Identify/Commands/IdentifyQuery
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 */
void uic_mqtt_dotdot_identify_publish_identify_query_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Identify/Commands/IdentifyQuery";


  std::string payload =
    get_json_payload_for_identify_identify_query_command(
    );

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a IdentifyQuery command for
 * the Identify cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Identify/Commands/IdentifyQuery
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 */
void uic_mqtt_dotdot_identify_publish_identify_query_command_to_group(
  uint16_t destination_group_id
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Identify/Commands/IdentifyQuery";

  std::string payload =
    get_json_payload_for_identify_identify_query_command(
    );

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a TriggerEffect command for
 * the Identify cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Identify/Commands/TriggerEffect
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_identify_publish_trigger_effect_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_identify_command_trigger_effect_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Identify/Commands/TriggerEffect";


  std::string payload =
    get_json_payload_for_identify_trigger_effect_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a TriggerEffect command for
 * the Identify cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Identify/Commands/TriggerEffect
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_identify_publish_trigger_effect_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_identify_command_trigger_effect_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Identify/Commands/TriggerEffect";

  std::string payload =
    get_json_payload_for_identify_trigger_effect_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a AddGroup command for
 * the Groups cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/Commands/AddGroup
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_add_group_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_groups_command_add_group_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Groups/Commands/AddGroup";


  std::string payload =
    get_json_payload_for_groups_add_group_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a AddGroup command for
 * the Groups cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Groups/Commands/AddGroup
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_add_group_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_groups_command_add_group_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Groups/Commands/AddGroup";

  std::string payload =
    get_json_payload_for_groups_add_group_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a AddGroupResponse command for
 * the Groups cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/Commands/AddGroupResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_add_group_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_groups_command_add_group_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Groups/Commands/AddGroupResponse";


  std::string payload =
    get_json_payload_for_groups_add_group_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a AddGroupResponse command for
 * the Groups cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Groups/Commands/AddGroupResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_add_group_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_groups_command_add_group_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Groups/Commands/AddGroupResponse";

  std::string payload =
    get_json_payload_for_groups_add_group_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ViewGroup command for
 * the Groups cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/Commands/ViewGroup
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_view_group_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_groups_command_view_group_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Groups/Commands/ViewGroup";


  std::string payload =
    get_json_payload_for_groups_view_group_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ViewGroup command for
 * the Groups cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Groups/Commands/ViewGroup
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_view_group_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_groups_command_view_group_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Groups/Commands/ViewGroup";

  std::string payload =
    get_json_payload_for_groups_view_group_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ViewGroupResponse command for
 * the Groups cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/Commands/ViewGroupResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_view_group_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_groups_command_view_group_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Groups/Commands/ViewGroupResponse";


  std::string payload =
    get_json_payload_for_groups_view_group_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ViewGroupResponse command for
 * the Groups cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Groups/Commands/ViewGroupResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_view_group_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_groups_command_view_group_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Groups/Commands/ViewGroupResponse";

  std::string payload =
    get_json_payload_for_groups_view_group_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetGroupMembership command for
 * the Groups cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/Commands/GetGroupMembership
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_get_group_membership_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_groups_command_get_group_membership_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Groups/Commands/GetGroupMembership";


  std::string payload =
    get_json_payload_for_groups_get_group_membership_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetGroupMembership command for
 * the Groups cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Groups/Commands/GetGroupMembership
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_get_group_membership_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_groups_command_get_group_membership_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Groups/Commands/GetGroupMembership";

  std::string payload =
    get_json_payload_for_groups_get_group_membership_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetGroupMembershipResponse command for
 * the Groups cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/Commands/GetGroupMembershipResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_get_group_membership_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_groups_command_get_group_membership_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Groups/Commands/GetGroupMembershipResponse";


  std::string payload =
    get_json_payload_for_groups_get_group_membership_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetGroupMembershipResponse command for
 * the Groups cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Groups/Commands/GetGroupMembershipResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_get_group_membership_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_groups_command_get_group_membership_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Groups/Commands/GetGroupMembershipResponse";

  std::string payload =
    get_json_payload_for_groups_get_group_membership_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a RemoveGroup command for
 * the Groups cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/Commands/RemoveGroup
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_remove_group_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_groups_command_remove_group_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Groups/Commands/RemoveGroup";


  std::string payload =
    get_json_payload_for_groups_remove_group_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a RemoveGroup command for
 * the Groups cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Groups/Commands/RemoveGroup
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_remove_group_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_groups_command_remove_group_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Groups/Commands/RemoveGroup";

  std::string payload =
    get_json_payload_for_groups_remove_group_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a RemoveGroupResponse command for
 * the Groups cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/Commands/RemoveGroupResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_remove_group_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_groups_command_remove_group_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Groups/Commands/RemoveGroupResponse";


  std::string payload =
    get_json_payload_for_groups_remove_group_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a RemoveGroupResponse command for
 * the Groups cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Groups/Commands/RemoveGroupResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_remove_group_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_groups_command_remove_group_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Groups/Commands/RemoveGroupResponse";

  std::string payload =
    get_json_payload_for_groups_remove_group_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a RemoveAllGroups command for
 * the Groups cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/Commands/RemoveAllGroups
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 */
void uic_mqtt_dotdot_groups_publish_remove_all_groups_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Groups/Commands/RemoveAllGroups";


  std::string payload =
    get_json_payload_for_groups_remove_all_groups_command(
    );

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a RemoveAllGroups command for
 * the Groups cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Groups/Commands/RemoveAllGroups
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 */
void uic_mqtt_dotdot_groups_publish_remove_all_groups_command_to_group(
  uint16_t destination_group_id
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Groups/Commands/RemoveAllGroups";

  std::string payload =
    get_json_payload_for_groups_remove_all_groups_command(
    );

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a AddGroupIfIdentifying command for
 * the Groups cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/Commands/AddGroupIfIdentifying
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_add_group_if_identifying_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_groups_command_add_group_if_identifying_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Groups/Commands/AddGroupIfIdentifying";


  std::string payload =
    get_json_payload_for_groups_add_group_if_identifying_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a AddGroupIfIdentifying command for
 * the Groups cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Groups/Commands/AddGroupIfIdentifying
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_add_group_if_identifying_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_groups_command_add_group_if_identifying_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Groups/Commands/AddGroupIfIdentifying";

  std::string payload =
    get_json_payload_for_groups_add_group_if_identifying_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a AddScene command for
 * the Scenes cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/Commands/AddScene
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_add_scene_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_scenes_command_add_scene_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Scenes/Commands/AddScene";


  std::string payload =
    get_json_payload_for_scenes_add_scene_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a AddScene command for
 * the Scenes cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Scenes/Commands/AddScene
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_add_scene_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_scenes_command_add_scene_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Scenes/Commands/AddScene";

  std::string payload =
    get_json_payload_for_scenes_add_scene_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a AddSceneResponse command for
 * the Scenes cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/Commands/AddSceneResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_add_scene_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_scenes_command_add_scene_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Scenes/Commands/AddSceneResponse";


  std::string payload =
    get_json_payload_for_scenes_add_scene_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a AddSceneResponse command for
 * the Scenes cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Scenes/Commands/AddSceneResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_add_scene_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_scenes_command_add_scene_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Scenes/Commands/AddSceneResponse";

  std::string payload =
    get_json_payload_for_scenes_add_scene_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ViewScene command for
 * the Scenes cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/Commands/ViewScene
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_view_scene_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_scenes_command_view_scene_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Scenes/Commands/ViewScene";


  std::string payload =
    get_json_payload_for_scenes_view_scene_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ViewScene command for
 * the Scenes cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Scenes/Commands/ViewScene
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_view_scene_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_scenes_command_view_scene_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Scenes/Commands/ViewScene";

  std::string payload =
    get_json_payload_for_scenes_view_scene_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ViewSceneResponse command for
 * the Scenes cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/Commands/ViewSceneResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_view_scene_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_scenes_command_view_scene_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Scenes/Commands/ViewSceneResponse";


  std::string payload =
    get_json_payload_for_scenes_view_scene_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ViewSceneResponse command for
 * the Scenes cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Scenes/Commands/ViewSceneResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_view_scene_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_scenes_command_view_scene_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Scenes/Commands/ViewSceneResponse";

  std::string payload =
    get_json_payload_for_scenes_view_scene_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a RemoveScene command for
 * the Scenes cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/Commands/RemoveScene
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_remove_scene_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_scenes_command_remove_scene_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Scenes/Commands/RemoveScene";


  std::string payload =
    get_json_payload_for_scenes_remove_scene_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a RemoveScene command for
 * the Scenes cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Scenes/Commands/RemoveScene
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_remove_scene_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_scenes_command_remove_scene_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Scenes/Commands/RemoveScene";

  std::string payload =
    get_json_payload_for_scenes_remove_scene_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a RemoveSceneResponse command for
 * the Scenes cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/Commands/RemoveSceneResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_remove_scene_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_scenes_command_remove_scene_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Scenes/Commands/RemoveSceneResponse";


  std::string payload =
    get_json_payload_for_scenes_remove_scene_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a RemoveSceneResponse command for
 * the Scenes cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Scenes/Commands/RemoveSceneResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_remove_scene_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_scenes_command_remove_scene_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Scenes/Commands/RemoveSceneResponse";

  std::string payload =
    get_json_payload_for_scenes_remove_scene_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a RemoveAllScenes command for
 * the Scenes cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/Commands/RemoveAllScenes
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_remove_all_scenes_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_scenes_command_remove_all_scenes_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Scenes/Commands/RemoveAllScenes";


  std::string payload =
    get_json_payload_for_scenes_remove_all_scenes_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a RemoveAllScenes command for
 * the Scenes cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Scenes/Commands/RemoveAllScenes
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_remove_all_scenes_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_scenes_command_remove_all_scenes_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Scenes/Commands/RemoveAllScenes";

  std::string payload =
    get_json_payload_for_scenes_remove_all_scenes_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a RemoveAllScenesResponse command for
 * the Scenes cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/Commands/RemoveAllScenesResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_remove_all_scenes_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_scenes_command_remove_all_scenes_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Scenes/Commands/RemoveAllScenesResponse";


  std::string payload =
    get_json_payload_for_scenes_remove_all_scenes_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a RemoveAllScenesResponse command for
 * the Scenes cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Scenes/Commands/RemoveAllScenesResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_remove_all_scenes_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_scenes_command_remove_all_scenes_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Scenes/Commands/RemoveAllScenesResponse";

  std::string payload =
    get_json_payload_for_scenes_remove_all_scenes_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a StoreScene command for
 * the Scenes cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/Commands/StoreScene
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_store_scene_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_scenes_command_store_scene_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Scenes/Commands/StoreScene";


  std::string payload =
    get_json_payload_for_scenes_store_scene_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a StoreScene command for
 * the Scenes cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Scenes/Commands/StoreScene
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_store_scene_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_scenes_command_store_scene_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Scenes/Commands/StoreScene";

  std::string payload =
    get_json_payload_for_scenes_store_scene_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a StoreSceneResponse command for
 * the Scenes cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/Commands/StoreSceneResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_store_scene_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_scenes_command_store_scene_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Scenes/Commands/StoreSceneResponse";


  std::string payload =
    get_json_payload_for_scenes_store_scene_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a StoreSceneResponse command for
 * the Scenes cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Scenes/Commands/StoreSceneResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_store_scene_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_scenes_command_store_scene_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Scenes/Commands/StoreSceneResponse";

  std::string payload =
    get_json_payload_for_scenes_store_scene_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a RecallScene command for
 * the Scenes cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/Commands/RecallScene
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_recall_scene_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_scenes_command_recall_scene_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Scenes/Commands/RecallScene";


  std::string payload =
    get_json_payload_for_scenes_recall_scene_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a RecallScene command for
 * the Scenes cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Scenes/Commands/RecallScene
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_recall_scene_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_scenes_command_recall_scene_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Scenes/Commands/RecallScene";

  std::string payload =
    get_json_payload_for_scenes_recall_scene_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetSceneMembership command for
 * the Scenes cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/Commands/GetSceneMembership
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_get_scene_membership_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_scenes_command_get_scene_membership_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Scenes/Commands/GetSceneMembership";


  std::string payload =
    get_json_payload_for_scenes_get_scene_membership_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetSceneMembership command for
 * the Scenes cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Scenes/Commands/GetSceneMembership
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_get_scene_membership_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_scenes_command_get_scene_membership_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Scenes/Commands/GetSceneMembership";

  std::string payload =
    get_json_payload_for_scenes_get_scene_membership_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetSceneMembershipResponse command for
 * the Scenes cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/Commands/GetSceneMembershipResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_get_scene_membership_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_scenes_command_get_scene_membership_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Scenes/Commands/GetSceneMembershipResponse";


  std::string payload =
    get_json_payload_for_scenes_get_scene_membership_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetSceneMembershipResponse command for
 * the Scenes cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Scenes/Commands/GetSceneMembershipResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_get_scene_membership_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_scenes_command_get_scene_membership_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Scenes/Commands/GetSceneMembershipResponse";

  std::string payload =
    get_json_payload_for_scenes_get_scene_membership_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a EnhancedAddScene command for
 * the Scenes cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/Commands/EnhancedAddScene
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_enhanced_add_scene_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_scenes_command_enhanced_add_scene_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Scenes/Commands/EnhancedAddScene";


  std::string payload =
    get_json_payload_for_scenes_enhanced_add_scene_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a EnhancedAddScene command for
 * the Scenes cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Scenes/Commands/EnhancedAddScene
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_enhanced_add_scene_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_scenes_command_enhanced_add_scene_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Scenes/Commands/EnhancedAddScene";

  std::string payload =
    get_json_payload_for_scenes_enhanced_add_scene_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a EnhancedAddSceneResponse command for
 * the Scenes cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/Commands/EnhancedAddSceneResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_enhanced_add_scene_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_scenes_command_enhanced_add_scene_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Scenes/Commands/EnhancedAddSceneResponse";


  std::string payload =
    get_json_payload_for_scenes_enhanced_add_scene_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a EnhancedAddSceneResponse command for
 * the Scenes cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Scenes/Commands/EnhancedAddSceneResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_enhanced_add_scene_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_scenes_command_enhanced_add_scene_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Scenes/Commands/EnhancedAddSceneResponse";

  std::string payload =
    get_json_payload_for_scenes_enhanced_add_scene_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a EnhancedViewScene command for
 * the Scenes cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/Commands/EnhancedViewScene
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_enhanced_view_scene_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_scenes_command_enhanced_view_scene_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Scenes/Commands/EnhancedViewScene";


  std::string payload =
    get_json_payload_for_scenes_enhanced_view_scene_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a EnhancedViewScene command for
 * the Scenes cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Scenes/Commands/EnhancedViewScene
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_enhanced_view_scene_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_scenes_command_enhanced_view_scene_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Scenes/Commands/EnhancedViewScene";

  std::string payload =
    get_json_payload_for_scenes_enhanced_view_scene_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a EnhancedViewSceneResponse command for
 * the Scenes cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/Commands/EnhancedViewSceneResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_enhanced_view_scene_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_scenes_command_enhanced_view_scene_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Scenes/Commands/EnhancedViewSceneResponse";


  std::string payload =
    get_json_payload_for_scenes_enhanced_view_scene_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a EnhancedViewSceneResponse command for
 * the Scenes cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Scenes/Commands/EnhancedViewSceneResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_enhanced_view_scene_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_scenes_command_enhanced_view_scene_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Scenes/Commands/EnhancedViewSceneResponse";

  std::string payload =
    get_json_payload_for_scenes_enhanced_view_scene_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a CopyScene command for
 * the Scenes cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/Commands/CopyScene
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_copy_scene_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_scenes_command_copy_scene_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Scenes/Commands/CopyScene";


  std::string payload =
    get_json_payload_for_scenes_copy_scene_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a CopyScene command for
 * the Scenes cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Scenes/Commands/CopyScene
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_copy_scene_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_scenes_command_copy_scene_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Scenes/Commands/CopyScene";

  std::string payload =
    get_json_payload_for_scenes_copy_scene_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a CopySceneResponse command for
 * the Scenes cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/Commands/CopySceneResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_copy_scene_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_scenes_command_copy_scene_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Scenes/Commands/CopySceneResponse";


  std::string payload =
    get_json_payload_for_scenes_copy_scene_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a CopySceneResponse command for
 * the Scenes cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Scenes/Commands/CopySceneResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_copy_scene_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_scenes_command_copy_scene_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Scenes/Commands/CopySceneResponse";

  std::string payload =
    get_json_payload_for_scenes_copy_scene_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a Off command for
 * the OnOff cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OnOff/Commands/Off
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 */
void uic_mqtt_dotdot_on_off_publish_off_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "OnOff/Commands/Off";


  std::string payload =
    get_json_payload_for_on_off_off_command(
    );

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a Off command for
 * the OnOff cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/OnOff/Commands/Off
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 */
void uic_mqtt_dotdot_on_off_publish_off_command_to_group(
  uint16_t destination_group_id
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/OnOff/Commands/Off";

  std::string payload =
    get_json_payload_for_on_off_off_command(
    );

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a On command for
 * the OnOff cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OnOff/Commands/On
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 */
void uic_mqtt_dotdot_on_off_publish_on_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "OnOff/Commands/On";


  std::string payload =
    get_json_payload_for_on_off_on_command(
    );

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a On command for
 * the OnOff cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/OnOff/Commands/On
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 */
void uic_mqtt_dotdot_on_off_publish_on_command_to_group(
  uint16_t destination_group_id
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/OnOff/Commands/On";

  std::string payload =
    get_json_payload_for_on_off_on_command(
    );

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a Toggle command for
 * the OnOff cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OnOff/Commands/Toggle
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 */
void uic_mqtt_dotdot_on_off_publish_toggle_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "OnOff/Commands/Toggle";


  std::string payload =
    get_json_payload_for_on_off_toggle_command(
    );

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a Toggle command for
 * the OnOff cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/OnOff/Commands/Toggle
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 */
void uic_mqtt_dotdot_on_off_publish_toggle_command_to_group(
  uint16_t destination_group_id
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/OnOff/Commands/Toggle";

  std::string payload =
    get_json_payload_for_on_off_toggle_command(
    );

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a OffWithEffect command for
 * the OnOff cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OnOff/Commands/OffWithEffect
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_on_off_publish_off_with_effect_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_on_off_command_off_with_effect_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "OnOff/Commands/OffWithEffect";


  std::string payload =
    get_json_payload_for_on_off_off_with_effect_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a OffWithEffect command for
 * the OnOff cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/OnOff/Commands/OffWithEffect
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_on_off_publish_off_with_effect_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_on_off_command_off_with_effect_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/OnOff/Commands/OffWithEffect";

  std::string payload =
    get_json_payload_for_on_off_off_with_effect_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a OnWithRecallGlobalScene command for
 * the OnOff cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OnOff/Commands/OnWithRecallGlobalScene
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 */
void uic_mqtt_dotdot_on_off_publish_on_with_recall_global_scene_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "OnOff/Commands/OnWithRecallGlobalScene";


  std::string payload =
    get_json_payload_for_on_off_on_with_recall_global_scene_command(
    );

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a OnWithRecallGlobalScene command for
 * the OnOff cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/OnOff/Commands/OnWithRecallGlobalScene
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 */
void uic_mqtt_dotdot_on_off_publish_on_with_recall_global_scene_command_to_group(
  uint16_t destination_group_id
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/OnOff/Commands/OnWithRecallGlobalScene";

  std::string payload =
    get_json_payload_for_on_off_on_with_recall_global_scene_command(
    );

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a OnWithTimedOff command for
 * the OnOff cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OnOff/Commands/OnWithTimedOff
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_on_off_publish_on_with_timed_off_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_on_off_command_on_with_timed_off_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "OnOff/Commands/OnWithTimedOff";


  std::string payload =
    get_json_payload_for_on_off_on_with_timed_off_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a OnWithTimedOff command for
 * the OnOff cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/OnOff/Commands/OnWithTimedOff
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_on_off_publish_on_with_timed_off_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_on_off_command_on_with_timed_off_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/OnOff/Commands/OnWithTimedOff";

  std::string payload =
    get_json_payload_for_on_off_on_with_timed_off_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a MoveToLevel command for
 * the Level cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/Commands/MoveToLevel
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_move_to_level_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_level_command_move_to_level_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Level/Commands/MoveToLevel";


  std::string payload =
    get_json_payload_for_level_move_to_level_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a MoveToLevel command for
 * the Level cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Level/Commands/MoveToLevel
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_move_to_level_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_level_command_move_to_level_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Level/Commands/MoveToLevel";

  std::string payload =
    get_json_payload_for_level_move_to_level_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a Move command for
 * the Level cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/Commands/Move
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_move_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_level_command_move_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Level/Commands/Move";


  std::string payload =
    get_json_payload_for_level_move_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a Move command for
 * the Level cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Level/Commands/Move
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_move_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_level_command_move_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Level/Commands/Move";

  std::string payload =
    get_json_payload_for_level_move_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a Step command for
 * the Level cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/Commands/Step
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_step_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_level_command_step_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Level/Commands/Step";


  std::string payload =
    get_json_payload_for_level_step_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a Step command for
 * the Level cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Level/Commands/Step
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_step_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_level_command_step_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Level/Commands/Step";

  std::string payload =
    get_json_payload_for_level_step_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a Stop command for
 * the Level cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/Commands/Stop
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_stop_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_level_command_stop_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Level/Commands/Stop";


  std::string payload =
    get_json_payload_for_level_stop_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a Stop command for
 * the Level cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Level/Commands/Stop
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_stop_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_level_command_stop_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Level/Commands/Stop";

  std::string payload =
    get_json_payload_for_level_stop_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a MoveToLevelWithOnOff command for
 * the Level cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/Commands/MoveToLevelWithOnOff
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_move_to_level_with_on_off_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_level_command_move_to_level_with_on_off_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Level/Commands/MoveToLevelWithOnOff";


  std::string payload =
    get_json_payload_for_level_move_to_level_with_on_off_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a MoveToLevelWithOnOff command for
 * the Level cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Level/Commands/MoveToLevelWithOnOff
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_move_to_level_with_on_off_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_level_command_move_to_level_with_on_off_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Level/Commands/MoveToLevelWithOnOff";

  std::string payload =
    get_json_payload_for_level_move_to_level_with_on_off_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a MoveWithOnOff command for
 * the Level cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/Commands/MoveWithOnOff
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_move_with_on_off_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_level_command_move_with_on_off_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Level/Commands/MoveWithOnOff";


  std::string payload =
    get_json_payload_for_level_move_with_on_off_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a MoveWithOnOff command for
 * the Level cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Level/Commands/MoveWithOnOff
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_move_with_on_off_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_level_command_move_with_on_off_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Level/Commands/MoveWithOnOff";

  std::string payload =
    get_json_payload_for_level_move_with_on_off_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a StepWithOnOff command for
 * the Level cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/Commands/StepWithOnOff
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_step_with_on_off_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_level_command_step_with_on_off_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Level/Commands/StepWithOnOff";


  std::string payload =
    get_json_payload_for_level_step_with_on_off_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a StepWithOnOff command for
 * the Level cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Level/Commands/StepWithOnOff
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_step_with_on_off_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_level_command_step_with_on_off_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Level/Commands/StepWithOnOff";

  std::string payload =
    get_json_payload_for_level_step_with_on_off_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a StopWithOnOff command for
 * the Level cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/Commands/StopWithOnOff
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_stop_with_on_off_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_level_command_stop_with_on_off_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Level/Commands/StopWithOnOff";


  std::string payload =
    get_json_payload_for_level_stop_with_on_off_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a StopWithOnOff command for
 * the Level cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Level/Commands/StopWithOnOff
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_stop_with_on_off_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_level_command_stop_with_on_off_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Level/Commands/StopWithOnOff";

  std::string payload =
    get_json_payload_for_level_stop_with_on_off_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a MoveToClosestFrequency command for
 * the Level cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/Commands/MoveToClosestFrequency
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_move_to_closest_frequency_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_level_command_move_to_closest_frequency_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Level/Commands/MoveToClosestFrequency";


  std::string payload =
    get_json_payload_for_level_move_to_closest_frequency_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a MoveToClosestFrequency command for
 * the Level cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Level/Commands/MoveToClosestFrequency
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_move_to_closest_frequency_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_level_command_move_to_closest_frequency_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Level/Commands/MoveToClosestFrequency";

  std::string payload =
    get_json_payload_for_level_move_to_closest_frequency_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ResetAlarm command for
 * the Alarms cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Alarms/Commands/ResetAlarm
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_alarms_publish_reset_alarm_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_alarms_command_reset_alarm_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Alarms/Commands/ResetAlarm";


  std::string payload =
    get_json_payload_for_alarms_reset_alarm_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ResetAlarm command for
 * the Alarms cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Alarms/Commands/ResetAlarm
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_alarms_publish_reset_alarm_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_alarms_command_reset_alarm_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Alarms/Commands/ResetAlarm";

  std::string payload =
    get_json_payload_for_alarms_reset_alarm_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a Alarm command for
 * the Alarms cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Alarms/Commands/Alarm
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_alarms_publish_alarm_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_alarms_command_alarm_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Alarms/Commands/Alarm";


  std::string payload =
    get_json_payload_for_alarms_alarm_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a Alarm command for
 * the Alarms cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Alarms/Commands/Alarm
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_alarms_publish_alarm_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_alarms_command_alarm_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Alarms/Commands/Alarm";

  std::string payload =
    get_json_payload_for_alarms_alarm_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ResetAllAlarms command for
 * the Alarms cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Alarms/Commands/ResetAllAlarms
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 */
void uic_mqtt_dotdot_alarms_publish_reset_all_alarms_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Alarms/Commands/ResetAllAlarms";


  std::string payload =
    get_json_payload_for_alarms_reset_all_alarms_command(
    );

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ResetAllAlarms command for
 * the Alarms cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Alarms/Commands/ResetAllAlarms
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 */
void uic_mqtt_dotdot_alarms_publish_reset_all_alarms_command_to_group(
  uint16_t destination_group_id
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Alarms/Commands/ResetAllAlarms";

  std::string payload =
    get_json_payload_for_alarms_reset_all_alarms_command(
    );

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetAlarmResponse command for
 * the Alarms cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Alarms/Commands/GetAlarmResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_alarms_publish_get_alarm_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_alarms_command_get_alarm_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Alarms/Commands/GetAlarmResponse";


  std::string payload =
    get_json_payload_for_alarms_get_alarm_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetAlarmResponse command for
 * the Alarms cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Alarms/Commands/GetAlarmResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_alarms_publish_get_alarm_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_alarms_command_get_alarm_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Alarms/Commands/GetAlarmResponse";

  std::string payload =
    get_json_payload_for_alarms_get_alarm_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetAlarm command for
 * the Alarms cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Alarms/Commands/GetAlarm
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 */
void uic_mqtt_dotdot_alarms_publish_get_alarm_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Alarms/Commands/GetAlarm";


  std::string payload =
    get_json_payload_for_alarms_get_alarm_command(
    );

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetAlarm command for
 * the Alarms cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Alarms/Commands/GetAlarm
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 */
void uic_mqtt_dotdot_alarms_publish_get_alarm_command_to_group(
  uint16_t destination_group_id
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Alarms/Commands/GetAlarm";

  std::string payload =
    get_json_payload_for_alarms_get_alarm_command(
    );

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ResetAlarmLog command for
 * the Alarms cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Alarms/Commands/ResetAlarmLog
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 */
void uic_mqtt_dotdot_alarms_publish_reset_alarm_log_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Alarms/Commands/ResetAlarmLog";


  std::string payload =
    get_json_payload_for_alarms_reset_alarm_log_command(
    );

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ResetAlarmLog command for
 * the Alarms cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Alarms/Commands/ResetAlarmLog
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 */
void uic_mqtt_dotdot_alarms_publish_reset_alarm_log_command_to_group(
  uint16_t destination_group_id
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Alarms/Commands/ResetAlarmLog";

  std::string payload =
    get_json_payload_for_alarms_reset_alarm_log_command(
    );

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ImageNotify command for
 * the OTAUpgrade cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OTAUpgrade/Commands/ImageNotify
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ota_upgrade_publish_image_notify_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_ota_upgrade_command_image_notify_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "OTAUpgrade/Commands/ImageNotify";


  std::string payload =
    get_json_payload_for_ota_upgrade_image_notify_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ImageNotify command for
 * the OTAUpgrade cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/OTAUpgrade/Commands/ImageNotify
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ota_upgrade_publish_image_notify_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_ota_upgrade_command_image_notify_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/OTAUpgrade/Commands/ImageNotify";

  std::string payload =
    get_json_payload_for_ota_upgrade_image_notify_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a QueryNextImageRequest command for
 * the OTAUpgrade cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OTAUpgrade/Commands/QueryNextImageRequest
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ota_upgrade_publish_query_next_image_request_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_ota_upgrade_command_query_next_image_request_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "OTAUpgrade/Commands/QueryNextImageRequest";


  std::string payload =
    get_json_payload_for_ota_upgrade_query_next_image_request_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a QueryNextImageRequest command for
 * the OTAUpgrade cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/OTAUpgrade/Commands/QueryNextImageRequest
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ota_upgrade_publish_query_next_image_request_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_ota_upgrade_command_query_next_image_request_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/OTAUpgrade/Commands/QueryNextImageRequest";

  std::string payload =
    get_json_payload_for_ota_upgrade_query_next_image_request_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a QueryNextImageResponse command for
 * the OTAUpgrade cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OTAUpgrade/Commands/QueryNextImageResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ota_upgrade_publish_query_next_image_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_ota_upgrade_command_query_next_image_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "OTAUpgrade/Commands/QueryNextImageResponse";


  std::string payload =
    get_json_payload_for_ota_upgrade_query_next_image_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a QueryNextImageResponse command for
 * the OTAUpgrade cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/OTAUpgrade/Commands/QueryNextImageResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ota_upgrade_publish_query_next_image_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_ota_upgrade_command_query_next_image_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/OTAUpgrade/Commands/QueryNextImageResponse";

  std::string payload =
    get_json_payload_for_ota_upgrade_query_next_image_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ImageBlockRequest command for
 * the OTAUpgrade cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OTAUpgrade/Commands/ImageBlockRequest
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ota_upgrade_publish_image_block_request_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_ota_upgrade_command_image_block_request_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "OTAUpgrade/Commands/ImageBlockRequest";


  std::string payload =
    get_json_payload_for_ota_upgrade_image_block_request_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ImageBlockRequest command for
 * the OTAUpgrade cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/OTAUpgrade/Commands/ImageBlockRequest
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ota_upgrade_publish_image_block_request_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_ota_upgrade_command_image_block_request_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/OTAUpgrade/Commands/ImageBlockRequest";

  std::string payload =
    get_json_payload_for_ota_upgrade_image_block_request_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ImagePageRequest command for
 * the OTAUpgrade cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OTAUpgrade/Commands/ImagePageRequest
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ota_upgrade_publish_image_page_request_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_ota_upgrade_command_image_page_request_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "OTAUpgrade/Commands/ImagePageRequest";


  std::string payload =
    get_json_payload_for_ota_upgrade_image_page_request_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ImagePageRequest command for
 * the OTAUpgrade cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/OTAUpgrade/Commands/ImagePageRequest
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ota_upgrade_publish_image_page_request_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_ota_upgrade_command_image_page_request_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/OTAUpgrade/Commands/ImagePageRequest";

  std::string payload =
    get_json_payload_for_ota_upgrade_image_page_request_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ImageBlockResponse command for
 * the OTAUpgrade cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OTAUpgrade/Commands/ImageBlockResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ota_upgrade_publish_image_block_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_ota_upgrade_command_image_block_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "OTAUpgrade/Commands/ImageBlockResponse";


  std::string payload =
    get_json_payload_for_ota_upgrade_image_block_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ImageBlockResponse command for
 * the OTAUpgrade cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/OTAUpgrade/Commands/ImageBlockResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ota_upgrade_publish_image_block_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_ota_upgrade_command_image_block_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/OTAUpgrade/Commands/ImageBlockResponse";

  std::string payload =
    get_json_payload_for_ota_upgrade_image_block_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a UpgradeEndRequest command for
 * the OTAUpgrade cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OTAUpgrade/Commands/UpgradeEndRequest
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ota_upgrade_publish_upgrade_end_request_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_ota_upgrade_command_upgrade_end_request_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "OTAUpgrade/Commands/UpgradeEndRequest";


  std::string payload =
    get_json_payload_for_ota_upgrade_upgrade_end_request_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a UpgradeEndRequest command for
 * the OTAUpgrade cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/OTAUpgrade/Commands/UpgradeEndRequest
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ota_upgrade_publish_upgrade_end_request_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_ota_upgrade_command_upgrade_end_request_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/OTAUpgrade/Commands/UpgradeEndRequest";

  std::string payload =
    get_json_payload_for_ota_upgrade_upgrade_end_request_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a UpgradeEndResponse command for
 * the OTAUpgrade cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OTAUpgrade/Commands/UpgradeEndResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ota_upgrade_publish_upgrade_end_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_ota_upgrade_command_upgrade_end_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "OTAUpgrade/Commands/UpgradeEndResponse";


  std::string payload =
    get_json_payload_for_ota_upgrade_upgrade_end_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a UpgradeEndResponse command for
 * the OTAUpgrade cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/OTAUpgrade/Commands/UpgradeEndResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ota_upgrade_publish_upgrade_end_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_ota_upgrade_command_upgrade_end_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/OTAUpgrade/Commands/UpgradeEndResponse";

  std::string payload =
    get_json_payload_for_ota_upgrade_upgrade_end_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a QueryDeviceSpecificFileRequest command for
 * the OTAUpgrade cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OTAUpgrade/Commands/QueryDeviceSpecificFileRequest
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ota_upgrade_publish_query_device_specific_file_request_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_ota_upgrade_command_query_device_specific_file_request_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "OTAUpgrade/Commands/QueryDeviceSpecificFileRequest";


  std::string payload =
    get_json_payload_for_ota_upgrade_query_device_specific_file_request_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a QueryDeviceSpecificFileRequest command for
 * the OTAUpgrade cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/OTAUpgrade/Commands/QueryDeviceSpecificFileRequest
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ota_upgrade_publish_query_device_specific_file_request_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_ota_upgrade_command_query_device_specific_file_request_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/OTAUpgrade/Commands/QueryDeviceSpecificFileRequest";

  std::string payload =
    get_json_payload_for_ota_upgrade_query_device_specific_file_request_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a QueryDeviceSpecificFileResponse command for
 * the OTAUpgrade cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OTAUpgrade/Commands/QueryDeviceSpecificFileResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ota_upgrade_publish_query_device_specific_file_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_ota_upgrade_command_query_device_specific_file_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "OTAUpgrade/Commands/QueryDeviceSpecificFileResponse";


  std::string payload =
    get_json_payload_for_ota_upgrade_query_device_specific_file_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a QueryDeviceSpecificFileResponse command for
 * the OTAUpgrade cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/OTAUpgrade/Commands/QueryDeviceSpecificFileResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ota_upgrade_publish_query_device_specific_file_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_ota_upgrade_command_query_device_specific_file_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/OTAUpgrade/Commands/QueryDeviceSpecificFileResponse";

  std::string payload =
    get_json_payload_for_ota_upgrade_query_device_specific_file_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a CheckIn command for
 * the PollControl cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/PollControl/Commands/CheckIn
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 */
void uic_mqtt_dotdot_poll_control_publish_check_in_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "PollControl/Commands/CheckIn";


  std::string payload =
    get_json_payload_for_poll_control_check_in_command(
    );

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a CheckIn command for
 * the PollControl cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/PollControl/Commands/CheckIn
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 */
void uic_mqtt_dotdot_poll_control_publish_check_in_command_to_group(
  uint16_t destination_group_id
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/PollControl/Commands/CheckIn";

  std::string payload =
    get_json_payload_for_poll_control_check_in_command(
    );

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a CheckInResponse command for
 * the PollControl cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/PollControl/Commands/CheckInResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_poll_control_publish_check_in_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_poll_control_command_check_in_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "PollControl/Commands/CheckInResponse";


  std::string payload =
    get_json_payload_for_poll_control_check_in_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a CheckInResponse command for
 * the PollControl cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/PollControl/Commands/CheckInResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_poll_control_publish_check_in_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_poll_control_command_check_in_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/PollControl/Commands/CheckInResponse";

  std::string payload =
    get_json_payload_for_poll_control_check_in_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a FastPollStop command for
 * the PollControl cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/PollControl/Commands/FastPollStop
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 */
void uic_mqtt_dotdot_poll_control_publish_fast_poll_stop_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "PollControl/Commands/FastPollStop";


  std::string payload =
    get_json_payload_for_poll_control_fast_poll_stop_command(
    );

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a FastPollStop command for
 * the PollControl cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/PollControl/Commands/FastPollStop
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 */
void uic_mqtt_dotdot_poll_control_publish_fast_poll_stop_command_to_group(
  uint16_t destination_group_id
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/PollControl/Commands/FastPollStop";

  std::string payload =
    get_json_payload_for_poll_control_fast_poll_stop_command(
    );

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetLongPollInterval command for
 * the PollControl cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/PollControl/Commands/SetLongPollInterval
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_poll_control_publish_set_long_poll_interval_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_poll_control_command_set_long_poll_interval_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "PollControl/Commands/SetLongPollInterval";


  std::string payload =
    get_json_payload_for_poll_control_set_long_poll_interval_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetLongPollInterval command for
 * the PollControl cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/PollControl/Commands/SetLongPollInterval
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_poll_control_publish_set_long_poll_interval_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_poll_control_command_set_long_poll_interval_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/PollControl/Commands/SetLongPollInterval";

  std::string payload =
    get_json_payload_for_poll_control_set_long_poll_interval_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetShortPollInterval command for
 * the PollControl cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/PollControl/Commands/SetShortPollInterval
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_poll_control_publish_set_short_poll_interval_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_poll_control_command_set_short_poll_interval_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "PollControl/Commands/SetShortPollInterval";


  std::string payload =
    get_json_payload_for_poll_control_set_short_poll_interval_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetShortPollInterval command for
 * the PollControl cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/PollControl/Commands/SetShortPollInterval
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_poll_control_publish_set_short_poll_interval_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_poll_control_command_set_short_poll_interval_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/PollControl/Commands/SetShortPollInterval";

  std::string payload =
    get_json_payload_for_poll_control_set_short_poll_interval_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a LockDoor command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/LockDoor
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_lock_door_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_lock_door_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/LockDoor";


  std::string payload =
    get_json_payload_for_door_lock_lock_door_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a LockDoor command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/LockDoor
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_lock_door_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_lock_door_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/LockDoor";

  std::string payload =
    get_json_payload_for_door_lock_lock_door_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a LockDoorResponse command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/LockDoorResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_lock_door_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_lock_door_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/LockDoorResponse";


  std::string payload =
    get_json_payload_for_door_lock_lock_door_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a LockDoorResponse command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/LockDoorResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_lock_door_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_lock_door_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/LockDoorResponse";

  std::string payload =
    get_json_payload_for_door_lock_lock_door_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a UnlockDoor command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/UnlockDoor
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_unlock_door_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_unlock_door_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/UnlockDoor";


  std::string payload =
    get_json_payload_for_door_lock_unlock_door_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a UnlockDoor command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/UnlockDoor
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_unlock_door_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_unlock_door_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/UnlockDoor";

  std::string payload =
    get_json_payload_for_door_lock_unlock_door_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a UnlockDoorResponse command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/UnlockDoorResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_unlock_door_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_unlock_door_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/UnlockDoorResponse";


  std::string payload =
    get_json_payload_for_door_lock_unlock_door_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a UnlockDoorResponse command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/UnlockDoorResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_unlock_door_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_unlock_door_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/UnlockDoorResponse";

  std::string payload =
    get_json_payload_for_door_lock_unlock_door_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a Toggle command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/Toggle
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_toggle_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_toggle_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/Toggle";


  std::string payload =
    get_json_payload_for_door_lock_toggle_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a Toggle command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/Toggle
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_toggle_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_toggle_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/Toggle";

  std::string payload =
    get_json_payload_for_door_lock_toggle_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ToggleResponse command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/ToggleResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_toggle_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_toggle_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/ToggleResponse";


  std::string payload =
    get_json_payload_for_door_lock_toggle_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ToggleResponse command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/ToggleResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_toggle_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_toggle_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/ToggleResponse";

  std::string payload =
    get_json_payload_for_door_lock_toggle_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a UnlockWithTimeout command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/UnlockWithTimeout
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_unlock_with_timeout_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_unlock_with_timeout_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/UnlockWithTimeout";


  std::string payload =
    get_json_payload_for_door_lock_unlock_with_timeout_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a UnlockWithTimeout command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/UnlockWithTimeout
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_unlock_with_timeout_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_unlock_with_timeout_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/UnlockWithTimeout";

  std::string payload =
    get_json_payload_for_door_lock_unlock_with_timeout_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a UnlockWithTimeoutResponse command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/UnlockWithTimeoutResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_unlock_with_timeout_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_unlock_with_timeout_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/UnlockWithTimeoutResponse";


  std::string payload =
    get_json_payload_for_door_lock_unlock_with_timeout_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a UnlockWithTimeoutResponse command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/UnlockWithTimeoutResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_unlock_with_timeout_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_unlock_with_timeout_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/UnlockWithTimeoutResponse";

  std::string payload =
    get_json_payload_for_door_lock_unlock_with_timeout_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetLogRecord command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/GetLogRecord
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_get_log_record_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_log_record_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/GetLogRecord";


  std::string payload =
    get_json_payload_for_door_lock_get_log_record_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetLogRecord command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/GetLogRecord
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_get_log_record_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_get_log_record_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/GetLogRecord";

  std::string payload =
    get_json_payload_for_door_lock_get_log_record_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetLogRecordResponse command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/GetLogRecordResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_get_log_record_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_log_record_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/GetLogRecordResponse";


  std::string payload =
    get_json_payload_for_door_lock_get_log_record_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetLogRecordResponse command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/GetLogRecordResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_get_log_record_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_get_log_record_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/GetLogRecordResponse";

  std::string payload =
    get_json_payload_for_door_lock_get_log_record_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetPINCode command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/SetPINCode
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_setpin_code_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_setpin_code_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/SetPINCode";


  std::string payload =
    get_json_payload_for_door_lock_setpin_code_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetPINCode command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/SetPINCode
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_setpin_code_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_setpin_code_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/SetPINCode";

  std::string payload =
    get_json_payload_for_door_lock_setpin_code_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetPINCodeResponse command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/SetPINCodeResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_setpin_code_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_setpin_code_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/SetPINCodeResponse";


  std::string payload =
    get_json_payload_for_door_lock_setpin_code_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetPINCodeResponse command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/SetPINCodeResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_setpin_code_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_setpin_code_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/SetPINCodeResponse";

  std::string payload =
    get_json_payload_for_door_lock_setpin_code_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetPINCode command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/GetPINCode
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_getpin_code_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_getpin_code_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/GetPINCode";


  std::string payload =
    get_json_payload_for_door_lock_getpin_code_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetPINCode command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/GetPINCode
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_getpin_code_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_getpin_code_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/GetPINCode";

  std::string payload =
    get_json_payload_for_door_lock_getpin_code_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetPINCodeResponse command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/GetPINCodeResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_getpin_code_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_getpin_code_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/GetPINCodeResponse";


  std::string payload =
    get_json_payload_for_door_lock_getpin_code_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetPINCodeResponse command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/GetPINCodeResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_getpin_code_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_getpin_code_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/GetPINCodeResponse";

  std::string payload =
    get_json_payload_for_door_lock_getpin_code_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ClearPINCode command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/ClearPINCode
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_clearpin_code_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_clearpin_code_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/ClearPINCode";


  std::string payload =
    get_json_payload_for_door_lock_clearpin_code_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ClearPINCode command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/ClearPINCode
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_clearpin_code_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_clearpin_code_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/ClearPINCode";

  std::string payload =
    get_json_payload_for_door_lock_clearpin_code_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ClearPINCodeResponse command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/ClearPINCodeResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_clearpin_code_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_clearpin_code_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/ClearPINCodeResponse";


  std::string payload =
    get_json_payload_for_door_lock_clearpin_code_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ClearPINCodeResponse command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/ClearPINCodeResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_clearpin_code_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_clearpin_code_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/ClearPINCodeResponse";

  std::string payload =
    get_json_payload_for_door_lock_clearpin_code_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ClearAllPINCodes command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/ClearAllPINCodes
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_clear_allpin_codes_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/ClearAllPINCodes";


  std::string payload =
    get_json_payload_for_door_lock_clear_allpin_codes_command(
    );

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ClearAllPINCodes command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/ClearAllPINCodes
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_clear_allpin_codes_command_to_group(
  uint16_t destination_group_id
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/ClearAllPINCodes";

  std::string payload =
    get_json_payload_for_door_lock_clear_allpin_codes_command(
    );

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ClearAllPINCodesResponse command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/ClearAllPINCodesResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_clear_allpin_codes_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_allpin_codes_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/ClearAllPINCodesResponse";


  std::string payload =
    get_json_payload_for_door_lock_clear_allpin_codes_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ClearAllPINCodesResponse command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/ClearAllPINCodesResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_clear_allpin_codes_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_clear_allpin_codes_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/ClearAllPINCodesResponse";

  std::string payload =
    get_json_payload_for_door_lock_clear_allpin_codes_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetUserStatus command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/SetUserStatus
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_set_user_status_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_user_status_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/SetUserStatus";


  std::string payload =
    get_json_payload_for_door_lock_set_user_status_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetUserStatus command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/SetUserStatus
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_set_user_status_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_set_user_status_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/SetUserStatus";

  std::string payload =
    get_json_payload_for_door_lock_set_user_status_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetUserStatusResponse command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/SetUserStatusResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_set_user_status_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_user_status_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/SetUserStatusResponse";


  std::string payload =
    get_json_payload_for_door_lock_set_user_status_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetUserStatusResponse command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/SetUserStatusResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_set_user_status_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_set_user_status_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/SetUserStatusResponse";

  std::string payload =
    get_json_payload_for_door_lock_set_user_status_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetUserStatus command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/GetUserStatus
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_get_user_status_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_user_status_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/GetUserStatus";


  std::string payload =
    get_json_payload_for_door_lock_get_user_status_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetUserStatus command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/GetUserStatus
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_get_user_status_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_get_user_status_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/GetUserStatus";

  std::string payload =
    get_json_payload_for_door_lock_get_user_status_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetUserStatusResponse command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/GetUserStatusResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_get_user_status_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_user_status_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/GetUserStatusResponse";


  std::string payload =
    get_json_payload_for_door_lock_get_user_status_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetUserStatusResponse command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/GetUserStatusResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_get_user_status_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_get_user_status_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/GetUserStatusResponse";

  std::string payload =
    get_json_payload_for_door_lock_get_user_status_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetWeekdaySchedule command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/SetWeekdaySchedule
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_set_weekday_schedule_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_weekday_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/SetWeekdaySchedule";


  std::string payload =
    get_json_payload_for_door_lock_set_weekday_schedule_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetWeekdaySchedule command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/SetWeekdaySchedule
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_set_weekday_schedule_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_set_weekday_schedule_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/SetWeekdaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_set_weekday_schedule_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetWeekdayScheduleResponse command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/SetWeekdayScheduleResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_set_weekday_schedule_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_weekday_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/SetWeekdayScheduleResponse";


  std::string payload =
    get_json_payload_for_door_lock_set_weekday_schedule_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetWeekdayScheduleResponse command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/SetWeekdayScheduleResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_set_weekday_schedule_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_set_weekday_schedule_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/SetWeekdayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_set_weekday_schedule_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetWeekdaySchedule command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/GetWeekdaySchedule
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_get_weekday_schedule_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_weekday_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/GetWeekdaySchedule";


  std::string payload =
    get_json_payload_for_door_lock_get_weekday_schedule_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetWeekdaySchedule command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/GetWeekdaySchedule
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_get_weekday_schedule_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_get_weekday_schedule_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/GetWeekdaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_get_weekday_schedule_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetWeekdayScheduleResponse command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/GetWeekdayScheduleResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_get_weekday_schedule_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_weekday_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/GetWeekdayScheduleResponse";


  std::string payload =
    get_json_payload_for_door_lock_get_weekday_schedule_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetWeekdayScheduleResponse command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/GetWeekdayScheduleResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_get_weekday_schedule_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_get_weekday_schedule_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/GetWeekdayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_get_weekday_schedule_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ClearWeekdaySchedule command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/ClearWeekdaySchedule
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_clear_weekday_schedule_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_weekday_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/ClearWeekdaySchedule";


  std::string payload =
    get_json_payload_for_door_lock_clear_weekday_schedule_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ClearWeekdaySchedule command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/ClearWeekdaySchedule
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_clear_weekday_schedule_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_clear_weekday_schedule_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/ClearWeekdaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_clear_weekday_schedule_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ClearWeekdayScheduleResponse command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/ClearWeekdayScheduleResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_clear_weekday_schedule_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_weekday_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/ClearWeekdayScheduleResponse";


  std::string payload =
    get_json_payload_for_door_lock_clear_weekday_schedule_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ClearWeekdayScheduleResponse command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/ClearWeekdayScheduleResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_clear_weekday_schedule_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_clear_weekday_schedule_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/ClearWeekdayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_clear_weekday_schedule_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetYearDaySchedule command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/SetYearDaySchedule
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_set_year_day_schedule_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_year_day_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/SetYearDaySchedule";


  std::string payload =
    get_json_payload_for_door_lock_set_year_day_schedule_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetYearDaySchedule command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/SetYearDaySchedule
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_set_year_day_schedule_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_set_year_day_schedule_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/SetYearDaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_set_year_day_schedule_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetYearDayScheduleResponse command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/SetYearDayScheduleResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_set_year_day_schedule_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_year_day_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/SetYearDayScheduleResponse";


  std::string payload =
    get_json_payload_for_door_lock_set_year_day_schedule_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetYearDayScheduleResponse command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/SetYearDayScheduleResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_set_year_day_schedule_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_set_year_day_schedule_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/SetYearDayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_set_year_day_schedule_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetYearDaySchedule command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/GetYearDaySchedule
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_get_year_day_schedule_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_year_day_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/GetYearDaySchedule";


  std::string payload =
    get_json_payload_for_door_lock_get_year_day_schedule_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetYearDaySchedule command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/GetYearDaySchedule
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_get_year_day_schedule_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_get_year_day_schedule_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/GetYearDaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_get_year_day_schedule_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetYearDayScheduleResponse command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/GetYearDayScheduleResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_get_year_day_schedule_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_year_day_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/GetYearDayScheduleResponse";


  std::string payload =
    get_json_payload_for_door_lock_get_year_day_schedule_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetYearDayScheduleResponse command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/GetYearDayScheduleResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_get_year_day_schedule_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_get_year_day_schedule_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/GetYearDayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_get_year_day_schedule_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ClearYearDaySchedule command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/ClearYearDaySchedule
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_clear_year_day_schedule_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_year_day_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/ClearYearDaySchedule";


  std::string payload =
    get_json_payload_for_door_lock_clear_year_day_schedule_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ClearYearDaySchedule command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/ClearYearDaySchedule
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_clear_year_day_schedule_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_clear_year_day_schedule_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/ClearYearDaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_clear_year_day_schedule_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ClearYearDayScheduleResponse command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/ClearYearDayScheduleResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_clear_year_day_schedule_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_year_day_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/ClearYearDayScheduleResponse";


  std::string payload =
    get_json_payload_for_door_lock_clear_year_day_schedule_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ClearYearDayScheduleResponse command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/ClearYearDayScheduleResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_clear_year_day_schedule_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_clear_year_day_schedule_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/ClearYearDayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_clear_year_day_schedule_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetHolidaySchedule command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/SetHolidaySchedule
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_set_holiday_schedule_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_holiday_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/SetHolidaySchedule";


  std::string payload =
    get_json_payload_for_door_lock_set_holiday_schedule_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetHolidaySchedule command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/SetHolidaySchedule
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_set_holiday_schedule_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_set_holiday_schedule_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/SetHolidaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_set_holiday_schedule_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetHolidayScheduleResponse command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/SetHolidayScheduleResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_set_holiday_schedule_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_holiday_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/SetHolidayScheduleResponse";


  std::string payload =
    get_json_payload_for_door_lock_set_holiday_schedule_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetHolidayScheduleResponse command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/SetHolidayScheduleResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_set_holiday_schedule_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_set_holiday_schedule_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/SetHolidayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_set_holiday_schedule_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetHolidaySchedule command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/GetHolidaySchedule
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_get_holiday_schedule_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_holiday_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/GetHolidaySchedule";


  std::string payload =
    get_json_payload_for_door_lock_get_holiday_schedule_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetHolidaySchedule command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/GetHolidaySchedule
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_get_holiday_schedule_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_get_holiday_schedule_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/GetHolidaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_get_holiday_schedule_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetHolidayScheduleResponse command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/GetHolidayScheduleResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_get_holiday_schedule_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_holiday_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/GetHolidayScheduleResponse";


  std::string payload =
    get_json_payload_for_door_lock_get_holiday_schedule_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetHolidayScheduleResponse command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/GetHolidayScheduleResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_get_holiday_schedule_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_get_holiday_schedule_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/GetHolidayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_get_holiday_schedule_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ClearHolidaySchedule command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/ClearHolidaySchedule
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_clear_holiday_schedule_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_holiday_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/ClearHolidaySchedule";


  std::string payload =
    get_json_payload_for_door_lock_clear_holiday_schedule_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ClearHolidaySchedule command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/ClearHolidaySchedule
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_clear_holiday_schedule_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_clear_holiday_schedule_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/ClearHolidaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_clear_holiday_schedule_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ClearHolidayScheduleResponse command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/ClearHolidayScheduleResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_clear_holiday_schedule_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_holiday_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/ClearHolidayScheduleResponse";


  std::string payload =
    get_json_payload_for_door_lock_clear_holiday_schedule_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ClearHolidayScheduleResponse command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/ClearHolidayScheduleResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_clear_holiday_schedule_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_clear_holiday_schedule_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/ClearHolidayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_clear_holiday_schedule_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetUserType command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/SetUserType
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_set_user_type_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_user_type_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/SetUserType";


  std::string payload =
    get_json_payload_for_door_lock_set_user_type_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetUserType command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/SetUserType
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_set_user_type_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_set_user_type_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/SetUserType";

  std::string payload =
    get_json_payload_for_door_lock_set_user_type_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetUserTypeResponse command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/SetUserTypeResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_set_user_type_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_user_type_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/SetUserTypeResponse";


  std::string payload =
    get_json_payload_for_door_lock_set_user_type_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetUserTypeResponse command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/SetUserTypeResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_set_user_type_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_set_user_type_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/SetUserTypeResponse";

  std::string payload =
    get_json_payload_for_door_lock_set_user_type_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetUserType command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/GetUserType
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_get_user_type_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_user_type_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/GetUserType";


  std::string payload =
    get_json_payload_for_door_lock_get_user_type_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetUserType command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/GetUserType
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_get_user_type_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_get_user_type_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/GetUserType";

  std::string payload =
    get_json_payload_for_door_lock_get_user_type_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetUserTypeResponse command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/GetUserTypeResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_get_user_type_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_user_type_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/GetUserTypeResponse";


  std::string payload =
    get_json_payload_for_door_lock_get_user_type_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetUserTypeResponse command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/GetUserTypeResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_get_user_type_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_get_user_type_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/GetUserTypeResponse";

  std::string payload =
    get_json_payload_for_door_lock_get_user_type_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetRFIDCode command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/SetRFIDCode
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_setrfid_code_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_setrfid_code_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/SetRFIDCode";


  std::string payload =
    get_json_payload_for_door_lock_setrfid_code_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetRFIDCode command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/SetRFIDCode
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_setrfid_code_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_setrfid_code_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/SetRFIDCode";

  std::string payload =
    get_json_payload_for_door_lock_setrfid_code_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetRFIDCodeResponse command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/SetRFIDCodeResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_setrfid_code_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_setrfid_code_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/SetRFIDCodeResponse";


  std::string payload =
    get_json_payload_for_door_lock_setrfid_code_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetRFIDCodeResponse command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/SetRFIDCodeResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_setrfid_code_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_setrfid_code_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/SetRFIDCodeResponse";

  std::string payload =
    get_json_payload_for_door_lock_setrfid_code_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetRFIDCode command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/GetRFIDCode
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_getrfid_code_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_getrfid_code_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/GetRFIDCode";


  std::string payload =
    get_json_payload_for_door_lock_getrfid_code_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetRFIDCode command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/GetRFIDCode
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_getrfid_code_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_getrfid_code_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/GetRFIDCode";

  std::string payload =
    get_json_payload_for_door_lock_getrfid_code_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetRFIDCodeResponse command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/GetRFIDCodeResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_getrfid_code_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_getrfid_code_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/GetRFIDCodeResponse";


  std::string payload =
    get_json_payload_for_door_lock_getrfid_code_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetRFIDCodeResponse command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/GetRFIDCodeResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_getrfid_code_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_getrfid_code_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/GetRFIDCodeResponse";

  std::string payload =
    get_json_payload_for_door_lock_getrfid_code_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ClearRFIDCode command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/ClearRFIDCode
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_clearrfid_code_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_clearrfid_code_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/ClearRFIDCode";


  std::string payload =
    get_json_payload_for_door_lock_clearrfid_code_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ClearRFIDCode command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/ClearRFIDCode
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_clearrfid_code_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_clearrfid_code_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/ClearRFIDCode";

  std::string payload =
    get_json_payload_for_door_lock_clearrfid_code_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ClearRFIDCodeResponse command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/ClearRFIDCodeResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_clearrfid_code_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_clearrfid_code_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/ClearRFIDCodeResponse";


  std::string payload =
    get_json_payload_for_door_lock_clearrfid_code_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ClearRFIDCodeResponse command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/ClearRFIDCodeResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_clearrfid_code_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_clearrfid_code_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/ClearRFIDCodeResponse";

  std::string payload =
    get_json_payload_for_door_lock_clearrfid_code_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ClearAllRFIDCodes command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/ClearAllRFIDCodes
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_clear_allrfid_codes_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/ClearAllRFIDCodes";


  std::string payload =
    get_json_payload_for_door_lock_clear_allrfid_codes_command(
    );

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ClearAllRFIDCodes command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/ClearAllRFIDCodes
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_clear_allrfid_codes_command_to_group(
  uint16_t destination_group_id
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/ClearAllRFIDCodes";

  std::string payload =
    get_json_payload_for_door_lock_clear_allrfid_codes_command(
    );

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ClearAllRFIDCodesResponse command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/ClearAllRFIDCodesResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_clear_allrfid_codes_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_allrfid_codes_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/ClearAllRFIDCodesResponse";


  std::string payload =
    get_json_payload_for_door_lock_clear_allrfid_codes_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ClearAllRFIDCodesResponse command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/ClearAllRFIDCodesResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_clear_allrfid_codes_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_clear_allrfid_codes_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/ClearAllRFIDCodesResponse";

  std::string payload =
    get_json_payload_for_door_lock_clear_allrfid_codes_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a OperatingEventNotification command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/OperatingEventNotification
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_operating_event_notification_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_operating_event_notification_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/OperatingEventNotification";


  std::string payload =
    get_json_payload_for_door_lock_operating_event_notification_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a OperatingEventNotification command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/OperatingEventNotification
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_operating_event_notification_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_operating_event_notification_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/OperatingEventNotification";

  std::string payload =
    get_json_payload_for_door_lock_operating_event_notification_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ProgrammingEventNotification command for
 * the DoorLock cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/Commands/ProgrammingEventNotification
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_programming_event_notification_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_door_lock_command_programming_event_notification_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "DoorLock/Commands/ProgrammingEventNotification";


  std::string payload =
    get_json_payload_for_door_lock_programming_event_notification_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ProgrammingEventNotification command for
 * the DoorLock cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/DoorLock/Commands/ProgrammingEventNotification
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_programming_event_notification_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_door_lock_command_programming_event_notification_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/DoorLock/Commands/ProgrammingEventNotification";

  std::string payload =
    get_json_payload_for_door_lock_programming_event_notification_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a UpOrOpen command for
 * the WindowCovering cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/WindowCovering/Commands/UpOrOpen
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_up_or_open_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "WindowCovering/Commands/UpOrOpen";


  std::string payload =
    get_json_payload_for_window_covering_up_or_open_command(
    );

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a UpOrOpen command for
 * the WindowCovering cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/WindowCovering/Commands/UpOrOpen
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_up_or_open_command_to_group(
  uint16_t destination_group_id
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/WindowCovering/Commands/UpOrOpen";

  std::string payload =
    get_json_payload_for_window_covering_up_or_open_command(
    );

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a DownOrClose command for
 * the WindowCovering cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/WindowCovering/Commands/DownOrClose
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_down_or_close_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "WindowCovering/Commands/DownOrClose";


  std::string payload =
    get_json_payload_for_window_covering_down_or_close_command(
    );

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a DownOrClose command for
 * the WindowCovering cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/WindowCovering/Commands/DownOrClose
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_down_or_close_command_to_group(
  uint16_t destination_group_id
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/WindowCovering/Commands/DownOrClose";

  std::string payload =
    get_json_payload_for_window_covering_down_or_close_command(
    );

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a Stop command for
 * the WindowCovering cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/WindowCovering/Commands/Stop
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_stop_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "WindowCovering/Commands/Stop";


  std::string payload =
    get_json_payload_for_window_covering_stop_command(
    );

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a Stop command for
 * the WindowCovering cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/WindowCovering/Commands/Stop
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_stop_command_to_group(
  uint16_t destination_group_id
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/WindowCovering/Commands/Stop";

  std::string payload =
    get_json_payload_for_window_covering_stop_command(
    );

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GoToLiftValue command for
 * the WindowCovering cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/WindowCovering/Commands/GoToLiftValue
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_go_to_lift_value_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_window_covering_command_go_to_lift_value_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "WindowCovering/Commands/GoToLiftValue";


  std::string payload =
    get_json_payload_for_window_covering_go_to_lift_value_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GoToLiftValue command for
 * the WindowCovering cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/WindowCovering/Commands/GoToLiftValue
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_go_to_lift_value_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_window_covering_command_go_to_lift_value_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/WindowCovering/Commands/GoToLiftValue";

  std::string payload =
    get_json_payload_for_window_covering_go_to_lift_value_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GoToLiftPercentage command for
 * the WindowCovering cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/WindowCovering/Commands/GoToLiftPercentage
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_go_to_lift_percentage_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_window_covering_command_go_to_lift_percentage_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "WindowCovering/Commands/GoToLiftPercentage";


  std::string payload =
    get_json_payload_for_window_covering_go_to_lift_percentage_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GoToLiftPercentage command for
 * the WindowCovering cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/WindowCovering/Commands/GoToLiftPercentage
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_go_to_lift_percentage_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_window_covering_command_go_to_lift_percentage_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/WindowCovering/Commands/GoToLiftPercentage";

  std::string payload =
    get_json_payload_for_window_covering_go_to_lift_percentage_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GoToTiltValue command for
 * the WindowCovering cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/WindowCovering/Commands/GoToTiltValue
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_go_to_tilt_value_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_window_covering_command_go_to_tilt_value_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "WindowCovering/Commands/GoToTiltValue";


  std::string payload =
    get_json_payload_for_window_covering_go_to_tilt_value_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GoToTiltValue command for
 * the WindowCovering cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/WindowCovering/Commands/GoToTiltValue
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_go_to_tilt_value_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_window_covering_command_go_to_tilt_value_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/WindowCovering/Commands/GoToTiltValue";

  std::string payload =
    get_json_payload_for_window_covering_go_to_tilt_value_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GoToTiltPercentage command for
 * the WindowCovering cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/WindowCovering/Commands/GoToTiltPercentage
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_go_to_tilt_percentage_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_window_covering_command_go_to_tilt_percentage_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "WindowCovering/Commands/GoToTiltPercentage";


  std::string payload =
    get_json_payload_for_window_covering_go_to_tilt_percentage_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GoToTiltPercentage command for
 * the WindowCovering cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/WindowCovering/Commands/GoToTiltPercentage
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_go_to_tilt_percentage_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_window_covering_command_go_to_tilt_percentage_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/WindowCovering/Commands/GoToTiltPercentage";

  std::string payload =
    get_json_payload_for_window_covering_go_to_tilt_percentage_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GoToPercent command for
 * the BarrierControl cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/BarrierControl/Commands/GoToPercent
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_barrier_control_publish_go_to_percent_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_barrier_control_command_go_to_percent_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "BarrierControl/Commands/GoToPercent";


  std::string payload =
    get_json_payload_for_barrier_control_go_to_percent_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GoToPercent command for
 * the BarrierControl cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/BarrierControl/Commands/GoToPercent
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_barrier_control_publish_go_to_percent_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_barrier_control_command_go_to_percent_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/BarrierControl/Commands/GoToPercent";

  std::string payload =
    get_json_payload_for_barrier_control_go_to_percent_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a Stop command for
 * the BarrierControl cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/BarrierControl/Commands/Stop
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 */
void uic_mqtt_dotdot_barrier_control_publish_stop_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "BarrierControl/Commands/Stop";


  std::string payload =
    get_json_payload_for_barrier_control_stop_command(
    );

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a Stop command for
 * the BarrierControl cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/BarrierControl/Commands/Stop
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 */
void uic_mqtt_dotdot_barrier_control_publish_stop_command_to_group(
  uint16_t destination_group_id
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/BarrierControl/Commands/Stop";

  std::string payload =
    get_json_payload_for_barrier_control_stop_command(
    );

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetpointRaiseOrLower command for
 * the Thermostat cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Thermostat/Commands/SetpointRaiseOrLower
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_setpoint_raise_or_lower_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_thermostat_command_setpoint_raise_or_lower_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Thermostat/Commands/SetpointRaiseOrLower";


  std::string payload =
    get_json_payload_for_thermostat_setpoint_raise_or_lower_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetpointRaiseOrLower command for
 * the Thermostat cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Thermostat/Commands/SetpointRaiseOrLower
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_setpoint_raise_or_lower_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_thermostat_command_setpoint_raise_or_lower_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Thermostat/Commands/SetpointRaiseOrLower";

  std::string payload =
    get_json_payload_for_thermostat_setpoint_raise_or_lower_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetWeeklyScheduleResponse command for
 * the Thermostat cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Thermostat/Commands/GetWeeklyScheduleResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_get_weekly_schedule_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_thermostat_command_get_weekly_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Thermostat/Commands/GetWeeklyScheduleResponse";


  std::string payload =
    get_json_payload_for_thermostat_get_weekly_schedule_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetWeeklyScheduleResponse command for
 * the Thermostat cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Thermostat/Commands/GetWeeklyScheduleResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_get_weekly_schedule_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_thermostat_command_get_weekly_schedule_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Thermostat/Commands/GetWeeklyScheduleResponse";

  std::string payload =
    get_json_payload_for_thermostat_get_weekly_schedule_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetWeeklySchedule command for
 * the Thermostat cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Thermostat/Commands/SetWeeklySchedule
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_set_weekly_schedule_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_thermostat_command_set_weekly_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Thermostat/Commands/SetWeeklySchedule";


  std::string payload =
    get_json_payload_for_thermostat_set_weekly_schedule_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetWeeklySchedule command for
 * the Thermostat cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Thermostat/Commands/SetWeeklySchedule
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_set_weekly_schedule_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_thermostat_command_set_weekly_schedule_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Thermostat/Commands/SetWeeklySchedule";

  std::string payload =
    get_json_payload_for_thermostat_set_weekly_schedule_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetRelayStatusLogResponse command for
 * the Thermostat cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Thermostat/Commands/GetRelayStatusLogResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_get_relay_status_log_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_thermostat_command_get_relay_status_log_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Thermostat/Commands/GetRelayStatusLogResponse";


  std::string payload =
    get_json_payload_for_thermostat_get_relay_status_log_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetRelayStatusLogResponse command for
 * the Thermostat cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Thermostat/Commands/GetRelayStatusLogResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_get_relay_status_log_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_thermostat_command_get_relay_status_log_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Thermostat/Commands/GetRelayStatusLogResponse";

  std::string payload =
    get_json_payload_for_thermostat_get_relay_status_log_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetWeeklySchedule command for
 * the Thermostat cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Thermostat/Commands/GetWeeklySchedule
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_get_weekly_schedule_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_thermostat_command_get_weekly_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Thermostat/Commands/GetWeeklySchedule";


  std::string payload =
    get_json_payload_for_thermostat_get_weekly_schedule_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetWeeklySchedule command for
 * the Thermostat cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Thermostat/Commands/GetWeeklySchedule
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_get_weekly_schedule_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_thermostat_command_get_weekly_schedule_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Thermostat/Commands/GetWeeklySchedule";

  std::string payload =
    get_json_payload_for_thermostat_get_weekly_schedule_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ClearWeeklySchedule command for
 * the Thermostat cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Thermostat/Commands/ClearWeeklySchedule
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_clear_weekly_schedule_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Thermostat/Commands/ClearWeeklySchedule";


  std::string payload =
    get_json_payload_for_thermostat_clear_weekly_schedule_command(
    );

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ClearWeeklySchedule command for
 * the Thermostat cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Thermostat/Commands/ClearWeeklySchedule
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_clear_weekly_schedule_command_to_group(
  uint16_t destination_group_id
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Thermostat/Commands/ClearWeeklySchedule";

  std::string payload =
    get_json_payload_for_thermostat_clear_weekly_schedule_command(
    );

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetRelayStatusLog command for
 * the Thermostat cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Thermostat/Commands/GetRelayStatusLog
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_get_relay_status_log_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Thermostat/Commands/GetRelayStatusLog";


  std::string payload =
    get_json_payload_for_thermostat_get_relay_status_log_command(
    );

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetRelayStatusLog command for
 * the Thermostat cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Thermostat/Commands/GetRelayStatusLog
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_get_relay_status_log_command_to_group(
  uint16_t destination_group_id
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Thermostat/Commands/GetRelayStatusLog";

  std::string payload =
    get_json_payload_for_thermostat_get_relay_status_log_command(
    );

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a MoveToHue command for
 * the ColorControl cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/Commands/MoveToHue
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_move_to_hue_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_color_control_command_move_to_hue_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "ColorControl/Commands/MoveToHue";


  std::string payload =
    get_json_payload_for_color_control_move_to_hue_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a MoveToHue command for
 * the ColorControl cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/ColorControl/Commands/MoveToHue
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_move_to_hue_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_color_control_command_move_to_hue_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/ColorControl/Commands/MoveToHue";

  std::string payload =
    get_json_payload_for_color_control_move_to_hue_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a MoveHue command for
 * the ColorControl cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/Commands/MoveHue
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_move_hue_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_color_control_command_move_hue_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "ColorControl/Commands/MoveHue";


  std::string payload =
    get_json_payload_for_color_control_move_hue_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a MoveHue command for
 * the ColorControl cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/ColorControl/Commands/MoveHue
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_move_hue_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_color_control_command_move_hue_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/ColorControl/Commands/MoveHue";

  std::string payload =
    get_json_payload_for_color_control_move_hue_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a StepHue command for
 * the ColorControl cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/Commands/StepHue
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_step_hue_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_color_control_command_step_hue_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "ColorControl/Commands/StepHue";


  std::string payload =
    get_json_payload_for_color_control_step_hue_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a StepHue command for
 * the ColorControl cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/ColorControl/Commands/StepHue
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_step_hue_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_color_control_command_step_hue_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/ColorControl/Commands/StepHue";

  std::string payload =
    get_json_payload_for_color_control_step_hue_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a MoveToSaturation command for
 * the ColorControl cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/Commands/MoveToSaturation
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_move_to_saturation_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_color_control_command_move_to_saturation_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "ColorControl/Commands/MoveToSaturation";


  std::string payload =
    get_json_payload_for_color_control_move_to_saturation_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a MoveToSaturation command for
 * the ColorControl cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/ColorControl/Commands/MoveToSaturation
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_move_to_saturation_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_color_control_command_move_to_saturation_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/ColorControl/Commands/MoveToSaturation";

  std::string payload =
    get_json_payload_for_color_control_move_to_saturation_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a MoveSaturation command for
 * the ColorControl cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/Commands/MoveSaturation
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_move_saturation_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_color_control_command_move_saturation_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "ColorControl/Commands/MoveSaturation";


  std::string payload =
    get_json_payload_for_color_control_move_saturation_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a MoveSaturation command for
 * the ColorControl cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/ColorControl/Commands/MoveSaturation
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_move_saturation_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_color_control_command_move_saturation_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/ColorControl/Commands/MoveSaturation";

  std::string payload =
    get_json_payload_for_color_control_move_saturation_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a StepSaturation command for
 * the ColorControl cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/Commands/StepSaturation
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_step_saturation_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_color_control_command_step_saturation_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "ColorControl/Commands/StepSaturation";


  std::string payload =
    get_json_payload_for_color_control_step_saturation_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a StepSaturation command for
 * the ColorControl cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/ColorControl/Commands/StepSaturation
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_step_saturation_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_color_control_command_step_saturation_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/ColorControl/Commands/StepSaturation";

  std::string payload =
    get_json_payload_for_color_control_step_saturation_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a MoveToHueAndSaturation command for
 * the ColorControl cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/Commands/MoveToHueAndSaturation
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_move_to_hue_and_saturation_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_color_control_command_move_to_hue_and_saturation_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "ColorControl/Commands/MoveToHueAndSaturation";


  std::string payload =
    get_json_payload_for_color_control_move_to_hue_and_saturation_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a MoveToHueAndSaturation command for
 * the ColorControl cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/ColorControl/Commands/MoveToHueAndSaturation
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_move_to_hue_and_saturation_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_color_control_command_move_to_hue_and_saturation_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/ColorControl/Commands/MoveToHueAndSaturation";

  std::string payload =
    get_json_payload_for_color_control_move_to_hue_and_saturation_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a MoveToColor command for
 * the ColorControl cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/Commands/MoveToColor
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_move_to_color_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_color_control_command_move_to_color_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "ColorControl/Commands/MoveToColor";


  std::string payload =
    get_json_payload_for_color_control_move_to_color_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a MoveToColor command for
 * the ColorControl cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/ColorControl/Commands/MoveToColor
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_move_to_color_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_color_control_command_move_to_color_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/ColorControl/Commands/MoveToColor";

  std::string payload =
    get_json_payload_for_color_control_move_to_color_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a MoveColor command for
 * the ColorControl cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/Commands/MoveColor
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_move_color_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_color_control_command_move_color_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "ColorControl/Commands/MoveColor";


  std::string payload =
    get_json_payload_for_color_control_move_color_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a MoveColor command for
 * the ColorControl cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/ColorControl/Commands/MoveColor
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_move_color_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_color_control_command_move_color_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/ColorControl/Commands/MoveColor";

  std::string payload =
    get_json_payload_for_color_control_move_color_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a StepColor command for
 * the ColorControl cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/Commands/StepColor
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_step_color_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_color_control_command_step_color_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "ColorControl/Commands/StepColor";


  std::string payload =
    get_json_payload_for_color_control_step_color_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a StepColor command for
 * the ColorControl cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/ColorControl/Commands/StepColor
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_step_color_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_color_control_command_step_color_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/ColorControl/Commands/StepColor";

  std::string payload =
    get_json_payload_for_color_control_step_color_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a MoveToColorTemperature command for
 * the ColorControl cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/Commands/MoveToColorTemperature
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_move_to_color_temperature_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_color_control_command_move_to_color_temperature_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "ColorControl/Commands/MoveToColorTemperature";


  std::string payload =
    get_json_payload_for_color_control_move_to_color_temperature_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a MoveToColorTemperature command for
 * the ColorControl cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/ColorControl/Commands/MoveToColorTemperature
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_move_to_color_temperature_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_color_control_command_move_to_color_temperature_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/ColorControl/Commands/MoveToColorTemperature";

  std::string payload =
    get_json_payload_for_color_control_move_to_color_temperature_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a EnhancedMoveToHue command for
 * the ColorControl cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/Commands/EnhancedMoveToHue
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_enhanced_move_to_hue_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_color_control_command_enhanced_move_to_hue_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "ColorControl/Commands/EnhancedMoveToHue";


  std::string payload =
    get_json_payload_for_color_control_enhanced_move_to_hue_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a EnhancedMoveToHue command for
 * the ColorControl cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/ColorControl/Commands/EnhancedMoveToHue
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_enhanced_move_to_hue_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_color_control_command_enhanced_move_to_hue_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/ColorControl/Commands/EnhancedMoveToHue";

  std::string payload =
    get_json_payload_for_color_control_enhanced_move_to_hue_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a EnhancedMoveHue command for
 * the ColorControl cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/Commands/EnhancedMoveHue
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_enhanced_move_hue_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_color_control_command_enhanced_move_hue_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "ColorControl/Commands/EnhancedMoveHue";


  std::string payload =
    get_json_payload_for_color_control_enhanced_move_hue_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a EnhancedMoveHue command for
 * the ColorControl cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/ColorControl/Commands/EnhancedMoveHue
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_enhanced_move_hue_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_color_control_command_enhanced_move_hue_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/ColorControl/Commands/EnhancedMoveHue";

  std::string payload =
    get_json_payload_for_color_control_enhanced_move_hue_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a EnhancedStepHue command for
 * the ColorControl cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/Commands/EnhancedStepHue
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_enhanced_step_hue_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_color_control_command_enhanced_step_hue_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "ColorControl/Commands/EnhancedStepHue";


  std::string payload =
    get_json_payload_for_color_control_enhanced_step_hue_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a EnhancedStepHue command for
 * the ColorControl cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/ColorControl/Commands/EnhancedStepHue
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_enhanced_step_hue_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_color_control_command_enhanced_step_hue_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/ColorControl/Commands/EnhancedStepHue";

  std::string payload =
    get_json_payload_for_color_control_enhanced_step_hue_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a EnhancedMoveToHueAndSaturation command for
 * the ColorControl cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/Commands/EnhancedMoveToHueAndSaturation
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_enhanced_move_to_hue_and_saturation_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_color_control_command_enhanced_move_to_hue_and_saturation_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "ColorControl/Commands/EnhancedMoveToHueAndSaturation";


  std::string payload =
    get_json_payload_for_color_control_enhanced_move_to_hue_and_saturation_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a EnhancedMoveToHueAndSaturation command for
 * the ColorControl cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/ColorControl/Commands/EnhancedMoveToHueAndSaturation
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_enhanced_move_to_hue_and_saturation_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_color_control_command_enhanced_move_to_hue_and_saturation_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/ColorControl/Commands/EnhancedMoveToHueAndSaturation";

  std::string payload =
    get_json_payload_for_color_control_enhanced_move_to_hue_and_saturation_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ColorLoopSet command for
 * the ColorControl cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/Commands/ColorLoopSet
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_color_loop_set_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_color_control_command_color_loop_set_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "ColorControl/Commands/ColorLoopSet";


  std::string payload =
    get_json_payload_for_color_control_color_loop_set_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ColorLoopSet command for
 * the ColorControl cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/ColorControl/Commands/ColorLoopSet
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_color_loop_set_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_color_control_command_color_loop_set_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/ColorControl/Commands/ColorLoopSet";

  std::string payload =
    get_json_payload_for_color_control_color_loop_set_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a StopMoveStep command for
 * the ColorControl cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/Commands/StopMoveStep
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_stop_move_step_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_color_control_command_stop_move_step_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "ColorControl/Commands/StopMoveStep";


  std::string payload =
    get_json_payload_for_color_control_stop_move_step_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a StopMoveStep command for
 * the ColorControl cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/ColorControl/Commands/StopMoveStep
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_stop_move_step_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_color_control_command_stop_move_step_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/ColorControl/Commands/StopMoveStep";

  std::string payload =
    get_json_payload_for_color_control_stop_move_step_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a MoveColorTemperature command for
 * the ColorControl cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/Commands/MoveColorTemperature
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_move_color_temperature_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_color_control_command_move_color_temperature_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "ColorControl/Commands/MoveColorTemperature";


  std::string payload =
    get_json_payload_for_color_control_move_color_temperature_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a MoveColorTemperature command for
 * the ColorControl cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/ColorControl/Commands/MoveColorTemperature
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_move_color_temperature_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_color_control_command_move_color_temperature_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/ColorControl/Commands/MoveColorTemperature";

  std::string payload =
    get_json_payload_for_color_control_move_color_temperature_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a StepColorTemperature command for
 * the ColorControl cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/Commands/StepColorTemperature
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_step_color_temperature_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_color_control_command_step_color_temperature_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "ColorControl/Commands/StepColorTemperature";


  std::string payload =
    get_json_payload_for_color_control_step_color_temperature_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a StepColorTemperature command for
 * the ColorControl cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/ColorControl/Commands/StepColorTemperature
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_step_color_temperature_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_color_control_command_step_color_temperature_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/ColorControl/Commands/StepColorTemperature";

  std::string payload =
    get_json_payload_for_color_control_step_color_temperature_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ZoneEnrollResponse command for
 * the IASZone cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IASZone/Commands/ZoneEnrollResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ias_zone_publish_zone_enroll_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_ias_zone_command_zone_enroll_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "IASZone/Commands/ZoneEnrollResponse";


  std::string payload =
    get_json_payload_for_ias_zone_zone_enroll_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ZoneEnrollResponse command for
 * the IASZone cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/IASZone/Commands/ZoneEnrollResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ias_zone_publish_zone_enroll_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_ias_zone_command_zone_enroll_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/IASZone/Commands/ZoneEnrollResponse";

  std::string payload =
    get_json_payload_for_ias_zone_zone_enroll_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ZoneStatusChangeNotification command for
 * the IASZone cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IASZone/Commands/ZoneStatusChangeNotification
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ias_zone_publish_zone_status_change_notification_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_ias_zone_command_zone_status_change_notification_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "IASZone/Commands/ZoneStatusChangeNotification";


  std::string payload =
    get_json_payload_for_ias_zone_zone_status_change_notification_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ZoneStatusChangeNotification command for
 * the IASZone cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/IASZone/Commands/ZoneStatusChangeNotification
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ias_zone_publish_zone_status_change_notification_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_ias_zone_command_zone_status_change_notification_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/IASZone/Commands/ZoneStatusChangeNotification";

  std::string payload =
    get_json_payload_for_ias_zone_zone_status_change_notification_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a InitiateNormalOperationMode command for
 * the IASZone cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IASZone/Commands/InitiateNormalOperationMode
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 */
void uic_mqtt_dotdot_ias_zone_publish_initiate_normal_operation_mode_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "IASZone/Commands/InitiateNormalOperationMode";


  std::string payload =
    get_json_payload_for_ias_zone_initiate_normal_operation_mode_command(
    );

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a InitiateNormalOperationMode command for
 * the IASZone cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/IASZone/Commands/InitiateNormalOperationMode
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 */
void uic_mqtt_dotdot_ias_zone_publish_initiate_normal_operation_mode_command_to_group(
  uint16_t destination_group_id
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/IASZone/Commands/InitiateNormalOperationMode";

  std::string payload =
    get_json_payload_for_ias_zone_initiate_normal_operation_mode_command(
    );

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ZoneEnrollRequest command for
 * the IASZone cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IASZone/Commands/ZoneEnrollRequest
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ias_zone_publish_zone_enroll_request_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_ias_zone_command_zone_enroll_request_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "IASZone/Commands/ZoneEnrollRequest";


  std::string payload =
    get_json_payload_for_ias_zone_zone_enroll_request_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a ZoneEnrollRequest command for
 * the IASZone cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/IASZone/Commands/ZoneEnrollRequest
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ias_zone_publish_zone_enroll_request_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_ias_zone_command_zone_enroll_request_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/IASZone/Commands/ZoneEnrollRequest";

  std::string payload =
    get_json_payload_for_ias_zone_zone_enroll_request_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a InitiateTestMode command for
 * the IASZone cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IASZone/Commands/InitiateTestMode
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ias_zone_publish_initiate_test_mode_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_ias_zone_command_initiate_test_mode_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "IASZone/Commands/InitiateTestMode";


  std::string payload =
    get_json_payload_for_ias_zone_initiate_test_mode_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a InitiateTestMode command for
 * the IASZone cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/IASZone/Commands/InitiateTestMode
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ias_zone_publish_initiate_test_mode_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_ias_zone_command_initiate_test_mode_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/IASZone/Commands/InitiateTestMode";

  std::string payload =
    get_json_payload_for_ias_zone_initiate_test_mode_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a StartWarning command for
 * the IASWD cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IASWD/Commands/StartWarning
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_iaswd_publish_start_warning_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_iaswd_command_start_warning_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "IASWD/Commands/StartWarning";


  std::string payload =
    get_json_payload_for_iaswd_start_warning_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a StartWarning command for
 * the IASWD cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/IASWD/Commands/StartWarning
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_iaswd_publish_start_warning_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_iaswd_command_start_warning_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/IASWD/Commands/StartWarning";

  std::string payload =
    get_json_payload_for_iaswd_start_warning_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a Squawk command for
 * the IASWD cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IASWD/Commands/Squawk
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_iaswd_publish_squawk_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_iaswd_command_squawk_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "IASWD/Commands/Squawk";


  std::string payload =
    get_json_payload_for_iaswd_squawk_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a Squawk command for
 * the IASWD cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/IASWD/Commands/Squawk
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_iaswd_publish_squawk_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_iaswd_command_squawk_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/IASWD/Commands/Squawk";

  std::string payload =
    get_json_payload_for_iaswd_squawk_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetProfileInfoResponse command for
 * the ElectricalMeasurement cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ElectricalMeasurement/Commands/GetProfileInfoResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_electrical_measurement_publish_get_profile_info_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_electrical_measurement_command_get_profile_info_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "ElectricalMeasurement/Commands/GetProfileInfoResponse";


  std::string payload =
    get_json_payload_for_electrical_measurement_get_profile_info_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetProfileInfoResponse command for
 * the ElectricalMeasurement cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/ElectricalMeasurement/Commands/GetProfileInfoResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_electrical_measurement_publish_get_profile_info_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_electrical_measurement_command_get_profile_info_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/ElectricalMeasurement/Commands/GetProfileInfoResponse";

  std::string payload =
    get_json_payload_for_electrical_measurement_get_profile_info_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetProfileInfo command for
 * the ElectricalMeasurement cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ElectricalMeasurement/Commands/GetProfileInfo
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 */
void uic_mqtt_dotdot_electrical_measurement_publish_get_profile_info_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "ElectricalMeasurement/Commands/GetProfileInfo";


  std::string payload =
    get_json_payload_for_electrical_measurement_get_profile_info_command(
    );

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetProfileInfo command for
 * the ElectricalMeasurement cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/ElectricalMeasurement/Commands/GetProfileInfo
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 */
void uic_mqtt_dotdot_electrical_measurement_publish_get_profile_info_command_to_group(
  uint16_t destination_group_id
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/ElectricalMeasurement/Commands/GetProfileInfo";

  std::string payload =
    get_json_payload_for_electrical_measurement_get_profile_info_command(
    );

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetMeasurementProfileResponse command for
 * the ElectricalMeasurement cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ElectricalMeasurement/Commands/GetMeasurementProfileResponse
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_electrical_measurement_publish_get_measurement_profile_response_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_electrical_measurement_command_get_measurement_profile_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "ElectricalMeasurement/Commands/GetMeasurementProfileResponse";


  std::string payload =
    get_json_payload_for_electrical_measurement_get_measurement_profile_response_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetMeasurementProfileResponse command for
 * the ElectricalMeasurement cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/ElectricalMeasurement/Commands/GetMeasurementProfileResponse
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_electrical_measurement_publish_get_measurement_profile_response_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_electrical_measurement_command_get_measurement_profile_response_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/ElectricalMeasurement/Commands/GetMeasurementProfileResponse";

  std::string payload =
    get_json_payload_for_electrical_measurement_get_measurement_profile_response_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetMeasurementProfile command for
 * the ElectricalMeasurement cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ElectricalMeasurement/Commands/GetMeasurementProfile
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_electrical_measurement_publish_get_measurement_profile_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_electrical_measurement_command_get_measurement_profile_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "ElectricalMeasurement/Commands/GetMeasurementProfile";


  std::string payload =
    get_json_payload_for_electrical_measurement_get_measurement_profile_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a GetMeasurementProfile command for
 * the ElectricalMeasurement cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/ElectricalMeasurement/Commands/GetMeasurementProfile
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_electrical_measurement_publish_get_measurement_profile_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_electrical_measurement_command_get_measurement_profile_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/ElectricalMeasurement/Commands/GetMeasurementProfile";

  std::string payload =
    get_json_payload_for_electrical_measurement_get_measurement_profile_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a TxReport command for
 * the ProtocolController-RFTelemetry cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/ProtocolController/RFTelemetry/Commands/TxReport
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_protocol_controller_rf_telemetry_publish_tx_report_command(
  const dotdot_unid_t destination_unid,
  const uic_mqtt_dotdot_protocol_controller_rf_telemetry_command_tx_report_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(destination_unid) + "/";
  topic += "ProtocolController/RFTelemetry/Commands/TxReport";


  std::string payload =
    get_json_payload_for_protocol_controller_rf_telemetry_tx_report_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a TxReport command for
 * the ProtocolController-RFTelemetry cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/ProtocolController/RFTelemetry/Commands/TxReport
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_protocol_controller_rf_telemetry_publish_tx_report_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_protocol_controller_rf_telemetry_command_tx_report_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/ProtocolController/RFTelemetry/Commands/TxReport";

  std::string payload =
    get_json_payload_for_protocol_controller_rf_telemetry_tx_report_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a Remove command for
 * the State cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/State/Commands/Remove
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * 
 */
void uic_mqtt_dotdot_state_publish_remove_command(
  const dotdot_unid_t destination_unid
) {
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(destination_unid) + "/";
  topic += "State/Commands/Remove";


  std::string payload =
    get_json_payload_for_state_remove_command(
    );

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a Remove command for
 * the State cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/State/Commands/Remove
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 */
void uic_mqtt_dotdot_state_publish_remove_command_to_group(
  uint16_t destination_group_id
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/State/Commands/Remove";

  std::string payload =
    get_json_payload_for_state_remove_command(
    );

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a RemoveOffline command for
 * the State cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/State/Commands/RemoveOffline
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * 
 */
void uic_mqtt_dotdot_state_publish_remove_offline_command(
  const dotdot_unid_t destination_unid
) {
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(destination_unid) + "/";
  topic += "State/Commands/RemoveOffline";


  std::string payload =
    get_json_payload_for_state_remove_offline_command(
    );

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a RemoveOffline command for
 * the State cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/State/Commands/RemoveOffline
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 */
void uic_mqtt_dotdot_state_publish_remove_offline_command_to_group(
  uint16_t destination_group_id
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/State/Commands/RemoveOffline";

  std::string payload =
    get_json_payload_for_state_remove_offline_command(
    );

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a DiscoverNeighbors command for
 * the State cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/State/Commands/DiscoverNeighbors
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * 
 */
void uic_mqtt_dotdot_state_publish_discover_neighbors_command(
  const dotdot_unid_t destination_unid
) {
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(destination_unid) + "/";
  topic += "State/Commands/DiscoverNeighbors";


  std::string payload =
    get_json_payload_for_state_discover_neighbors_command(
    );

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a DiscoverNeighbors command for
 * the State cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/State/Commands/DiscoverNeighbors
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 */
void uic_mqtt_dotdot_state_publish_discover_neighbors_command_to_group(
  uint16_t destination_group_id
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/State/Commands/DiscoverNeighbors";

  std::string payload =
    get_json_payload_for_state_discover_neighbors_command(
    );

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a Interview command for
 * the State cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/State/Commands/Interview
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * 
 */
void uic_mqtt_dotdot_state_publish_interview_command(
  const dotdot_unid_t destination_unid
) {
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(destination_unid) + "/";
  topic += "State/Commands/Interview";


  std::string payload =
    get_json_payload_for_state_interview_command(
    );

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a Interview command for
 * the State cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/State/Commands/Interview
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 */
void uic_mqtt_dotdot_state_publish_interview_command_to_group(
  uint16_t destination_group_id
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/State/Commands/Interview";

  std::string payload =
    get_json_payload_for_state_interview_command(
    );

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a Bind command for
 * the Binding cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Binding/Commands/Bind
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_binding_publish_bind_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_binding_command_bind_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Binding/Commands/Bind";


  std::string payload =
    get_json_payload_for_binding_bind_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a Bind command for
 * the Binding cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Binding/Commands/Bind
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_binding_publish_bind_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_binding_command_bind_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Binding/Commands/Bind";

  std::string payload =
    get_json_payload_for_binding_bind_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a Unbind command for
 * the Binding cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Binding/Commands/Unbind
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_binding_publish_unbind_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_binding_command_unbind_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Binding/Commands/Unbind";


  std::string payload =
    get_json_payload_for_binding_unbind_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a Unbind command for
 * the Binding cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Binding/Commands/Unbind
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_binding_publish_unbind_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_binding_command_unbind_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Binding/Commands/Unbind";

  std::string payload =
    get_json_payload_for_binding_unbind_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a BindToProtocolController command for
 * the Binding cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Binding/Commands/BindToProtocolController
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_binding_publish_bind_to_protocol_controller_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_binding_command_bind_to_protocol_controller_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Binding/Commands/BindToProtocolController";


  std::string payload =
    get_json_payload_for_binding_bind_to_protocol_controller_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a BindToProtocolController command for
 * the Binding cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Binding/Commands/BindToProtocolController
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_binding_publish_bind_to_protocol_controller_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_binding_command_bind_to_protocol_controller_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Binding/Commands/BindToProtocolController";

  std::string payload =
    get_json_payload_for_binding_bind_to_protocol_controller_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a UnbindFromProtocolController command for
 * the Binding cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Binding/Commands/UnbindFromProtocolController
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_binding_publish_unbind_from_protocol_controller_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_binding_command_unbind_from_protocol_controller_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "Binding/Commands/UnbindFromProtocolController";


  std::string payload =
    get_json_payload_for_binding_unbind_from_protocol_controller_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a UnbindFromProtocolController command for
 * the Binding cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/Binding/Commands/UnbindFromProtocolController
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_binding_publish_unbind_from_protocol_controller_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_binding_command_unbind_from_protocol_controller_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/Binding/Commands/UnbindFromProtocolController";

  std::string payload =
    get_json_payload_for_binding_unbind_from_protocol_controller_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a LogEntry command for
 * the ApplicationMonitoring cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/ApplicationMonitoring/Commands/LogEntry
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_application_monitoring_publish_log_entry_command(
  const dotdot_unid_t destination_unid,
  const uic_mqtt_dotdot_application_monitoring_command_log_entry_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(destination_unid) + "/";
  topic += "ApplicationMonitoring/Commands/LogEntry";


  std::string payload =
    get_json_payload_for_application_monitoring_log_entry_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a LogEntry command for
 * the ApplicationMonitoring cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/ApplicationMonitoring/Commands/LogEntry
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_application_monitoring_publish_log_entry_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_application_monitoring_command_log_entry_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/ApplicationMonitoring/Commands/LogEntry";

  std::string payload =
    get_json_payload_for_application_monitoring_log_entry_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a DiscoverParameter command for
 * the ConfigurationParameters cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ConfigurationParameters/Commands/DiscoverParameter
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_configuration_parameters_publish_discover_parameter_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_configuration_parameters_command_discover_parameter_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "ConfigurationParameters/Commands/DiscoverParameter";


  std::string payload =
    get_json_payload_for_configuration_parameters_discover_parameter_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a DiscoverParameter command for
 * the ConfigurationParameters cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/ConfigurationParameters/Commands/DiscoverParameter
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_configuration_parameters_publish_discover_parameter_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_configuration_parameters_command_discover_parameter_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/ConfigurationParameters/Commands/DiscoverParameter";

  std::string payload =
    get_json_payload_for_configuration_parameters_discover_parameter_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a DefaultResetAllParameters command for
 * the ConfigurationParameters cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ConfigurationParameters/Commands/DefaultResetAllParameters
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 */
void uic_mqtt_dotdot_configuration_parameters_publish_default_reset_all_parameters_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "ConfigurationParameters/Commands/DefaultResetAllParameters";


  std::string payload =
    get_json_payload_for_configuration_parameters_default_reset_all_parameters_command(
    );

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a DefaultResetAllParameters command for
 * the ConfigurationParameters cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/ConfigurationParameters/Commands/DefaultResetAllParameters
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 */
void uic_mqtt_dotdot_configuration_parameters_publish_default_reset_all_parameters_command_to_group(
  uint16_t destination_group_id
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/ConfigurationParameters/Commands/DefaultResetAllParameters";

  std::string payload =
    get_json_payload_for_configuration_parameters_default_reset_all_parameters_command(
    );

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetParameter command for
 * the ConfigurationParameters cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ConfigurationParameters/Commands/SetParameter
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_configuration_parameters_publish_set_parameter_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_configuration_parameters_command_set_parameter_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "ConfigurationParameters/Commands/SetParameter";


  std::string payload =
    get_json_payload_for_configuration_parameters_set_parameter_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a SetParameter command for
 * the ConfigurationParameters cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/ConfigurationParameters/Commands/SetParameter
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_configuration_parameters_publish_set_parameter_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_configuration_parameters_command_set_parameter_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/ConfigurationParameters/Commands/SetParameter";

  std::string payload =
    get_json_payload_for_configuration_parameters_set_parameter_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a DiscoverParameterRange command for
 * the ConfigurationParameters cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ConfigurationParameters/Commands/DiscoverParameterRange
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_configuration_parameters_publish_discover_parameter_range_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_configuration_parameters_command_discover_parameter_range_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "ConfigurationParameters/Commands/DiscoverParameterRange";


  std::string payload =
    get_json_payload_for_configuration_parameters_discover_parameter_range_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a DiscoverParameterRange command for
 * the ConfigurationParameters cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/ConfigurationParameters/Commands/DiscoverParameterRange
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_configuration_parameters_publish_discover_parameter_range_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_configuration_parameters_command_discover_parameter_range_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/ConfigurationParameters/Commands/DiscoverParameterRange";

  std::string payload =
    get_json_payload_for_configuration_parameters_discover_parameter_range_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a IQReport command for
 * the AoXLocator cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/AoXLocator/Commands/IQReport
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_aox_locator_publish_iq_report_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_aox_locator_command_iq_report_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "AoXLocator/Commands/IQReport";


  std::string payload =
    get_json_payload_for_aox_locator_iq_report_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a IQReport command for
 * the AoXLocator cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/AoXLocator/Commands/IQReport
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_aox_locator_publish_iq_report_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_aox_locator_command_iq_report_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/AoXLocator/Commands/IQReport";

  std::string payload =
    get_json_payload_for_aox_locator_iq_report_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a AngleReport command for
 * the AoXLocator cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/AoXLocator/Commands/AngleReport
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_aox_locator_publish_angle_report_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_aox_locator_command_angle_report_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "AoXLocator/Commands/AngleReport";


  std::string payload =
    get_json_payload_for_aox_locator_angle_report_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a AngleReport command for
 * the AoXLocator cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/AoXLocator/Commands/AngleReport
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_aox_locator_publish_angle_report_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_aox_locator_command_angle_report_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/AoXLocator/Commands/AngleReport";

  std::string payload =
    get_json_payload_for_aox_locator_angle_report_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a AngleCorrection command for
 * the AoXLocator cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/AoXLocator/Commands/AngleCorrection
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_aox_locator_publish_angle_correction_command(
  const dotdot_unid_t destination_unid,
  const dotdot_endpoint_id_t destination_endpoint,
  const uic_mqtt_dotdot_aox_locator_command_angle_correction_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
                      std::to_string(destination_endpoint) + "/";
  topic += "AoXLocator/Commands/AngleCorrection";


  std::string payload =
    get_json_payload_for_aox_locator_angle_correction_command(
    fields);

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a AngleCorrection command for
 * the AoXLocator cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/AoXLocator/Commands/AngleCorrection
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_aox_locator_publish_angle_correction_command_to_group(
  uint16_t destination_group_id,
  const uic_mqtt_dotdot_aox_locator_command_angle_correction_fields_t *fields
  
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/AoXLocator/Commands/AngleCorrection";

  std::string payload =
    get_json_payload_for_aox_locator_angle_correction_command(
    fields);

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a Write command for
 * the ProtocolController-NetworkManagement cluster to a destination.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/ProtocolController/NetworkManagement/Commands/Write
 *
 * @param destination_unid      The UNID of the node that should receive the command.
 * 
 * 
 */
void uic_mqtt_dotdot_protocol_controller_network_management_publish_write_command(
  const dotdot_unid_t destination_unid
) {
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(destination_unid) + "/";
  topic += "ProtocolController/NetworkManagement/Commands/Write";


  std::string payload =
    get_json_payload_for_protocol_controller_network_management_write_command(
    );

  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}

/**
 * @brief Sends/Publishes a Write command for
 * the ProtocolController-NetworkManagement cluster to a group.
 *
 * Publication will be made at the following topic
 * ucl/by-group/GroupID/ProtocolController/NetworkManagement/Commands/Write
 *
 * @param destination_group_id  The GroupID that should receive the command.
 * 
 */
void uic_mqtt_dotdot_protocol_controller_network_management_publish_write_command_to_group(
  uint16_t destination_group_id
){
  // Create the topic
  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
                      "/ProtocolController/NetworkManagement/Commands/Write";

  std::string payload =
    get_json_payload_for_protocol_controller_network_management_write_command(
    );

  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());

  // Publish our command, not retained
  uic_mqtt_publish(topic.c_str(),
                   payload.c_str(),
                   payload.size(),
                   false);
}
